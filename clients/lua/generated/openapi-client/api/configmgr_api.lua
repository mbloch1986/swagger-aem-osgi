--[[
  Adobe Experience Manager OSGI config (AEM) API
 
  Swagger AEM OSGI is an OpenAPI specification for Adobe Experience Manager (AEM) OSGI Configurations API
 
  OpenAPI spec version: 1.0.0-pre.0
  Contact: opensource@shinesolutions.com
  Generated by: https://openapi-generator.tech
]]

--package openapi-client

local http_request = require "http.request"
local http_util = require "http.util"
local dkjson = require "dkjson"
local basexx = require "basexx"

-- model import
local openapi-client_messaging_user_component_factory_info = require "openapi-client.model.messaging_user_component_factory_info"
local openapi-client_adaptive_form_and_interactive_communication_web_channel_configuration_info = require "openapi-client.model.adaptive_form_and_interactive_communication_web_channel_configuration_info"
local openapi-client_adaptive_form_and_interactive_communication_web_channel_theme_configur_info = require "openapi-client.model.adaptive_form_and_interactive_communication_web_channel_theme_configur_info"
local openapi-client_analytics_component_query_cache_service_info = require "openapi-client.model.analytics_component_query_cache_service_info"
local openapi-client_apache_sling_health_check_result_html_serializer_info = require "openapi-client.model.apache_sling_health_check_result_html_serializer_info"
local openapi-client_com_adobe_aem_formsndocuments_config_aem_forms_manager_configuration_info = require "openapi-client.model.com_adobe_aem_formsndocuments_config_aem_forms_manager_configuration_info"
local openapi-client_com_adobe_aem_transaction_core_impl_transaction_recorder_info = require "openapi-client.model.com_adobe_aem_transaction_core_impl_transaction_recorder_info"
local openapi-client_com_adobe_aem_upgrade_prechecks_hc_impl_deprecate_indexes_hc_info = require "openapi-client.model.com_adobe_aem_upgrade_prechecks_hc_impl_deprecate_indexes_hc_info"
local openapi-client_com_adobe_aem_upgrade_prechecks_hc_impl_replication_agents_disabled_hc_info = require "openapi-client.model.com_adobe_aem_upgrade_prechecks_hc_impl_replication_agents_disabled_hc_info"
local openapi-client_com_adobe_aem_upgrade_prechecks_mbean_impl_pre_upgrade_tasks_m_bean_impl_info = require "openapi-client.model.com_adobe_aem_upgrade_prechecks_mbean_impl_pre_upgrade_tasks_m_bean_impl_info"
local openapi-client_com_adobe_aem_upgrade_prechecks_tasks_impl_consistency_check_task_impl_info = require "openapi-client.model.com_adobe_aem_upgrade_prechecks_tasks_impl_consistency_check_task_impl_info"
local openapi-client_com_adobe_cq_account_api_account_management_service_info = require "openapi-client.model.com_adobe_cq_account_api_account_management_service_info"
local openapi-client_com_adobe_cq_account_impl_account_management_servlet_info = require "openapi-client.model.com_adobe_cq_account_impl_account_management_servlet_info"
local openapi-client_com_adobe_cq_address_impl_location_location_list_servlet_info = require "openapi-client.model.com_adobe_cq_address_impl_location_location_list_servlet_info"
local openapi-client_com_adobe_cq_audit_purge_dam_info = require "openapi-client.model.com_adobe_cq_audit_purge_dam_info"
local openapi-client_com_adobe_cq_audit_purge_pages_info = require "openapi-client.model.com_adobe_cq_audit_purge_pages_info"
local openapi-client_com_adobe_cq_audit_purge_replication_info = require "openapi-client.model.com_adobe_cq_audit_purge_replication_info"
local openapi-client_com_adobe_cq_cdn_rewriter_impl_aws_cloud_front_rewriter_info = require "openapi-client.model.com_adobe_cq_cdn_rewriter_impl_aws_cloud_front_rewriter_info"
local openapi-client_com_adobe_cq_cdn_rewriter_impl_cdn_config_service_impl_info = require "openapi-client.model.com_adobe_cq_cdn_rewriter_impl_cdn_config_service_impl_info"
local openapi-client_com_adobe_cq_cdn_rewriter_impl_cdn_rewriter_info = require "openapi-client.model.com_adobe_cq_cdn_rewriter_impl_cdn_rewriter_info"
local openapi-client_com_adobe_cq_cloudconfig_core_impl_configuration_replication_event_handle_info = require "openapi-client.model.com_adobe_cq_cloudconfig_core_impl_configuration_replication_event_handle_info"
local openapi-client_com_adobe_cq_commerce_impl_asset_dynamic_image_handler_info = require "openapi-client.model.com_adobe_cq_commerce_impl_asset_dynamic_image_handler_info"
local openapi-client_com_adobe_cq_commerce_impl_asset_product_asset_handler_provider_impl_info = require "openapi-client.model.com_adobe_cq_commerce_impl_asset_product_asset_handler_provider_impl_info"
local openapi-client_com_adobe_cq_commerce_impl_asset_static_image_handler_info = require "openapi-client.model.com_adobe_cq_commerce_impl_asset_static_image_handler_info"
local openapi-client_com_adobe_cq_commerce_impl_asset_video_handler_info = require "openapi-client.model.com_adobe_cq_commerce_impl_asset_video_handler_info"
local openapi-client_com_adobe_cq_commerce_impl_promotion_promotion_manager_impl_info = require "openapi-client.model.com_adobe_cq_commerce_impl_promotion_promotion_manager_impl_info"
local openapi-client_com_adobe_cq_commerce_pim_impl_cataloggenerator_catalog_generator_impl_info = require "openapi-client.model.com_adobe_cq_commerce_pim_impl_cataloggenerator_catalog_generator_impl_info"
local openapi-client_com_adobe_cq_commerce_pim_impl_page_event_listener_info = require "openapi-client.model.com_adobe_cq_commerce_pim_impl_page_event_listener_info"
local openapi-client_com_adobe_cq_commerce_pim_impl_productfeed_product_feed_service_impl_info = require "openapi-client.model.com_adobe_cq_commerce_pim_impl_productfeed_product_feed_service_impl_info"
local openapi-client_com_adobe_cq_contentinsight_impl_reporting_services_settings_provider_info = require "openapi-client.model.com_adobe_cq_contentinsight_impl_reporting_services_settings_provider_info"
local openapi-client_com_adobe_cq_contentinsight_impl_servlets_bright_edge_proxy_servlet_info = require "openapi-client.model.com_adobe_cq_contentinsight_impl_servlets_bright_edge_proxy_servlet_info"
local openapi-client_com_adobe_cq_contentinsight_impl_servlets_reporting_services_proxy_servle_info = require "openapi-client.model.com_adobe_cq_contentinsight_impl_servlets_reporting_services_proxy_servle_info"
local openapi-client_com_adobe_cq_dam_cfm_impl_component_component_config_impl_info = require "openapi-client.model.com_adobe_cq_dam_cfm_impl_component_component_config_impl_info"
local openapi-client_com_adobe_cq_dam_cfm_impl_conf_feature_config_impl_info = require "openapi-client.model.com_adobe_cq_dam_cfm_impl_conf_feature_config_impl_info"
local openapi-client_com_adobe_cq_dam_cfm_impl_content_rewriter_asset_processor_info = require "openapi-client.model.com_adobe_cq_dam_cfm_impl_content_rewriter_asset_processor_info"
local openapi-client_com_adobe_cq_dam_cfm_impl_content_rewriter_par_range_filter_info = require "openapi-client.model.com_adobe_cq_dam_cfm_impl_content_rewriter_par_range_filter_info"
local openapi-client_com_adobe_cq_dam_cfm_impl_content_rewriter_payload_filter_info = require "openapi-client.model.com_adobe_cq_dam_cfm_impl_content_rewriter_payload_filter_info"
local openapi-client_com_adobe_cq_dam_dm_process_image_p_tiff_manager_impl_info = require "openapi-client.model.com_adobe_cq_dam_dm_process_image_p_tiff_manager_impl_info"
local openapi-client_com_adobe_cq_dam_ips_impl_replication_trigger_replicate_on_modify_worker_info = require "openapi-client.model.com_adobe_cq_dam_ips_impl_replication_trigger_replicate_on_modify_worker_info"
local openapi-client_com_adobe_cq_dam_mac_sync_helper_impl_mac_sync_client_impl_info = require "openapi-client.model.com_adobe_cq_dam_mac_sync_helper_impl_mac_sync_client_impl_info"
local openapi-client_com_adobe_cq_dam_mac_sync_impl_dam_sync_service_impl_info = require "openapi-client.model.com_adobe_cq_dam_mac_sync_impl_dam_sync_service_impl_info"
local openapi-client_com_adobe_cq_dam_processor_nui_impl_nui_asset_processor_info = require "openapi-client.model.com_adobe_cq_dam_processor_nui_impl_nui_asset_processor_info"
local openapi-client_com_adobe_cq_dam_s7imaging_impl_is_image_server_component_info = require "openapi-client.model.com_adobe_cq_dam_s7imaging_impl_is_image_server_component_info"
local openapi-client_com_adobe_cq_dam_s7imaging_impl_ps_platform_server_servlet_info = require "openapi-client.model.com_adobe_cq_dam_s7imaging_impl_ps_platform_server_servlet_info"
local openapi-client_com_adobe_cq_dam_webdav_impl_io_asset_io_handler_info = require "openapi-client.model.com_adobe_cq_dam_webdav_impl_io_asset_io_handler_info"
local openapi-client_com_adobe_cq_dam_webdav_impl_io_dam_webdav_version_linking_job_info = require "openapi-client.model.com_adobe_cq_dam_webdav_impl_io_dam_webdav_version_linking_job_info"
local openapi-client_com_adobe_cq_dam_webdav_impl_io_special_files_handler_info = require "openapi-client.model.com_adobe_cq_dam_webdav_impl_io_special_files_handler_info"
local openapi-client_com_adobe_cq_deserfw_impl_deserialization_firewall_impl_info = require "openapi-client.model.com_adobe_cq_deserfw_impl_deserialization_firewall_impl_info"
local openapi-client_com_adobe_cq_dtm_impl_service_dtm_web_service_impl_info = require "openapi-client.model.com_adobe_cq_dtm_impl_service_dtm_web_service_impl_info"
local openapi-client_com_adobe_cq_dtm_impl_servlets_dtm_deploy_hook_servlet_info = require "openapi-client.model.com_adobe_cq_dtm_impl_servlets_dtm_deploy_hook_servlet_info"
local openapi-client_com_adobe_cq_dtm_reactor_impl_service_web_service_impl_info = require "openapi-client.model.com_adobe_cq_dtm_reactor_impl_service_web_service_impl_info"
local openapi-client_com_adobe_cq_experiencelog_impl_experience_log_config_servlet_info = require "openapi-client.model.com_adobe_cq_experiencelog_impl_experience_log_config_servlet_info"
local openapi-client_com_adobe_cq_hc_content_packages_health_check_info = require "openapi-client.model.com_adobe_cq_hc_content_packages_health_check_info"
local openapi-client_com_adobe_cq_history_impl_history_request_filter_info = require "openapi-client.model.com_adobe_cq_history_impl_history_request_filter_info"
local openapi-client_com_adobe_cq_history_impl_history_service_impl_info = require "openapi-client.model.com_adobe_cq_history_impl_history_service_impl_info"
local openapi-client_com_adobe_cq_inbox_impl_typeprovider_item_type_provider_info = require "openapi-client.model.com_adobe_cq_inbox_impl_typeprovider_item_type_provider_info"
local openapi-client_com_adobe_cq_projects_impl_servlet_project_image_servlet_info = require "openapi-client.model.com_adobe_cq_projects_impl_servlet_project_image_servlet_info"
local openapi-client_com_adobe_cq_projects_purge_scheduler_info = require "openapi-client.model.com_adobe_cq_projects_purge_scheduler_info"
local openapi-client_com_adobe_cq_scheduled_exporter_impl_scheduled_exporter_impl_info = require "openapi-client.model.com_adobe_cq_scheduled_exporter_impl_scheduled_exporter_impl_info"
local openapi-client_com_adobe_cq_screens_analytics_impl_screens_analytics_service_impl_info = require "openapi-client.model.com_adobe_cq_screens_analytics_impl_screens_analytics_service_impl_info"
local openapi-client_com_adobe_cq_screens_device_impl_device_service_info = require "openapi-client.model.com_adobe_cq_screens_device_impl_device_service_info"
local openapi-client_com_adobe_cq_screens_device_registration_impl_registration_service_impl_info = require "openapi-client.model.com_adobe_cq_screens_device_registration_impl_registration_service_impl_info"
local openapi-client_com_adobe_cq_screens_impl_handler_channels_update_handler_info = require "openapi-client.model.com_adobe_cq_screens_impl_handler_channels_update_handler_info"
local openapi-client_com_adobe_cq_screens_impl_jobs_distributed_devices_stati_update_job_info = require "openapi-client.model.com_adobe_cq_screens_impl_jobs_distributed_devices_stati_update_job_info"
local openapi-client_com_adobe_cq_screens_impl_remote_impl_distributed_http_client_impl_info = require "openapi-client.model.com_adobe_cq_screens_impl_remote_impl_distributed_http_client_impl_info"
local openapi-client_com_adobe_cq_screens_impl_screens_channel_post_processor_info = require "openapi-client.model.com_adobe_cq_screens_impl_screens_channel_post_processor_info"
local openapi-client_com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_info = require "openapi-client.model.com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_info"
local openapi-client_com_adobe_cq_screens_mq_activemq_impl_artemis_jms_provider_info = require "openapi-client.model.com_adobe_cq_screens_mq_activemq_impl_artemis_jms_provider_info"
local openapi-client_com_adobe_cq_screens_offlinecontent_impl_bulk_offline_update_service_impl_info = require "openapi-client.model.com_adobe_cq_screens_offlinecontent_impl_bulk_offline_update_service_impl_info"
local openapi-client_com_adobe_cq_screens_offlinecontent_impl_offline_content_service_impl_info = require "openapi-client.model.com_adobe_cq_screens_offlinecontent_impl_offline_content_service_impl_info"
local openapi-client_com_adobe_cq_screens_segmentation_impl_segmentation_feature_flag_info = require "openapi-client.model.com_adobe_cq_screens_segmentation_impl_segmentation_feature_flag_info"
local openapi-client_com_adobe_cq_security_hc_bundles_impl_html_library_manager_config_health_ch_info = require "openapi-client.model.com_adobe_cq_security_hc_bundles_impl_html_library_manager_config_health_ch_info"
local openapi-client_com_adobe_cq_security_hc_bundles_impl_wcm_filter_health_check_info = require "openapi-client.model.com_adobe_cq_security_hc_bundles_impl_wcm_filter_health_check_info"
local openapi-client_com_adobe_cq_security_hc_dispatcher_impl_dispatcher_access_health_check_info = require "openapi-client.model.com_adobe_cq_security_hc_dispatcher_impl_dispatcher_access_health_check_info"
local openapi-client_com_adobe_cq_security_hc_packages_impl_example_content_health_check_info = require "openapi-client.model.com_adobe_cq_security_hc_packages_impl_example_content_health_check_info"
local openapi-client_com_adobe_cq_security_hc_webserver_impl_clickjacking_health_check_info = require "openapi-client.model.com_adobe_cq_security_hc_webserver_impl_clickjacking_health_check_info"
local openapi-client_com_adobe_cq_social_accountverification_impl_account_management_config_im_info = require "openapi-client.model.com_adobe_cq_social_accountverification_impl_account_management_config_im_info"
local openapi-client_com_adobe_cq_social_activitystreams_client_impl_social_activity_componen_info = require "openapi-client.model.com_adobe_cq_social_activitystreams_client_impl_social_activity_componen_info"
local openapi-client_com_adobe_cq_social_activitystreams_client_impl_social_activity_stream_co_info = require "openapi-client.model.com_adobe_cq_social_activitystreams_client_impl_social_activity_stream_co_info"
local openapi-client_com_adobe_cq_social_activitystreams_listener_impl_event_listener_handler_info = require "openapi-client.model.com_adobe_cq_social_activitystreams_listener_impl_event_listener_handler_info"
local openapi-client_com_adobe_cq_social_activitystreams_listener_impl_moderation_event_exten_info = require "openapi-client.model.com_adobe_cq_social_activitystreams_listener_impl_moderation_event_exten_info"
local openapi-client_com_adobe_cq_social_activitystreams_listener_impl_rating_event_activity_s_info = require "openapi-client.model.com_adobe_cq_social_activitystreams_listener_impl_rating_event_activity_s_info"
local openapi-client_com_adobe_cq_social_activitystreams_listener_impl_resource_activity_stre_info = require "openapi-client.model.com_adobe_cq_social_activitystreams_listener_impl_resource_activity_stre_info"
local openapi-client_com_adobe_cq_social_calendar_client_endpoints_impl_calendar_operations_i_info = require "openapi-client.model.com_adobe_cq_social_calendar_client_endpoints_impl_calendar_operations_i_info"
local openapi-client_com_adobe_cq_social_calendar_client_operationextensions_event_attachmen_info = require "openapi-client.model.com_adobe_cq_social_calendar_client_operationextensions_event_attachmen_info"
local openapi-client_com_adobe_cq_social_calendar_servlets_time_zone_servlet_info = require "openapi-client.model.com_adobe_cq_social_calendar_servlets_time_zone_servlet_info"
local openapi-client_com_adobe_cq_social_commons_comments_endpoints_impl_comment_delete_event_info = require "openapi-client.model.com_adobe_cq_social_commons_comments_endpoints_impl_comment_delete_event_info"
local openapi-client_com_adobe_cq_social_commons_comments_endpoints_impl_comment_operation_se_info = require "openapi-client.model.com_adobe_cq_social_commons_comments_endpoints_impl_comment_operation_se_info"
local openapi-client_com_adobe_cq_social_commons_comments_endpoints_impl_translation_operati_info = require "openapi-client.model.com_adobe_cq_social_commons_comments_endpoints_impl_translation_operati_info"
local openapi-client_com_adobe_cq_social_commons_comments_listing_impl_search_comment_social_c_info = require "openapi-client.model.com_adobe_cq_social_commons_comments_listing_impl_search_comment_social_c_info"
local openapi-client_com_adobe_cq_social_commons_comments_scheduler_impl_search_scheduled_pos_info = require "openapi-client.model.com_adobe_cq_social_commons_comments_scheduler_impl_search_scheduled_pos_info"
local openapi-client_com_adobe_cq_social_commons_cors_cors_authentication_filter_info = require "openapi-client.model.com_adobe_cq_social_commons_cors_cors_authentication_filter_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_android_email_client_provider_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_android_email_client_provider_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_comment_email_builder_impl_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_comment_email_builder_impl_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_comment_email_event_listener_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_comment_email_event_listener_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_custom_email_client_provider_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_custom_email_client_provider_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_email_quoted_text_patterns_imp_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_email_quoted_text_patterns_imp_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_email_reply_configuration_imp_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_email_reply_configuration_imp_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_email_reply_importer_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_email_reply_importer_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_gmail_email_client_provider_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_gmail_email_client_provider_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_ios_email_client_provider_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_ios_email_client_provider_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_macmail_email_client_provider_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_macmail_email_client_provider_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_out_look_email_client_provider_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_out_look_email_client_provider_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_unknown_email_client_provider_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_unknown_email_client_provider_info"
local openapi-client_com_adobe_cq_social_commons_emailreply_impl_yahoo_email_client_provider_info = require "openapi-client.model.com_adobe_cq_social_commons_emailreply_impl_yahoo_email_client_provider_info"
local openapi-client_com_adobe_cq_social_commons_maintainance_impl_delete_temp_ugc_image_upload_info = require "openapi-client.model.com_adobe_cq_social_commons_maintainance_impl_delete_temp_ugc_image_upload_info"
local openapi-client_com_adobe_cq_social_commons_ugclimiter_impl_ugc_limiter_service_impl_info = require "openapi-client.model.com_adobe_cq_social_commons_ugclimiter_impl_ugc_limiter_service_impl_info"
local openapi-client_com_adobe_cq_social_commons_ugclimitsconfig_impl_community_user_ugc_limit_info = require "openapi-client.model.com_adobe_cq_social_commons_ugclimitsconfig_impl_community_user_ugc_limit_info"
local openapi-client_com_adobe_cq_social_connect_oauth_impl_facebook_provider_impl_info = require "openapi-client.model.com_adobe_cq_social_connect_oauth_impl_facebook_provider_impl_info"
local openapi-client_com_adobe_cq_social_connect_oauth_impl_social_o_auth_authentication_handle_info = require "openapi-client.model.com_adobe_cq_social_connect_oauth_impl_social_o_auth_authentication_handle_info"
local openapi-client_com_adobe_cq_social_connect_oauth_impl_social_o_auth_user_profile_mapper_info = require "openapi-client.model.com_adobe_cq_social_connect_oauth_impl_social_o_auth_user_profile_mapper_info"
local openapi-client_com_adobe_cq_social_connect_oauth_impl_twitter_provider_impl_info = require "openapi-client.model.com_adobe_cq_social_connect_oauth_impl_twitter_provider_impl_info"
local openapi-client_com_adobe_cq_social_content_fragments_services_impl_communities_fragmen_info = require "openapi-client.model.com_adobe_cq_social_content_fragments_services_impl_communities_fragmen_info"
local openapi-client_com_adobe_cq_social_datastore_as_impl_as_resource_provider_factory_info = require "openapi-client.model.com_adobe_cq_social_datastore_as_impl_as_resource_provider_factory_info"
local openapi-client_com_adobe_cq_social_datastore_op_impl_social_ms_resource_provider_factory_info = require "openapi-client.model.com_adobe_cq_social_datastore_op_impl_social_ms_resource_provider_factory_info"
local openapi-client_com_adobe_cq_social_datastore_rdb_impl_social_rdb_resource_provider_factor_info = require "openapi-client.model.com_adobe_cq_social_datastore_rdb_impl_social_rdb_resource_provider_factor_info"
local openapi-client_com_adobe_cq_social_enablement_adaptors_enablement_learning_path_adaptor_f_info = require "openapi-client.model.com_adobe_cq_social_enablement_adaptors_enablement_learning_path_adaptor_f_info"
local openapi-client_com_adobe_cq_social_enablement_adaptors_enablement_resource_adaptor_facto_info = require "openapi-client.model.com_adobe_cq_social_enablement_adaptors_enablement_resource_adaptor_facto_info"
local openapi-client_com_adobe_cq_social_enablement_learningpath_endpoints_impl_enablement_l_info = require "openapi-client.model.com_adobe_cq_social_enablement_learningpath_endpoints_impl_enablement_l_info"
local openapi-client_com_adobe_cq_social_enablement_resource_endpoints_impl_enablement_resou_info = require "openapi-client.model.com_adobe_cq_social_enablement_resource_endpoints_impl_enablement_resou_info"
local openapi-client_com_adobe_cq_social_enablement_services_impl_author_marker_impl_info = require "openapi-client.model.com_adobe_cq_social_enablement_services_impl_author_marker_impl_info"
local openapi-client_com_adobe_cq_social_filelibrary_client_endpoints_filelibrary_download_ge_info = require "openapi-client.model.com_adobe_cq_social_filelibrary_client_endpoints_filelibrary_download_ge_info"
local openapi-client_com_adobe_cq_social_filelibrary_client_endpoints_impl_file_library_opera_info = require "openapi-client.model.com_adobe_cq_social_filelibrary_client_endpoints_impl_file_library_opera_info"
local openapi-client_com_adobe_cq_social_forum_client_endpoints_impl_forum_operations_service_info = require "openapi-client.model.com_adobe_cq_social_forum_client_endpoints_impl_forum_operations_service_info"
local openapi-client_com_adobe_cq_social_forum_dispatcher_impl_flush_operations_info = require "openapi-client.model.com_adobe_cq_social_forum_dispatcher_impl_flush_operations_info"
local openapi-client_com_adobe_cq_social_group_client_impl_community_group_collection_componen_info = require "openapi-client.model.com_adobe_cq_social_group_client_impl_community_group_collection_componen_info"
local openapi-client_com_adobe_cq_social_group_impl_group_service_impl_info = require "openapi-client.model.com_adobe_cq_social_group_impl_group_service_impl_info"
local openapi-client_com_adobe_cq_social_handlebars_guava_template_cache_impl_info = require "openapi-client.model.com_adobe_cq_social_handlebars_guava_template_cache_impl_info"
local openapi-client_com_adobe_cq_social_ideation_client_endpoints_impl_ideation_operations_s_info = require "openapi-client.model.com_adobe_cq_social_ideation_client_endpoints_impl_ideation_operations_s_info"
local openapi-client_com_adobe_cq_social_journal_client_endpoints_impl_journal_operations_ser_info = require "openapi-client.model.com_adobe_cq_social_journal_client_endpoints_impl_journal_operations_ser_info"
local openapi-client_com_adobe_cq_social_members_endpoints_impl_community_member_group_profile_info = require "openapi-client.model.com_adobe_cq_social_members_endpoints_impl_community_member_group_profile_info"
local openapi-client_com_adobe_cq_social_members_endpoints_impl_community_member_user_profile_o_info = require "openapi-client.model.com_adobe_cq_social_members_endpoints_impl_community_member_user_profile_o_info"
local openapi-client_com_adobe_cq_social_members_impl_community_member_group_profile_component_f_info = require "openapi-client.model.com_adobe_cq_social_members_impl_community_member_group_profile_component_f_info"
local openapi-client_com_adobe_cq_social_messaging_client_endpoints_impl_messaging_operation_info = require "openapi-client.model.com_adobe_cq_social_messaging_client_endpoints_impl_messaging_operation_info"
local openapi-client_com_adobe_cq_social_moderation_dashboard_api_filter_group_social_componen_info = require "openapi-client.model.com_adobe_cq_social_moderation_dashboard_api_filter_group_social_componen_info"
local openapi-client_com_adobe_cq_social_moderation_dashboard_api_moderation_dashboard_social_info = require "openapi-client.model.com_adobe_cq_social_moderation_dashboard_api_moderation_dashboard_social_info"
local openapi-client_com_adobe_cq_social_moderation_dashboard_api_user_details_social_componen_info = require "openapi-client.model.com_adobe_cq_social_moderation_dashboard_api_user_details_social_componen_info"
local openapi-client_com_adobe_cq_social_moderation_dashboard_internal_impl_filter_group_soci_info = require "openapi-client.model.com_adobe_cq_social_moderation_dashboard_internal_impl_filter_group_soci_info"
local openapi-client_com_adobe_cq_social_notifications_impl_mentions_router_info = require "openapi-client.model.com_adobe_cq_social_notifications_impl_mentions_router_info"
local openapi-client_com_adobe_cq_social_notifications_impl_notification_manager_impl_info = require "openapi-client.model.com_adobe_cq_social_notifications_impl_notification_manager_impl_info"
local openapi-client_com_adobe_cq_social_notifications_impl_notifications_router_info = require "openapi-client.model.com_adobe_cq_social_notifications_impl_notifications_router_info"
local openapi-client_com_adobe_cq_social_qna_client_endpoints_impl_qna_forum_operations_servic_info = require "openapi-client.model.com_adobe_cq_social_qna_client_endpoints_impl_qna_forum_operations_servic_info"
local openapi-client_com_adobe_cq_social_reporting_analytics_services_impl_analytics_report_i_info = require "openapi-client.model.com_adobe_cq_social_reporting_analytics_services_impl_analytics_report_i_info"
local openapi-client_com_adobe_cq_social_reporting_analytics_services_impl_analytics_report_m_info = require "openapi-client.model.com_adobe_cq_social_reporting_analytics_services_impl_analytics_report_m_info"
local openapi-client_com_adobe_cq_social_reporting_analytics_services_impl_site_trend_report_s_info = require "openapi-client.model.com_adobe_cq_social_reporting_analytics_services_impl_site_trend_report_s_info"
local openapi-client_com_adobe_cq_social_review_client_endpoints_impl_review_operations_servi_info = require "openapi-client.model.com_adobe_cq_social_review_client_endpoints_impl_review_operations_servi_info"
local openapi-client_com_adobe_cq_social_scf_core_operations_impl_social_operations_servlet_info = require "openapi-client.model.com_adobe_cq_social_scf_core_operations_impl_social_operations_servlet_info"
local openapi-client_com_adobe_cq_social_scf_endpoints_impl_default_social_get_servlet_info = require "openapi-client.model.com_adobe_cq_social_scf_endpoints_impl_default_social_get_servlet_info"
local openapi-client_com_adobe_cq_social_scoring_impl_scoring_event_listener_info = require "openapi-client.model.com_adobe_cq_social_scoring_impl_scoring_event_listener_info"
local openapi-client_com_adobe_cq_social_serviceusers_internal_impl_service_user_wrapper_impl_info = require "openapi-client.model.com_adobe_cq_social_serviceusers_internal_impl_service_user_wrapper_impl_info"
local openapi-client_com_adobe_cq_social_site_endpoints_impl_site_operation_service_info = require "openapi-client.model.com_adobe_cq_social_site_endpoints_impl_site_operation_service_info"
local openapi-client_com_adobe_cq_social_site_impl_analytics_component_configuration_service_im_info = require "openapi-client.model.com_adobe_cq_social_site_impl_analytics_component_configuration_service_im_info"
local openapi-client_com_adobe_cq_social_site_impl_site_configurator_impl_info = require "openapi-client.model.com_adobe_cq_social_site_impl_site_configurator_impl_info"
local openapi-client_com_adobe_cq_social_srp_impl_social_solr_connector_info = require "openapi-client.model.com_adobe_cq_social_srp_impl_social_solr_connector_info"
local openapi-client_com_adobe_cq_social_sync_impl_diff_changes_observer_info = require "openapi-client.model.com_adobe_cq_social_sync_impl_diff_changes_observer_info"
local openapi-client_com_adobe_cq_social_sync_impl_group_sync_listener_impl_info = require "openapi-client.model.com_adobe_cq_social_sync_impl_group_sync_listener_impl_info"
local openapi-client_com_adobe_cq_social_sync_impl_publisher_sync_service_impl_info = require "openapi-client.model.com_adobe_cq_social_sync_impl_publisher_sync_service_impl_info"
local openapi-client_com_adobe_cq_social_sync_impl_user_sync_listener_impl_info = require "openapi-client.model.com_adobe_cq_social_sync_impl_user_sync_listener_impl_info"
local openapi-client_com_adobe_cq_social_translation_impl_translation_service_config_manager_info = require "openapi-client.model.com_adobe_cq_social_translation_impl_translation_service_config_manager_info"
local openapi-client_com_adobe_cq_social_translation_impl_ugc_language_detector_info = require "openapi-client.model.com_adobe_cq_social_translation_impl_ugc_language_detector_info"
local openapi-client_com_adobe_cq_social_ugcbase_dispatcher_impl_flush_service_impl_info = require "openapi-client.model.com_adobe_cq_social_ugcbase_dispatcher_impl_flush_service_impl_info"
local openapi-client_com_adobe_cq_social_ugcbase_impl_aysnc_reverse_replicator_impl_info = require "openapi-client.model.com_adobe_cq_social_ugcbase_impl_aysnc_reverse_replicator_impl_info"
local openapi-client_com_adobe_cq_social_ugcbase_impl_publisher_configuration_impl_info = require "openapi-client.model.com_adobe_cq_social_ugcbase_impl_publisher_configuration_impl_info"
local openapi-client_com_adobe_cq_social_ugcbase_impl_social_utils_impl_info = require "openapi-client.model.com_adobe_cq_social_ugcbase_impl_social_utils_impl_info"
local openapi-client_com_adobe_cq_social_ugcbase_moderation_impl_auto_moderation_impl_info = require "openapi-client.model.com_adobe_cq_social_ugcbase_moderation_impl_auto_moderation_impl_info"
local openapi-client_com_adobe_cq_social_ugcbase_moderation_impl_sentiment_process_info = require "openapi-client.model.com_adobe_cq_social_ugcbase_moderation_impl_sentiment_process_info"
local openapi-client_com_adobe_cq_social_ugcbase_security_impl_default_attachment_type_blackli_info = require "openapi-client.model.com_adobe_cq_social_ugcbase_security_impl_default_attachment_type_blackli_info"
local openapi-client_com_adobe_cq_social_ugcbase_security_impl_safer_sling_post_validator_impl_info = require "openapi-client.model.com_adobe_cq_social_ugcbase_security_impl_safer_sling_post_validator_impl_info"
local openapi-client_com_adobe_cq_social_user_endpoints_impl_users_group_from_publish_servlet_info = require "openapi-client.model.com_adobe_cq_social_user_endpoints_impl_users_group_from_publish_servlet_info"
local openapi-client_com_adobe_cq_social_user_impl_transport_http_to_publisher_info = require "openapi-client.model.com_adobe_cq_social_user_impl_transport_http_to_publisher_info"
local openapi-client_com_adobe_cq_ui_wcm_commons_internal_servlets_rte_rte_filter_servlet_fact_info = require "openapi-client.model.com_adobe_cq_ui_wcm_commons_internal_servlets_rte_rte_filter_servlet_fact_info"
local openapi-client_com_adobe_cq_upgrades_cleanup_impl_upgrade_content_cleanup_info = require "openapi-client.model.com_adobe_cq_upgrades_cleanup_impl_upgrade_content_cleanup_info"
local openapi-client_com_adobe_cq_upgrades_cleanup_impl_upgrade_install_folder_cleanup_info = require "openapi-client.model.com_adobe_cq_upgrades_cleanup_impl_upgrade_install_folder_cleanup_info"
local openapi-client_com_adobe_cq_wcm_jobs_async_impl_async_delete_config_provider_service_info = require "openapi-client.model.com_adobe_cq_wcm_jobs_async_impl_async_delete_config_provider_service_info"
local openapi-client_com_adobe_cq_wcm_jobs_async_impl_async_job_clean_up_task_info = require "openapi-client.model.com_adobe_cq_wcm_jobs_async_impl_async_job_clean_up_task_info"
local openapi-client_com_adobe_cq_wcm_jobs_async_impl_async_move_config_provider_service_info = require "openapi-client.model.com_adobe_cq_wcm_jobs_async_impl_async_move_config_provider_service_info"
local openapi-client_com_adobe_cq_wcm_jobs_async_impl_async_page_move_config_provider_service_info = require "openapi-client.model.com_adobe_cq_wcm_jobs_async_impl_async_page_move_config_provider_service_info"
local openapi-client_com_adobe_cq_wcm_launches_impl_launches_event_handler_info = require "openapi-client.model.com_adobe_cq_wcm_launches_impl_launches_event_handler_info"
local openapi-client_com_adobe_cq_wcm_mobile_qrcode_servlet_qr_code_image_generator_info = require "openapi-client.model.com_adobe_cq_wcm_mobile_qrcode_servlet_qr_code_image_generator_info"
local openapi-client_com_adobe_cq_wcm_style_internal_component_style_info_cache_impl_info = require "openapi-client.model.com_adobe_cq_wcm_style_internal_component_style_info_cache_impl_info"
local openapi-client_com_adobe_cq_wcm_translation_impl_translation_platform_configuration_impl_info = require "openapi-client.model.com_adobe_cq_wcm_translation_impl_translation_platform_configuration_impl_info"
local openapi-client_com_adobe_fd_fp_config_forms_portal_draftsand_submission_config_service_info = require "openapi-client.model.com_adobe_fd_fp_config_forms_portal_draftsand_submission_config_service_info"
local openapi-client_com_adobe_fd_fp_config_forms_portal_scheduler_service_info = require "openapi-client.model.com_adobe_fd_fp_config_forms_portal_scheduler_service_info"
local openapi-client_com_adobe_forms_common_service_impl_default_data_provider_info = require "openapi-client.model.com_adobe_forms_common_service_impl_default_data_provider_info"
local openapi-client_com_adobe_forms_common_service_impl_forms_common_configuration_service_imp_info = require "openapi-client.model.com_adobe_forms_common_service_impl_forms_common_configuration_service_imp_info"
local openapi-client_com_adobe_forms_common_servlet_temp_clean_up_task_info = require "openapi-client.model.com_adobe_forms_common_servlet_temp_clean_up_task_info"
local openapi-client_com_adobe_granite_acp_platform_platform_servlet_info = require "openapi-client.model.com_adobe_granite_acp_platform_platform_servlet_info"
local openapi-client_com_adobe_granite_activitystreams_impl_activity_manager_impl_info = require "openapi-client.model.com_adobe_granite_activitystreams_impl_activity_manager_impl_info"
local openapi-client_com_adobe_granite_analyzer_base_system_status_servlet_info = require "openapi-client.model.com_adobe_granite_analyzer_base_system_status_servlet_info"
local openapi-client_com_adobe_granite_analyzer_scripts_compile_all_scripts_compiler_servlet_info = require "openapi-client.model.com_adobe_granite_analyzer_scripts_compile_all_scripts_compiler_servlet_info"
local openapi-client_com_adobe_granite_apicontroller_filter_resolver_hook_factory_info = require "openapi-client.model.com_adobe_granite_apicontroller_filter_resolver_hook_factory_info"
local openapi-client_com_adobe_granite_auth_cert_impl_client_cert_auth_handler_info = require "openapi-client.model.com_adobe_granite_auth_cert_impl_client_cert_auth_handler_info"
local openapi-client_com_adobe_granite_auth_ims_impl_external_user_id_mapping_provider_extension_info = require "openapi-client.model.com_adobe_granite_auth_ims_impl_external_user_id_mapping_provider_extension_info"
local openapi-client_com_adobe_granite_auth_ims_impl_ims_access_token_request_customizer_impl_info = require "openapi-client.model.com_adobe_granite_auth_ims_impl_ims_access_token_request_customizer_impl_info"
local openapi-client_com_adobe_granite_auth_ims_impl_ims_instance_credentials_validator_info = require "openapi-client.model.com_adobe_granite_auth_ims_impl_ims_instance_credentials_validator_info"
local openapi-client_com_adobe_granite_auth_ims_impl_ims_provider_impl_info = require "openapi-client.model.com_adobe_granite_auth_ims_impl_ims_provider_impl_info"
local openapi-client_com_adobe_granite_auth_ims_impl_ims_config_provider_impl_info = require "openapi-client.model.com_adobe_granite_auth_ims_impl_ims_config_provider_impl_info"
local openapi-client_com_adobe_granite_auth_ims_info = require "openapi-client.model.com_adobe_granite_auth_ims_info"
local openapi-client_com_adobe_granite_auth_oauth_accesstoken_provider_info = require "openapi-client.model.com_adobe_granite_auth_oauth_accesstoken_provider_info"
local openapi-client_com_adobe_granite_auth_oauth_impl_bearer_authentication_handler_info = require "openapi-client.model.com_adobe_granite_auth_oauth_impl_bearer_authentication_handler_info"
local openapi-client_com_adobe_granite_auth_oauth_impl_default_token_validator_impl_info = require "openapi-client.model.com_adobe_granite_auth_oauth_impl_default_token_validator_impl_info"
local openapi-client_com_adobe_granite_auth_oauth_impl_facebook_provider_impl_info = require "openapi-client.model.com_adobe_granite_auth_oauth_impl_facebook_provider_impl_info"
local openapi-client_com_adobe_granite_auth_oauth_impl_github_provider_impl_info = require "openapi-client.model.com_adobe_granite_auth_oauth_impl_github_provider_impl_info"
local openapi-client_com_adobe_granite_auth_oauth_impl_granite_provider_info = require "openapi-client.model.com_adobe_granite_auth_oauth_impl_granite_provider_info"
local openapi-client_com_adobe_granite_auth_oauth_impl_helper_provider_config_manager_info = require "openapi-client.model.com_adobe_granite_auth_oauth_impl_helper_provider_config_manager_info"
local openapi-client_com_adobe_granite_auth_oauth_impl_helper_provider_config_manager_internal_info = require "openapi-client.model.com_adobe_granite_auth_oauth_impl_helper_provider_config_manager_internal_info"
local openapi-client_com_adobe_granite_auth_oauth_impl_o_auth_authentication_handler_info = require "openapi-client.model.com_adobe_granite_auth_oauth_impl_o_auth_authentication_handler_info"
local openapi-client_com_adobe_granite_auth_oauth_impl_twitter_provider_impl_info = require "openapi-client.model.com_adobe_granite_auth_oauth_impl_twitter_provider_impl_info"
local openapi-client_com_adobe_granite_auth_oauth_provider_info = require "openapi-client.model.com_adobe_granite_auth_oauth_provider_info"
local openapi-client_com_adobe_granite_auth_requirement_impl_default_requirement_handler_info = require "openapi-client.model.com_adobe_granite_auth_requirement_impl_default_requirement_handler_info"
local openapi-client_com_adobe_granite_auth_saml_saml_authentication_handler_info = require "openapi-client.model.com_adobe_granite_auth_saml_saml_authentication_handler_info"
local openapi-client_com_adobe_granite_auth_sso_impl_sso_authentication_handler_info = require "openapi-client.model.com_adobe_granite_auth_sso_impl_sso_authentication_handler_info"
local openapi-client_com_adobe_granite_bundles_hc_impl_code_cache_health_check_info = require "openapi-client.model.com_adobe_granite_bundles_hc_impl_code_cache_health_check_info"
local openapi-client_com_adobe_granite_bundles_hc_impl_crxde_support_bundle_health_check_info = require "openapi-client.model.com_adobe_granite_bundles_hc_impl_crxde_support_bundle_health_check_info"
local openapi-client_com_adobe_granite_bundles_hc_impl_dav_ex_bundle_health_check_info = require "openapi-client.model.com_adobe_granite_bundles_hc_impl_dav_ex_bundle_health_check_info"
local openapi-client_com_adobe_granite_bundles_hc_impl_inactive_bundles_health_check_info = require "openapi-client.model.com_adobe_granite_bundles_hc_impl_inactive_bundles_health_check_info"
local openapi-client_com_adobe_granite_bundles_hc_impl_jobs_health_check_info = require "openapi-client.model.com_adobe_granite_bundles_hc_impl_jobs_health_check_info"
local openapi-client_com_adobe_granite_bundles_hc_impl_sling_get_servlet_health_check_info = require "openapi-client.model.com_adobe_granite_bundles_hc_impl_sling_get_servlet_health_check_info"
local openapi-client_com_adobe_granite_bundles_hc_impl_sling_java_script_handler_health_check_info = require "openapi-client.model.com_adobe_granite_bundles_hc_impl_sling_java_script_handler_health_check_info"
local openapi-client_com_adobe_granite_bundles_hc_impl_sling_jsp_script_handler_health_check_info = require "openapi-client.model.com_adobe_granite_bundles_hc_impl_sling_jsp_script_handler_health_check_info"
local openapi-client_com_adobe_granite_bundles_hc_impl_sling_referrer_filter_health_check_info = require "openapi-client.model.com_adobe_granite_bundles_hc_impl_sling_referrer_filter_health_check_info"
local openapi-client_com_adobe_granite_bundles_hc_impl_web_dav_bundle_health_check_info = require "openapi-client.model.com_adobe_granite_bundles_hc_impl_web_dav_bundle_health_check_info"
local openapi-client_com_adobe_granite_comments_internal_comment_replication_content_filter_fac_info = require "openapi-client.model.com_adobe_granite_comments_internal_comment_replication_content_filter_fac_info"
local openapi-client_com_adobe_granite_compatrouter_impl_compat_switching_service_impl_info = require "openapi-client.model.com_adobe_granite_compatrouter_impl_compat_switching_service_impl_info"
local openapi-client_com_adobe_granite_compatrouter_impl_routing_config_info = require "openapi-client.model.com_adobe_granite_compatrouter_impl_routing_config_info"
local openapi-client_com_adobe_granite_compatrouter_impl_switch_mapping_config_info = require "openapi-client.model.com_adobe_granite_compatrouter_impl_switch_mapping_config_info"
local openapi-client_com_adobe_granite_conf_impl_runtime_aware_configuration_resource_resolving_info = require "openapi-client.model.com_adobe_granite_conf_impl_runtime_aware_configuration_resource_resolving_info"
local openapi-client_com_adobe_granite_contexthub_impl_context_hub_impl_info = require "openapi-client.model.com_adobe_granite_contexthub_impl_context_hub_impl_info"
local openapi-client_com_adobe_granite_cors_impl_cors_policy_impl_info = require "openapi-client.model.com_adobe_granite_cors_impl_cors_policy_impl_info"
local openapi-client_com_adobe_granite_csrf_impl_csrf_filter_info = require "openapi-client.model.com_adobe_granite_csrf_impl_csrf_filter_info"
local openapi-client_com_adobe_granite_csrf_impl_csrf_servlet_info = require "openapi-client.model.com_adobe_granite_csrf_impl_csrf_servlet_info"
local openapi-client_com_adobe_granite_distribution_core_impl_crypto_distribution_transport_se_info = require "openapi-client.model.com_adobe_granite_distribution_core_impl_crypto_distribution_transport_se_info"
local openapi-client_com_adobe_granite_distribution_core_impl_diff_diff_changes_observer_info = require "openapi-client.model.com_adobe_granite_distribution_core_impl_diff_diff_changes_observer_info"
local openapi-client_com_adobe_granite_distribution_core_impl_diff_diff_event_listener_info = require "openapi-client.model.com_adobe_granite_distribution_core_impl_diff_diff_event_listener_info"
local openapi-client_com_adobe_granite_distribution_core_impl_distribution_to_replication_even_info = require "openapi-client.model.com_adobe_granite_distribution_core_impl_distribution_to_replication_even_info"
local openapi-client_com_adobe_granite_distribution_core_impl_replication_adapters_replicat_info = require "openapi-client.model.com_adobe_granite_distribution_core_impl_replication_adapters_replicat_info"
local openapi-client_com_adobe_granite_distribution_core_impl_replication_distribution_trans_info = require "openapi-client.model.com_adobe_granite_distribution_core_impl_replication_distribution_trans_info"
local openapi-client_com_adobe_granite_distribution_core_impl_transport_access_token_distribu_info = require "openapi-client.model.com_adobe_granite_distribution_core_impl_transport_access_token_distribu_info"
local openapi-client_com_adobe_granite_frags_impl_check_http_header_flag_info = require "openapi-client.model.com_adobe_granite_frags_impl_check_http_header_flag_info"
local openapi-client_com_adobe_granite_frags_impl_random_feature_info = require "openapi-client.model.com_adobe_granite_frags_impl_random_feature_info"
local openapi-client_com_adobe_granite_httpcache_file_file_cache_store_info = require "openapi-client.model.com_adobe_granite_httpcache_file_file_cache_store_info"
local openapi-client_com_adobe_granite_httpcache_impl_outer_cache_filter_info = require "openapi-client.model.com_adobe_granite_httpcache_impl_outer_cache_filter_info"
local openapi-client_com_adobe_granite_i18n_impl_bundle_pseudo_translations_info = require "openapi-client.model.com_adobe_granite_i18n_impl_bundle_pseudo_translations_info"
local openapi-client_com_adobe_granite_i18n_impl_preferences_locale_resolver_service_info = require "openapi-client.model.com_adobe_granite_i18n_impl_preferences_locale_resolver_service_info"
local openapi-client_com_adobe_granite_infocollector_info_collector_info = require "openapi-client.model.com_adobe_granite_infocollector_info_collector_info"
local openapi-client_com_adobe_granite_jetty_ssl_internal_granite_ssl_connector_factory_info = require "openapi-client.model.com_adobe_granite_jetty_ssl_internal_granite_ssl_connector_factory_info"
local openapi-client_com_adobe_granite_license_impl_license_check_filter_info = require "openapi-client.model.com_adobe_granite_license_impl_license_check_filter_info"
local openapi-client_com_adobe_granite_logging_impl_log_analyser_impl_info = require "openapi-client.model.com_adobe_granite_logging_impl_log_analyser_impl_info"
local openapi-client_com_adobe_granite_logging_impl_log_error_health_check_info = require "openapi-client.model.com_adobe_granite_logging_impl_log_error_health_check_info"
local openapi-client_com_adobe_granite_maintenance_crx_impl_data_store_garbage_collection_task_info = require "openapi-client.model.com_adobe_granite_maintenance_crx_impl_data_store_garbage_collection_task_info"
local openapi-client_com_adobe_granite_maintenance_crx_impl_lucene_binaries_cleanup_task_info = require "openapi-client.model.com_adobe_granite_maintenance_crx_impl_lucene_binaries_cleanup_task_info"
local openapi-client_com_adobe_granite_maintenance_crx_impl_revision_cleanup_task_info = require "openapi-client.model.com_adobe_granite_maintenance_crx_impl_revision_cleanup_task_info"
local openapi-client_com_adobe_granite_monitoring_impl_script_config_impl_info = require "openapi-client.model.com_adobe_granite_monitoring_impl_script_config_impl_info"
local openapi-client_com_adobe_granite_oauth_server_auth_impl_o_auth2_server_authentication_han_info = require "openapi-client.model.com_adobe_granite_oauth_server_auth_impl_o_auth2_server_authentication_han_info"
local openapi-client_com_adobe_granite_oauth_server_impl_access_token_cleanup_task_info = require "openapi-client.model.com_adobe_granite_oauth_server_impl_access_token_cleanup_task_info"
local openapi-client_com_adobe_granite_oauth_server_impl_o_auth2_client_revocation_servlet_info = require "openapi-client.model.com_adobe_granite_oauth_server_impl_o_auth2_client_revocation_servlet_info"
local openapi-client_com_adobe_granite_oauth_server_impl_o_auth2_revocation_endpoint_servlet_info = require "openapi-client.model.com_adobe_granite_oauth_server_impl_o_auth2_revocation_endpoint_servlet_info"
local openapi-client_com_adobe_granite_oauth_server_impl_o_auth2_token_endpoint_servlet_info = require "openapi-client.model.com_adobe_granite_oauth_server_impl_o_auth2_token_endpoint_servlet_info"
local openapi-client_com_adobe_granite_oauth_server_impl_o_auth2_token_revocation_servlet_info = require "openapi-client.model.com_adobe_granite_oauth_server_impl_o_auth2_token_revocation_servlet_info"
local openapi-client_com_adobe_granite_offloading_impl_offloading_configurator_info = require "openapi-client.model.com_adobe_granite_offloading_impl_offloading_configurator_info"
local openapi-client_com_adobe_granite_offloading_impl_offloading_job_cloner_info = require "openapi-client.model.com_adobe_granite_offloading_impl_offloading_job_cloner_info"
local openapi-client_com_adobe_granite_offloading_impl_offloading_job_offloader_info = require "openapi-client.model.com_adobe_granite_offloading_impl_offloading_job_offloader_info"
local openapi-client_com_adobe_granite_offloading_impl_transporter_offloading_agent_manager_info = require "openapi-client.model.com_adobe_granite_offloading_impl_transporter_offloading_agent_manager_info"
local openapi-client_com_adobe_granite_offloading_impl_transporter_offloading_default_transpo_info = require "openapi-client.model.com_adobe_granite_offloading_impl_transporter_offloading_default_transpo_info"
local openapi-client_com_adobe_granite_omnisearch_impl_core_omni_search_service_impl_info = require "openapi-client.model.com_adobe_granite_omnisearch_impl_core_omni_search_service_impl_info"
local openapi-client_com_adobe_granite_optout_impl_opt_out_service_impl_info = require "openapi-client.model.com_adobe_granite_optout_impl_opt_out_service_impl_info"
local openapi-client_com_adobe_granite_queries_impl_hc_async_index_health_check_info = require "openapi-client.model.com_adobe_granite_queries_impl_hc_async_index_health_check_info"
local openapi-client_com_adobe_granite_queries_impl_hc_large_index_health_check_info = require "openapi-client.model.com_adobe_granite_queries_impl_hc_large_index_health_check_info"
local openapi-client_com_adobe_granite_queries_impl_hc_queries_status_health_check_info = require "openapi-client.model.com_adobe_granite_queries_impl_hc_queries_status_health_check_info"
local openapi-client_com_adobe_granite_queries_impl_hc_query_health_check_metrics_info = require "openapi-client.model.com_adobe_granite_queries_impl_hc_query_health_check_metrics_info"
local openapi-client_com_adobe_granite_queries_impl_hc_query_limits_health_check_info = require "openapi-client.model.com_adobe_granite_queries_impl_hc_query_limits_health_check_info"
local openapi-client_com_adobe_granite_replication_hc_impl_replication_queue_health_check_info = require "openapi-client.model.com_adobe_granite_replication_hc_impl_replication_queue_health_check_info"
local openapi-client_com_adobe_granite_replication_hc_impl_replication_transport_users_health_c_info = require "openapi-client.model.com_adobe_granite_replication_hc_impl_replication_transport_users_health_c_info"
local openapi-client_com_adobe_granite_repository_hc_impl_authorizable_node_name_health_check_info = require "openapi-client.model.com_adobe_granite_repository_hc_impl_authorizable_node_name_health_check_info"
local openapi-client_com_adobe_granite_repository_hc_impl_content_sling_sling_content_health_c_info = require "openapi-client.model.com_adobe_granite_repository_hc_impl_content_sling_sling_content_health_c_info"
local openapi-client_com_adobe_granite_repository_hc_impl_continuous_rgc_health_check_info = require "openapi-client.model.com_adobe_granite_repository_hc_impl_continuous_rgc_health_check_info"
local openapi-client_com_adobe_granite_repository_hc_impl_default_access_user_profile_health_che_info = require "openapi-client.model.com_adobe_granite_repository_hc_impl_default_access_user_profile_health_che_info"
local openapi-client_com_adobe_granite_repository_hc_impl_default_logins_health_check_info = require "openapi-client.model.com_adobe_granite_repository_hc_impl_default_logins_health_check_info"
local openapi-client_com_adobe_granite_repository_hc_impl_disk_space_health_check_info = require "openapi-client.model.com_adobe_granite_repository_hc_impl_disk_space_health_check_info"
local openapi-client_com_adobe_granite_repository_hc_impl_observation_queue_length_health_check_info = require "openapi-client.model.com_adobe_granite_repository_hc_impl_observation_queue_length_health_check_info"
local openapi-client_com_adobe_granite_repository_impl_commit_stats_config_info = require "openapi-client.model.com_adobe_granite_repository_impl_commit_stats_config_info"
local openapi-client_com_adobe_granite_repository_service_user_configuration_info = require "openapi-client.model.com_adobe_granite_repository_service_user_configuration_info"
local openapi-client_com_adobe_granite_requests_logging_impl_hc_requests_status_health_check_im_info = require "openapi-client.model.com_adobe_granite_requests_logging_impl_hc_requests_status_health_check_im_info"
local openapi-client_com_adobe_granite_resourcestatus_impl_composite_status_type_info = require "openapi-client.model.com_adobe_granite_resourcestatus_impl_composite_status_type_info"
local openapi-client_com_adobe_granite_resourcestatus_impl_status_resource_provider_impl_info = require "openapi-client.model.com_adobe_granite_resourcestatus_impl_status_resource_provider_impl_info"
local openapi-client_com_adobe_granite_rest_assets_impl_asset_content_disposition_filter_info = require "openapi-client.model.com_adobe_granite_rest_assets_impl_asset_content_disposition_filter_info"
local openapi-client_com_adobe_granite_rest_impl_api_endpoint_resource_provider_factory_impl_info = require "openapi-client.model.com_adobe_granite_rest_impl_api_endpoint_resource_provider_factory_impl_info"
local openapi-client_com_adobe_granite_rest_impl_servlet_default_get_servlet_info = require "openapi-client.model.com_adobe_granite_rest_impl_servlet_default_get_servlet_info"
local openapi-client_com_adobe_granite_security_user_ui_internal_servlets_ssl_configuration_s_info = require "openapi-client.model.com_adobe_granite_security_user_ui_internal_servlets_ssl_configuration_s_info"
local openapi-client_com_adobe_granite_security_user_user_properties_service_info = require "openapi-client.model.com_adobe_granite_security_user_user_properties_service_info"
local openapi-client_com_adobe_granite_socialgraph_impl_social_graph_factory_impl_info = require "openapi-client.model.com_adobe_granite_socialgraph_impl_social_graph_factory_impl_info"
local openapi-client_com_adobe_granite_system_monitoring_impl_system_stats_m_bean_impl_info = require "openapi-client.model.com_adobe_granite_system_monitoring_impl_system_stats_m_bean_impl_info"
local openapi-client_com_adobe_granite_taskmanagement_impl_jcr_task_adapter_factory_info = require "openapi-client.model.com_adobe_granite_taskmanagement_impl_jcr_task_adapter_factory_info"
local openapi-client_com_adobe_granite_taskmanagement_impl_jcr_task_archive_service_info = require "openapi-client.model.com_adobe_granite_taskmanagement_impl_jcr_task_archive_service_info"
local openapi-client_com_adobe_granite_taskmanagement_impl_purge_task_purge_maintenance_task_info = require "openapi-client.model.com_adobe_granite_taskmanagement_impl_purge_task_purge_maintenance_task_info"
local openapi-client_com_adobe_granite_taskmanagement_impl_service_task_manager_adapter_factor_info = require "openapi-client.model.com_adobe_granite_taskmanagement_impl_service_task_manager_adapter_factor_info"
local openapi-client_com_adobe_granite_threaddump_thread_dump_collector_info = require "openapi-client.model.com_adobe_granite_threaddump_thread_dump_collector_info"
local openapi-client_com_adobe_granite_translation_connector_msft_core_impl_microsoft_transl_info = require "openapi-client.model.com_adobe_granite_translation_connector_msft_core_impl_microsoft_transl_info"
local openapi-client_com_adobe_granite_translation_core_impl_translation_manager_impl_info = require "openapi-client.model.com_adobe_granite_translation_core_impl_translation_manager_impl_info"
local openapi-client_com_adobe_granite_ui_clientlibs_impl_html_library_manager_impl_info = require "openapi-client.model.com_adobe_granite_ui_clientlibs_impl_html_library_manager_impl_info"
local openapi-client_com_adobe_granite_workflow_console_frags_workflow_withdraw_feature_info = require "openapi-client.model.com_adobe_granite_workflow_console_frags_workflow_withdraw_feature_info"
local openapi-client_com_adobe_granite_workflow_console_publish_workflow_publish_event_service_info = require "openapi-client.model.com_adobe_granite_workflow_console_publish_workflow_publish_event_service_info"
local openapi-client_com_adobe_granite_workflow_core_jcr_workflow_bucket_manager_info = require "openapi-client.model.com_adobe_granite_workflow_core_jcr_workflow_bucket_manager_info"
local openapi-client_com_adobe_granite_workflow_core_job_external_process_job_handler_info = require "openapi-client.model.com_adobe_granite_workflow_core_job_external_process_job_handler_info"
local openapi-client_com_adobe_granite_workflow_core_job_job_handler_info = require "openapi-client.model.com_adobe_granite_workflow_core_job_job_handler_info"
local openapi-client_com_adobe_granite_workflow_core_offloading_workflow_offloading_job_consum_info = require "openapi-client.model.com_adobe_granite_workflow_core_offloading_workflow_offloading_job_consum_info"
local openapi-client_com_adobe_granite_workflow_core_payload_map_cache_info = require "openapi-client.model.com_adobe_granite_workflow_core_payload_map_cache_info"
local openapi-client_com_adobe_granite_workflow_core_payloadmap_payload_move_listener_info = require "openapi-client.model.com_adobe_granite_workflow_core_payloadmap_payload_move_listener_info"
local openapi-client_com_adobe_granite_workflow_core_workflow_config_info = require "openapi-client.model.com_adobe_granite_workflow_core_workflow_config_info"
local openapi-client_com_adobe_granite_workflow_core_workflow_session_factory_info = require "openapi-client.model.com_adobe_granite_workflow_core_workflow_session_factory_info"
local openapi-client_com_adobe_granite_workflow_purge_scheduler_info = require "openapi-client.model.com_adobe_granite_workflow_purge_scheduler_info"
local openapi-client_com_adobe_octopus_ncomm_bootstrap_info = require "openapi-client.model.com_adobe_octopus_ncomm_bootstrap_info"
local openapi-client_com_adobe_social_integrations_livefyre_user_pingforpull_impl_ping_pull_s_info = require "openapi-client.model.com_adobe_social_integrations_livefyre_user_pingforpull_impl_ping_pull_s_info"
local openapi-client_com_adobe_xmp_worker_files_ncomm_xmp_files_n_comm_info = require "openapi-client.model.com_adobe_xmp_worker_files_ncomm_xmp_files_n_comm_info"
local openapi-client_com_day_commons_datasource_jdbcpool_jdbc_pool_service_info = require "openapi-client.model.com_day_commons_datasource_jdbcpool_jdbc_pool_service_info"
local openapi-client_com_day_commons_httpclient_info = require "openapi-client.model.com_day_commons_httpclient_info"
local openapi-client_com_day_cq_analytics_impl_store_properties_change_listener_info = require "openapi-client.model.com_day_cq_analytics_impl_store_properties_change_listener_info"
local openapi-client_com_day_cq_analytics_sitecatalyst_impl_exporter_classifications_exporte_info = require "openapi-client.model.com_day_cq_analytics_sitecatalyst_impl_exporter_classifications_exporte_info"
local openapi-client_com_day_cq_analytics_sitecatalyst_impl_importer_report_importer_info = require "openapi-client.model.com_day_cq_analytics_sitecatalyst_impl_importer_report_importer_info"
local openapi-client_com_day_cq_analytics_sitecatalyst_impl_sitecatalyst_adapter_factory_info = require "openapi-client.model.com_day_cq_analytics_sitecatalyst_impl_sitecatalyst_adapter_factory_info"
local openapi-client_com_day_cq_analytics_sitecatalyst_impl_sitecatalyst_http_client_impl_info = require "openapi-client.model.com_day_cq_analytics_sitecatalyst_impl_sitecatalyst_http_client_impl_info"
local openapi-client_com_day_cq_analytics_testandtarget_impl_account_options_updater_info = require "openapi-client.model.com_day_cq_analytics_testandtarget_impl_account_options_updater_info"
local openapi-client_com_day_cq_analytics_testandtarget_impl_delete_author_activity_listener_info = require "openapi-client.model.com_day_cq_analytics_testandtarget_impl_delete_author_activity_listener_info"
local openapi-client_com_day_cq_analytics_testandtarget_impl_push_author_campaign_page_listener_info = require "openapi-client.model.com_day_cq_analytics_testandtarget_impl_push_author_campaign_page_listener_info"
local openapi-client_com_day_cq_analytics_testandtarget_impl_segment_importer_info = require "openapi-client.model.com_day_cq_analytics_testandtarget_impl_segment_importer_info"
local openapi-client_com_day_cq_analytics_testandtarget_impl_service_web_service_impl_info = require "openapi-client.model.com_day_cq_analytics_testandtarget_impl_service_web_service_impl_info"
local openapi-client_com_day_cq_analytics_testandtarget_impl_servlets_admin_server_servlet_info = require "openapi-client.model.com_day_cq_analytics_testandtarget_impl_servlets_admin_server_servlet_info"
local openapi-client_com_day_cq_analytics_testandtarget_impl_testandtarget_http_client_impl_info = require "openapi-client.model.com_day_cq_analytics_testandtarget_impl_testandtarget_http_client_impl_info"
local openapi-client_com_day_cq_auth_impl_cug_cug_support_impl_info = require "openapi-client.model.com_day_cq_auth_impl_cug_cug_support_impl_info"
local openapi-client_com_day_cq_auth_impl_login_selector_handler_info = require "openapi-client.model.com_day_cq_auth_impl_login_selector_handler_info"
local openapi-client_com_day_cq_commons_impl_externalizer_impl_info = require "openapi-client.model.com_day_cq_commons_impl_externalizer_impl_info"
local openapi-client_com_day_cq_commons_servlets_root_mapping_servlet_info = require "openapi-client.model.com_day_cq_commons_servlets_root_mapping_servlet_info"
local openapi-client_com_day_cq_compat_codeupgrade_impl_code_upgrade_execution_condition_checke_info = require "openapi-client.model.com_day_cq_compat_codeupgrade_impl_code_upgrade_execution_condition_checke_info"
local openapi-client_com_day_cq_compat_codeupgrade_impl_upgrade_task_ignore_list_info = require "openapi-client.model.com_day_cq_compat_codeupgrade_impl_upgrade_task_ignore_list_info"
local openapi-client_com_day_cq_compat_codeupgrade_impl_version_range_task_ignorelist_info = require "openapi-client.model.com_day_cq_compat_codeupgrade_impl_version_range_task_ignorelist_info"
local openapi-client_com_day_cq_contentsync_impl_content_sync_manager_impl_info = require "openapi-client.model.com_day_cq_contentsync_impl_content_sync_manager_impl_info"
local openapi-client_com_day_cq_dam_commons_handler_standard_image_handler_info = require "openapi-client.model.com_day_cq_dam_commons_handler_standard_image_handler_info"
local openapi-client_com_day_cq_dam_commons_metadata_xmp_filter_black_white_info = require "openapi-client.model.com_day_cq_dam_commons_metadata_xmp_filter_black_white_info"
local openapi-client_com_day_cq_dam_commons_util_impl_asset_cache_impl_info = require "openapi-client.model.com_day_cq_dam_commons_util_impl_asset_cache_impl_info"
local openapi-client_com_day_cq_dam_core_impl_annotation_pdf_annotation_pdf_config_info = require "openapi-client.model.com_day_cq_dam_core_impl_annotation_pdf_annotation_pdf_config_info"
local openapi-client_com_day_cq_dam_core_impl_asset_move_listener_info = require "openapi-client.model.com_day_cq_dam_core_impl_asset_move_listener_info"
local openapi-client_com_day_cq_dam_core_impl_assethome_asset_home_page_configuration_info = require "openapi-client.model.com_day_cq_dam_core_impl_assethome_asset_home_page_configuration_info"
local openapi-client_com_day_cq_dam_core_impl_assetlinkshare_adhoc_asset_share_proxy_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_assetlinkshare_adhoc_asset_share_proxy_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_cache_cq_buffered_image_cache_info = require "openapi-client.model.com_day_cq_dam_core_impl_cache_cq_buffered_image_cache_info"
local openapi-client_com_day_cq_dam_core_impl_dam_change_event_listener_info = require "openapi-client.model.com_day_cq_dam_core_impl_dam_change_event_listener_info"
local openapi-client_com_day_cq_dam_core_impl_dam_event_purge_service_info = require "openapi-client.model.com_day_cq_dam_core_impl_dam_event_purge_service_info"
local openapi-client_com_day_cq_dam_core_impl_dam_event_recorder_impl_info = require "openapi-client.model.com_day_cq_dam_core_impl_dam_event_recorder_impl_info"
local openapi-client_com_day_cq_dam_core_impl_event_dam_event_audit_listener_info = require "openapi-client.model.com_day_cq_dam_core_impl_event_dam_event_audit_listener_info"
local openapi-client_com_day_cq_dam_core_impl_expiry_notification_job_impl_info = require "openapi-client.model.com_day_cq_dam_core_impl_expiry_notification_job_impl_info"
local openapi-client_com_day_cq_dam_core_impl_foldermetadataschema_folder_metadata_schema_feat_info = require "openapi-client.model.com_day_cq_dam_core_impl_foldermetadataschema_folder_metadata_schema_feat_info"
local openapi-client_com_day_cq_dam_core_impl_gfx_commons_gfx_renderer_info = require "openapi-client.model.com_day_cq_dam_core_impl_gfx_commons_gfx_renderer_info"
local openapi-client_com_day_cq_dam_core_impl_handler_eps_format_handler_info = require "openapi-client.model.com_day_cq_dam_core_impl_handler_eps_format_handler_info"
local openapi-client_com_day_cq_dam_core_impl_handler_indesign_format_handler_info = require "openapi-client.model.com_day_cq_dam_core_impl_handler_indesign_format_handler_info"
local openapi-client_com_day_cq_dam_core_impl_handler_jpeg_handler_info = require "openapi-client.model.com_day_cq_dam_core_impl_handler_jpeg_handler_info"
local openapi-client_com_day_cq_dam_core_impl_handler_xmp_n_comm_xmp_handler_info = require "openapi-client.model.com_day_cq_dam_core_impl_handler_xmp_n_comm_xmp_handler_info"
local openapi-client_com_day_cq_dam_core_impl_jmx_asset_index_update_monitor_info = require "openapi-client.model.com_day_cq_dam_core_impl_jmx_asset_index_update_monitor_info"
local openapi-client_com_day_cq_dam_core_impl_jmx_asset_migration_m_bean_impl_info = require "openapi-client.model.com_day_cq_dam_core_impl_jmx_asset_migration_m_bean_impl_info"
local openapi-client_com_day_cq_dam_core_impl_jmx_asset_update_monitor_impl_info = require "openapi-client.model.com_day_cq_dam_core_impl_jmx_asset_update_monitor_impl_info"
local openapi-client_com_day_cq_dam_core_impl_jobs_metadataexport_async_metadata_export_config_info = require "openapi-client.model.com_day_cq_dam_core_impl_jobs_metadataexport_async_metadata_export_config_info"
local openapi-client_com_day_cq_dam_core_impl_jobs_metadataimport_async_metadata_import_config_info = require "openapi-client.model.com_day_cq_dam_core_impl_jobs_metadataimport_async_metadata_import_config_info"
local openapi-client_com_day_cq_dam_core_impl_lightbox_lightbox_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_lightbox_lightbox_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_metadata_editor_select_component_handler_info = require "openapi-client.model.com_day_cq_dam_core_impl_metadata_editor_select_component_handler_info"
local openapi-client_com_day_cq_dam_core_impl_mime_type_asset_upload_restriction_helper_info = require "openapi-client.model.com_day_cq_dam_core_impl_mime_type_asset_upload_restriction_helper_info"
local openapi-client_com_day_cq_dam_core_impl_mime_type_dam_mime_type_service_impl_info = require "openapi-client.model.com_day_cq_dam_core_impl_mime_type_dam_mime_type_service_impl_info"
local openapi-client_com_day_cq_dam_core_impl_missing_metadata_notification_job_info = require "openapi-client.model.com_day_cq_dam_core_impl_missing_metadata_notification_job_info"
local openapi-client_com_day_cq_dam_core_impl_process_send_transient_workflow_completed_email_pr_info = require "openapi-client.model.com_day_cq_dam_core_impl_process_send_transient_workflow_completed_email_pr_info"
local openapi-client_com_day_cq_dam_core_impl_process_text_extraction_process_info = require "openapi-client.model.com_day_cq_dam_core_impl_process_text_extraction_process_info"
local openapi-client_com_day_cq_dam_core_impl_rendition_maker_impl_info = require "openapi-client.model.com_day_cq_dam_core_impl_rendition_maker_impl_info"
local openapi-client_com_day_cq_dam_core_impl_reports_report_export_service_info = require "openapi-client.model.com_day_cq_dam_core_impl_reports_report_export_service_info"
local openapi-client_com_day_cq_dam_core_impl_reports_report_purge_service_info = require "openapi-client.model.com_day_cq_dam_core_impl_reports_report_purge_service_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_asset_download_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_asset_download_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_asset_status_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_asset_status_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_asset_xmp_search_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_asset_xmp_search_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_batch_metadata_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_batch_metadata_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_binary_provider_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_binary_provider_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_collection_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_collection_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_collections_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_collections_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_companion_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_companion_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_create_asset_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_create_asset_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_dam_content_disposition_filter_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_dam_content_disposition_filter_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_guid_lookup_filter_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_guid_lookup_filter_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_health_check_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_health_check_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_metadata_get_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_metadata_get_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_multiple_license_accept_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_multiple_license_accept_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_servlet_resource_collection_servlet_info = require "openapi-client.model.com_day_cq_dam_core_impl_servlet_resource_collection_servlet_info"
local openapi-client_com_day_cq_dam_core_impl_ui_preview_folder_preview_updater_impl_info = require "openapi-client.model.com_day_cq_dam_core_impl_ui_preview_folder_preview_updater_impl_info"
local openapi-client_com_day_cq_dam_core_impl_unzip_unzip_config_info = require "openapi-client.model.com_day_cq_dam_core_impl_unzip_unzip_config_info"
local openapi-client_com_day_cq_dam_core_process_exif_tool_extract_metadata_process_info = require "openapi-client.model.com_day_cq_dam_core_process_exif_tool_extract_metadata_process_info"
local openapi-client_com_day_cq_dam_core_process_extract_metadata_process_info = require "openapi-client.model.com_day_cq_dam_core_process_extract_metadata_process_info"
local openapi-client_com_day_cq_dam_core_process_metadata_processor_process_info = require "openapi-client.model.com_day_cq_dam_core_process_metadata_processor_process_info"
local openapi-client_com_day_cq_dam_handler_ffmpeg_locator_impl_info = require "openapi-client.model.com_day_cq_dam_handler_ffmpeg_locator_impl_info"
local openapi-client_com_day_cq_dam_handler_gibson_fontmanager_impl_font_manager_service_impl_info = require "openapi-client.model.com_day_cq_dam_handler_gibson_fontmanager_impl_font_manager_service_impl_info"
local openapi-client_com_day_cq_dam_handler_standard_pdf_pdf_handler_info = require "openapi-client.model.com_day_cq_dam_handler_standard_pdf_pdf_handler_info"
local openapi-client_com_day_cq_dam_handler_standard_ps_post_script_handler_info = require "openapi-client.model.com_day_cq_dam_handler_standard_ps_post_script_handler_info"
local openapi-client_com_day_cq_dam_handler_standard_psd_psd_handler_info = require "openapi-client.model.com_day_cq_dam_handler_standard_psd_psd_handler_info"
local openapi-client_com_day_cq_dam_ids_impl_ids_job_processor_info = require "openapi-client.model.com_day_cq_dam_ids_impl_ids_job_processor_info"
local openapi-client_com_day_cq_dam_ids_impl_ids_pool_manager_impl_info = require "openapi-client.model.com_day_cq_dam_ids_impl_ids_pool_manager_impl_info"
local openapi-client_com_day_cq_dam_indd_impl_handler_indesign_xmp_handler_info = require "openapi-client.model.com_day_cq_dam_indd_impl_handler_indesign_xmp_handler_info"
local openapi-client_com_day_cq_dam_indd_impl_servlet_snippet_creation_servlet_info = require "openapi-client.model.com_day_cq_dam_indd_impl_servlet_snippet_creation_servlet_info"
local openapi-client_com_day_cq_dam_indd_process_indd_media_extract_process_info = require "openapi-client.model.com_day_cq_dam_indd_process_indd_media_extract_process_info"
local openapi-client_com_day_cq_dam_performance_internal_asset_performance_data_handler_impl_info = require "openapi-client.model.com_day_cq_dam_performance_internal_asset_performance_data_handler_impl_info"
local openapi-client_com_day_cq_dam_performance_internal_asset_performance_report_sync_job_info = require "openapi-client.model.com_day_cq_dam_performance_internal_asset_performance_report_sync_job_info"
local openapi-client_com_day_cq_dam_pim_impl_sourcing_upload_process_product_assets_upload_pro_info = require "openapi-client.model.com_day_cq_dam_pim_impl_sourcing_upload_process_product_assets_upload_pro_info"
local openapi-client_com_day_cq_dam_s7dam_common_analytics_impl_s7dam_dynamic_media_config_even_info = require "openapi-client.model.com_day_cq_dam_s7dam_common_analytics_impl_s7dam_dynamic_media_config_even_info"
local openapi-client_com_day_cq_dam_s7dam_common_analytics_impl_site_catalyst_report_runner_info = require "openapi-client.model.com_day_cq_dam_s7dam_common_analytics_impl_site_catalyst_report_runner_info"
local openapi-client_com_day_cq_dam_s7dam_common_post_servlets_set_create_handler_info = require "openapi-client.model.com_day_cq_dam_s7dam_common_post_servlets_set_create_handler_info"
local openapi-client_com_day_cq_dam_s7dam_common_post_servlets_set_modify_handler_info = require "openapi-client.model.com_day_cq_dam_s7dam_common_post_servlets_set_modify_handler_info"
local openapi-client_com_day_cq_dam_s7dam_common_process_video_thumbnail_download_process_info = require "openapi-client.model.com_day_cq_dam_s7dam_common_process_video_thumbnail_download_process_info"
local openapi-client_com_day_cq_dam_s7dam_common_s7dam_dam_change_event_listener_info = require "openapi-client.model.com_day_cq_dam_s7dam_common_s7dam_dam_change_event_listener_info"
local openapi-client_com_day_cq_dam_s7dam_common_servlets_s7dam_product_info_servlet_info = require "openapi-client.model.com_day_cq_dam_s7dam_common_servlets_s7dam_product_info_servlet_info"
local openapi-client_com_day_cq_dam_s7dam_common_video_impl_video_proxy_client_service_impl_info = require "openapi-client.model.com_day_cq_dam_s7dam_common_video_impl_video_proxy_client_service_impl_info"
local openapi-client_com_day_cq_dam_scene7_impl_scene7_api_client_impl_info = require "openapi-client.model.com_day_cq_dam_scene7_impl_scene7_api_client_impl_info"
local openapi-client_com_day_cq_dam_scene7_impl_scene7_asset_mime_type_service_impl_info = require "openapi-client.model.com_day_cq_dam_scene7_impl_scene7_asset_mime_type_service_impl_info"
local openapi-client_com_day_cq_dam_scene7_impl_scene7_configuration_event_listener_info = require "openapi-client.model.com_day_cq_dam_scene7_impl_scene7_configuration_event_listener_info"
local openapi-client_com_day_cq_dam_scene7_impl_scene7_dam_change_event_listener_info = require "openapi-client.model.com_day_cq_dam_scene7_impl_scene7_dam_change_event_listener_info"
local openapi-client_com_day_cq_dam_scene7_impl_scene7_flash_templates_service_impl_info = require "openapi-client.model.com_day_cq_dam_scene7_impl_scene7_flash_templates_service_impl_info"
local openapi-client_com_day_cq_dam_scene7_impl_scene7_upload_service_impl_info = require "openapi-client.model.com_day_cq_dam_scene7_impl_scene7_upload_service_impl_info"
local openapi-client_com_day_cq_dam_stock_integration_impl_cache_stock_cache_configuration_ser_info = require "openapi-client.model.com_day_cq_dam_stock_integration_impl_cache_stock_cache_configuration_ser_info"
local openapi-client_com_day_cq_dam_stock_integration_impl_configuration_stock_configuration_info = require "openapi-client.model.com_day_cq_dam_stock_integration_impl_configuration_stock_configuration_info"
local openapi-client_com_day_cq_dam_video_impl_servlet_video_test_servlet_info = require "openapi-client.model.com_day_cq_dam_video_impl_servlet_video_test_servlet_info"
local openapi-client_com_day_cq_extwidget_servlets_image_sprite_servlet_info = require "openapi-client.model.com_day_cq_extwidget_servlets_image_sprite_servlet_info"
local openapi-client_com_day_cq_image_internal_font_font_helper_info = require "openapi-client.model.com_day_cq_image_internal_font_font_helper_info"
local openapi-client_com_day_cq_jcrclustersupport_cluster_start_level_controller_info = require "openapi-client.model.com_day_cq_jcrclustersupport_cluster_start_level_controller_info"
local openapi-client_com_day_cq_mailer_default_mail_service_info = require "openapi-client.model.com_day_cq_mailer_default_mail_service_info"
local openapi-client_com_day_cq_mailer_impl_cq_mailing_service_info = require "openapi-client.model.com_day_cq_mailer_impl_cq_mailing_service_info"
local openapi-client_com_day_cq_mailer_impl_email_cq_email_template_factory_info = require "openapi-client.model.com_day_cq_mailer_impl_email_cq_email_template_factory_info"
local openapi-client_com_day_cq_mailer_impl_email_cq_retriever_template_factory_info = require "openapi-client.model.com_day_cq_mailer_impl_email_cq_retriever_template_factory_info"
local openapi-client_com_day_cq_mcm_campaign_impl_integration_config_impl_info = require "openapi-client.model.com_day_cq_mcm_campaign_impl_integration_config_impl_info"
local openapi-client_com_day_cq_mcm_campaign_importer_personalized_text_handler_factory_info = require "openapi-client.model.com_day_cq_mcm_campaign_importer_personalized_text_handler_factory_info"
local openapi-client_com_day_cq_mcm_core_newsletter_newsletter_email_service_impl_info = require "openapi-client.model.com_day_cq_mcm_core_newsletter_newsletter_email_service_impl_info"
local openapi-client_com_day_cq_mcm_impl_mcm_configuration_info = require "openapi-client.model.com_day_cq_mcm_impl_mcm_configuration_info"
local openapi-client_com_day_cq_mcm_landingpage_parser_taghandlers_cta_click_through_componen_info = require "openapi-client.model.com_day_cq_mcm_landingpage_parser_taghandlers_cta_click_through_componen_info"
local openapi-client_com_day_cq_mcm_landingpage_parser_taghandlers_cta_graphical_click_throug_info = require "openapi-client.model.com_day_cq_mcm_landingpage_parser_taghandlers_cta_graphical_click_throug_info"
local openapi-client_com_day_cq_mcm_landingpage_parser_taghandlers_cta_lead_form_cta_component_info = require "openapi-client.model.com_day_cq_mcm_landingpage_parser_taghandlers_cta_lead_form_cta_component_info"
local openapi-client_com_day_cq_mcm_landingpage_parser_taghandlers_mbox_m_box_experience_tag_ha_info = require "openapi-client.model.com_day_cq_mcm_landingpage_parser_taghandlers_mbox_m_box_experience_tag_ha_info"
local openapi-client_com_day_cq_mcm_landingpage_parser_taghandlers_mbox_target_component_tag_h_info = require "openapi-client.model.com_day_cq_mcm_landingpage_parser_taghandlers_mbox_target_component_tag_h_info"
local openapi-client_com_day_cq_notification_impl_notification_service_impl_info = require "openapi-client.model.com_day_cq_notification_impl_notification_service_impl_info"
local openapi-client_com_day_cq_personalization_impl_servlets_targeting_configuration_servlet_info = require "openapi-client.model.com_day_cq_personalization_impl_servlets_targeting_configuration_servlet_info"
local openapi-client_com_day_cq_polling_importer_impl_managed_poll_config_impl_info = require "openapi-client.model.com_day_cq_polling_importer_impl_managed_poll_config_impl_info"
local openapi-client_com_day_cq_polling_importer_impl_managed_polling_importer_impl_info = require "openapi-client.model.com_day_cq_polling_importer_impl_managed_polling_importer_impl_info"
local openapi-client_com_day_cq_polling_importer_impl_polling_importer_impl_info = require "openapi-client.model.com_day_cq_polling_importer_impl_polling_importer_impl_info"
local openapi-client_com_day_cq_replication_audit_replication_event_listener_info = require "openapi-client.model.com_day_cq_replication_audit_replication_event_listener_info"
local openapi-client_com_day_cq_replication_content_static_content_builder_info = require "openapi-client.model.com_day_cq_replication_content_static_content_builder_info"
local openapi-client_com_day_cq_replication_impl_agent_manager_impl_info = require "openapi-client.model.com_day_cq_replication_impl_agent_manager_impl_info"
local openapi-client_com_day_cq_replication_impl_content_durbo_binary_less_content_builder_info = require "openapi-client.model.com_day_cq_replication_impl_content_durbo_binary_less_content_builder_info"
local openapi-client_com_day_cq_replication_impl_content_durbo_durbo_import_configuration_prov_info = require "openapi-client.model.com_day_cq_replication_impl_content_durbo_durbo_import_configuration_prov_info"
local openapi-client_com_day_cq_replication_impl_replication_content_factory_provider_impl_info = require "openapi-client.model.com_day_cq_replication_impl_replication_content_factory_provider_impl_info"
local openapi-client_com_day_cq_replication_impl_replication_receiver_impl_info = require "openapi-client.model.com_day_cq_replication_impl_replication_receiver_impl_info"
local openapi-client_com_day_cq_replication_impl_replicator_impl_info = require "openapi-client.model.com_day_cq_replication_impl_replicator_impl_info"
local openapi-client_com_day_cq_replication_impl_reverse_replicator_info = require "openapi-client.model.com_day_cq_replication_impl_reverse_replicator_info"
local openapi-client_com_day_cq_replication_impl_transport_binary_less_transport_handler_info = require "openapi-client.model.com_day_cq_replication_impl_transport_binary_less_transport_handler_info"
local openapi-client_com_day_cq_replication_impl_transport_http_info = require "openapi-client.model.com_day_cq_replication_impl_transport_http_info"
local openapi-client_com_day_cq_reporting_impl_cache_cache_impl_info = require "openapi-client.model.com_day_cq_reporting_impl_cache_cache_impl_info"
local openapi-client_com_day_cq_reporting_impl_config_service_impl_info = require "openapi-client.model.com_day_cq_reporting_impl_config_service_impl_info"
local openapi-client_com_day_cq_reporting_impl_r_log_analyzer_info = require "openapi-client.model.com_day_cq_reporting_impl_r_log_analyzer_info"
local openapi-client_com_day_cq_rewriter_linkchecker_impl_link_checker_impl_info = require "openapi-client.model.com_day_cq_rewriter_linkchecker_impl_link_checker_impl_info"
local openapi-client_com_day_cq_rewriter_linkchecker_impl_link_checker_task_info = require "openapi-client.model.com_day_cq_rewriter_linkchecker_impl_link_checker_task_info"
local openapi-client_com_day_cq_rewriter_linkchecker_impl_link_checker_transformer_factory_info = require "openapi-client.model.com_day_cq_rewriter_linkchecker_impl_link_checker_transformer_factory_info"
local openapi-client_com_day_cq_rewriter_linkchecker_impl_link_info_storage_impl_info = require "openapi-client.model.com_day_cq_rewriter_linkchecker_impl_link_info_storage_impl_info"
local openapi-client_com_day_cq_rewriter_processor_impl_html_parser_factory_info = require "openapi-client.model.com_day_cq_rewriter_processor_impl_html_parser_factory_info"
local openapi-client_com_day_cq_search_impl_builder_query_builder_impl_info = require "openapi-client.model.com_day_cq_search_impl_builder_query_builder_impl_info"
local openapi-client_com_day_cq_search_suggest_impl_suggestion_index_manager_impl_info = require "openapi-client.model.com_day_cq_search_suggest_impl_suggestion_index_manager_impl_info"
local openapi-client_com_day_cq_searchpromote_impl_publish_search_promote_config_handler_info = require "openapi-client.model.com_day_cq_searchpromote_impl_publish_search_promote_config_handler_info"
local openapi-client_com_day_cq_searchpromote_impl_search_promote_service_impl_info = require "openapi-client.model.com_day_cq_searchpromote_impl_search_promote_service_impl_info"
local openapi-client_com_day_cq_security_acl_setup_info = require "openapi-client.model.com_day_cq_security_acl_setup_info"
local openapi-client_com_day_cq_statistics_impl_statistics_service_impl_info = require "openapi-client.model.com_day_cq_statistics_impl_statistics_service_impl_info"
local openapi-client_com_day_cq_tagging_impl_jcr_tag_manager_factory_impl_info = require "openapi-client.model.com_day_cq_tagging_impl_jcr_tag_manager_factory_impl_info"
local openapi-client_com_day_cq_tagging_impl_search_tag_predicate_evaluator_info = require "openapi-client.model.com_day_cq_tagging_impl_search_tag_predicate_evaluator_info"
local openapi-client_com_day_cq_tagging_impl_tag_garbage_collector_info = require "openapi-client.model.com_day_cq_tagging_impl_tag_garbage_collector_info"
local openapi-client_com_day_cq_wcm_contentsync_impl_handler_pages_update_handler_info = require "openapi-client.model.com_day_cq_wcm_contentsync_impl_handler_pages_update_handler_info"
local openapi-client_com_day_cq_wcm_contentsync_impl_rewriter_path_rewriter_transformer_factor_info = require "openapi-client.model.com_day_cq_wcm_contentsync_impl_rewriter_path_rewriter_transformer_factor_info"
local openapi-client_com_day_cq_wcm_core_impl_authoring_ui_mode_service_impl_info = require "openapi-client.model.com_day_cq_wcm_core_impl_authoring_ui_mode_service_impl_info"
local openapi-client_com_day_cq_wcm_core_impl_commands_wcm_command_servlet_info = require "openapi-client.model.com_day_cq_wcm_core_impl_commands_wcm_command_servlet_info"
local openapi-client_com_day_cq_wcm_core_impl_devicedetection_device_identification_mode_impl_info = require "openapi-client.model.com_day_cq_wcm_core_impl_devicedetection_device_identification_mode_impl_info"
local openapi-client_com_day_cq_wcm_core_impl_event_page_event_audit_listener_info = require "openapi-client.model.com_day_cq_wcm_core_impl_event_page_event_audit_listener_info"
local openapi-client_com_day_cq_wcm_core_impl_event_page_post_processor_info = require "openapi-client.model.com_day_cq_wcm_core_impl_event_page_post_processor_info"
local openapi-client_com_day_cq_wcm_core_impl_event_repository_change_event_listener_info = require "openapi-client.model.com_day_cq_wcm_core_impl_event_repository_change_event_listener_info"
local openapi-client_com_day_cq_wcm_core_impl_event_template_post_processor_info = require "openapi-client.model.com_day_cq_wcm_core_impl_event_template_post_processor_info"
local openapi-client_com_day_cq_wcm_core_impl_language_manager_impl_info = require "openapi-client.model.com_day_cq_wcm_core_impl_language_manager_impl_info"
local openapi-client_com_day_cq_wcm_core_impl_link_checker_configuration_factory_impl_info = require "openapi-client.model.com_day_cq_wcm_core_impl_link_checker_configuration_factory_impl_info"
local openapi-client_com_day_cq_wcm_core_impl_page_page_info_aggregator_impl_info = require "openapi-client.model.com_day_cq_wcm_core_impl_page_page_info_aggregator_impl_info"
local openapi-client_com_day_cq_wcm_core_impl_page_page_manager_factory_impl_info = require "openapi-client.model.com_day_cq_wcm_core_impl_page_page_manager_factory_impl_info"
local openapi-client_com_day_cq_wcm_core_impl_references_content_content_reference_config_info = require "openapi-client.model.com_day_cq_wcm_core_impl_references_content_content_reference_config_info"
local openapi-client_com_day_cq_wcm_core_impl_servlets_contentfinder_asset_view_handler_info = require "openapi-client.model.com_day_cq_wcm_core_impl_servlets_contentfinder_asset_view_handler_info"
local openapi-client_com_day_cq_wcm_core_impl_servlets_contentfinder_connector_connector_vie_info = require "openapi-client.model.com_day_cq_wcm_core_impl_servlets_contentfinder_connector_connector_vie_info"
local openapi-client_com_day_cq_wcm_core_impl_servlets_contentfinder_page_view_handler_info = require "openapi-client.model.com_day_cq_wcm_core_impl_servlets_contentfinder_page_view_handler_info"
local openapi-client_com_day_cq_wcm_core_impl_servlets_find_replace_servlet_info = require "openapi-client.model.com_day_cq_wcm_core_impl_servlets_find_replace_servlet_info"
local openapi-client_com_day_cq_wcm_core_impl_servlets_reference_search_servlet_info = require "openapi-client.model.com_day_cq_wcm_core_impl_servlets_reference_search_servlet_info"
local openapi-client_com_day_cq_wcm_core_impl_servlets_thumbnail_servlet_info = require "openapi-client.model.com_day_cq_wcm_core_impl_servlets_thumbnail_servlet_info"
local openapi-client_com_day_cq_wcm_core_impl_utils_default_page_name_validator_info = require "openapi-client.model.com_day_cq_wcm_core_impl_utils_default_page_name_validator_info"
local openapi-client_com_day_cq_wcm_core_impl_variants_page_variants_provider_impl_info = require "openapi-client.model.com_day_cq_wcm_core_impl_variants_page_variants_provider_impl_info"
local openapi-client_com_day_cq_wcm_core_impl_version_manager_impl_info = require "openapi-client.model.com_day_cq_wcm_core_impl_version_manager_impl_info"
local openapi-client_com_day_cq_wcm_core_impl_version_purge_task_info = require "openapi-client.model.com_day_cq_wcm_core_impl_version_purge_task_info"
local openapi-client_com_day_cq_wcm_core_impl_wcm_debug_filter_info = require "openapi-client.model.com_day_cq_wcm_core_impl_wcm_debug_filter_info"
local openapi-client_com_day_cq_wcm_core_impl_wcm_developer_mode_filter_info = require "openapi-client.model.com_day_cq_wcm_core_impl_wcm_developer_mode_filter_info"
local openapi-client_com_day_cq_wcm_core_impl_warp_time_warp_filter_info = require "openapi-client.model.com_day_cq_wcm_core_impl_warp_time_warp_filter_info"
local openapi-client_com_day_cq_wcm_core_mvt_mvt_statistics_impl_info = require "openapi-client.model.com_day_cq_wcm_core_mvt_mvt_statistics_impl_info"
local openapi-client_com_day_cq_wcm_core_stats_page_view_statistics_impl_info = require "openapi-client.model.com_day_cq_wcm_core_stats_page_view_statistics_impl_info"
local openapi-client_com_day_cq_wcm_core_wcm_request_filter_info = require "openapi-client.model.com_day_cq_wcm_core_wcm_request_filter_info"
local openapi-client_com_day_cq_wcm_designimporter_design_package_importer_info = require "openapi-client.model.com_day_cq_wcm_designimporter_design_package_importer_info"
local openapi-client_com_day_cq_wcm_designimporter_impl_canvas_builder_impl_info = require "openapi-client.model.com_day_cq_wcm_designimporter_impl_canvas_builder_impl_info"
local openapi-client_com_day_cq_wcm_designimporter_impl_canvas_page_delete_handler_info = require "openapi-client.model.com_day_cq_wcm_designimporter_impl_canvas_page_delete_handler_info"
local openapi-client_com_day_cq_wcm_designimporter_impl_entry_preprocessor_impl_info = require "openapi-client.model.com_day_cq_wcm_designimporter_impl_entry_preprocessor_impl_info"
local openapi-client_com_day_cq_wcm_designimporter_impl_mobile_canvas_builder_impl_info = require "openapi-client.model.com_day_cq_wcm_designimporter_impl_mobile_canvas_builder_impl_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_canvas_compone_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_canvas_compone_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_default_compon_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_default_compon_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_default_tag_han_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_default_tag_han_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_head_tag_handle_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_head_tag_handle_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_i_frame_tag_hand_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_i_frame_tag_hand_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_image_componen_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_image_componen_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_img_tag_handler_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_img_tag_handler_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_inline_script_t_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_inline_script_t_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_link_tag_handle_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_link_tag_handle_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_meta_tag_handle_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_meta_tag_handle_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_non_script_tag_h_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_non_script_tag_h_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_parsys_compone_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_parsys_compone_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_script_tag_hand_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_script_tag_hand_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_style_tag_handl_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_style_tag_handl_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_text_component_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_text_component_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_title_componen_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_title_componen_info"
local openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_title_tag_handl_info = require "openapi-client.model.com_day_cq_wcm_designimporter_parser_taghandlers_factory_title_tag_handl_info"
local openapi-client_com_day_cq_wcm_foundation_forms_impl_form_chooser_servlet_info = require "openapi-client.model.com_day_cq_wcm_foundation_forms_impl_form_chooser_servlet_info"
local openapi-client_com_day_cq_wcm_foundation_forms_impl_form_paragraph_post_processor_info = require "openapi-client.model.com_day_cq_wcm_foundation_forms_impl_form_paragraph_post_processor_info"
local openapi-client_com_day_cq_wcm_foundation_forms_impl_forms_handling_servlet_info = require "openapi-client.model.com_day_cq_wcm_foundation_forms_impl_forms_handling_servlet_info"
local openapi-client_com_day_cq_wcm_foundation_forms_impl_mail_servlet_info = require "openapi-client.model.com_day_cq_wcm_foundation_forms_impl_mail_servlet_info"
local openapi-client_com_day_cq_wcm_foundation_impl_adaptive_image_component_servlet_info = require "openapi-client.model.com_day_cq_wcm_foundation_impl_adaptive_image_component_servlet_info"
local openapi-client_com_day_cq_wcm_foundation_impl_http_auth_handler_info = require "openapi-client.model.com_day_cq_wcm_foundation_impl_http_auth_handler_info"
local openapi-client_com_day_cq_wcm_foundation_impl_page_impressions_tracker_info = require "openapi-client.model.com_day_cq_wcm_foundation_impl_page_impressions_tracker_info"
local openapi-client_com_day_cq_wcm_foundation_impl_page_redirect_servlet_info = require "openapi-client.model.com_day_cq_wcm_foundation_impl_page_redirect_servlet_info"
local openapi-client_com_day_cq_wcm_foundation_security_impl_default_attachment_type_blacklist_info = require "openapi-client.model.com_day_cq_wcm_foundation_security_impl_default_attachment_type_blacklist_info"
local openapi-client_com_day_cq_wcm_foundation_security_impl_safer_sling_post_validator_impl_info = require "openapi-client.model.com_day_cq_wcm_foundation_security_impl_safer_sling_post_validator_impl_info"
local openapi-client_com_day_cq_wcm_mobile_core_impl_device_device_info_transformer_factory_info = require "openapi-client.model.com_day_cq_wcm_mobile_core_impl_device_device_info_transformer_factory_info"
local openapi-client_com_day_cq_wcm_mobile_core_impl_redirect_redirect_filter_info = require "openapi-client.model.com_day_cq_wcm_mobile_core_impl_redirect_redirect_filter_info"
local openapi-client_com_day_cq_wcm_msm_impl_actions_content_copy_action_factory_info = require "openapi-client.model.com_day_cq_wcm_msm_impl_actions_content_copy_action_factory_info"
local openapi-client_com_day_cq_wcm_msm_impl_actions_content_delete_action_factory_info = require "openapi-client.model.com_day_cq_wcm_msm_impl_actions_content_delete_action_factory_info"
local openapi-client_com_day_cq_wcm_msm_impl_actions_content_update_action_factory_info = require "openapi-client.model.com_day_cq_wcm_msm_impl_actions_content_update_action_factory_info"
local openapi-client_com_day_cq_wcm_msm_impl_actions_order_children_action_factory_info = require "openapi-client.model.com_day_cq_wcm_msm_impl_actions_order_children_action_factory_info"
local openapi-client_com_day_cq_wcm_msm_impl_actions_page_move_action_factory_info = require "openapi-client.model.com_day_cq_wcm_msm_impl_actions_page_move_action_factory_info"
local openapi-client_com_day_cq_wcm_msm_impl_actions_references_update_action_factory_info = require "openapi-client.model.com_day_cq_wcm_msm_impl_actions_references_update_action_factory_info"
local openapi-client_com_day_cq_wcm_msm_impl_actions_version_copy_action_factory_info = require "openapi-client.model.com_day_cq_wcm_msm_impl_actions_version_copy_action_factory_info"
local openapi-client_com_day_cq_wcm_msm_impl_live_relationship_manager_impl_info = require "openapi-client.model.com_day_cq_wcm_msm_impl_live_relationship_manager_impl_info"
local openapi-client_com_day_cq_wcm_msm_impl_rollout_manager_impl_info = require "openapi-client.model.com_day_cq_wcm_msm_impl_rollout_manager_impl_info"
local openapi-client_com_day_cq_wcm_msm_impl_servlets_audit_log_servlet_info = require "openapi-client.model.com_day_cq_wcm_msm_impl_servlets_audit_log_servlet_info"
local openapi-client_com_day_cq_wcm_notification_email_impl_email_channel_info = require "openapi-client.model.com_day_cq_wcm_notification_email_impl_email_channel_info"
local openapi-client_com_day_cq_wcm_notification_impl_notification_manager_impl_info = require "openapi-client.model.com_day_cq_wcm_notification_impl_notification_manager_impl_info"
local openapi-client_com_day_cq_wcm_scripting_impl_bvp_manager_info = require "openapi-client.model.com_day_cq_wcm_scripting_impl_bvp_manager_info"
local openapi-client_com_day_cq_wcm_undo_undo_config_info = require "openapi-client.model.com_day_cq_wcm_undo_undo_config_info"
local openapi-client_com_day_cq_wcm_webservicesupport_impl_replication_event_listener_info = require "openapi-client.model.com_day_cq_wcm_webservicesupport_impl_replication_event_listener_info"
local openapi-client_com_day_cq_wcm_workflow_impl_wcm_workflow_service_impl_info = require "openapi-client.model.com_day_cq_wcm_workflow_impl_wcm_workflow_service_impl_info"
local openapi-client_com_day_cq_wcm_workflow_impl_workflow_package_info_provider_info = require "openapi-client.model.com_day_cq_wcm_workflow_impl_workflow_package_info_provider_info"
local openapi-client_com_day_cq_widget_impl_html_library_manager_impl_info = require "openapi-client.model.com_day_cq_widget_impl_html_library_manager_impl_info"
local openapi-client_com_day_cq_widget_impl_widget_extension_provider_impl_info = require "openapi-client.model.com_day_cq_widget_impl_widget_extension_provider_impl_info"
local openapi-client_com_day_cq_workflow_impl_email_e_mail_notification_service_info = require "openapi-client.model.com_day_cq_workflow_impl_email_e_mail_notification_service_info"
local openapi-client_com_day_cq_workflow_impl_email_task_e_mail_notification_service_info = require "openapi-client.model.com_day_cq_workflow_impl_email_task_e_mail_notification_service_info"
local openapi-client_com_day_crx_security_token_impl_impl_token_authentication_handler_info = require "openapi-client.model.com_day_crx_security_token_impl_impl_token_authentication_handler_info"
local openapi-client_com_day_crx_security_token_impl_token_cleanup_task_info = require "openapi-client.model.com_day_crx_security_token_impl_token_cleanup_task_info"
local openapi-client_guide_localization_service_info = require "openapi-client.model.guide_localization_service_info"
local openapi-client_org_apache_aries_jmx_framework_state_config_info = require "openapi-client.model.org_apache_aries_jmx_framework_state_config_info"
local openapi-client_org_apache_felix_eventadmin_impl_event_admin_info = require "openapi-client.model.org_apache_felix_eventadmin_impl_event_admin_info"
local openapi-client_org_apache_felix_http_info = require "openapi-client.model.org_apache_felix_http_info"
local openapi-client_org_apache_felix_http_sslfilter_ssl_filter_info = require "openapi-client.model.org_apache_felix_http_sslfilter_ssl_filter_info"
local openapi-client_org_apache_felix_jaas_configuration_factory_info = require "openapi-client.model.org_apache_felix_jaas_configuration_factory_info"
local openapi-client_org_apache_felix_jaas_configuration_spi_info = require "openapi-client.model.org_apache_felix_jaas_configuration_spi_info"
local openapi-client_org_apache_felix_scr_scr_service_info = require "openapi-client.model.org_apache_felix_scr_scr_service_info"
local openapi-client_org_apache_felix_systemready_impl_components_check_info = require "openapi-client.model.org_apache_felix_systemready_impl_components_check_info"
local openapi-client_org_apache_felix_systemready_impl_framework_start_check_info = require "openapi-client.model.org_apache_felix_systemready_impl_framework_start_check_info"
local openapi-client_org_apache_felix_systemready_impl_services_check_info = require "openapi-client.model.org_apache_felix_systemready_impl_services_check_info"
local openapi-client_org_apache_felix_systemready_impl_servlet_system_alive_servlet_info = require "openapi-client.model.org_apache_felix_systemready_impl_servlet_system_alive_servlet_info"
local openapi-client_org_apache_felix_systemready_impl_servlet_system_ready_servlet_info = require "openapi-client.model.org_apache_felix_systemready_impl_servlet_system_ready_servlet_info"
local openapi-client_org_apache_felix_systemready_system_ready_monitor_info = require "openapi-client.model.org_apache_felix_systemready_system_ready_monitor_info"
local openapi-client_org_apache_felix_webconsole_internal_servlet_osgi_manager_info = require "openapi-client.model.org_apache_felix_webconsole_internal_servlet_osgi_manager_info"
local openapi-client_org_apache_felix_webconsole_plugins_event_internal_plugin_servlet_info = require "openapi-client.model.org_apache_felix_webconsole_plugins_event_internal_plugin_servlet_info"
local openapi-client_org_apache_felix_webconsole_plugins_memoryusage_internal_memory_usage_co_info = require "openapi-client.model.org_apache_felix_webconsole_plugins_memoryusage_internal_memory_usage_co_info"
local openapi-client_org_apache_http_proxyconfigurator_info = require "openapi-client.model.org_apache_http_proxyconfigurator_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_blob_datastore_data_store_text_provider_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_blob_datastore_data_store_text_provider_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_blob_datastore_file_data_store_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_blob_datastore_file_data_store_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_document_document_node_store_service_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_document_document_node_store_service_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_document_document_node_store_service_pre_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_document_document_node_store_service_pre_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_document_secondary_secondary_store_cac_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_document_secondary_secondary_store_cac_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_index_async_indexer_service_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_index_async_indexer_service_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_index_lucene_lucene_index_provider_serv_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_index_lucene_lucene_index_provider_serv_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_index_solr_osgi_embedded_solr_server_co_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_index_solr_osgi_embedded_solr_server_co_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_index_solr_osgi_node_state_solr_servers_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_index_solr_osgi_node_state_solr_servers_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_index_solr_osgi_oak_solr_configuration_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_index_solr_osgi_oak_solr_configuration_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_index_solr_osgi_remote_solr_server_conf_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_index_solr_osgi_remote_solr_server_conf_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_index_solr_osgi_solr_query_index_provid_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_index_solr_osgi_solr_query_index_provid_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_index_solr_osgi_solr_server_provider_se_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_index_solr_osgi_solr_server_provider_se_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_metric_statistics_provider_factory_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_metric_statistics_provider_factory_info"
local openapi-client_org_apache_jackrabbit_oak_plugins_observation_change_collector_provider_info = require "openapi-client.model.org_apache_jackrabbit_oak_plugins_observation_change_collector_provider_info"
local openapi-client_org_apache_jackrabbit_oak_query_query_engine_settings_service_info = require "openapi-client.model.org_apache_jackrabbit_oak_query_query_engine_settings_service_info"
local openapi-client_org_apache_jackrabbit_oak_security_authentication_authentication_config_info = require "openapi-client.model.org_apache_jackrabbit_oak_security_authentication_authentication_config_info"
local openapi-client_org_apache_jackrabbit_oak_security_authentication_ldap_impl_ldap_identi_info = require "openapi-client.model.org_apache_jackrabbit_oak_security_authentication_ldap_impl_ldap_identi_info"
local openapi-client_org_apache_jackrabbit_oak_security_authentication_token_token_configura_info = require "openapi-client.model.org_apache_jackrabbit_oak_security_authentication_token_token_configura_info"
local openapi-client_org_apache_jackrabbit_oak_security_authorization_authorization_configur_info = require "openapi-client.model.org_apache_jackrabbit_oak_security_authorization_authorization_configur_info"
local openapi-client_org_apache_jackrabbit_oak_security_internal_security_provider_registrati_info = require "openapi-client.model.org_apache_jackrabbit_oak_security_internal_security_provider_registrati_info"
local openapi-client_org_apache_jackrabbit_oak_security_user_random_authorizable_node_name_info = require "openapi-client.model.org_apache_jackrabbit_oak_security_user_random_authorizable_node_name_info"
local openapi-client_org_apache_jackrabbit_oak_security_user_user_configuration_impl_info = require "openapi-client.model.org_apache_jackrabbit_oak_security_user_user_configuration_impl_info"
local openapi-client_org_apache_jackrabbit_oak_segment_azure_azure_segment_store_service_info = require "openapi-client.model.org_apache_jackrabbit_oak_segment_azure_azure_segment_store_service_info"
local openapi-client_org_apache_jackrabbit_oak_segment_segment_node_store_factory_info = require "openapi-client.model.org_apache_jackrabbit_oak_segment_segment_node_store_factory_info"
local openapi-client_org_apache_jackrabbit_oak_segment_segment_node_store_monitor_service_info = require "openapi-client.model.org_apache_jackrabbit_oak_segment_segment_node_store_monitor_service_info"
local openapi-client_org_apache_jackrabbit_oak_segment_segment_node_store_service_info = require "openapi-client.model.org_apache_jackrabbit_oak_segment_segment_node_store_service_info"
local openapi-client_org_apache_jackrabbit_oak_segment_standby_store_standby_store_service_info = require "openapi-client.model.org_apache_jackrabbit_oak_segment_standby_store_standby_store_service_info"
local openapi-client_org_apache_jackrabbit_oak_spi_security_authentication_external_impl_de_info = require "openapi-client.model.org_apache_jackrabbit_oak_spi_security_authentication_external_impl_de_info"
local openapi-client_org_apache_jackrabbit_oak_spi_security_authentication_external_impl_ex_info = require "openapi-client.model.org_apache_jackrabbit_oak_spi_security_authentication_external_impl_ex_info"
local openapi-client_org_apache_jackrabbit_oak_spi_security_authentication_external_impl_pr_info = require "openapi-client.model.org_apache_jackrabbit_oak_spi_security_authentication_external_impl_pr_info"
local openapi-client_org_apache_jackrabbit_oak_spi_security_authorization_cug_impl_cug_confi_info = require "openapi-client.model.org_apache_jackrabbit_oak_spi_security_authorization_cug_impl_cug_confi_info"
local openapi-client_org_apache_jackrabbit_oak_spi_security_authorization_cug_impl_cug_exclu_info = require "openapi-client.model.org_apache_jackrabbit_oak_spi_security_authorization_cug_impl_cug_exclu_info"
local openapi-client_org_apache_jackrabbit_oak_spi_security_user_action_default_authorizable_info = require "openapi-client.model.org_apache_jackrabbit_oak_spi_security_user_action_default_authorizable_info"
local openapi-client_org_apache_jackrabbit_vault_packaging_impl_packaging_impl_info = require "openapi-client.model.org_apache_jackrabbit_vault_packaging_impl_packaging_impl_info"
local openapi-client_org_apache_jackrabbit_vault_packaging_registry_impl_fs_package_registry_info = require "openapi-client.model.org_apache_jackrabbit_vault_packaging_registry_impl_fs_package_registry_info"
local openapi-client_org_apache_sling_auth_core_impl_logout_servlet_info = require "openapi-client.model.org_apache_sling_auth_core_impl_logout_servlet_info"
local openapi-client_org_apache_sling_caconfig_impl_configuration_bindings_value_provider_info = require "openapi-client.model.org_apache_sling_caconfig_impl_configuration_bindings_value_provider_info"
local openapi-client_org_apache_sling_caconfig_impl_configuration_resolver_impl_info = require "openapi-client.model.org_apache_sling_caconfig_impl_configuration_resolver_impl_info"
local openapi-client_org_apache_sling_caconfig_impl_def_default_configuration_inheritance_stra_info = require "openapi-client.model.org_apache_sling_caconfig_impl_def_default_configuration_inheritance_stra_info"
local openapi-client_org_apache_sling_caconfig_impl_def_default_configuration_persistence_stra_info = require "openapi-client.model.org_apache_sling_caconfig_impl_def_default_configuration_persistence_stra_info"
local openapi-client_org_apache_sling_caconfig_impl_override_osgi_configuration_override_provi_info = require "openapi-client.model.org_apache_sling_caconfig_impl_override_osgi_configuration_override_provi_info"
local openapi-client_org_apache_sling_caconfig_impl_override_system_property_configuration_ove_info = require "openapi-client.model.org_apache_sling_caconfig_impl_override_system_property_configuration_ove_info"
local openapi-client_org_apache_sling_caconfig_management_impl_configuration_management_setti_info = require "openapi-client.model.org_apache_sling_caconfig_management_impl_configuration_management_setti_info"
local openapi-client_org_apache_sling_caconfig_resource_impl_def_default_configuration_resour_info = require "openapi-client.model.org_apache_sling_caconfig_resource_impl_def_default_configuration_resour_info"
local openapi-client_org_apache_sling_caconfig_resource_impl_def_default_context_path_strategy_info = require "openapi-client.model.org_apache_sling_caconfig_resource_impl_def_default_context_path_strategy_info"
local openapi-client_org_apache_sling_commons_html_internal_tagsoup_html_parser_info = require "openapi-client.model.org_apache_sling_commons_html_internal_tagsoup_html_parser_info"
local openapi-client_org_apache_sling_commons_log_log_manager_factory_config_info = require "openapi-client.model.org_apache_sling_commons_log_log_manager_factory_config_info"
local openapi-client_org_apache_sling_commons_log_log_manager_factory_writer_info = require "openapi-client.model.org_apache_sling_commons_log_log_manager_factory_writer_info"
local openapi-client_org_apache_sling_commons_log_log_manager_info = require "openapi-client.model.org_apache_sling_commons_log_log_manager_info"
local openapi-client_org_apache_sling_commons_metrics_internal_log_reporter_info = require "openapi-client.model.org_apache_sling_commons_metrics_internal_log_reporter_info"
local openapi-client_org_apache_sling_commons_metrics_rrd4j_impl_codahale_metrics_reporter_info = require "openapi-client.model.org_apache_sling_commons_metrics_rrd4j_impl_codahale_metrics_reporter_info"
local openapi-client_org_apache_sling_commons_mime_internal_mime_type_service_impl_info = require "openapi-client.model.org_apache_sling_commons_mime_internal_mime_type_service_impl_info"
local openapi-client_org_apache_sling_commons_scheduler_impl_quartz_scheduler_info = require "openapi-client.model.org_apache_sling_commons_scheduler_impl_quartz_scheduler_info"
local openapi-client_org_apache_sling_commons_scheduler_impl_scheduler_health_check_info = require "openapi-client.model.org_apache_sling_commons_scheduler_impl_scheduler_health_check_info"
local openapi-client_org_apache_sling_commons_threads_impl_default_thread_pool_factory_info = require "openapi-client.model.org_apache_sling_commons_threads_impl_default_thread_pool_factory_info"
local openapi-client_org_apache_sling_datasource_data_source_factory_info = require "openapi-client.model.org_apache_sling_datasource_data_source_factory_info"
local openapi-client_org_apache_sling_datasource_jndi_data_source_factory_info = require "openapi-client.model.org_apache_sling_datasource_jndi_data_source_factory_info"
local openapi-client_org_apache_sling_discovery_oak_config_info = require "openapi-client.model.org_apache_sling_discovery_oak_config_info"
local openapi-client_org_apache_sling_discovery_oak_synchronized_clocks_health_check_info = require "openapi-client.model.org_apache_sling_discovery_oak_synchronized_clocks_health_check_info"
local openapi-client_org_apache_sling_distribution_agent_impl_forward_distribution_agent_facto_info = require "openapi-client.model.org_apache_sling_distribution_agent_impl_forward_distribution_agent_facto_info"
local openapi-client_org_apache_sling_distribution_agent_impl_privilege_distribution_request_a_info = require "openapi-client.model.org_apache_sling_distribution_agent_impl_privilege_distribution_request_a_info"
local openapi-client_org_apache_sling_distribution_agent_impl_queue_distribution_agent_factory_info = require "openapi-client.model.org_apache_sling_distribution_agent_impl_queue_distribution_agent_factory_info"
local openapi-client_org_apache_sling_distribution_agent_impl_reverse_distribution_agent_facto_info = require "openapi-client.model.org_apache_sling_distribution_agent_impl_reverse_distribution_agent_facto_info"
local openapi-client_org_apache_sling_distribution_agent_impl_simple_distribution_agent_factor_info = require "openapi-client.model.org_apache_sling_distribution_agent_impl_simple_distribution_agent_factor_info"
local openapi-client_org_apache_sling_distribution_agent_impl_sync_distribution_agent_factory_info = require "openapi-client.model.org_apache_sling_distribution_agent_impl_sync_distribution_agent_factory_info"
local openapi-client_org_apache_sling_distribution_monitor_distribution_queue_health_check_info = require "openapi-client.model.org_apache_sling_distribution_monitor_distribution_queue_health_check_info"
local openapi-client_org_apache_sling_distribution_packaging_impl_exporter_agent_distributio_info = require "openapi-client.model.org_apache_sling_distribution_packaging_impl_exporter_agent_distributio_info"
local openapi-client_org_apache_sling_distribution_packaging_impl_exporter_local_distributio_info = require "openapi-client.model.org_apache_sling_distribution_packaging_impl_exporter_local_distributio_info"
local openapi-client_org_apache_sling_distribution_packaging_impl_exporter_remote_distributi_info = require "openapi-client.model.org_apache_sling_distribution_packaging_impl_exporter_remote_distributi_info"
local openapi-client_org_apache_sling_distribution_packaging_impl_importer_local_distributio_info = require "openapi-client.model.org_apache_sling_distribution_packaging_impl_importer_local_distributio_info"
local openapi-client_org_apache_sling_distribution_packaging_impl_importer_remote_distributi_info = require "openapi-client.model.org_apache_sling_distribution_packaging_impl_importer_remote_distributi_info"
local openapi-client_org_apache_sling_distribution_packaging_impl_importer_repository_distri_info = require "openapi-client.model.org_apache_sling_distribution_packaging_impl_importer_repository_distri_info"
local openapi-client_org_apache_sling_distribution_resources_impl_distribution_configuration_info = require "openapi-client.model.org_apache_sling_distribution_resources_impl_distribution_configuration_info"
local openapi-client_org_apache_sling_distribution_resources_impl_distribution_service_resour_info = require "openapi-client.model.org_apache_sling_distribution_resources_impl_distribution_service_resour_info"
local openapi-client_org_apache_sling_distribution_serialization_impl_distribution_package_bu_info = require "openapi-client.model.org_apache_sling_distribution_serialization_impl_distribution_package_bu_info"
local openapi-client_org_apache_sling_distribution_serialization_impl_vlt_vault_distribution_info = require "openapi-client.model.org_apache_sling_distribution_serialization_impl_vlt_vault_distribution_info"
local openapi-client_org_apache_sling_distribution_transport_impl_user_credentials_distributi_info = require "openapi-client.model.org_apache_sling_distribution_transport_impl_user_credentials_distributi_info"
local openapi-client_org_apache_sling_distribution_trigger_impl_distribution_event_distribute_info = require "openapi-client.model.org_apache_sling_distribution_trigger_impl_distribution_event_distribute_info"
local openapi-client_org_apache_sling_distribution_trigger_impl_jcr_event_distribution_trigger_info = require "openapi-client.model.org_apache_sling_distribution_trigger_impl_jcr_event_distribution_trigger_info"
local openapi-client_org_apache_sling_distribution_trigger_impl_persisted_jcr_event_distributi_info = require "openapi-client.model.org_apache_sling_distribution_trigger_impl_persisted_jcr_event_distributi_info"
local openapi-client_org_apache_sling_distribution_trigger_impl_remote_event_distribution_trig_info = require "openapi-client.model.org_apache_sling_distribution_trigger_impl_remote_event_distribution_trig_info"
local openapi-client_org_apache_sling_distribution_trigger_impl_resource_event_distribution_tr_info = require "openapi-client.model.org_apache_sling_distribution_trigger_impl_resource_event_distribution_tr_info"
local openapi-client_org_apache_sling_distribution_trigger_impl_scheduled_distribution_trigge_info = require "openapi-client.model.org_apache_sling_distribution_trigger_impl_scheduled_distribution_trigge_info"
local openapi-client_org_apache_sling_engine_impl_auth_sling_authenticator_info = require "openapi-client.model.org_apache_sling_engine_impl_auth_sling_authenticator_info"
local openapi-client_org_apache_sling_engine_impl_debug_request_progress_tracker_log_filter_info = require "openapi-client.model.org_apache_sling_engine_impl_debug_request_progress_tracker_log_filter_info"
local openapi-client_org_apache_sling_engine_impl_log_request_logger_info = require "openapi-client.model.org_apache_sling_engine_impl_log_request_logger_info"
local openapi-client_org_apache_sling_engine_impl_log_request_logger_service_info = require "openapi-client.model.org_apache_sling_engine_impl_log_request_logger_service_info"
local openapi-client_org_apache_sling_engine_impl_sling_main_servlet_info = require "openapi-client.model.org_apache_sling_engine_impl_sling_main_servlet_info"
local openapi-client_org_apache_sling_engine_parameters_info = require "openapi-client.model.org_apache_sling_engine_parameters_info"
local openapi-client_org_apache_sling_event_impl_eventing_thread_pool_info = require "openapi-client.model.org_apache_sling_event_impl_eventing_thread_pool_info"
local openapi-client_org_apache_sling_event_impl_jobs_default_job_manager_info = require "openapi-client.model.org_apache_sling_event_impl_jobs_default_job_manager_info"
local openapi-client_org_apache_sling_event_impl_jobs_jcr_persistence_handler_info = require "openapi-client.model.org_apache_sling_event_impl_jobs_jcr_persistence_handler_info"
local openapi-client_org_apache_sling_event_impl_jobs_job_consumer_manager_info = require "openapi-client.model.org_apache_sling_event_impl_jobs_job_consumer_manager_info"
local openapi-client_org_apache_sling_event_jobs_queue_configuration_info = require "openapi-client.model.org_apache_sling_event_jobs_queue_configuration_info"
local openapi-client_org_apache_sling_extensions_webconsolesecurityprovider_internal_sling_w_info = require "openapi-client.model.org_apache_sling_extensions_webconsolesecurityprovider_internal_sling_w_info"
local openapi-client_org_apache_sling_featureflags_feature_info = require "openapi-client.model.org_apache_sling_featureflags_feature_info"
local openapi-client_org_apache_sling_featureflags_impl_configured_feature_info = require "openapi-client.model.org_apache_sling_featureflags_impl_configured_feature_info"
local openapi-client_org_apache_sling_hapi_impl_h_api_util_impl_info = require "openapi-client.model.org_apache_sling_hapi_impl_h_api_util_impl_info"
local openapi-client_org_apache_sling_hc_core_impl_composite_health_check_info = require "openapi-client.model.org_apache_sling_hc_core_impl_composite_health_check_info"
local openapi-client_org_apache_sling_hc_core_impl_executor_health_check_executor_impl_info = require "openapi-client.model.org_apache_sling_hc_core_impl_executor_health_check_executor_impl_info"
local openapi-client_org_apache_sling_hc_core_impl_jmx_attribute_health_check_info = require "openapi-client.model.org_apache_sling_hc_core_impl_jmx_attribute_health_check_info"
local openapi-client_org_apache_sling_hc_core_impl_scriptable_health_check_info = require "openapi-client.model.org_apache_sling_hc_core_impl_scriptable_health_check_info"
local openapi-client_org_apache_sling_hc_core_impl_servlet_health_check_executor_servlet_info = require "openapi-client.model.org_apache_sling_hc_core_impl_servlet_health_check_executor_servlet_info"
local openapi-client_org_apache_sling_hc_core_impl_servlet_result_txt_verbose_serializer_info = require "openapi-client.model.org_apache_sling_hc_core_impl_servlet_result_txt_verbose_serializer_info"
local openapi-client_org_apache_sling_i18n_impl_i18_n_filter_info = require "openapi-client.model.org_apache_sling_i18n_impl_i18_n_filter_info"
local openapi-client_org_apache_sling_i18n_impl_jcr_resource_bundle_provider_info = require "openapi-client.model.org_apache_sling_i18n_impl_jcr_resource_bundle_provider_info"
local openapi-client_org_apache_sling_installer_provider_jcr_impl_jcr_installer_info = require "openapi-client.model.org_apache_sling_installer_provider_jcr_impl_jcr_installer_info"
local openapi-client_org_apache_sling_jcr_base_internal_login_admin_whitelist_fragment_info = require "openapi-client.model.org_apache_sling_jcr_base_internal_login_admin_whitelist_fragment_info"
local openapi-client_org_apache_sling_jcr_base_internal_login_admin_whitelist_info = require "openapi-client.model.org_apache_sling_jcr_base_internal_login_admin_whitelist_info"
local openapi-client_org_apache_sling_jcr_davex_impl_servlets_sling_dav_ex_servlet_info = require "openapi-client.model.org_apache_sling_jcr_davex_impl_servlets_sling_dav_ex_servlet_info"
local openapi-client_org_apache_sling_jcr_jackrabbit_server_jndi_registration_support_info = require "openapi-client.model.org_apache_sling_jcr_jackrabbit_server_jndi_registration_support_info"
local openapi-client_org_apache_sling_jcr_jackrabbit_server_rmi_registration_support_info = require "openapi-client.model.org_apache_sling_jcr_jackrabbit_server_rmi_registration_support_info"
local openapi-client_org_apache_sling_jcr_repoinit_impl_repository_initializer_info = require "openapi-client.model.org_apache_sling_jcr_repoinit_impl_repository_initializer_info"
local openapi-client_org_apache_sling_jcr_repoinit_repository_initializer_info = require "openapi-client.model.org_apache_sling_jcr_repoinit_repository_initializer_info"
local openapi-client_org_apache_sling_jcr_resource_internal_jcr_resource_resolver_factory_impl_info = require "openapi-client.model.org_apache_sling_jcr_resource_internal_jcr_resource_resolver_factory_impl_info"
local openapi-client_org_apache_sling_jcr_resource_internal_jcr_system_user_validator_info = require "openapi-client.model.org_apache_sling_jcr_resource_internal_jcr_system_user_validator_info"
local openapi-client_org_apache_sling_jcr_resourcesecurity_impl_resource_access_gate_factory_info = require "openapi-client.model.org_apache_sling_jcr_resourcesecurity_impl_resource_access_gate_factory_info"
local openapi-client_org_apache_sling_jcr_webdav_impl_handler_default_handler_service_info = require "openapi-client.model.org_apache_sling_jcr_webdav_impl_handler_default_handler_service_info"
local openapi-client_org_apache_sling_jcr_webdav_impl_handler_dir_listing_export_handler_servic_info = require "openapi-client.model.org_apache_sling_jcr_webdav_impl_handler_dir_listing_export_handler_servic_info"
local openapi-client_org_apache_sling_jcr_webdav_impl_servlets_simple_web_dav_servlet_info = require "openapi-client.model.org_apache_sling_jcr_webdav_impl_servlets_simple_web_dav_servlet_info"
local openapi-client_org_apache_sling_jmx_provider_impl_jmx_resource_provider_info = require "openapi-client.model.org_apache_sling_jmx_provider_impl_jmx_resource_provider_info"
local openapi-client_org_apache_sling_models_impl_model_adapter_factory_info = require "openapi-client.model.org_apache_sling_models_impl_model_adapter_factory_info"
local openapi-client_org_apache_sling_models_jacksonexporter_impl_resource_module_provider_info = require "openapi-client.model.org_apache_sling_models_jacksonexporter_impl_resource_module_provider_info"
local openapi-client_org_apache_sling_resource_inventory_impl_resource_inventory_printer_facto_info = require "openapi-client.model.org_apache_sling_resource_inventory_impl_resource_inventory_printer_facto_info"
local openapi-client_org_apache_sling_resourcemerger_impl_merged_resource_provider_factory_info = require "openapi-client.model.org_apache_sling_resourcemerger_impl_merged_resource_provider_factory_info"
local openapi-client_org_apache_sling_resourcemerger_picker_overriding_info = require "openapi-client.model.org_apache_sling_resourcemerger_picker_overriding_info"
local openapi-client_org_apache_sling_scripting_core_impl_script_cache_impl_info = require "openapi-client.model.org_apache_sling_scripting_core_impl_script_cache_impl_info"
local openapi-client_org_apache_sling_scripting_core_impl_scripting_resource_resolver_provider_info = require "openapi-client.model.org_apache_sling_scripting_core_impl_scripting_resource_resolver_provider_info"
local openapi-client_org_apache_sling_scripting_java_impl_java_script_engine_factory_info = require "openapi-client.model.org_apache_sling_scripting_java_impl_java_script_engine_factory_info"
local openapi-client_org_apache_sling_scripting_javascript_internal_rhino_java_script_engine_fa_info = require "openapi-client.model.org_apache_sling_scripting_javascript_internal_rhino_java_script_engine_fa_info"
local openapi-client_org_apache_sling_scripting_jsp_jsp_script_engine_factory_info = require "openapi-client.model.org_apache_sling_scripting_jsp_jsp_script_engine_factory_info"
local openapi-client_org_apache_sling_scripting_sightly_js_impl_jsapi_sly_bindings_values_prov_info = require "openapi-client.model.org_apache_sling_scripting_sightly_js_impl_jsapi_sly_bindings_values_prov_info"
local openapi-client_org_apache_sling_security_impl_content_disposition_filter_info = require "openapi-client.model.org_apache_sling_security_impl_content_disposition_filter_info"
local openapi-client_org_apache_sling_security_impl_referrer_filter_info = require "openapi-client.model.org_apache_sling_security_impl_referrer_filter_info"
local openapi-client_org_apache_sling_serviceusermapping_impl_service_user_mapper_impl_amended_info = require "openapi-client.model.org_apache_sling_serviceusermapping_impl_service_user_mapper_impl_amended_info"
local openapi-client_org_apache_sling_serviceusermapping_impl_service_user_mapper_impl_info = require "openapi-client.model.org_apache_sling_serviceusermapping_impl_service_user_mapper_impl_info"
local openapi-client_org_apache_sling_servlets_get_default_get_servlet_info = require "openapi-client.model.org_apache_sling_servlets_get_default_get_servlet_info"
local openapi-client_org_apache_sling_servlets_get_impl_version_version_info_servlet_info = require "openapi-client.model.org_apache_sling_servlets_get_impl_version_version_info_servlet_info"
local openapi-client_org_apache_sling_servlets_post_impl_helper_chunk_clean_up_task_info = require "openapi-client.model.org_apache_sling_servlets_post_impl_helper_chunk_clean_up_task_info"
local openapi-client_org_apache_sling_servlets_post_impl_sling_post_servlet_info = require "openapi-client.model.org_apache_sling_servlets_post_impl_sling_post_servlet_info"
local openapi-client_org_apache_sling_servlets_resolver_sling_servlet_resolver_info = require "openapi-client.model.org_apache_sling_servlets_resolver_sling_servlet_resolver_info"
local openapi-client_org_apache_sling_settings_impl_sling_settings_service_impl_info = require "openapi-client.model.org_apache_sling_settings_impl_sling_settings_service_impl_info"
local openapi-client_org_apache_sling_startupfilter_impl_startup_filter_impl_info = require "openapi-client.model.org_apache_sling_startupfilter_impl_startup_filter_impl_info"
local openapi-client_org_apache_sling_tenant_internal_tenant_provider_impl_info = require "openapi-client.model.org_apache_sling_tenant_internal_tenant_provider_impl_info"
local openapi-client_org_apache_sling_tracer_internal_log_tracer_info = require "openapi-client.model.org_apache_sling_tracer_internal_log_tracer_info"
local openapi-client_org_apache_sling_xss_impl_xss_filter_impl_info = require "openapi-client.model.org_apache_sling_xss_impl_xss_filter_impl_info"

local configmgr_api = {}
local configmgr_api_mt = {
	__name = "configmgr_api";
	__index = configmgr_api;
}

local function new_configmgr_api(host, basePath, schemes)
	local schemes_map = {}
	for _,v in ipairs(schemes) do
		schemes_map[v] = v
	end
	local default_scheme = schemes_map.https or schemes_map.http
	return setmetatable({
		host = host;
		basePath = basePath or "http://localhost";
		schemes = schemes_map;
		default_scheme = default_scheme;
		http_username = nil;
		http_password = nil;
		api_key = {};
		access_token = nil;
	}, configmgr_api_mt)
end

function configmgr_api:adaptive_form_and_interactive_communication_web_channel_configuration(post, apply, delete, action, location, propertylist, show_placeholder, maximum_cache_entries, af_scripting_compatversion, make_file_name_unique, generating_compliant_data)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/Adaptive Form and Interactive Communication Web Channel Configuration?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&showPlaceholder=%s&maximumCacheEntries=%s&af.scripting.compatversion=%s&makeFileNameUnique=%s&generatingCompliantData=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(show_placeholder), http_util.encodeURIComponent(maximum_cache_entries), http_util.encodeURIComponent(af_scripting_compatversion), http_util.encodeURIComponent(make_file_name_unique), http_util.encodeURIComponent(generating_compliant_data));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_adaptive_form_and_interactive_communication_web_channel_configuration_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:adaptive_form_and_interactive_communication_web_channel_theme_configur(post, apply, delete, action, location, propertylist, font_list)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/Adaptive Form and Interactive Communication Web Channel Theme Configuration?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fontList=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(font_list));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_adaptive_form_and_interactive_communication_web_channel_theme_configur_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:analytics_component_query_cache_service(post, apply, delete, action, location, propertylist, cq_analytics_component_query_cache_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/Analytics Component Query Cache Service?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.analytics.component.query.cache.size=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_analytics_component_query_cache_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_analytics_component_query_cache_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:apache_sling_health_check_result_html_serializer(post, apply, delete, action, location, propertylist, style_string)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/Apache Sling Health Check Result HTML Serializer?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&styleString=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(style_string));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_apache_sling_health_check_result_html_serializer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_aem_formsndocuments_config_aem_forms_manager_configuration(post, apply, delete, action, location, propertylist, forms_manager_config_include_ootb_templates, forms_manager_config_include_deprecated_templates)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.aem.formsndocuments.config.AEMFormsManagerConfiguration?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&formsManagerConfig.includeOOTBTemplates=%s&formsManagerConfig.includeDeprecatedTemplates=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(forms_manager_config_include_ootb_templates), http_util.encodeURIComponent(forms_manager_config_include_deprecated_templates));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_aem_formsndocuments_config_aem_forms_manager_configuration_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_aem_transaction_core_impl_transaction_recorder(post, apply, delete, action, location, propertylist, is_transaction_recording_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.aem.transaction.core.impl.TransactionRecorder?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&isTransactionRecordingEnabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(is_transaction_recording_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_aem_transaction_core_impl_transaction_recorder_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_aem_upgrade_prechecks_hc_impl_deprecate_indexes_hc(post, apply, delete, action, location, propertylist, hc_name, hc_tags, hc_mbean_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.aem.upgrade.prechecks.hc.impl.DeprecateIndexesHC?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.name=%s&hc.tags=%s&hc.mbean.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_name), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(hc_mbean_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_aem_upgrade_prechecks_hc_impl_deprecate_indexes_hc_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_aem_upgrade_prechecks_hc_impl_replication_agents_disabled_hc(post, apply, delete, action, location, propertylist, hc_name, hc_tags, hc_mbean_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.aem.upgrade.prechecks.hc.impl.ReplicationAgentsDisabledHC?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.name=%s&hc.tags=%s&hc.mbean.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_name), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(hc_mbean_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_aem_upgrade_prechecks_hc_impl_replication_agents_disabled_hc_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_aem_upgrade_prechecks_mbean_impl_pre_upgrade_tasks_m_bean_impl(post, apply, delete, action, location, propertylist, pre_upgrade_maintenance_tasks, pre_upgrade_hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.aem.upgrade.prechecks.mbean.impl.PreUpgradeTasksMBeanImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&pre-upgrade.maintenance.tasks=%s&pre-upgrade.hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(pre_upgrade_maintenance_tasks), http_util.encodeURIComponent(pre_upgrade_hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_aem_upgrade_prechecks_mbean_impl_pre_upgrade_tasks_m_bean_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_aem_upgrade_prechecks_tasks_impl_consistency_check_task_impl(post, apply, delete, action, location, propertylist, root_path, fix_inconsistencies)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.aem.upgrade.prechecks.tasks.impl.ConsistencyCheckTaskImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&root.path=%s&fix.inconsistencies=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(root_path), http_util.encodeURIComponent(fix_inconsistencies));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_aem_upgrade_prechecks_tasks_impl_consistency_check_task_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_account_api_account_management_service(post, apply, delete, action, location, propertylist, cq_accountmanager_token_validity_period, cq_accountmanager_config_requestnewaccount_mail, cq_accountmanager_config_requestnewpwd_mail)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.account.api.AccountManagementService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.accountmanager.token.validity.period=%s&cq.accountmanager.config.requestnewaccount.mail=%s&cq.accountmanager.config.requestnewpwd.mail=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_accountmanager_token_validity_period), http_util.encodeURIComponent(cq_accountmanager_config_requestnewaccount_mail), http_util.encodeURIComponent(cq_accountmanager_config_requestnewpwd_mail));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_account_api_account_management_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_account_impl_account_management_servlet(post, apply, delete, action, location, propertylist, cq_accountmanager_config_informnewaccount_mail, cq_accountmanager_config_informnewpwd_mail)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.account.impl.AccountManagementServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.accountmanager.config.informnewaccount.mail=%s&cq.accountmanager.config.informnewpwd.mail=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_accountmanager_config_informnewaccount_mail), http_util.encodeURIComponent(cq_accountmanager_config_informnewpwd_mail));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_account_impl_account_management_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_address_impl_location_location_list_servlet(post, apply, delete, action, location, propertylist, cq_address_location_default_max_results)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.address.impl.location.LocationListServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.address.location.default.maxResults=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_address_location_default_max_results));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_address_impl_location_location_list_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_audit_purge_dam(post, apply, delete, action, location, propertylist, auditlog_rule_name, auditlog_rule_contentpath, auditlog_rule_minimumage, auditlog_rule_types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.audit.purge.Dam?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&auditlog.rule.name=%s&auditlog.rule.contentpath=%s&auditlog.rule.minimumage=%s&auditlog.rule.types=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(auditlog_rule_name), http_util.encodeURIComponent(auditlog_rule_contentpath), http_util.encodeURIComponent(auditlog_rule_minimumage), http_util.encodeURIComponent(auditlog_rule_types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_audit_purge_dam_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_audit_purge_pages(post, apply, delete, action, location, propertylist, auditlog_rule_name, auditlog_rule_contentpath, auditlog_rule_minimumage, auditlog_rule_types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.audit.purge.Pages?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&auditlog.rule.name=%s&auditlog.rule.contentpath=%s&auditlog.rule.minimumage=%s&auditlog.rule.types=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(auditlog_rule_name), http_util.encodeURIComponent(auditlog_rule_contentpath), http_util.encodeURIComponent(auditlog_rule_minimumage), http_util.encodeURIComponent(auditlog_rule_types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_audit_purge_pages_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_audit_purge_replication(post, apply, delete, action, location, propertylist, auditlog_rule_name, auditlog_rule_contentpath, auditlog_rule_minimumage, auditlog_rule_types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.audit.purge.Replication?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&auditlog.rule.name=%s&auditlog.rule.contentpath=%s&auditlog.rule.minimumage=%s&auditlog.rule.types=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(auditlog_rule_name), http_util.encodeURIComponent(auditlog_rule_contentpath), http_util.encodeURIComponent(auditlog_rule_minimumage), http_util.encodeURIComponent(auditlog_rule_types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_audit_purge_replication_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_cdn_rewriter_impl_aws_cloud_front_rewriter(post, apply, delete, action, location, propertylist, service_ranking, keypair_id, keypair_alias, cdnrewriter_attributes, cdn_rewriter_distribution_domain)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.AWSCloudFrontRewriter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&keypair.id=%s&keypair.alias=%s&cdnrewriter.attributes=%s&cdn.rewriter.distribution.domain=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(keypair_id), http_util.encodeURIComponent(keypair_alias), http_util.encodeURIComponent(cdnrewriter_attributes), http_util.encodeURIComponent(cdn_rewriter_distribution_domain));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_cdn_rewriter_impl_aws_cloud_front_rewriter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_cdn_rewriter_impl_cdn_config_service_impl(post, apply, delete, action, location, propertylist, cdn_config_distribution_domain, cdn_config_enable_rewriting, cdn_config_path_prefixes, cdn_config_cdnttl, cdn_config_application_protocol)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.CDNConfigServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cdn.config.distribution.domain=%s&cdn.config.enable.rewriting=%s&cdn.config.path.prefixes=%s&cdn.config.cdnttl=%s&cdn.config.application.protocol=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cdn_config_distribution_domain), http_util.encodeURIComponent(cdn_config_enable_rewriting), http_util.encodeURIComponent(cdn_config_path_prefixes), http_util.encodeURIComponent(cdn_config_cdnttl), http_util.encodeURIComponent(cdn_config_application_protocol));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_cdn_rewriter_impl_cdn_config_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_cdn_rewriter_impl_cdn_rewriter(post, apply, delete, action, location, propertylist, service_ranking, cdnrewriter_attributes, cdn_rewriter_distribution_domain)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.CDNRewriter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&cdnrewriter.attributes=%s&cdn.rewriter.distribution.domain=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(cdnrewriter_attributes), http_util.encodeURIComponent(cdn_rewriter_distribution_domain));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_cdn_rewriter_impl_cdn_rewriter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_cloudconfig_core_impl_configuration_replication_event_handle(post, apply, delete, action, location, propertylist, flush_agents)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.cloudconfig.core.impl.ConfigurationReplicationEventHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&flush.agents=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(flush_agents));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_cloudconfig_core_impl_configuration_replication_event_handle_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_commerce_impl_asset_dynamic_image_handler(post, apply, delete, action, location, propertylist, cq_commerce_asset_handler_active, cq_commerce_asset_handler_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.commerce.impl.asset.DynamicImageHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.commerce.asset.handler.active=%s&cq.commerce.asset.handler.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_commerce_asset_handler_active), http_util.encodeURIComponent(cq_commerce_asset_handler_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_commerce_impl_asset_dynamic_image_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_commerce_impl_asset_product_asset_handler_provider_impl(post, apply, delete, action, location, propertylist, cq_commerce_asset_handler_fallback)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.commerce.impl.asset.ProductAssetHandlerProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.commerce.asset.handler.fallback=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_commerce_asset_handler_fallback));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_commerce_impl_asset_product_asset_handler_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_commerce_impl_asset_static_image_handler(post, apply, delete, action, location, propertylist, cq_commerce_asset_handler_active, cq_commerce_asset_handler_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.commerce.impl.asset.StaticImageHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.commerce.asset.handler.active=%s&cq.commerce.asset.handler.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_commerce_asset_handler_active), http_util.encodeURIComponent(cq_commerce_asset_handler_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_commerce_impl_asset_static_image_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_commerce_impl_asset_video_handler(post, apply, delete, action, location, propertylist, cq_commerce_asset_handler_active, cq_commerce_asset_handler_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.commerce.impl.asset.VideoHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.commerce.asset.handler.active=%s&cq.commerce.asset.handler.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_commerce_asset_handler_active), http_util.encodeURIComponent(cq_commerce_asset_handler_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_commerce_impl_asset_video_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_commerce_impl_promotion_promotion_manager_impl(post, apply, delete, action, location, propertylist, cq_commerce_promotion_root)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.commerce.impl.promotion.PromotionManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.commerce.promotion.root=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_commerce_promotion_root));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_commerce_impl_promotion_promotion_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_commerce_pim_impl_cataloggenerator_catalog_generator_impl(post, apply, delete, action, location, propertylist, cq_commerce_cataloggenerator_bucketsize, cq_commerce_cataloggenerator_bucketname, cq_commerce_cataloggenerator_excludedtemplateproperties)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.commerce.pim.impl.cataloggenerator.CatalogGeneratorImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.commerce.cataloggenerator.bucketsize=%s&cq.commerce.cataloggenerator.bucketname=%s&cq.commerce.cataloggenerator.excludedtemplateproperties=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_commerce_cataloggenerator_bucketsize), http_util.encodeURIComponent(cq_commerce_cataloggenerator_bucketname), http_util.encodeURIComponent(cq_commerce_cataloggenerator_excludedtemplateproperties));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_commerce_pim_impl_cataloggenerator_catalog_generator_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_commerce_pim_impl_page_event_listener(post, apply, delete, action, location, propertylist, cq_commerce_pageeventlistener_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.commerce.pim.impl.PageEventListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.commerce.pageeventlistener.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_commerce_pageeventlistener_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_commerce_pim_impl_page_event_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_commerce_pim_impl_productfeed_product_feed_service_impl(post, apply, delete, action, location, propertylist, feed_generator_algorithm)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.commerce.pim.impl.productfeed.ProductFeedServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&Feed generator algorithm=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(feed_generator_algorithm));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_commerce_pim_impl_productfeed_product_feed_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_contentinsight_impl_reporting_services_settings_provider(post, apply, delete, action, location, propertylist, reportingservices_url)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.contentinsight.impl.ReportingServicesSettingsProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&reportingservices.url=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(reportingservices_url));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_contentinsight_impl_reporting_services_settings_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_contentinsight_impl_servlets_bright_edge_proxy_servlet(post, apply, delete, action, location, propertylist, brightedge_url)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.contentinsight.impl.servlets.BrightEdgeProxyServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&brightedge.url=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(brightedge_url));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_contentinsight_impl_servlets_bright_edge_proxy_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_contentinsight_impl_servlets_reporting_services_proxy_servle(post, apply, delete, action, location, propertylist, reportingservices_proxy_whitelist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.contentinsight.impl.servlets.ReportingServicesProxyServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&reportingservices.proxy.whitelist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(reportingservices_proxy_whitelist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_contentinsight_impl_servlets_reporting_services_proxy_servle_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_cfm_impl_component_component_config_impl(post, apply, delete, action, location, propertylist, dam_cfm_component_resource_type, dam_cfm_component_file_reference_prop, dam_cfm_component_elements_prop, dam_cfm_component_variation_prop)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.cfm.impl.component.ComponentConfigImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&dam.cfm.component.resourceType=%s&dam.cfm.component.fileReferenceProp=%s&dam.cfm.component.elementsProp=%s&dam.cfm.component.variationProp=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(dam_cfm_component_resource_type), http_util.encodeURIComponent(dam_cfm_component_file_reference_prop), http_util.encodeURIComponent(dam_cfm_component_elements_prop), http_util.encodeURIComponent(dam_cfm_component_variation_prop));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_cfm_impl_component_component_config_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_cfm_impl_conf_feature_config_impl(post, apply, delete, action, location, propertylist, dam_cfm_resource_types, dam_cfm_reference_properties)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.cfm.impl.conf.FeatureConfigImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&dam.cfm.resourceTypes=%s&dam.cfm.referenceProperties=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(dam_cfm_resource_types), http_util.encodeURIComponent(dam_cfm_reference_properties));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_cfm_impl_conf_feature_config_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_cfm_impl_content_rewriter_asset_processor(post, apply, delete, action, location, propertylist, pipeline_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.AssetProcessor?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&pipeline.type=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(pipeline_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_cfm_impl_content_rewriter_asset_processor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_cfm_impl_content_rewriter_par_range_filter(post, apply, delete, action, location, propertylist, pipeline_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.ParRangeFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&pipeline.type=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(pipeline_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_cfm_impl_content_rewriter_par_range_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_cfm_impl_content_rewriter_payload_filter(post, apply, delete, action, location, propertylist, pipeline_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.PayloadFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&pipeline.type=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(pipeline_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_cfm_impl_content_rewriter_payload_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_dm_process_image_p_tiff_manager_impl(post, apply, delete, action, location, propertylist, max_memory)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.dm.process.image.PTiffManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&maxMemory=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_memory));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_dm_process_image_p_tiff_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_ips_impl_replication_trigger_replicate_on_modify_worker(post, apply, delete, action, location, propertylist, dmreplicateonmodify_enabled, dmreplicateonmodify_forcesyncdeletes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.ips.impl.replication.trigger.ReplicateOnModifyWorker?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&dmreplicateonmodify.enabled=%s&dmreplicateonmodify.forcesyncdeletes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(dmreplicateonmodify_enabled), http_util.encodeURIComponent(dmreplicateonmodify_forcesyncdeletes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_ips_impl_replication_trigger_replicate_on_modify_worker_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_mac_sync_helper_impl_mac_sync_client_impl(post, apply, delete, action, location, propertylist, com_adobe_dam_mac_sync_client_so_timeout)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.mac.sync.helper.impl.MACSyncClientImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.adobe.dam.mac.sync.client.so.timeout=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_adobe_dam_mac_sync_client_so_timeout));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_mac_sync_helper_impl_mac_sync_client_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_mac_sync_impl_dam_sync_service_impl(post, apply, delete, action, location, propertylist, com_adobe_cq_dam_mac_sync_damsyncservice_registered_paths, com_adobe_cq_dam_mac_sync_damsyncservice_sync_renditions, com_adobe_cq_dam_mac_sync_damsyncservice_replicate_thread_wait_ms, com_adobe_cq_dam_mac_sync_damsyncservice_platform)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.mac.sync.impl.DAMSyncServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.adobe.cq.dam.mac.sync.damsyncservice.registered_paths=%s&com.adobe.cq.dam.mac.sync.damsyncservice.sync.renditions=%s&com.adobe.cq.dam.mac.sync.damsyncservice.replicate.thread.wait.ms=%s&com.adobe.cq.dam.mac.sync.damsyncservice.platform=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_adobe_cq_dam_mac_sync_damsyncservice_registered_paths), http_util.encodeURIComponent(com_adobe_cq_dam_mac_sync_damsyncservice_sync_renditions), http_util.encodeURIComponent(com_adobe_cq_dam_mac_sync_damsyncservice_replicate_thread_wait_ms), http_util.encodeURIComponent(com_adobe_cq_dam_mac_sync_damsyncservice_platform));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_mac_sync_impl_dam_sync_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_processor_nui_impl_nui_asset_processor(post, apply, delete, action, location, propertylist, nui_enabled, nui_service_url, nui_api_key)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.processor.nui.impl.NuiAssetProcessor?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&nuiEnabled=%s&nuiServiceUrl=%s&nuiApiKey=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(nui_enabled), http_util.encodeURIComponent(nui_service_url), http_util.encodeURIComponent(nui_api_key));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_processor_nui_impl_nui_asset_processor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_s7imaging_impl_is_image_server_component(post, apply, delete, action, location, propertylist, tcp_port, allow_remote_access, max_render_rgn_pixels, max_message_size, random_access_url_timeout, worker_threads)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.s7imaging.impl.is.ImageServerComponent?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&TcpPort=%s&AllowRemoteAccess=%s&MaxRenderRgnPixels=%s&MaxMessageSize=%s&RandomAccessUrlTimeout=%s&WorkerThreads=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(tcp_port), http_util.encodeURIComponent(allow_remote_access), http_util.encodeURIComponent(max_render_rgn_pixels), http_util.encodeURIComponent(max_message_size), http_util.encodeURIComponent(random_access_url_timeout), http_util.encodeURIComponent(worker_threads));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_s7imaging_impl_is_image_server_component_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_s7imaging_impl_ps_platform_server_servlet(post, apply, delete, action, location, propertylist, cache_enable, cache_root_paths, cache_max_size, cache_max_entries)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.s7imaging.impl.ps.PlatformServerServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cache.enable=%s&cache.rootPaths=%s&cache.maxSize=%s&cache.maxEntries=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cache_enable), http_util.encodeURIComponent(cache_root_paths), http_util.encodeURIComponent(cache_max_size), http_util.encodeURIComponent(cache_max_entries));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_s7imaging_impl_ps_platform_server_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_webdav_impl_io_asset_io_handler(post, apply, delete, action, location, propertylist, service_ranking, path_prefix, create_version)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.AssetIOHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&pathPrefix=%s&createVersion=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(path_prefix), http_util.encodeURIComponent(create_version));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_webdav_impl_io_asset_io_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_webdav_impl_io_dam_webdav_version_linking_job(post, apply, delete, action, location, propertylist, cq_dam_webdav_version_linking_enable, cq_dam_webdav_version_linking_scheduler_period, cq_dam_webdav_version_linking_staging_timeout)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.DamWebdavVersionLinkingJob?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.webdav.version.linking.enable=%s&cq.dam.webdav.version.linking.scheduler.period=%s&cq.dam.webdav.version.linking.staging.timeout=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_webdav_version_linking_enable), http_util.encodeURIComponent(cq_dam_webdav_version_linking_scheduler_period), http_util.encodeURIComponent(cq_dam_webdav_version_linking_staging_timeout));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_webdav_impl_io_dam_webdav_version_linking_job_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dam_webdav_impl_io_special_files_handler(post, apply, delete, action, location, propertylist, com_day_cq_dam_core_impl_io_special_files_handler_filepatters)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.SpecialFilesHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.day.cq.dam.core.impl.io.SpecialFilesHandler.filepatters=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_day_cq_dam_core_impl_io_special_files_handler_filepatters));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dam_webdav_impl_io_special_files_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_deserfw_impl_deserialization_firewall_impl(post, apply, delete, action, location, propertylist, firewall_deserialization_whitelist, firewall_deserialization_blacklist, firewall_deserialization_diagnostics)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.deserfw.impl.DeserializationFirewallImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&firewall.deserialization.whitelist=%s&firewall.deserialization.blacklist=%s&firewall.deserialization.diagnostics=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(firewall_deserialization_whitelist), http_util.encodeURIComponent(firewall_deserialization_blacklist), http_util.encodeURIComponent(firewall_deserialization_diagnostics));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_deserfw_impl_deserialization_firewall_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dtm_impl_service_dtm_web_service_impl(post, apply, delete, action, location, propertylist, connection_timeout, socket_timeout)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dtm.impl.service.DTMWebServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&connection.timeout=%s&socket.timeout=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(connection_timeout), http_util.encodeURIComponent(socket_timeout));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dtm_impl_service_dtm_web_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dtm_impl_servlets_dtm_deploy_hook_servlet(post, apply, delete, action, location, propertylist, dtm_staging_ip_whitelist, dtm_production_ip_whitelist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dtm.impl.servlets.DTMDeployHookServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&dtm.staging.ip.whitelist=%s&dtm.production.ip.whitelist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(dtm_staging_ip_whitelist), http_util.encodeURIComponent(dtm_production_ip_whitelist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dtm_impl_servlets_dtm_deploy_hook_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_dtm_reactor_impl_service_web_service_impl(post, apply, delete, action, location, propertylist, endpoint_uri, connection_timeout, socket_timeout)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.dtm.reactor.impl.service.WebServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&endpointUri=%s&connectionTimeout=%s&socketTimeout=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(endpoint_uri), http_util.encodeURIComponent(connection_timeout), http_util.encodeURIComponent(socket_timeout));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_dtm_reactor_impl_service_web_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_experiencelog_impl_experience_log_config_servlet(post, apply, delete, action, location, propertylist, enabled, disabled_for_groups)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.experiencelog.impl.ExperienceLogConfigServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s&disabledForGroups=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(disabled_for_groups));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_experiencelog_impl_experience_log_config_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_hc_content_packages_health_check(post, apply, delete, action, location, propertylist, hc_name, hc_tags, hc_mbean_name, package_names)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.hc.ContentPackagesHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.name=%s&hc.tags=%s&hc.mbean.name=%s&package.names=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_name), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(hc_mbean_name), http_util.encodeURIComponent(package_names));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_hc_content_packages_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_history_impl_history_request_filter(post, apply, delete, action, location, propertylist, history_request_filter_excluded_selectors, history_request_filter_excluded_extensions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.history.impl.HistoryRequestFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&history.requestFilter.excludedSelectors=%s&history.requestFilter.excludedExtensions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(history_request_filter_excluded_selectors), http_util.encodeURIComponent(history_request_filter_excluded_extensions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_history_impl_history_request_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_history_impl_history_service_impl(post, apply, delete, action, location, propertylist, history_service_resource_types, history_service_path_filter)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.history.impl.HistoryServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&history.service.resourceTypes=%s&history.service.pathFilter=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(history_service_resource_types), http_util.encodeURIComponent(history_service_path_filter));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_history_impl_history_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_inbox_impl_typeprovider_item_type_provider(post, apply, delete, action, location, propertylist, inbox_impl_typeprovider_registrypaths, inbox_impl_typeprovider_legacypaths, inbox_impl_typeprovider_defaulturl_failureitem, inbox_impl_typeprovider_defaulturl_workitem, inbox_impl_typeprovider_defaulturl_task)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.inbox.impl.typeprovider.ItemTypeProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&inbox.impl.typeprovider.registrypaths=%s&inbox.impl.typeprovider.legacypaths=%s&inbox.impl.typeprovider.defaulturl.failureitem=%s&inbox.impl.typeprovider.defaulturl.workitem=%s&inbox.impl.typeprovider.defaulturl.task=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(inbox_impl_typeprovider_registrypaths), http_util.encodeURIComponent(inbox_impl_typeprovider_legacypaths), http_util.encodeURIComponent(inbox_impl_typeprovider_defaulturl_failureitem), http_util.encodeURIComponent(inbox_impl_typeprovider_defaulturl_workitem), http_util.encodeURIComponent(inbox_impl_typeprovider_defaulturl_task));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_inbox_impl_typeprovider_item_type_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_projects_impl_servlet_project_image_servlet(post, apply, delete, action, location, propertylist, image_quality, image_supported_resolutions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.projects.impl.servlet.ProjectImageServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&image.quality=%s&image.supported.resolutions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(image_quality), http_util.encodeURIComponent(image_supported_resolutions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_projects_impl_servlet_project_image_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_projects_purge_scheduler(post, apply, delete, action, location, propertylist, scheduledpurge_name, scheduledpurge_purge_active, scheduledpurge_templates, scheduledpurge_purge_groups, scheduledpurge_purge_assets, scheduledpurge_terminate_running_workflows, scheduledpurge_daysold, scheduledpurge_save_threshold)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.projects.purge.Scheduler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduledpurge.name=%s&scheduledpurge.purgeActive=%s&scheduledpurge.templates=%s&scheduledpurge.purgeGroups=%s&scheduledpurge.purgeAssets=%s&scheduledpurge.terminateRunningWorkflows=%s&scheduledpurge.daysold=%s&scheduledpurge.saveThreshold=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduledpurge_name), http_util.encodeURIComponent(scheduledpurge_purge_active), http_util.encodeURIComponent(scheduledpurge_templates), http_util.encodeURIComponent(scheduledpurge_purge_groups), http_util.encodeURIComponent(scheduledpurge_purge_assets), http_util.encodeURIComponent(scheduledpurge_terminate_running_workflows), http_util.encodeURIComponent(scheduledpurge_daysold), http_util.encodeURIComponent(scheduledpurge_save_threshold));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_projects_purge_scheduler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_scheduled_exporter_impl_scheduled_exporter_impl(post, apply, delete, action, location, propertylist, include_paths, exporter_user)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.scheduled.exporter.impl.ScheduledExporterImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&include.paths=%s&exporter.user=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(include_paths), http_util.encodeURIComponent(exporter_user));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_scheduled_exporter_impl_scheduled_exporter_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_screens_analytics_impl_screens_analytics_service_impl(post, apply, delete, action, location, propertylist, com_adobe_cq_screens_analytics_impl_url, com_adobe_cq_screens_analytics_impl_apikey, com_adobe_cq_screens_analytics_impl_project, com_adobe_cq_screens_analytics_impl_environment, com_adobe_cq_screens_analytics_impl_send_frequency)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.screens.analytics.impl.ScreensAnalyticsServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.adobe.cq.screens.analytics.impl.url=%s&com.adobe.cq.screens.analytics.impl.apikey=%s&com.adobe.cq.screens.analytics.impl.project=%s&com.adobe.cq.screens.analytics.impl.environment=%s&com.adobe.cq.screens.analytics.impl.sendFrequency=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_adobe_cq_screens_analytics_impl_url), http_util.encodeURIComponent(com_adobe_cq_screens_analytics_impl_apikey), http_util.encodeURIComponent(com_adobe_cq_screens_analytics_impl_project), http_util.encodeURIComponent(com_adobe_cq_screens_analytics_impl_environment), http_util.encodeURIComponent(com_adobe_cq_screens_analytics_impl_send_frequency));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_screens_analytics_impl_screens_analytics_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_screens_device_impl_device_service(post, apply, delete, action, location, propertylist, com_adobe_aem_screens_player_pingfrequency, com_adobe_aem_screens_device_pasword_specialchars, com_adobe_aem_screens_device_pasword_minlowercasechars, com_adobe_aem_screens_device_pasword_minuppercasechars, com_adobe_aem_screens_device_pasword_minnumberchars, com_adobe_aem_screens_device_pasword_minspecialchars, com_adobe_aem_screens_device_pasword_minlength)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.screens.device.impl.DeviceService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.adobe.aem.screens.player.pingfrequency=%s&com.adobe.aem.screens.device.pasword.specialchars=%s&com.adobe.aem.screens.device.pasword.minlowercasechars=%s&com.adobe.aem.screens.device.pasword.minuppercasechars=%s&com.adobe.aem.screens.device.pasword.minnumberchars=%s&com.adobe.aem.screens.device.pasword.minspecialchars=%s&com.adobe.aem.screens.device.pasword.minlength=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_adobe_aem_screens_player_pingfrequency), http_util.encodeURIComponent(com_adobe_aem_screens_device_pasword_specialchars), http_util.encodeURIComponent(com_adobe_aem_screens_device_pasword_minlowercasechars), http_util.encodeURIComponent(com_adobe_aem_screens_device_pasword_minuppercasechars), http_util.encodeURIComponent(com_adobe_aem_screens_device_pasword_minnumberchars), http_util.encodeURIComponent(com_adobe_aem_screens_device_pasword_minspecialchars), http_util.encodeURIComponent(com_adobe_aem_screens_device_pasword_minlength));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_screens_device_impl_device_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_screens_device_registration_impl_registration_service_impl(post, apply, delete, action, location, propertylist, device_registration_timeout)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.screens.device.registration.impl.RegistrationServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&deviceRegistrationTimeout=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(device_registration_timeout));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_screens_device_registration_impl_registration_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_screens_impl_handler_channels_update_handler(post, apply, delete, action, location, propertylist, cq_pagesupdatehandler_imageresourcetypes, cq_pagesupdatehandler_productresourcetypes, cq_pagesupdatehandler_videoresourcetypes, cq_pagesupdatehandler_dynamicsequenceresourcetypes, cq_pagesupdatehandler_previewmodepaths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.screens.impl.handler.ChannelsUpdateHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.pagesupdatehandler.imageresourcetypes=%s&cq.pagesupdatehandler.productresourcetypes=%s&cq.pagesupdatehandler.videoresourcetypes=%s&cq.pagesupdatehandler.dynamicsequenceresourcetypes=%s&cq.pagesupdatehandler.previewmodepaths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_pagesupdatehandler_imageresourcetypes), http_util.encodeURIComponent(cq_pagesupdatehandler_productresourcetypes), http_util.encodeURIComponent(cq_pagesupdatehandler_videoresourcetypes), http_util.encodeURIComponent(cq_pagesupdatehandler_dynamicsequenceresourcetypes), http_util.encodeURIComponent(cq_pagesupdatehandler_previewmodepaths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_screens_impl_handler_channels_update_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_screens_impl_jobs_distributed_devices_stati_update_job(post, apply, delete, action, location, propertylist, scheduler_expression)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.screens.impl.jobs.DistributedDevicesStatiUpdateJob?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.expression=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_expression));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_screens_impl_jobs_distributed_devices_stati_update_job_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_screens_impl_remote_impl_distributed_http_client_impl(post, apply, delete, action, location, propertylist, com_adobe_aem_screens_impl_remote_request_timeout)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.screens.impl.remote.impl.DistributedHttpClientImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.adobe.aem.screens.impl.remote.request_timeout=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_adobe_aem_screens_impl_remote_request_timeout));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_screens_impl_remote_impl_distributed_http_client_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_screens_impl_screens_channel_post_processor(post, apply, delete, action, location, propertylist, screens_channels_properties_to_remove)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.screens.impl.ScreensChannelPostProcessor?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&screens.channels.properties.to.remove=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(screens_channels_properties_to_remove));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_screens_impl_screens_channel_post_processor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl(post, apply, delete, action, location, propertylist, com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_project_path, com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_schedule_frequency, com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_ping_timeout, com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_recipients, com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_smtpserver, com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_smtpport, com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_usetls, com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_username, com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_password)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.projectPath=%s&com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.scheduleFrequency=%s&com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.pingTimeout=%s&com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.recipients=%s&com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpserver=%s&com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpport=%s&com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.usetls=%s&com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.username=%s&com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.password=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_project_path), http_util.encodeURIComponent(com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_schedule_frequency), http_util.encodeURIComponent(com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_ping_timeout), http_util.encodeURIComponent(com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_recipients), http_util.encodeURIComponent(com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_smtpserver), http_util.encodeURIComponent(com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_smtpport), http_util.encodeURIComponent(com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_usetls), http_util.encodeURIComponent(com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_username), http_util.encodeURIComponent(com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_password));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_screens_mq_activemq_impl_artemis_jms_provider(post, apply, delete, action, location, propertylist, service_ranking, global_size, max_disk_usage, persistence_enabled, thread_pool_max_size, scheduled_thread_pool_max_size, graceful_shutdown_timeout, queues, topics, addresses_max_delivery_attempts, addresses_expiry_delay, addresses_address_full_message_policy, addresses_max_size_bytes, addresses_page_size_bytes, addresses_page_cache_max_size, cluster_user, cluster_password, cluster_call_timeout, cluster_call_failover_timeout, cluster_client_failure_check_period, cluster_notification_attempts, cluster_notification_interval, id_cache_size, cluster_confirmation_window_size, cluster_connection_ttl, cluster_duplicate_detection, cluster_initial_connect_attempts, cluster_max_retry_interval, cluster_min_large_message_size, cluster_producer_window_size, cluster_reconnect_attempts, cluster_retry_interval, cluster_retry_interval_multiplier)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.screens.mq.activemq.impl.ArtemisJMSProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&global.size=%s&max.disk.usage=%s&persistence.enabled=%s&thread.pool.max.size=%s&scheduled.thread.pool.max.size=%s&graceful.shutdown.timeout=%s&queues=%s&topics=%s&addresses.max.delivery.attempts=%s&addresses.expiry.delay=%s&addresses.address.full.message.policy=%s&addresses.max.size.bytes=%s&addresses.page.size.bytes=%s&addresses.page.cache.max.size=%s&cluster.user=%s&cluster.password=%s&cluster.call.timeout=%s&cluster.call.failover.timeout=%s&cluster.client.failure.check.period=%s&cluster.notification.attempts=%s&cluster.notification.interval=%s&id.cache.size=%s&cluster.confirmation.window.size=%s&cluster.connection.ttl=%s&cluster.duplicate.detection=%s&cluster.initial.connect.attempts=%s&cluster.max.retry.interval=%s&cluster.min.large.message.size=%s&cluster.producer.window.size=%s&cluster.reconnect.attempts=%s&cluster.retry.interval=%s&cluster.retry.interval.multiplier=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(global_size), http_util.encodeURIComponent(max_disk_usage), http_util.encodeURIComponent(persistence_enabled), http_util.encodeURIComponent(thread_pool_max_size), http_util.encodeURIComponent(scheduled_thread_pool_max_size), http_util.encodeURIComponent(graceful_shutdown_timeout), http_util.encodeURIComponent(queues), http_util.encodeURIComponent(topics), http_util.encodeURIComponent(addresses_max_delivery_attempts), http_util.encodeURIComponent(addresses_expiry_delay), http_util.encodeURIComponent(addresses_address_full_message_policy), http_util.encodeURIComponent(addresses_max_size_bytes), http_util.encodeURIComponent(addresses_page_size_bytes), http_util.encodeURIComponent(addresses_page_cache_max_size), http_util.encodeURIComponent(cluster_user), http_util.encodeURIComponent(cluster_password), http_util.encodeURIComponent(cluster_call_timeout), http_util.encodeURIComponent(cluster_call_failover_timeout), http_util.encodeURIComponent(cluster_client_failure_check_period), http_util.encodeURIComponent(cluster_notification_attempts), http_util.encodeURIComponent(cluster_notification_interval), http_util.encodeURIComponent(id_cache_size), http_util.encodeURIComponent(cluster_confirmation_window_size), http_util.encodeURIComponent(cluster_connection_ttl), http_util.encodeURIComponent(cluster_duplicate_detection), http_util.encodeURIComponent(cluster_initial_connect_attempts), http_util.encodeURIComponent(cluster_max_retry_interval), http_util.encodeURIComponent(cluster_min_large_message_size), http_util.encodeURIComponent(cluster_producer_window_size), http_util.encodeURIComponent(cluster_reconnect_attempts), http_util.encodeURIComponent(cluster_retry_interval), http_util.encodeURIComponent(cluster_retry_interval_multiplier));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_screens_mq_activemq_impl_artemis_jms_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_screens_offlinecontent_impl_bulk_offline_update_service_impl(post, apply, delete, action, location, propertylist, com_adobe_cq_screens_offlinecontent_impl_bulk_offline_update_service_impl_project_path, com_adobe_cq_screens_offlinecontent_impl_bulk_offline_update_service_impl_schedule_frequency)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.projectPath=%s&com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.scheduleFrequency=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_adobe_cq_screens_offlinecontent_impl_bulk_offline_update_service_impl_project_path), http_util.encodeURIComponent(com_adobe_cq_screens_offlinecontent_impl_bulk_offline_update_service_impl_schedule_frequency));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_screens_offlinecontent_impl_bulk_offline_update_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_screens_offlinecontent_impl_offline_content_service_impl(post, apply, delete, action, location, propertylist, disable_smart_sync)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.screens.offlinecontent.impl.OfflineContentServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&disableSmartSync=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(disable_smart_sync));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_screens_offlinecontent_impl_offline_content_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_screens_segmentation_impl_segmentation_feature_flag(post, apply, delete, action, location, propertylist, enable_data_triggered_content)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.screens.segmentation.impl.SegmentationFeatureFlag?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enableDataTriggeredContent=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enable_data_triggered_content));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_screens_segmentation_impl_segmentation_feature_flag_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_security_hc_bundles_impl_html_library_manager_config_health_ch(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.security.hc.bundles.impl.HtmlLibraryManagerConfigHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_security_hc_bundles_impl_html_library_manager_config_health_ch_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_security_hc_bundles_impl_wcm_filter_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.security.hc.bundles.impl.WcmFilterHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_security_hc_bundles_impl_wcm_filter_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_security_hc_dispatcher_impl_dispatcher_access_health_check(post, apply, delete, action, location, propertylist, hc_tags, dispatcher_address, dispatcher_filter_allowed, dispatcher_filter_blocked)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.security.hc.dispatcher.impl.DispatcherAccessHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s&dispatcher.address=%s&dispatcher.filter.allowed=%s&dispatcher.filter.blocked=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(dispatcher_address), http_util.encodeURIComponent(dispatcher_filter_allowed), http_util.encodeURIComponent(dispatcher_filter_blocked));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_security_hc_dispatcher_impl_dispatcher_access_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_security_hc_packages_impl_example_content_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.security.hc.packages.impl.ExampleContentHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_security_hc_packages_impl_example_content_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_security_hc_webserver_impl_clickjacking_health_check(post, apply, delete, action, location, propertylist, hc_tags, webserver_address)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.security.hc.webserver.impl.ClickjackingHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s&webserver.address=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(webserver_address));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_security_hc_webserver_impl_clickjacking_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_accountverification_impl_account_management_config_im(post, apply, delete, action, location, propertylist, enable, ttl1, ttl2)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.accountverification.impl.AccountManagementConfigImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enable=%s&ttl1=%s&ttl2=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enable), http_util.encodeURIComponent(ttl1), http_util.encodeURIComponent(ttl2));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_accountverification_impl_account_management_config_im_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_activitystreams_client_impl_social_activity_componen(post, apply, delete, action, location, propertylist, priority)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.activitystreams.client.impl.SocialActivityComponentFactoryImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&priority=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(priority));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_activitystreams_client_impl_social_activity_componen_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_activitystreams_client_impl_social_activity_stream_co(post, apply, delete, action, location, propertylist, priority)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.activitystreams.client.impl.SocialActivityStreamComponentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&priority=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(priority));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_activitystreams_client_impl_social_activity_stream_co_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_activitystreams_listener_impl_event_listener_handler(post, apply, delete, action, location, propertylist, event_topics, event_filter)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.EventListenerHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.topics=%s&event.filter=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_topics), http_util.encodeURIComponent(event_filter));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_activitystreams_listener_impl_event_listener_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_activitystreams_listener_impl_moderation_event_exten(post, apply, delete, action, location, propertylist, accepted, ranked)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.ModerationEventExtension?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&accepted=%s&ranked=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(accepted), http_util.encodeURIComponent(ranked));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_activitystreams_listener_impl_moderation_event_exten_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_activitystreams_listener_impl_rating_event_activity_s(post, apply, delete, action, location, propertylist, ranking, enable)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.RatingEventActivitySuppressor?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&ranking=%s&enable=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(ranking), http_util.encodeURIComponent(enable));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_activitystreams_listener_impl_rating_event_activity_s_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_activitystreams_listener_impl_resource_activity_stre(post, apply, delete, action, location, propertylist, stream_path, stream_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.ResourceActivityStreamProviderFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&streamPath=%s&streamName=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(stream_path), http_util.encodeURIComponent(stream_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_activitystreams_listener_impl_resource_activity_stre_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_calendar_client_endpoints_impl_calendar_operations_i(post, apply, delete, action, location, propertylist, max_retry, field_whitelist, attachment_type_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.calendar.client.endpoints.impl.CalendarOperationsImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&MaxRetry=%s&fieldWhitelist=%s&attachmentTypeBlacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_retry), http_util.encodeURIComponent(field_whitelist), http_util.encodeURIComponent(attachment_type_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_calendar_client_endpoints_impl_calendar_operations_i_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_calendar_client_operationextensions_event_attachmen(post, apply, delete, action, location, propertylist, attachment_type_blacklist, extension_order)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.calendar.client.operationextensions.EventAttachment?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&attachmentTypeBlacklist=%s&extension.order=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(attachment_type_blacklist), http_util.encodeURIComponent(extension_order));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_calendar_client_operationextensions_event_attachmen_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_calendar_servlets_time_zone_servlet(post, apply, delete, action, location, propertylist, timezones_expirytime)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.calendar.servlets.TimeZoneServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&timezones.expirytime=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(timezones_expirytime));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_calendar_servlets_time_zone_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_comments_endpoints_impl_comment_delete_event(post, apply, delete, action, location, propertylist, ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.CommentDeleteEventActivitySuppressor?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&ranking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_comments_endpoints_impl_comment_delete_event_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_comments_endpoints_impl_comment_operation_se(post, apply, delete, action, location, propertylist, field_whitelist, attachment_type_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.CommentOperationService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s&attachmentTypeBlacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist), http_util.encodeURIComponent(attachment_type_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_comments_endpoints_impl_comment_operation_se_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_comments_endpoints_impl_translation_operati(post, apply, delete, action, location, propertylist, field_whitelist, attachment_type_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.TranslationOperationService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s&attachmentTypeBlacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist), http_util.encodeURIComponent(attachment_type_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_comments_endpoints_impl_translation_operati_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_comments_listing_impl_search_comment_social_c(post, apply, delete, action, location, propertylist, num_user_limit)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.comments.listing.impl.SearchCommentSocialComponentListProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&numUserLimit=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(num_user_limit));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_comments_listing_impl_search_comment_social_c_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_comments_scheduler_impl_search_scheduled_pos(post, apply, delete, action, location, propertylist, enable_scheduled_posts_search, number_of_minutes, max_search_limit)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.comments.scheduler.impl.SearchScheduledPosts?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enableScheduledPostsSearch=%s&numberOfMinutes=%s&maxSearchLimit=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enable_scheduled_posts_search), http_util.encodeURIComponent(number_of_minutes), http_util.encodeURIComponent(max_search_limit));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_comments_scheduler_impl_search_scheduled_pos_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_cors_cors_authentication_filter(post, apply, delete, action, location, propertylist, cors_enabling)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.cors.CORSAuthenticationFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cors.enabling=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cors_enabling));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_cors_cors_authentication_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_android_email_client_provider(post, apply, delete, action, location, propertylist, priority_order, reply_email_patterns)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.AndroidEmailClientProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&priorityOrder=%s&replyEmailPatterns=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(priority_order), http_util.encodeURIComponent(reply_email_patterns));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_android_email_client_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_comment_email_builder_impl(post, apply, delete, action, location, propertylist, context_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CommentEmailBuilderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&context.path=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(context_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_comment_email_builder_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_comment_email_event_listener(post, apply, delete, action, location, propertylist, event_topics)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CommentEmailEventListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.topics=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_topics));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_comment_email_event_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_custom_email_client_provider(post, apply, delete, action, location, propertylist, priority_order, reply_email_patterns)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CustomEmailClientProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&priorityOrder=%s&replyEmailPatterns=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(priority_order), http_util.encodeURIComponent(reply_email_patterns));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_custom_email_client_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_email_quoted_text_patterns_imp(post, apply, delete, action, location, propertylist, pattern_time, pattern_newline, pattern_day_of_month, pattern_month, pattern_year, pattern_date, pattern_date_time, pattern_email)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailQuotedTextPatternsImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&pattern.time=%s&pattern.newline=%s&pattern.dayOfMonth=%s&pattern.month=%s&pattern.year=%s&pattern.date=%s&pattern.dateTime=%s&pattern.email=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(pattern_time), http_util.encodeURIComponent(pattern_newline), http_util.encodeURIComponent(pattern_day_of_month), http_util.encodeURIComponent(pattern_month), http_util.encodeURIComponent(pattern_year), http_util.encodeURIComponent(pattern_date), http_util.encodeURIComponent(pattern_date_time), http_util.encodeURIComponent(pattern_email));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_email_quoted_text_patterns_imp_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_email_reply_configuration_imp(post, apply, delete, action, location, propertylist, email_name, email_create_post_from_reply, email_add_comment_id_to, email_subject_maximum_length, email_reply_to_address, email_reply_to_delimiter, email_tracker_id_prefix_in_subject, email_tracker_id_prefix_in_body, email_as_html, email_default_user_name, email_templates_root_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailReplyConfigurationImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&email.name=%s&email.createPostFromReply=%s&email.addCommentIdTo=%s&email.subjectMaximumLength=%s&email.replyToAddress=%s&email.replyToDelimiter=%s&email.trackerIdPrefixInSubject=%s&email.trackerIdPrefixInBody=%s&email.asHTML=%s&email.defaultUserName=%s&email.templates.rootPath=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(email_name), http_util.encodeURIComponent(email_create_post_from_reply), http_util.encodeURIComponent(email_add_comment_id_to), http_util.encodeURIComponent(email_subject_maximum_length), http_util.encodeURIComponent(email_reply_to_address), http_util.encodeURIComponent(email_reply_to_delimiter), http_util.encodeURIComponent(email_tracker_id_prefix_in_subject), http_util.encodeURIComponent(email_tracker_id_prefix_in_body), http_util.encodeURIComponent(email_as_html), http_util.encodeURIComponent(email_default_user_name), http_util.encodeURIComponent(email_templates_root_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_email_reply_configuration_imp_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_email_reply_importer(post, apply, delete, action, location, propertylist, connect_protocol)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailReplyImporter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&connectProtocol=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(connect_protocol));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_email_reply_importer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_gmail_email_client_provider(post, apply, delete, action, location, propertylist, priority_order, reply_email_patterns)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.GmailEmailClientProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&priorityOrder=%s&replyEmailPatterns=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(priority_order), http_util.encodeURIComponent(reply_email_patterns));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_gmail_email_client_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_ios_email_client_provider(post, apply, delete, action, location, propertylist, priority_order, reply_email_patterns)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.IOSEmailClientProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&priorityOrder=%s&replyEmailPatterns=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(priority_order), http_util.encodeURIComponent(reply_email_patterns));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_ios_email_client_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_macmail_email_client_provider(post, apply, delete, action, location, propertylist, priority_order, reply_email_patterns)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.MacmailEmailClientProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&priorityOrder=%s&replyEmailPatterns=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(priority_order), http_util.encodeURIComponent(reply_email_patterns));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_macmail_email_client_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_out_look_email_client_provider(post, apply, delete, action, location, propertylist, priority_order, reply_email_patterns)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.OutLookEmailClientProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&priorityOrder=%s&replyEmailPatterns=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(priority_order), http_util.encodeURIComponent(reply_email_patterns));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_out_look_email_client_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_unknown_email_client_provider(post, apply, delete, action, location, propertylist, reply_email_patterns, priority_order)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.UnknownEmailClientProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&replyEmailPatterns=%s&priorityOrder=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(reply_email_patterns), http_util.encodeURIComponent(priority_order));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_unknown_email_client_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_emailreply_impl_yahoo_email_client_provider(post, apply, delete, action, location, propertylist, priority_order, reply_email_patterns)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.YahooEmailClientProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&priorityOrder=%s&replyEmailPatterns=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(priority_order), http_util.encodeURIComponent(reply_email_patterns));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_emailreply_impl_yahoo_email_client_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_maintainance_impl_delete_temp_ugc_image_upload(post, apply, delete, action, location, propertylist, number_of_days, age_of_file)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.maintainance.impl.DeleteTempUGCImageUploads?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&numberOfDays=%s&ageOfFile=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(number_of_days), http_util.encodeURIComponent(age_of_file));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_maintainance_impl_delete_temp_ugc_image_upload_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_ugclimiter_impl_ugc_limiter_service_impl(post, apply, delete, action, location, propertylist, event_topics, event_filter, verbs)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.ugclimiter.impl.UGCLimiterServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.topics=%s&event.filter=%s&verbs=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_topics), http_util.encodeURIComponent(event_filter), http_util.encodeURIComponent(verbs));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_ugclimiter_impl_ugc_limiter_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_commons_ugclimitsconfig_impl_community_user_ugc_limit(post, apply, delete, action, location, propertylist, enable, ugc_limit, ugc_limit_duration, domains, to_list)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.commons.ugclimitsconfig.impl.CommunityUserUGCLimitsConfigImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enable=%s&UGCLimit=%s&ugcLimitDuration=%s&domains=%s&toList=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enable), http_util.encodeURIComponent(ugc_limit), http_util.encodeURIComponent(ugc_limit_duration), http_util.encodeURIComponent(domains), http_util.encodeURIComponent(to_list));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_commons_ugclimitsconfig_impl_community_user_ugc_limit_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_connect_oauth_impl_facebook_provider_impl(post, apply, delete, action, location, propertylist, oauth_provider_id, oauth_cloud_config_root, provider_config_root, provider_config_create_tags_enabled, provider_config_user_folder, provider_config_facebook_fetch_fields, provider_config_facebook_fields, provider_config_refresh_userdata_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.FacebookProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.provider.id=%s&oauth.cloud.config.root=%s&provider.config.root=%s&provider.config.create.tags.enabled=%s&provider.config.user.folder=%s&provider.config.facebook.fetch.fields=%s&provider.config.facebook.fields=%s&provider.config.refresh.userdata.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_provider_id), http_util.encodeURIComponent(oauth_cloud_config_root), http_util.encodeURIComponent(provider_config_root), http_util.encodeURIComponent(provider_config_create_tags_enabled), http_util.encodeURIComponent(provider_config_user_folder), http_util.encodeURIComponent(provider_config_facebook_fetch_fields), http_util.encodeURIComponent(provider_config_facebook_fields), http_util.encodeURIComponent(provider_config_refresh_userdata_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_connect_oauth_impl_facebook_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_connect_oauth_impl_social_o_auth_authentication_handle(post, apply, delete, action, location, propertylist, path, service_ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.SocialOAuthAuthenticationHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path=%s&service.ranking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path), http_util.encodeURIComponent(service_ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_connect_oauth_impl_social_o_auth_authentication_handle_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_connect_oauth_impl_social_o_auth_user_profile_mapper(post, apply, delete, action, location, propertylist, facebook, twitter, provider_config_user_folder)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.SocialOAuthUserProfileMapper?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&facebook=%s&twitter=%s&provider.config.user.folder=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(facebook), http_util.encodeURIComponent(twitter), http_util.encodeURIComponent(provider_config_user_folder));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_connect_oauth_impl_social_o_auth_user_profile_mapper_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_connect_oauth_impl_twitter_provider_impl(post, apply, delete, action, location, propertylist, oauth_provider_id, oauth_cloud_config_root, provider_config_root, provider_config_user_folder, provider_config_twitter_enable_params, provider_config_twitter_params, provider_config_refresh_userdata_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.TwitterProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.provider.id=%s&oauth.cloud.config.root=%s&provider.config.root=%s&provider.config.user.folder=%s&provider.config.twitter.enable.params=%s&provider.config.twitter.params=%s&provider.config.refresh.userdata.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_provider_id), http_util.encodeURIComponent(oauth_cloud_config_root), http_util.encodeURIComponent(provider_config_root), http_util.encodeURIComponent(provider_config_user_folder), http_util.encodeURIComponent(provider_config_twitter_enable_params), http_util.encodeURIComponent(provider_config_twitter_params), http_util.encodeURIComponent(provider_config_refresh_userdata_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_connect_oauth_impl_twitter_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_content_fragments_services_impl_communities_fragmen(post, apply, delete, action, location, propertylist, cq_social_content_fragments_services_enabled, cq_social_content_fragments_services_wait_time_seconds)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.content.fragments.services.impl.CommunitiesFragmentCreationServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.social.content.fragments.services.enabled=%s&cq.social.content.fragments.services.waitTimeSeconds=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_social_content_fragments_services_enabled), http_util.encodeURIComponent(cq_social_content_fragments_services_wait_time_seconds));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_content_fragments_services_impl_communities_fragmen_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_datastore_as_impl_as_resource_provider_factory(post, apply, delete, action, location, propertylist, version_id, cache_on, concurrency_level, cache_start_size, cache_ttl, cache_size, time_limit)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.datastore.as.impl.ASResourceProviderFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&version.id=%s&cache.on=%s&concurrency.level=%s&cache.start.size=%s&cache.ttl=%s&cache.size=%s&time.limit=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(version_id), http_util.encodeURIComponent(cache_on), http_util.encodeURIComponent(concurrency_level), http_util.encodeURIComponent(cache_start_size), http_util.encodeURIComponent(cache_ttl), http_util.encodeURIComponent(cache_size), http_util.encodeURIComponent(time_limit));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_datastore_as_impl_as_resource_provider_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_datastore_op_impl_social_ms_resource_provider_factory(post, apply, delete, action, location, propertylist, solr_zk_timeout, solr_commit, cache_on, concurrency_level, cache_start_size, cache_ttl, cache_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.datastore.op.impl.SocialMSResourceProviderFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&solr.zk.timeout=%s&solr.commit=%s&cache.on=%s&concurrency.level=%s&cache.start.size=%s&cache.ttl=%s&cache.size=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(solr_zk_timeout), http_util.encodeURIComponent(solr_commit), http_util.encodeURIComponent(cache_on), http_util.encodeURIComponent(concurrency_level), http_util.encodeURIComponent(cache_start_size), http_util.encodeURIComponent(cache_ttl), http_util.encodeURIComponent(cache_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_datastore_op_impl_social_ms_resource_provider_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_datastore_rdb_impl_social_rdb_resource_provider_factor(post, apply, delete, action, location, propertylist, solr_zk_timeout, solr_commit, cache_on, concurrency_level, cache_start_size, cache_ttl, cache_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.datastore.rdb.impl.SocialRDBResourceProviderFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&solr.zk.timeout=%s&solr.commit=%s&cache.on=%s&concurrency.level=%s&cache.start.size=%s&cache.ttl=%s&cache.size=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(solr_zk_timeout), http_util.encodeURIComponent(solr_commit), http_util.encodeURIComponent(cache_on), http_util.encodeURIComponent(concurrency_level), http_util.encodeURIComponent(cache_start_size), http_util.encodeURIComponent(cache_ttl), http_util.encodeURIComponent(cache_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_datastore_rdb_impl_social_rdb_resource_provider_factor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_enablement_adaptors_enablement_learning_path_adaptor_f(post, apply, delete, action, location, propertylist, is_member_check)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.enablement.adaptors.EnablementLearningPathAdaptorFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&isMemberCheck=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(is_member_check));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_enablement_adaptors_enablement_learning_path_adaptor_f_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_enablement_adaptors_enablement_resource_adaptor_facto(post, apply, delete, action, location, propertylist, is_member_check)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.enablement.adaptors.EnablementResourceAdaptorFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&isMemberCheck=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(is_member_check));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_enablement_adaptors_enablement_resource_adaptor_facto_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_enablement_learningpath_endpoints_impl_enablement_l(post, apply, delete, action, location, propertylist, field_whitelist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.enablement.learningpath.endpoints.impl.EnablementLearningPathModelOperationService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_enablement_learningpath_endpoints_impl_enablement_l_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_enablement_resource_endpoints_impl_enablement_resou(post, apply, delete, action, location, propertylist, field_whitelist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.enablement.resource.endpoints.impl.EnablementResourceModelOperationService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_enablement_resource_endpoints_impl_enablement_resou_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_enablement_services_impl_author_marker_impl(post, apply, delete, action, location, propertylist, service_ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.enablement.services.impl.AuthorMarkerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_enablement_services_impl_author_marker_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_filelibrary_client_endpoints_filelibrary_download_ge(post, apply, delete, action, location, propertylist, sling_servlet_selectors, sling_servlet_extensions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.filelibrary.client.endpoints.FilelibraryDownloadGetServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.selectors=%s&sling.servlet.extensions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_selectors), http_util.encodeURIComponent(sling_servlet_extensions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_filelibrary_client_endpoints_filelibrary_download_ge_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_filelibrary_client_endpoints_impl_file_library_opera(post, apply, delete, action, location, propertylist, field_whitelist, attachment_type_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.filelibrary.client.endpoints.impl.FileLibraryOperationsService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s&attachmentTypeBlacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist), http_util.encodeURIComponent(attachment_type_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_filelibrary_client_endpoints_impl_file_library_opera_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_forum_client_endpoints_impl_forum_operations_service(post, apply, delete, action, location, propertylist, field_whitelist, attachment_type_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.forum.client.endpoints.impl.ForumOperationsService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s&attachmentTypeBlacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist), http_util.encodeURIComponent(attachment_type_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_forum_client_endpoints_impl_forum_operations_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_forum_dispatcher_impl_flush_operations(post, apply, delete, action, location, propertylist, extension_order, flush_forumontopic)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.forum.dispatcher.impl.FlushOperations?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&extension.order=%s&flush.forumontopic=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(extension_order), http_util.encodeURIComponent(flush_forumontopic));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_forum_dispatcher_impl_flush_operations_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_group_client_impl_community_group_collection_componen(post, apply, delete, action, location, propertylist, group_listing_pagination_enable, group_listing_lazyloading_enable, page_size, priority)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.group.client.impl.CommunityGroupCollectionComponentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&group.listing.pagination.enable=%s&group.listing.lazyloading.enable=%s&page.size=%s&priority=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(group_listing_pagination_enable), http_util.encodeURIComponent(group_listing_lazyloading_enable), http_util.encodeURIComponent(page_size), http_util.encodeURIComponent(priority));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_group_client_impl_community_group_collection_componen_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_group_impl_group_service_impl(post, apply, delete, action, location, propertylist, max_wait_time, min_wait_between_retries)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.group.impl.GroupServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&maxWaitTime=%s&minWaitBetweenRetries=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_wait_time), http_util.encodeURIComponent(min_wait_between_retries));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_group_impl_group_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_handlebars_guava_template_cache_impl(post, apply, delete, action, location, propertylist, parameter_guava_cache_enabled, parameter_guava_cache_params, parameter_guava_cache_reload, service_ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.handlebars.GuavaTemplateCacheImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&parameter.guava.cache.enabled=%s&parameter.guava.cache.params=%s&parameter.guava.cache.reload=%s&service.ranking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(parameter_guava_cache_enabled), http_util.encodeURIComponent(parameter_guava_cache_params), http_util.encodeURIComponent(parameter_guava_cache_reload), http_util.encodeURIComponent(service_ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_handlebars_guava_template_cache_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_ideation_client_endpoints_impl_ideation_operations_s(post, apply, delete, action, location, propertylist, field_whitelist, attachment_type_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.ideation.client.endpoints.impl.IdeationOperationsService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s&attachmentTypeBlacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist), http_util.encodeURIComponent(attachment_type_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_ideation_client_endpoints_impl_ideation_operations_s_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_journal_client_endpoints_impl_journal_operations_ser(post, apply, delete, action, location, propertylist, field_whitelist, attachment_type_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.journal.client.endpoints.impl.JournalOperationsService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s&attachmentTypeBlacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist), http_util.encodeURIComponent(attachment_type_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_journal_client_endpoints_impl_journal_operations_ser_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_members_endpoints_impl_community_member_group_profile(post, apply, delete, action, location, propertylist, field_whitelist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.members.endpoints.impl.CommunityMemberGroupProfileOperationService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_members_endpoints_impl_community_member_group_profile_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_members_endpoints_impl_community_member_user_profile_o(post, apply, delete, action, location, propertylist, field_whitelist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.members.endpoints.impl.CommunityMemberUserProfileOperationService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_members_endpoints_impl_community_member_user_profile_o_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_members_impl_community_member_group_profile_component_f(post, apply, delete, action, location, propertylist, everyone_limit, priority)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.members.impl.CommunityMemberGroupProfileComponentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&everyoneLimit=%s&priority=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(everyone_limit), http_util.encodeURIComponent(priority));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_members_impl_community_member_group_profile_component_f_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_messaging_client_endpoints_impl_messaging_operation(post, apply, delete, action, location, propertylist, message_properties, message_box_size_limit, message_count_limit, notify_failure, failure_message_from, failure_template_path, max_retries, min_wait_between_retries, count_update_pool_size, inbox_path, sentitems_path, support_attachments, support_group_messaging, max_total_recipients, batch_size, max_total_attachment_size, attachment_type_blacklist, allowed_attachment_types, service_selector, field_whitelist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.messaging.client.endpoints.impl.MessagingOperationsServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&message.properties=%s&messageBoxSizeLimit=%s&messageCountLimit=%s&notifyFailure=%s&failureMessageFrom=%s&failureTemplatePath=%s&maxRetries=%s&minWaitBetweenRetries=%s&countUpdatePoolSize=%s&inbox.path=%s&sentitems.path=%s&supportAttachments=%s&supportGroupMessaging=%s&maxTotalRecipients=%s&batchSize=%s&maxTotalAttachmentSize=%s&attachmentTypeBlacklist=%s&allowedAttachmentTypes=%s&serviceSelector=%s&fieldWhitelist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(message_properties), http_util.encodeURIComponent(message_box_size_limit), http_util.encodeURIComponent(message_count_limit), http_util.encodeURIComponent(notify_failure), http_util.encodeURIComponent(failure_message_from), http_util.encodeURIComponent(failure_template_path), http_util.encodeURIComponent(max_retries), http_util.encodeURIComponent(min_wait_between_retries), http_util.encodeURIComponent(count_update_pool_size), http_util.encodeURIComponent(inbox_path), http_util.encodeURIComponent(sentitems_path), http_util.encodeURIComponent(support_attachments), http_util.encodeURIComponent(support_group_messaging), http_util.encodeURIComponent(max_total_recipients), http_util.encodeURIComponent(batch_size), http_util.encodeURIComponent(max_total_attachment_size), http_util.encodeURIComponent(attachment_type_blacklist), http_util.encodeURIComponent(allowed_attachment_types), http_util.encodeURIComponent(service_selector), http_util.encodeURIComponent(field_whitelist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_messaging_client_endpoints_impl_messaging_operation_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_moderation_dashboard_api_filter_group_social_componen(post, apply, delete, action, location, propertylist, resource_type_filters, priority)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.FilterGroupSocialComponentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&resourceType.filters=%s&priority=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(resource_type_filters), http_util.encodeURIComponent(priority));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_moderation_dashboard_api_filter_group_social_componen_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_moderation_dashboard_api_moderation_dashboard_social(post, apply, delete, action, location, propertylist, priority)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.ModerationDashboardSocialComponentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&priority=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(priority));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_moderation_dashboard_api_moderation_dashboard_social_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_moderation_dashboard_api_user_details_social_componen(post, apply, delete, action, location, propertylist, priority)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.UserDetailsSocialComponentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&priority=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(priority));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_moderation_dashboard_api_user_details_social_componen_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_moderation_dashboard_internal_impl_filter_group_soci(post, apply, delete, action, location, propertylist, resource_type_filters, priority)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.internal.impl.FilterGroupSocialComponentFactoryV2?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&resourceType.filters=%s&priority=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(resource_type_filters), http_util.encodeURIComponent(priority));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_moderation_dashboard_internal_impl_filter_group_soci_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_notifications_impl_mentions_router(post, apply, delete, action, location, propertylist, event_topics, event_filter)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.notifications.impl.MentionsRouter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.topics=%s&event.filter=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_topics), http_util.encodeURIComponent(event_filter));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_notifications_impl_mentions_router_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_notifications_impl_notification_manager_impl(post, apply, delete, action, location, propertylist, max_unread_notification_count)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.notifications.impl.NotificationManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&max.unread.notification.count=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_unread_notification_count));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_notifications_impl_notification_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_notifications_impl_notifications_router(post, apply, delete, action, location, propertylist, event_topics, event_filter)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.notifications.impl.NotificationsRouter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.topics=%s&event.filter=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_topics), http_util.encodeURIComponent(event_filter));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_notifications_impl_notifications_router_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_qna_client_endpoints_impl_qna_forum_operations_servic(post, apply, delete, action, location, propertylist, field_whitelist, attachment_type_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.qna.client.endpoints.impl.QnaForumOperationsService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s&attachmentTypeBlacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist), http_util.encodeURIComponent(attachment_type_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_qna_client_endpoints_impl_qna_forum_operations_servic_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_reporting_analytics_services_impl_analytics_report_i(post, apply, delete, action, location, propertylist, cq_social_reporting_analytics_polling_importer_interval, cq_social_reporting_analytics_polling_importer_page_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.AnalyticsReportImporterServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.social.reporting.analytics.polling.importer.interval=%s&cq.social.reporting.analytics.polling.importer.pageSize=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_social_reporting_analytics_polling_importer_interval), http_util.encodeURIComponent(cq_social_reporting_analytics_polling_importer_page_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_reporting_analytics_services_impl_analytics_report_i_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_reporting_analytics_services_impl_analytics_report_m(post, apply, delete, action, location, propertylist, report_fetch_delay)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.AnalyticsReportManagementServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&report.fetch.delay=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(report_fetch_delay));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_reporting_analytics_services_impl_analytics_report_m_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_reporting_analytics_services_impl_site_trend_report_s(post, apply, delete, action, location, propertylist, cq_social_console_analytics_sites_mapping, priority)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.SiteTrendReportSocialComponentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.social.console.analytics.sites.mapping=%s&priority=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_social_console_analytics_sites_mapping), http_util.encodeURIComponent(priority));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_reporting_analytics_services_impl_site_trend_report_s_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_review_client_endpoints_impl_review_operations_servi(post, apply, delete, action, location, propertylist, field_whitelist, attachment_type_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.review.client.endpoints.impl.ReviewOperationsService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s&attachmentTypeBlacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist), http_util.encodeURIComponent(attachment_type_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_review_client_endpoints_impl_review_operations_servi_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_scf_core_operations_impl_social_operations_servlet(post, apply, delete, action, location, propertylist, sling_servlet_selectors, sling_servlet_extensions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.scf.core.operations.impl.SocialOperationsServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.selectors=%s&sling.servlet.extensions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_selectors), http_util.encodeURIComponent(sling_servlet_extensions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_scf_core_operations_impl_social_operations_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_scf_endpoints_impl_default_social_get_servlet(post, apply, delete, action, location, propertylist, sling_servlet_selectors, sling_servlet_extensions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.scf.endpoints.impl.DefaultSocialGetServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.selectors=%s&sling.servlet.extensions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_selectors), http_util.encodeURIComponent(sling_servlet_extensions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_scf_endpoints_impl_default_social_get_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_scoring_impl_scoring_event_listener(post, apply, delete, action, location, propertylist, event_topics, event_filter)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.scoring.impl.ScoringEventListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.topics=%s&event.filter=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_topics), http_util.encodeURIComponent(event_filter));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_scoring_impl_scoring_event_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_serviceusers_internal_impl_service_user_wrapper_impl(post, apply, delete, action, location, propertylist, enable_fallback)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.serviceusers.internal.impl.ServiceUserWrapperImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enableFallback=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enable_fallback));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_serviceusers_internal_impl_service_user_wrapper_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_site_endpoints_impl_site_operation_service(post, apply, delete, action, location, propertylist, field_whitelist, site_path_filters, site_package_group)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.site.endpoints.impl.SiteOperationService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fieldWhitelist=%s&sitePathFilters=%s&sitePackageGroup=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(field_whitelist), http_util.encodeURIComponent(site_path_filters), http_util.encodeURIComponent(site_package_group));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_site_endpoints_impl_site_operation_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_site_impl_analytics_component_configuration_service_im(post, apply, delete, action, location, propertylist, cq_social_console_analytics_components)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.site.impl.AnalyticsComponentConfigurationServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.social.console.analytics.components=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_social_console_analytics_components));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_site_impl_analytics_component_configuration_service_im_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_site_impl_site_configurator_impl(post, apply, delete, action, location, propertylist, components_using_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.site.impl.SiteConfiguratorImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&componentsUsingTags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(components_using_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_site_impl_site_configurator_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_srp_impl_social_solr_connector(post, apply, delete, action, location, propertylist, srp_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.srp.impl.SocialSolrConnector?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&srp.type=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(srp_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_srp_impl_social_solr_connector_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_sync_impl_diff_changes_observer(post, apply, delete, action, location, propertylist, enabled, agent_name, diff_path, property_names)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.sync.impl.DiffChangesObserver?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s&agentName=%s&diffPath=%s&propertyNames=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(agent_name), http_util.encodeURIComponent(diff_path), http_util.encodeURIComponent(property_names));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_sync_impl_diff_changes_observer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_sync_impl_group_sync_listener_impl(post, apply, delete, action, location, propertylist, nodetypes, ignorableprops, ignorablenodes, enabled, distfolders)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.sync.impl.GroupSyncListenerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&nodetypes=%s&ignorableprops=%s&ignorablenodes=%s&enabled=%s&distfolders=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(nodetypes), http_util.encodeURIComponent(ignorableprops), http_util.encodeURIComponent(ignorablenodes), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(distfolders));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_sync_impl_group_sync_listener_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_sync_impl_publisher_sync_service_impl(post, apply, delete, action, location, propertylist, active_run_modes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.sync.impl.PublisherSyncServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&activeRunModes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(active_run_modes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_sync_impl_publisher_sync_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_sync_impl_user_sync_listener_impl(post, apply, delete, action, location, propertylist, nodetypes, ignorableprops, ignorablenodes, enabled, distfolders)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.sync.impl.UserSyncListenerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&nodetypes=%s&ignorableprops=%s&ignorablenodes=%s&enabled=%s&distfolders=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(nodetypes), http_util.encodeURIComponent(ignorableprops), http_util.encodeURIComponent(ignorablenodes), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(distfolders));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_sync_impl_user_sync_listener_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_translation_impl_translation_service_config_manager(post, apply, delete, action, location, propertylist, translate_language, translate_display, translate_attribution, translate_caching, translate_smart_rendering, translate_caching_duration, translate_session_save_interval, translate_session_save_batch_limit)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.translation.impl.TranslationServiceConfigManager?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&translate.language=%s&translate.display=%s&translate.attribution=%s&translate.caching=%s&translate.smart.rendering=%s&translate.caching.duration=%s&translate.session.save.interval=%s&translate.session.save.batchLimit=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(translate_language), http_util.encodeURIComponent(translate_display), http_util.encodeURIComponent(translate_attribution), http_util.encodeURIComponent(translate_caching), http_util.encodeURIComponent(translate_smart_rendering), http_util.encodeURIComponent(translate_caching_duration), http_util.encodeURIComponent(translate_session_save_interval), http_util.encodeURIComponent(translate_session_save_batch_limit));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_translation_impl_translation_service_config_manager_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_translation_impl_ugc_language_detector(post, apply, delete, action, location, propertylist, event_topics, event_filter, translate_listener_type, translate_property_list, pool_size, max_pool_size, queue_size, keep_alive_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.translation.impl.UGCLanguageDetector?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.topics=%s&event.filter=%s&translate.listener.type=%s&translate.property.list=%s&poolSize=%s&maxPoolSize=%s&queueSize=%s&keepAliveTime=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_topics), http_util.encodeURIComponent(event_filter), http_util.encodeURIComponent(translate_listener_type), http_util.encodeURIComponent(translate_property_list), http_util.encodeURIComponent(pool_size), http_util.encodeURIComponent(max_pool_size), http_util.encodeURIComponent(queue_size), http_util.encodeURIComponent(keep_alive_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_translation_impl_ugc_language_detector_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_ugcbase_dispatcher_impl_flush_service_impl(post, apply, delete, action, location, propertylist, thread_pool_size, delay_time, worker_sleep_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.ugcbase.dispatcher.impl.FlushServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&threadPoolSize=%s&delayTime=%s&workerSleepTime=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(thread_pool_size), http_util.encodeURIComponent(delay_time), http_util.encodeURIComponent(worker_sleep_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_ugcbase_dispatcher_impl_flush_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_ugcbase_impl_aysnc_reverse_replicator_impl(post, apply, delete, action, location, propertylist, pool_size, max_pool_size, queue_size, keep_alive_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.AysncReverseReplicatorImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&poolSize=%s&maxPoolSize=%s&queueSize=%s&keepAliveTime=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(pool_size), http_util.encodeURIComponent(max_pool_size), http_util.encodeURIComponent(queue_size), http_util.encodeURIComponent(keep_alive_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_ugcbase_impl_aysnc_reverse_replicator_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_ugcbase_impl_publisher_configuration_impl(post, apply, delete, action, location, propertylist, is_primary_publisher)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.PublisherConfigurationImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&isPrimaryPublisher=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(is_primary_publisher));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_ugcbase_impl_publisher_configuration_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_ugcbase_impl_social_utils_impl(post, apply, delete, action, location, propertylist, legacy_cloud_ugc_path_mapping)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.SocialUtilsImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&legacyCloudUGCPathMapping=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(legacy_cloud_ugc_path_mapping));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_ugcbase_impl_social_utils_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_ugcbase_moderation_impl_auto_moderation_impl(post, apply, delete, action, location, propertylist, automoderation_sequence, automoderation_onfailurestop)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.ugcbase.moderation.impl.AutoModerationImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&automoderation.sequence=%s&automoderation.onfailurestop=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(automoderation_sequence), http_util.encodeURIComponent(automoderation_onfailurestop));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_ugcbase_moderation_impl_auto_moderation_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_ugcbase_moderation_impl_sentiment_process(post, apply, delete, action, location, propertylist, watchwords_positive, watchwords_negative, watchwords_path, sentiment_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.ugcbase.moderation.impl.SentimentProcess?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&watchwords.positive=%s&watchwords.negative=%s&watchwords.path=%s&sentiment.path=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(watchwords_positive), http_util.encodeURIComponent(watchwords_negative), http_util.encodeURIComponent(watchwords_path), http_util.encodeURIComponent(sentiment_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_ugcbase_moderation_impl_sentiment_process_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_ugcbase_security_impl_default_attachment_type_blackli(post, apply, delete, action, location, propertylist, default_attachment_type_blacklist, baseline_attachment_type_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.ugcbase.security.impl.DefaultAttachmentTypeBlacklistService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&default.attachment.type.blacklist=%s&baseline.attachment.type.blacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(default_attachment_type_blacklist), http_util.encodeURIComponent(baseline_attachment_type_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_ugcbase_security_impl_default_attachment_type_blackli_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_ugcbase_security_impl_safer_sling_post_validator_impl(post, apply, delete, action, location, propertylist, parameter_whitelist, parameter_whitelist_prefixes, binary_parameter_whitelist, modifier_whitelist, operation_whitelist, operation_whitelist_prefixes, typehint_whitelist, resourcetype_whitelist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.ugcbase.security.impl.SaferSlingPostValidatorImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&parameter.whitelist=%s&parameter.whitelist.prefixes=%s&binary.parameter.whitelist=%s&modifier.whitelist=%s&operation.whitelist=%s&operation.whitelist.prefixes=%s&typehint.whitelist=%s&resourcetype.whitelist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(parameter_whitelist), http_util.encodeURIComponent(parameter_whitelist_prefixes), http_util.encodeURIComponent(binary_parameter_whitelist), http_util.encodeURIComponent(modifier_whitelist), http_util.encodeURIComponent(operation_whitelist), http_util.encodeURIComponent(operation_whitelist_prefixes), http_util.encodeURIComponent(typehint_whitelist), http_util.encodeURIComponent(resourcetype_whitelist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_ugcbase_security_impl_safer_sling_post_validator_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_user_endpoints_impl_users_group_from_publish_servlet(post, apply, delete, action, location, propertylist, sling_servlet_extensions, sling_servlet_paths, sling_servlet_methods)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.user.endpoints.impl.UsersGroupFromPublishServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.extensions=%s&sling.servlet.paths=%s&sling.servlet.methods=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_extensions), http_util.encodeURIComponent(sling_servlet_paths), http_util.encodeURIComponent(sling_servlet_methods));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_user_endpoints_impl_users_group_from_publish_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_social_user_impl_transport_http_to_publisher(post, apply, delete, action, location, propertylist, enable, agent_configuration, context_path, disabled_cipher_suites, enabled_cipher_suites)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.social.user.impl.transport.HttpToPublisher?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enable=%s&agent.configuration=%s&context.path=%s&disabled.cipher.suites=%s&enabled.cipher.suites=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enable), http_util.encodeURIComponent(agent_configuration), http_util.encodeURIComponent(context_path), http_util.encodeURIComponent(disabled_cipher_suites), http_util.encodeURIComponent(enabled_cipher_suites));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_social_user_impl_transport_http_to_publisher_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_ui_wcm_commons_internal_servlets_rte_rte_filter_servlet_fact(post, apply, delete, action, location, propertylist, resource_types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.ui.wcm.commons.internal.servlets.rte.RTEFilterServletFactory.amended?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&resource.types=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(resource_types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_ui_wcm_commons_internal_servlets_rte_rte_filter_servlet_fact_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_upgrades_cleanup_impl_upgrade_content_cleanup(post, apply, delete, action, location, propertylist, delete_path_regexps, delete_sql2_query)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.upgrades.cleanup.impl.UpgradeContentCleanup?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&delete.path.regexps=%s&delete.sql2.query=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(delete_path_regexps), http_util.encodeURIComponent(delete_sql2_query));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_upgrades_cleanup_impl_upgrade_content_cleanup_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_upgrades_cleanup_impl_upgrade_install_folder_cleanup(post, apply, delete, action, location, propertylist, delete_name_regexps)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.upgrades.cleanup.impl.UpgradeInstallFolderCleanup?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&delete.name.regexps=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(delete_name_regexps));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_upgrades_cleanup_impl_upgrade_install_folder_cleanup_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_wcm_jobs_async_impl_async_delete_config_provider_service(post, apply, delete, action, location, propertylist, threshold, job_topic_name, email_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncDeleteConfigProviderService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&threshold=%s&jobTopicName=%s&emailEnabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(threshold), http_util.encodeURIComponent(job_topic_name), http_util.encodeURIComponent(email_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_wcm_jobs_async_impl_async_delete_config_provider_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_wcm_jobs_async_impl_async_job_clean_up_task(post, apply, delete, action, location, propertylist, scheduler_expression, job_purge_threshold, job_purge_max_jobs)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncJobCleanUpTask?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.expression=%s&job.purge.threshold=%s&job.purge.max.jobs=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_expression), http_util.encodeURIComponent(job_purge_threshold), http_util.encodeURIComponent(job_purge_max_jobs));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_wcm_jobs_async_impl_async_job_clean_up_task_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_wcm_jobs_async_impl_async_move_config_provider_service(post, apply, delete, action, location, propertylist, threshold, job_topic_name, email_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncMoveConfigProviderService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&threshold=%s&jobTopicName=%s&emailEnabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(threshold), http_util.encodeURIComponent(job_topic_name), http_util.encodeURIComponent(email_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_wcm_jobs_async_impl_async_move_config_provider_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_wcm_jobs_async_impl_async_page_move_config_provider_service(post, apply, delete, action, location, propertylist, threshold, job_topic_name, email_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncPageMoveConfigProviderService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&threshold=%s&jobTopicName=%s&emailEnabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(threshold), http_util.encodeURIComponent(job_topic_name), http_util.encodeURIComponent(email_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_wcm_jobs_async_impl_async_page_move_config_provider_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_wcm_launches_impl_launches_event_handler(post, apply, delete, action, location, propertylist, event_filter, launches_eventhandler_threadpool_maxsize, launches_eventhandler_threadpool_priority, launches_eventhandler_updatelastmodification)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.wcm.launches.impl.LaunchesEventHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.filter=%s&launches.eventhandler.threadpool.maxsize=%s&launches.eventhandler.threadpool.priority=%s&launches.eventhandler.updatelastmodification=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_filter), http_util.encodeURIComponent(launches_eventhandler_threadpool_maxsize), http_util.encodeURIComponent(launches_eventhandler_threadpool_priority), http_util.encodeURIComponent(launches_eventhandler_updatelastmodification));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_wcm_launches_impl_launches_event_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_wcm_mobile_qrcode_servlet_qr_code_image_generator(post, apply, delete, action, location, propertylist, cq_wcm_qrcode_servlet_whitelist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.wcm.mobile.qrcode.servlet.QRCodeImageGenerator?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.wcm.qrcode.servlet.whitelist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_wcm_qrcode_servlet_whitelist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_wcm_mobile_qrcode_servlet_qr_code_image_generator_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_wcm_style_internal_component_style_info_cache_impl(post, apply, delete, action, location, propertylist, size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.wcm.style.internal.ComponentStyleInfoCacheImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&size=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_wcm_style_internal_component_style_info_cache_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_cq_wcm_translation_impl_translation_platform_configuration_impl(post, apply, delete, action, location, propertylist, sync_translation_state_scheduling_format, scheduling_repeat_translation_scheduling_format, sync_translation_state_lock_timeout_in_minutes, export_format)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.cq.wcm.translation.impl.TranslationPlatformConfigurationImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&syncTranslationState.schedulingFormat=%s&schedulingRepeatTranslation.schedulingFormat=%s&syncTranslationState.lockTimeoutInMinutes=%s&export.format=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sync_translation_state_scheduling_format), http_util.encodeURIComponent(scheduling_repeat_translation_scheduling_format), http_util.encodeURIComponent(sync_translation_state_lock_timeout_in_minutes), http_util.encodeURIComponent(export_format));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_cq_wcm_translation_impl_translation_platform_configuration_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_fd_fp_config_forms_portal_draftsand_submission_config_service(post, apply, delete, action, location, propertylist, portal_outboxes, draft_data_service, draft_metadata_service, submit_data_service, submit_metadata_service, pending_sign_data_service, pending_sign_metadata_service)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.fd.fp.config.FormsPortalDraftsandSubmissionConfigService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&portal.outboxes=%s&draft.data.service=%s&draft.metadata.service=%s&submit.data.service=%s&submit.metadata.service=%s&pendingSign.data.service=%s&pendingSign.metadata.service=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(portal_outboxes), http_util.encodeURIComponent(draft_data_service), http_util.encodeURIComponent(draft_metadata_service), http_util.encodeURIComponent(submit_data_service), http_util.encodeURIComponent(submit_metadata_service), http_util.encodeURIComponent(pending_sign_data_service), http_util.encodeURIComponent(pending_sign_metadata_service));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_fd_fp_config_forms_portal_draftsand_submission_config_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_fd_fp_config_forms_portal_scheduler_service(post, apply, delete, action, location, propertylist, formportal_interval)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.fd.fp.config.FormsPortalSchedulerService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&formportal.interval=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(formportal_interval));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_fd_fp_config_forms_portal_scheduler_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_forms_common_service_impl_default_data_provider(post, apply, delete, action, location, propertylist, alloweddata_file_locations)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.forms.common.service.impl.DefaultDataProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&alloweddataFileLocations=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(alloweddata_file_locations));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_forms_common_service_impl_default_data_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_forms_common_service_impl_forms_common_configuration_service_imp(post, apply, delete, action, location, propertylist, temp_storage_config)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.forms.common.service.impl.FormsCommonConfigurationServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&tempStorageConfig=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(temp_storage_config));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_forms_common_service_impl_forms_common_configuration_service_imp_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_forms_common_servlet_temp_clean_up_task(post, apply, delete, action, location, propertylist, scheduler_expression, duration_for_temporary_storage, duration_for_anonymous_storage)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.forms.common.servlet.TempCleanUpTask?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.expression=%s&Duration for Temporary Storage=%s&Duration for Anonymous Storage=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_expression), http_util.encodeURIComponent(duration_for_temporary_storage), http_util.encodeURIComponent(duration_for_anonymous_storage));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_forms_common_servlet_temp_clean_up_task_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_acp_platform_platform_servlet(post, apply, delete, action, location, propertylist, query_limit, file_type_extension_map)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.acp.platform.PlatformServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&query.limit=%s&file.type.extension.map=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(query_limit), http_util.encodeURIComponent(file_type_extension_map));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_acp_platform_platform_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_activitystreams_impl_activity_manager_impl(post, apply, delete, action, location, propertylist, aggregate_relationships, aggregate_descend_virtual)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.activitystreams.impl.ActivityManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&aggregate.relationships=%s&aggregate.descend.virtual=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(aggregate_relationships), http_util.encodeURIComponent(aggregate_descend_virtual));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_activitystreams_impl_activity_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_analyzer_base_system_status_servlet(post, apply, delete, action, location, propertylist, disabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.analyzer.base.SystemStatusServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&disabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(disabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_analyzer_base_system_status_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_analyzer_scripts_compile_all_scripts_compiler_servlet(post, apply, delete, action, location, propertylist, disabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.analyzer.scripts.compile.AllScriptsCompilerServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&disabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(disabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_analyzer_scripts_compile_all_scripts_compiler_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_apicontroller_filter_resolver_hook_factory(post, apply, delete, action, location, propertylist, com_adobe_cq_cdn_cdn_rewriter, com_adobe_cq_cloud_config_components, com_adobe_cq_cloud_config_core, com_adobe_cq_cloud_config_ui, com_adobe_cq_com_adobe_cq_editor, com_adobe_cq_com_adobe_cq_projects_core, com_adobe_cq_com_adobe_cq_projects_wcm_core, com_adobe_cq_com_adobe_cq_ui_commons, com_adobe_cq_com_adobe_cq_wcm_style, com_adobe_cq_cq_activitymap_integration, com_adobe_cq_cq_contexthub_commons, com_adobe_cq_cq_dtm, com_adobe_cq_cq_healthcheck, com_adobe_cq_cq_multisite_targeting, com_adobe_cq_cq_pre_upgrade_cleanup, com_adobe_cq_cq_product_info_provider, com_adobe_cq_cq_rest_sites, com_adobe_cq_cq_security_hc, com_adobe_cq_dam_cq_dam_svg_handler, com_adobe_cq_dam_cq_scene7_imaging, com_adobe_cq_dtm_reactor_core, com_adobe_cq_dtm_reactor_ui, com_adobe_cq_exp_jspel_resolver, com_adobe_cq_inbox_cq_inbox, com_adobe_cq_json_schema_parser, com_adobe_cq_media_cq_media_publishing_dps_fp_core, com_adobe_cq_mobile_cq_mobile_caas, com_adobe_cq_mobile_cq_mobile_index_builder, com_adobe_cq_mobile_cq_mobile_phonegap_build, com_adobe_cq_myspell, com_adobe_cq_sample_we_retail_core, com_adobe_cq_screens_com_adobe_cq_screens_dcc, com_adobe_cq_screens_com_adobe_cq_screens_mq_core, com_adobe_cq_social_cq_social_as_provider, com_adobe_cq_social_cq_social_badging_basic_impl, com_adobe_cq_social_cq_social_badging_impl, com_adobe_cq_social_cq_social_calendar_impl, com_adobe_cq_social_cq_social_content_fragments_impl, com_adobe_cq_social_cq_social_enablement_impl, com_adobe_cq_social_cq_social_graph_impl, com_adobe_cq_social_cq_social_ideation_impl, com_adobe_cq_social_cq_social_jcr_provider, com_adobe_cq_social_cq_social_members_impl, com_adobe_cq_social_cq_social_ms_provider, com_adobe_cq_social_cq_social_notifications_channels_web, com_adobe_cq_social_cq_social_notifications_impl, com_adobe_cq_social_cq_social_rdb_provider, com_adobe_cq_social_cq_social_scf_impl, com_adobe_cq_social_cq_social_scoring_basic_impl, com_adobe_cq_social_cq_social_scoring_impl, com_adobe_cq_social_cq_social_serviceusers_impl, com_adobe_cq_social_cq_social_srp_impl, com_adobe_cq_social_cq_social_ugcbase_impl, com_adobe_dam_cq_dam_cfm_impl, com_adobe_forms_foundation_forms_foundation_base, com_adobe_granite_apicontroller, com_adobe_granite_asset_core, com_adobe_granite_auth_sso, com_adobe_granite_bundles_hc_impl, com_adobe_granite_compat_router, com_adobe_granite_conf, com_adobe_granite_conf_ui_core, com_adobe_granite_cors, com_adobe_granite_crx_explorer, com_adobe_granite_crxde_lite, com_adobe_granite_crypto_config, com_adobe_granite_crypto_extension, com_adobe_granite_crypto_file, com_adobe_granite_crypto_jcr, com_adobe_granite_csrf, com_adobe_granite_distribution_core, com_adobe_granite_dropwizard_metrics, com_adobe_granite_frags_impl, com_adobe_granite_gibson, com_adobe_granite_infocollector, com_adobe_granite_installer_factory_packages, com_adobe_granite_jetty_ssl, com_adobe_granite_jobs_async, com_adobe_granite_maintenance_oak, com_adobe_granite_monitoring_core, com_adobe_granite_queries, com_adobe_granite_replication_hc_impl, com_adobe_granite_repository_checker, com_adobe_granite_repository_hc_impl, com_adobe_granite_rest_assets, com_adobe_granite_security_ui, com_adobe_granite_startup, com_adobe_granite_tagsoup, com_adobe_granite_taskmanagement_core, com_adobe_granite_taskmanagement_workflow, com_adobe_granite_ui_clientlibs_compiler_less, com_adobe_granite_ui_clientlibs_processor_gcc, com_adobe_granite_webconsole_plugins, com_adobe_granite_workflow_console, com_adobe_xmp_worker_files_native_fragment_linux, com_adobe_xmp_worker_files_native_fragment_macosx, com_adobe_xmp_worker_files_native_fragment_win, com_day_commons_osgi_wrapper_simple_jndi, com_day_cq_cq_authhandler, com_day_cq_cq_compat_configupdate, com_day_cq_cq_licensebranding, com_day_cq_cq_notifcation_impl, com_day_cq_cq_replication_audit, com_day_cq_cq_search_ext, com_day_cq_dam_cq_dam_annotation_print, com_day_cq_dam_cq_dam_asset_usage, com_day_cq_dam_cq_dam_s7dam, com_day_cq_dam_cq_dam_similaritysearch, com_day_cq_dam_dam_webdav_support, com_day_cq_pre_upgrade_tasks, com_day_cq_replication_extensions, com_day_cq_wcm_cq_msm_core, com_day_cq_wcm_cq_wcm_translation, day_commons_jrawio, org_apache_aries_jmx_whiteboard, org_apache_felix_http_sslfilter, org_apache_felix_org_apache_felix_threaddump, org_apache_felix_webconsole_plugins_ds, org_apache_felix_webconsole_plugins_event, org_apache_felix_webconsole_plugins_memoryusage, org_apache_felix_webconsole_plugins_packageadmin, org_apache_jackrabbit_oak_auth_ldap, org_apache_jackrabbit_oak_segment_tar, org_apache_jackrabbit_oak_solr_osgi, org_apache_sling_bundleresource_impl, org_apache_sling_commons_fsclassloader, org_apache_sling_commons_log_webconsole, org_apache_sling_datasource, org_apache_sling_discovery_base, org_apache_sling_discovery_oak, org_apache_sling_discovery_support, org_apache_sling_distribution_api, org_apache_sling_distribution_core, org_apache_sling_extensions_webconsolesecurityprovider, org_apache_sling_hc_webconsole, org_apache_sling_installer_console, org_apache_sling_installer_provider_file, org_apache_sling_installer_provider_jcr, org_apache_sling_jcr_davex, org_apache_sling_jcr_resourcesecurity, org_apache_sling_jmx_provider, org_apache_sling_launchpad_installer, org_apache_sling_models_impl, org_apache_sling_repoinit_parser, org_apache_sling_resource_inventory, org_apache_sling_resourceresolver, org_apache_sling_scripting_javascript, org_apache_sling_scripting_jst, org_apache_sling_scripting_sightly_js_provider, org_apache_sling_scripting_sightly_models_provider, org_apache_sling_security, org_apache_sling_servlets_compat, org_apache_sling_servlets_get, org_apache_sling_startupfilter_disabler, org_apache_sling_tracer, we_retail_client_app_core)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.apicontroller.FilterResolverHookFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.adobe.cq.cdn.cdn-rewriter=%s&com.adobe.cq.cloud-config.components=%s&com.adobe.cq.cloud-config.core=%s&com.adobe.cq.cloud-config.ui=%s&com.adobe.cq.com.adobe.cq.editor=%s&com.adobe.cq.com.adobe.cq.projects.core=%s&com.adobe.cq.com.adobe.cq.projects.wcm.core=%s&com.adobe.cq.com.adobe.cq.ui.commons=%s&com.adobe.cq.com.adobe.cq.wcm.style=%s&com.adobe.cq.cq-activitymap-integration=%s&com.adobe.cq.cq-contexthub-commons=%s&com.adobe.cq.cq-dtm=%s&com.adobe.cq.cq-healthcheck=%s&com.adobe.cq.cq-multisite-targeting=%s&com.adobe.cq.cq-pre-upgrade-cleanup=%s&com.adobe.cq.cq-product-info-provider=%s&com.adobe.cq.cq-rest-sites=%s&com.adobe.cq.cq-security-hc=%s&com.adobe.cq.dam.cq-dam-svg-handler=%s&com.adobe.cq.dam.cq-scene7-imaging=%s&com.adobe.cq.dtm-reactor.core=%s&com.adobe.cq.dtm-reactor.ui=%s&com.adobe.cq.exp-jspel-resolver=%s&com.adobe.cq.inbox.cq-inbox=%s&com.adobe.cq.json-schema-parser=%s&com.adobe.cq.media.cq-media-publishing-dps-fp-core=%s&com.adobe.cq.mobile.cq-mobile-caas=%s&com.adobe.cq.mobile.cq-mobile-index-builder=%s&com.adobe.cq.mobile.cq-mobile-phonegap-build=%s&com.adobe.cq.myspell=%s&com.adobe.cq.sample.we.retail.core=%s&com.adobe.cq.screens.com.adobe.cq.screens.dcc=%s&com.adobe.cq.screens.com.adobe.cq.screens.mq.core=%s&com.adobe.cq.social.cq-social-as-provider=%s&com.adobe.cq.social.cq-social-badging-basic-impl=%s&com.adobe.cq.social.cq-social-badging-impl=%s&com.adobe.cq.social.cq-social-calendar-impl=%s&com.adobe.cq.social.cq-social-content-fragments-impl=%s&com.adobe.cq.social.cq-social-enablement-impl=%s&com.adobe.cq.social.cq-social-graph-impl=%s&com.adobe.cq.social.cq-social-ideation-impl=%s&com.adobe.cq.social.cq-social-jcr-provider=%s&com.adobe.cq.social.cq-social-members-impl=%s&com.adobe.cq.social.cq-social-ms-provider=%s&com.adobe.cq.social.cq-social-notifications-channels-web=%s&com.adobe.cq.social.cq-social-notifications-impl=%s&com.adobe.cq.social.cq-social-rdb-provider=%s&com.adobe.cq.social.cq-social-scf-impl=%s&com.adobe.cq.social.cq-social-scoring-basic-impl=%s&com.adobe.cq.social.cq-social-scoring-impl=%s&com.adobe.cq.social.cq-social-serviceusers-impl=%s&com.adobe.cq.social.cq-social-srp-impl=%s&com.adobe.cq.social.cq-social-ugcbase-impl=%s&com.adobe.dam.cq-dam-cfm-impl=%s&com.adobe.forms.foundation-forms-foundation-base=%s&com.adobe.granite.apicontroller=%s&com.adobe.granite.asset.core=%s&com.adobe.granite.auth.sso=%s&com.adobe.granite.bundles.hc.impl=%s&com.adobe.granite.compat-router=%s&com.adobe.granite.conf=%s&com.adobe.granite.conf.ui.core=%s&com.adobe.granite.cors=%s&com.adobe.granite.crx-explorer=%s&com.adobe.granite.crxde-lite=%s&com.adobe.granite.crypto.config=%s&com.adobe.granite.crypto.extension=%s&com.adobe.granite.crypto.file=%s&com.adobe.granite.crypto.jcr=%s&com.adobe.granite.csrf=%s&com.adobe.granite.distribution.core=%s&com.adobe.granite.dropwizard.metrics=%s&com.adobe.granite.frags.impl=%s&com.adobe.granite.gibson=%s&com.adobe.granite.infocollector=%s&com.adobe.granite.installer.factory.packages=%s&com.adobe.granite.jetty.ssl=%s&com.adobe.granite.jobs.async=%s&com.adobe.granite.maintenance.oak=%s&com.adobe.granite.monitoring.core=%s&com.adobe.granite.queries=%s&com.adobe.granite.replication.hc.impl=%s&com.adobe.granite.repository.checker=%s&com.adobe.granite.repository.hc.impl=%s&com.adobe.granite.rest.assets=%s&com.adobe.granite.security.ui=%s&com.adobe.granite.startup=%s&com.adobe.granite.tagsoup=%s&com.adobe.granite.taskmanagement.core=%s&com.adobe.granite.taskmanagement.workflow=%s&com.adobe.granite.ui.clientlibs.compiler.less=%s&com.adobe.granite.ui.clientlibs.processor.gcc=%s&com.adobe.granite.webconsole.plugins=%s&com.adobe.granite.workflow.console=%s&com.adobe.xmp.worker.files.native.fragment.linux=%s&com.adobe.xmp.worker.files.native.fragment.macosx=%s&com.adobe.xmp.worker.files.native.fragment.win=%s&com.day.commons.osgi.wrapper.simple-jndi=%s&com.day.cq.cq-authhandler=%s&com.day.cq.cq-compat-configupdate=%s&com.day.cq.cq-licensebranding=%s&com.day.cq.cq-notifcation-impl=%s&com.day.cq.cq-replication-audit=%s&com.day.cq.cq-search-ext=%s&com.day.cq.dam.cq-dam-annotation-print=%s&com.day.cq.dam.cq-dam-asset-usage=%s&com.day.cq.dam.cq-dam-s7dam=%s&com.day.cq.dam.cq-dam-similaritysearch=%s&com.day.cq.dam.dam-webdav-support=%s&com.day.cq.pre-upgrade-tasks=%s&com.day.cq.replication.extensions=%s&com.day.cq.wcm.cq-msm-core=%s&com.day.cq.wcm.cq-wcm-translation=%s&day-commons-jrawio=%s&org.apache.aries.jmx.whiteboard=%s&org.apache.felix.http.sslfilter=%s&org.apache.felix.org.apache.felix.threaddump=%s&org.apache.felix.webconsole.plugins.ds=%s&org.apache.felix.webconsole.plugins.event=%s&org.apache.felix.webconsole.plugins.memoryusage=%s&org.apache.felix.webconsole.plugins.packageadmin=%s&org.apache.jackrabbit.oak-auth-ldap=%s&org.apache.jackrabbit.oak-segment-tar=%s&org.apache.jackrabbit.oak-solr-osgi=%s&org.apache.sling.bundleresource.impl=%s&org.apache.sling.commons.fsclassloader=%s&org.apache.sling.commons.log.webconsole=%s&org.apache.sling.datasource=%s&org.apache.sling.discovery.base=%s&org.apache.sling.discovery.oak=%s&org.apache.sling.discovery.support=%s&org.apache.sling.distribution.api=%s&org.apache.sling.distribution.core=%s&org.apache.sling.extensions.webconsolesecurityprovider=%s&org.apache.sling.hc.webconsole=%s&org.apache.sling.installer.console=%s&org.apache.sling.installer.provider.file=%s&org.apache.sling.installer.provider.jcr=%s&org.apache.sling.jcr.davex=%s&org.apache.sling.jcr.resourcesecurity=%s&org.apache.sling.jmx.provider=%s&org.apache.sling.launchpad.installer=%s&org.apache.sling.models.impl=%s&org.apache.sling.repoinit.parser=%s&org.apache.sling.resource.inventory=%s&org.apache.sling.resourceresolver=%s&org.apache.sling.scripting.javascript=%s&org.apache.sling.scripting.jst=%s&org.apache.sling.scripting.sightly.js.provider=%s&org.apache.sling.scripting.sightly.models.provider=%s&org.apache.sling.security=%s&org.apache.sling.servlets.compat=%s&org.apache.sling.servlets.get=%s&org.apache.sling.startupfilter.disabler=%s&org.apache.sling.tracer=%s&we.retail.client.app.core=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_adobe_cq_cdn_cdn_rewriter), http_util.encodeURIComponent(com_adobe_cq_cloud_config_components), http_util.encodeURIComponent(com_adobe_cq_cloud_config_core), http_util.encodeURIComponent(com_adobe_cq_cloud_config_ui), http_util.encodeURIComponent(com_adobe_cq_com_adobe_cq_editor), http_util.encodeURIComponent(com_adobe_cq_com_adobe_cq_projects_core), http_util.encodeURIComponent(com_adobe_cq_com_adobe_cq_projects_wcm_core), http_util.encodeURIComponent(com_adobe_cq_com_adobe_cq_ui_commons), http_util.encodeURIComponent(com_adobe_cq_com_adobe_cq_wcm_style), http_util.encodeURIComponent(com_adobe_cq_cq_activitymap_integration), http_util.encodeURIComponent(com_adobe_cq_cq_contexthub_commons), http_util.encodeURIComponent(com_adobe_cq_cq_dtm), http_util.encodeURIComponent(com_adobe_cq_cq_healthcheck), http_util.encodeURIComponent(com_adobe_cq_cq_multisite_targeting), http_util.encodeURIComponent(com_adobe_cq_cq_pre_upgrade_cleanup), http_util.encodeURIComponent(com_adobe_cq_cq_product_info_provider), http_util.encodeURIComponent(com_adobe_cq_cq_rest_sites), http_util.encodeURIComponent(com_adobe_cq_cq_security_hc), http_util.encodeURIComponent(com_adobe_cq_dam_cq_dam_svg_handler), http_util.encodeURIComponent(com_adobe_cq_dam_cq_scene7_imaging), http_util.encodeURIComponent(com_adobe_cq_dtm_reactor_core), http_util.encodeURIComponent(com_adobe_cq_dtm_reactor_ui), http_util.encodeURIComponent(com_adobe_cq_exp_jspel_resolver), http_util.encodeURIComponent(com_adobe_cq_inbox_cq_inbox), http_util.encodeURIComponent(com_adobe_cq_json_schema_parser), http_util.encodeURIComponent(com_adobe_cq_media_cq_media_publishing_dps_fp_core), http_util.encodeURIComponent(com_adobe_cq_mobile_cq_mobile_caas), http_util.encodeURIComponent(com_adobe_cq_mobile_cq_mobile_index_builder), http_util.encodeURIComponent(com_adobe_cq_mobile_cq_mobile_phonegap_build), http_util.encodeURIComponent(com_adobe_cq_myspell), http_util.encodeURIComponent(com_adobe_cq_sample_we_retail_core), http_util.encodeURIComponent(com_adobe_cq_screens_com_adobe_cq_screens_dcc), http_util.encodeURIComponent(com_adobe_cq_screens_com_adobe_cq_screens_mq_core), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_as_provider), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_badging_basic_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_badging_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_calendar_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_content_fragments_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_enablement_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_graph_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_ideation_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_jcr_provider), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_members_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_ms_provider), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_notifications_channels_web), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_notifications_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_rdb_provider), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_scf_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_scoring_basic_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_scoring_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_serviceusers_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_srp_impl), http_util.encodeURIComponent(com_adobe_cq_social_cq_social_ugcbase_impl), http_util.encodeURIComponent(com_adobe_dam_cq_dam_cfm_impl), http_util.encodeURIComponent(com_adobe_forms_foundation_forms_foundation_base), http_util.encodeURIComponent(com_adobe_granite_apicontroller), http_util.encodeURIComponent(com_adobe_granite_asset_core), http_util.encodeURIComponent(com_adobe_granite_auth_sso), http_util.encodeURIComponent(com_adobe_granite_bundles_hc_impl), http_util.encodeURIComponent(com_adobe_granite_compat_router), http_util.encodeURIComponent(com_adobe_granite_conf), http_util.encodeURIComponent(com_adobe_granite_conf_ui_core), http_util.encodeURIComponent(com_adobe_granite_cors), http_util.encodeURIComponent(com_adobe_granite_crx_explorer), http_util.encodeURIComponent(com_adobe_granite_crxde_lite), http_util.encodeURIComponent(com_adobe_granite_crypto_config), http_util.encodeURIComponent(com_adobe_granite_crypto_extension), http_util.encodeURIComponent(com_adobe_granite_crypto_file), http_util.encodeURIComponent(com_adobe_granite_crypto_jcr), http_util.encodeURIComponent(com_adobe_granite_csrf), http_util.encodeURIComponent(com_adobe_granite_distribution_core), http_util.encodeURIComponent(com_adobe_granite_dropwizard_metrics), http_util.encodeURIComponent(com_adobe_granite_frags_impl), http_util.encodeURIComponent(com_adobe_granite_gibson), http_util.encodeURIComponent(com_adobe_granite_infocollector), http_util.encodeURIComponent(com_adobe_granite_installer_factory_packages), http_util.encodeURIComponent(com_adobe_granite_jetty_ssl), http_util.encodeURIComponent(com_adobe_granite_jobs_async), http_util.encodeURIComponent(com_adobe_granite_maintenance_oak), http_util.encodeURIComponent(com_adobe_granite_monitoring_core), http_util.encodeURIComponent(com_adobe_granite_queries), http_util.encodeURIComponent(com_adobe_granite_replication_hc_impl), http_util.encodeURIComponent(com_adobe_granite_repository_checker), http_util.encodeURIComponent(com_adobe_granite_repository_hc_impl), http_util.encodeURIComponent(com_adobe_granite_rest_assets), http_util.encodeURIComponent(com_adobe_granite_security_ui), http_util.encodeURIComponent(com_adobe_granite_startup), http_util.encodeURIComponent(com_adobe_granite_tagsoup), http_util.encodeURIComponent(com_adobe_granite_taskmanagement_core), http_util.encodeURIComponent(com_adobe_granite_taskmanagement_workflow), http_util.encodeURIComponent(com_adobe_granite_ui_clientlibs_compiler_less), http_util.encodeURIComponent(com_adobe_granite_ui_clientlibs_processor_gcc), http_util.encodeURIComponent(com_adobe_granite_webconsole_plugins), http_util.encodeURIComponent(com_adobe_granite_workflow_console), http_util.encodeURIComponent(com_adobe_xmp_worker_files_native_fragment_linux), http_util.encodeURIComponent(com_adobe_xmp_worker_files_native_fragment_macosx), http_util.encodeURIComponent(com_adobe_xmp_worker_files_native_fragment_win), http_util.encodeURIComponent(com_day_commons_osgi_wrapper_simple_jndi), http_util.encodeURIComponent(com_day_cq_cq_authhandler), http_util.encodeURIComponent(com_day_cq_cq_compat_configupdate), http_util.encodeURIComponent(com_day_cq_cq_licensebranding), http_util.encodeURIComponent(com_day_cq_cq_notifcation_impl), http_util.encodeURIComponent(com_day_cq_cq_replication_audit), http_util.encodeURIComponent(com_day_cq_cq_search_ext), http_util.encodeURIComponent(com_day_cq_dam_cq_dam_annotation_print), http_util.encodeURIComponent(com_day_cq_dam_cq_dam_asset_usage), http_util.encodeURIComponent(com_day_cq_dam_cq_dam_s7dam), http_util.encodeURIComponent(com_day_cq_dam_cq_dam_similaritysearch), http_util.encodeURIComponent(com_day_cq_dam_dam_webdav_support), http_util.encodeURIComponent(com_day_cq_pre_upgrade_tasks), http_util.encodeURIComponent(com_day_cq_replication_extensions), http_util.encodeURIComponent(com_day_cq_wcm_cq_msm_core), http_util.encodeURIComponent(com_day_cq_wcm_cq_wcm_translation), http_util.encodeURIComponent(day_commons_jrawio), http_util.encodeURIComponent(org_apache_aries_jmx_whiteboard), http_util.encodeURIComponent(org_apache_felix_http_sslfilter), http_util.encodeURIComponent(org_apache_felix_org_apache_felix_threaddump), http_util.encodeURIComponent(org_apache_felix_webconsole_plugins_ds), http_util.encodeURIComponent(org_apache_felix_webconsole_plugins_event), http_util.encodeURIComponent(org_apache_felix_webconsole_plugins_memoryusage), http_util.encodeURIComponent(org_apache_felix_webconsole_plugins_packageadmin), http_util.encodeURIComponent(org_apache_jackrabbit_oak_auth_ldap), http_util.encodeURIComponent(org_apache_jackrabbit_oak_segment_tar), http_util.encodeURIComponent(org_apache_jackrabbit_oak_solr_osgi), http_util.encodeURIComponent(org_apache_sling_bundleresource_impl), http_util.encodeURIComponent(org_apache_sling_commons_fsclassloader), http_util.encodeURIComponent(org_apache_sling_commons_log_webconsole), http_util.encodeURIComponent(org_apache_sling_datasource), http_util.encodeURIComponent(org_apache_sling_discovery_base), http_util.encodeURIComponent(org_apache_sling_discovery_oak), http_util.encodeURIComponent(org_apache_sling_discovery_support), http_util.encodeURIComponent(org_apache_sling_distribution_api), http_util.encodeURIComponent(org_apache_sling_distribution_core), http_util.encodeURIComponent(org_apache_sling_extensions_webconsolesecurityprovider), http_util.encodeURIComponent(org_apache_sling_hc_webconsole), http_util.encodeURIComponent(org_apache_sling_installer_console), http_util.encodeURIComponent(org_apache_sling_installer_provider_file), http_util.encodeURIComponent(org_apache_sling_installer_provider_jcr), http_util.encodeURIComponent(org_apache_sling_jcr_davex), http_util.encodeURIComponent(org_apache_sling_jcr_resourcesecurity), http_util.encodeURIComponent(org_apache_sling_jmx_provider), http_util.encodeURIComponent(org_apache_sling_launchpad_installer), http_util.encodeURIComponent(org_apache_sling_models_impl), http_util.encodeURIComponent(org_apache_sling_repoinit_parser), http_util.encodeURIComponent(org_apache_sling_resource_inventory), http_util.encodeURIComponent(org_apache_sling_resourceresolver), http_util.encodeURIComponent(org_apache_sling_scripting_javascript), http_util.encodeURIComponent(org_apache_sling_scripting_jst), http_util.encodeURIComponent(org_apache_sling_scripting_sightly_js_provider), http_util.encodeURIComponent(org_apache_sling_scripting_sightly_models_provider), http_util.encodeURIComponent(org_apache_sling_security), http_util.encodeURIComponent(org_apache_sling_servlets_compat), http_util.encodeURIComponent(org_apache_sling_servlets_get), http_util.encodeURIComponent(org_apache_sling_startupfilter_disabler), http_util.encodeURIComponent(org_apache_sling_tracer), http_util.encodeURIComponent(we_retail_client_app_core));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_apicontroller_filter_resolver_hook_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_cert_impl_client_cert_auth_handler(post, apply, delete, action, location, propertylist, path, service_ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.cert.impl.ClientCertAuthHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path=%s&service.ranking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path), http_util.encodeURIComponent(service_ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_cert_impl_client_cert_auth_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_ims(post, apply, delete, action, location, propertylist, configid, scope)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.ims?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&configid=%s&scope=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(configid), http_util.encodeURIComponent(scope));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_ims_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_ims_impl_external_user_id_mapping_provider_extension(post, apply, delete, action, location, propertylist, oauth_provider_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.ims.impl.ExternalUserIdMappingProviderExtension?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.provider.id=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_provider_id));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_ims_impl_external_user_id_mapping_provider_extension_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_ims_impl_ims_access_token_request_customizer_impl(post, apply, delete, action, location, propertylist, auth_ims_client_secret, customizer_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSAccessTokenRequestCustomizerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&auth.ims.client.secret=%s&customizer.type=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(auth_ims_client_secret), http_util.encodeURIComponent(customizer_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_ims_impl_ims_access_token_request_customizer_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_ims_impl_ims_config_provider_impl(post, apply, delete, action, location, propertylist, oauth_configmanager_ims_configid, ims_owning_entity, aem_instance_id, ims_service_code)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.ims.impl.ImsConfigProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.configmanager.ims.configid=%s&ims.owningEntity=%s&aem.instanceId=%s&ims.serviceCode=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_configmanager_ims_configid), http_util.encodeURIComponent(ims_owning_entity), http_util.encodeURIComponent(aem_instance_id), http_util.encodeURIComponent(ims_service_code));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_ims_impl_ims_config_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_ims_impl_ims_instance_credentials_validator(post, apply, delete, action, location, propertylist, oauth_provider_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSInstanceCredentialsValidator?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.provider.id=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_provider_id));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_ims_impl_ims_instance_credentials_validator_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_ims_impl_ims_provider_impl(post, apply, delete, action, location, propertylist, oauth_provider_id, oauth_provider_ims_authorization_url, oauth_provider_ims_token_url, oauth_provider_ims_profile_url, oauth_provider_ims_extended_details_urls, oauth_provider_ims_validate_token_url, oauth_provider_ims_session_property, oauth_provider_ims_service_token_client_id, oauth_provider_ims_service_token_client_secret, oauth_provider_ims_service_token, ims_org_ref, ims_group_mapping, oauth_provider_ims_only_license_group)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.provider.id=%s&oauth.provider.ims.authorization.url=%s&oauth.provider.ims.token.url=%s&oauth.provider.ims.profile.url=%s&oauth.provider.ims.extended.details.urls=%s&oauth.provider.ims.validate.token.url=%s&oauth.provider.ims.session.property=%s&oauth.provider.ims.service.token.client.id=%s&oauth.provider.ims.service.token.client.secret=%s&oauth.provider.ims.service.token=%s&ims.org.ref=%s&ims.group.mapping=%s&oauth.provider.ims.only.license.group=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_provider_id), http_util.encodeURIComponent(oauth_provider_ims_authorization_url), http_util.encodeURIComponent(oauth_provider_ims_token_url), http_util.encodeURIComponent(oauth_provider_ims_profile_url), http_util.encodeURIComponent(oauth_provider_ims_extended_details_urls), http_util.encodeURIComponent(oauth_provider_ims_validate_token_url), http_util.encodeURIComponent(oauth_provider_ims_session_property), http_util.encodeURIComponent(oauth_provider_ims_service_token_client_id), http_util.encodeURIComponent(oauth_provider_ims_service_token_client_secret), http_util.encodeURIComponent(oauth_provider_ims_service_token), http_util.encodeURIComponent(ims_org_ref), http_util.encodeURIComponent(ims_group_mapping), http_util.encodeURIComponent(oauth_provider_ims_only_license_group));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_ims_impl_ims_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_oauth_accesstoken_provider(post, apply, delete, action, location, propertylist, name, auth_token_provider_title, auth_token_provider_default_claims, auth_token_provider_endpoint, auth_access_token_request, auth_token_provider_keypair_alias, auth_token_provider_conn_timeout, auth_token_provider_so_timeout, auth_token_provider_client_id, auth_token_provider_scope, auth_token_provider_reuse_access_token, auth_token_provider_relaxed_ssl, token_request_customizer_type, auth_token_validator_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.oauth.accesstoken.provider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&auth.token.provider.title=%s&auth.token.provider.default.claims=%s&auth.token.provider.endpoint=%s&auth.access.token.request=%s&auth.token.provider.keypair.alias=%s&auth.token.provider.conn.timeout=%s&auth.token.provider.so.timeout=%s&auth.token.provider.client.id=%s&auth.token.provider.scope=%s&auth.token.provider.reuse.access.token=%s&auth.token.provider.relaxed.ssl=%s&token.request.customizer.type=%s&auth.token.validator.type=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(auth_token_provider_title), http_util.encodeURIComponent(auth_token_provider_default_claims), http_util.encodeURIComponent(auth_token_provider_endpoint), http_util.encodeURIComponent(auth_access_token_request), http_util.encodeURIComponent(auth_token_provider_keypair_alias), http_util.encodeURIComponent(auth_token_provider_conn_timeout), http_util.encodeURIComponent(auth_token_provider_so_timeout), http_util.encodeURIComponent(auth_token_provider_client_id), http_util.encodeURIComponent(auth_token_provider_scope), http_util.encodeURIComponent(auth_token_provider_reuse_access_token), http_util.encodeURIComponent(auth_token_provider_relaxed_ssl), http_util.encodeURIComponent(token_request_customizer_type), http_util.encodeURIComponent(auth_token_validator_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_oauth_accesstoken_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_oauth_impl_bearer_authentication_handler(post, apply, delete, action, location, propertylist, path, oauth_client_ids_allowed, auth_bearer_sync_ims, auth_token_request_parameter, oauth_bearer_configid, oauth_jwt_support)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.oauth.impl.BearerAuthenticationHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path=%s&oauth.clientIds.allowed=%s&auth.bearer.sync.ims=%s&auth.tokenRequestParameter=%s&oauth.bearer.configid=%s&oauth.jwt.support=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path), http_util.encodeURIComponent(oauth_client_ids_allowed), http_util.encodeURIComponent(auth_bearer_sync_ims), http_util.encodeURIComponent(auth_token_request_parameter), http_util.encodeURIComponent(oauth_bearer_configid), http_util.encodeURIComponent(oauth_jwt_support));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_oauth_impl_bearer_authentication_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_oauth_impl_default_token_validator_impl(post, apply, delete, action, location, propertylist, auth_token_validator_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.oauth.impl.DefaultTokenValidatorImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&auth.token.validator.type=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(auth_token_validator_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_oauth_impl_default_token_validator_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_oauth_impl_facebook_provider_impl(post, apply, delete, action, location, propertylist, oauth_provider_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.oauth.impl.FacebookProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.provider.id=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_provider_id));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_oauth_impl_facebook_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_oauth_impl_github_provider_impl(post, apply, delete, action, location, propertylist, oauth_provider_id, oauth_provider_github_authorization_url, oauth_provider_github_token_url, oauth_provider_github_profile_url)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.oauth.impl.GithubProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.provider.id=%s&oauth.provider.github.authorization.url=%s&oauth.provider.github.token.url=%s&oauth.provider.github.profile.url=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_provider_id), http_util.encodeURIComponent(oauth_provider_github_authorization_url), http_util.encodeURIComponent(oauth_provider_github_token_url), http_util.encodeURIComponent(oauth_provider_github_profile_url));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_oauth_impl_github_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_oauth_impl_granite_provider(post, apply, delete, action, location, propertylist, oauth_provider_id, oauth_provider_granite_authorization_url, oauth_provider_granite_token_url, oauth_provider_granite_profile_url, oauth_provider_granite_extended_details_urls)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.oauth.impl.GraniteProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.provider.id=%s&oauth.provider.granite.authorization.url=%s&oauth.provider.granite.token.url=%s&oauth.provider.granite.profile.url=%s&oauth.provider.granite.extended.details.urls=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_provider_id), http_util.encodeURIComponent(oauth_provider_granite_authorization_url), http_util.encodeURIComponent(oauth_provider_granite_token_url), http_util.encodeURIComponent(oauth_provider_granite_profile_url), http_util.encodeURIComponent(oauth_provider_granite_extended_details_urls));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_oauth_impl_granite_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_oauth_impl_helper_provider_config_manager(post, apply, delete, action, location, propertylist, oauth_cookie_login_timeout, oauth_cookie_max_age)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.oauth.impl.helper.ProviderConfigManager?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.cookie.login.timeout=%s&oauth.cookie.max.age=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_cookie_login_timeout), http_util.encodeURIComponent(oauth_cookie_max_age));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_oauth_impl_helper_provider_config_manager_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_oauth_impl_helper_provider_config_manager_internal(post, apply, delete, action, location, propertylist, oauth_cookie_login_timeout, oauth_cookie_max_age)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.oauth.impl.helper.ProviderConfigManagerInternal?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.cookie.login.timeout=%s&oauth.cookie.max.age=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_cookie_login_timeout), http_util.encodeURIComponent(oauth_cookie_max_age));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_oauth_impl_helper_provider_config_manager_internal_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_oauth_impl_o_auth_authentication_handler(post, apply, delete, action, location, propertylist, path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.oauth.impl.OAuthAuthenticationHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_oauth_impl_o_auth_authentication_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_oauth_impl_twitter_provider_impl(post, apply, delete, action, location, propertylist, oauth_provider_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.oauth.impl.TwitterProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.provider.id=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_provider_id));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_oauth_impl_twitter_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_oauth_provider(post, apply, delete, action, location, propertylist, oauth_config_id, oauth_client_id, oauth_client_secret, oauth_scope, oauth_config_provider_id, oauth_create_users, oauth_userid_property, force_strict_username_matching, oauth_encode_userids, oauth_hash_userids, oauth_call_back_url, oauth_access_token_persist, oauth_access_token_persist_cookie, oauth_csrf_state_protection, oauth_redirect_request_params, oauth_config_siblings_allow)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.oauth.provider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.config.id=%s&oauth.client.id=%s&oauth.client.secret=%s&oauth.scope=%s&oauth.config.provider.id=%s&oauth.create.users=%s&oauth.userid.property=%s&force.strict.username.matching=%s&oauth.encode.userids=%s&oauth.hash.userids=%s&oauth.callBackUrl=%s&oauth.access.token.persist=%s&oauth.access.token.persist.cookie=%s&oauth.csrf.state.protection=%s&oauth.redirect.request.params=%s&oauth.config.siblings.allow=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_config_id), http_util.encodeURIComponent(oauth_client_id), http_util.encodeURIComponent(oauth_client_secret), http_util.encodeURIComponent(oauth_scope), http_util.encodeURIComponent(oauth_config_provider_id), http_util.encodeURIComponent(oauth_create_users), http_util.encodeURIComponent(oauth_userid_property), http_util.encodeURIComponent(force_strict_username_matching), http_util.encodeURIComponent(oauth_encode_userids), http_util.encodeURIComponent(oauth_hash_userids), http_util.encodeURIComponent(oauth_call_back_url), http_util.encodeURIComponent(oauth_access_token_persist), http_util.encodeURIComponent(oauth_access_token_persist_cookie), http_util.encodeURIComponent(oauth_csrf_state_protection), http_util.encodeURIComponent(oauth_redirect_request_params), http_util.encodeURIComponent(oauth_config_siblings_allow));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_oauth_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_requirement_impl_default_requirement_handler(post, apply, delete, action, location, propertylist, supported_paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.requirement.impl.DefaultRequirementHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&supportedPaths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(supported_paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_requirement_impl_default_requirement_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_saml_saml_authentication_handler(post, apply, delete, action, location, propertylist, path, service_ranking, idp_url, idp_cert_alias, idp_http_redirect, service_provider_entity_id, assertion_consumer_service_url, sp_private_key_alias, key_store_password, default_redirect_url, user_id_attribute, use_encryption, create_user, user_intermediate_path, add_group_memberships, group_membership_attribute, default_groups, name_id_format, synchronize_attributes, handle_logout, logout_url, clock_tolerance, digest_method, signature_method, identity_sync_type, idp_identifier)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path=%s&service.ranking=%s&idpUrl=%s&idpCertAlias=%s&idpHttpRedirect=%s&serviceProviderEntityId=%s&assertionConsumerServiceURL=%s&spPrivateKeyAlias=%s&keyStorePassword=%s&defaultRedirectUrl=%s&userIDAttribute=%s&useEncryption=%s&createUser=%s&userIntermediatePath=%s&addGroupMemberships=%s&groupMembershipAttribute=%s&defaultGroups=%s&nameIdFormat=%s&synchronizeAttributes=%s&handleLogout=%s&logoutUrl=%s&clockTolerance=%s&digestMethod=%s&signatureMethod=%s&identitySyncType=%s&idpIdentifier=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(idp_url), http_util.encodeURIComponent(idp_cert_alias), http_util.encodeURIComponent(idp_http_redirect), http_util.encodeURIComponent(service_provider_entity_id), http_util.encodeURIComponent(assertion_consumer_service_url), http_util.encodeURIComponent(sp_private_key_alias), http_util.encodeURIComponent(key_store_password), http_util.encodeURIComponent(default_redirect_url), http_util.encodeURIComponent(user_id_attribute), http_util.encodeURIComponent(use_encryption), http_util.encodeURIComponent(create_user), http_util.encodeURIComponent(user_intermediate_path), http_util.encodeURIComponent(add_group_memberships), http_util.encodeURIComponent(group_membership_attribute), http_util.encodeURIComponent(default_groups), http_util.encodeURIComponent(name_id_format), http_util.encodeURIComponent(synchronize_attributes), http_util.encodeURIComponent(handle_logout), http_util.encodeURIComponent(logout_url), http_util.encodeURIComponent(clock_tolerance), http_util.encodeURIComponent(digest_method), http_util.encodeURIComponent(signature_method), http_util.encodeURIComponent(identity_sync_type), http_util.encodeURIComponent(idp_identifier));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_saml_saml_authentication_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_auth_sso_impl_sso_authentication_handler(post, apply, delete, action, location, propertylist, path, service_ranking, jaas_control_flag, jaas_realm_name, jaas_ranking, headers, cookies, parameters, usermap, format, trusted_credentials_attribute)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.auth.sso.impl.SsoAuthenticationHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path=%s&service.ranking=%s&jaas.controlFlag=%s&jaas.realmName=%s&jaas.ranking=%s&headers=%s&cookies=%s&parameters=%s&usermap=%s&format=%s&trustedCredentialsAttribute=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(jaas_control_flag), http_util.encodeURIComponent(jaas_realm_name), http_util.encodeURIComponent(jaas_ranking), http_util.encodeURIComponent(headers), http_util.encodeURIComponent(cookies), http_util.encodeURIComponent(parameters), http_util.encodeURIComponent(usermap), http_util.encodeURIComponent(format), http_util.encodeURIComponent(trusted_credentials_attribute));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_auth_sso_impl_sso_authentication_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_bundles_hc_impl_code_cache_health_check(post, apply, delete, action, location, propertylist, hc_tags, minimum_code_cache_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.bundles.hc.impl.CodeCacheHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s&minimum.code.cache.size=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(minimum_code_cache_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_bundles_hc_impl_code_cache_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_bundles_hc_impl_crxde_support_bundle_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.bundles.hc.impl.CrxdeSupportBundleHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_bundles_hc_impl_crxde_support_bundle_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_bundles_hc_impl_dav_ex_bundle_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.bundles.hc.impl.DavExBundleHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_bundles_hc_impl_dav_ex_bundle_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_bundles_hc_impl_inactive_bundles_health_check(post, apply, delete, action, location, propertylist, hc_tags, ignored_bundles)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.bundles.hc.impl.InactiveBundlesHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s&ignored.bundles=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(ignored_bundles));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_bundles_hc_impl_inactive_bundles_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_bundles_hc_impl_jobs_health_check(post, apply, delete, action, location, propertylist, hc_tags, max_queued_jobs)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.bundles.hc.impl.JobsHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s&max.queued.jobs=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(max_queued_jobs));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_bundles_hc_impl_jobs_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_bundles_hc_impl_sling_get_servlet_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingGetServletHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_bundles_hc_impl_sling_get_servlet_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_bundles_hc_impl_sling_java_script_handler_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingJavaScriptHandlerHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_bundles_hc_impl_sling_java_script_handler_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_bundles_hc_impl_sling_jsp_script_handler_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingJspScriptHandlerHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_bundles_hc_impl_sling_jsp_script_handler_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_bundles_hc_impl_sling_referrer_filter_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingReferrerFilterHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_bundles_hc_impl_sling_referrer_filter_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_bundles_hc_impl_web_dav_bundle_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.bundles.hc.impl.WebDavBundleHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_bundles_hc_impl_web_dav_bundle_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_comments_internal_comment_replication_content_filter_fac(post, apply, delete, action, location, propertylist, replicate_comment_resource_types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.comments.internal.CommentReplicationContentFilterFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&replicate.comment.resourceTypes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(replicate_comment_resource_types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_comments_internal_comment_replication_content_filter_fac_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_compatrouter_impl_compat_switching_service_impl(post, apply, delete, action, location, propertylist, compatgroups, enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.compatrouter.impl.CompatSwitchingServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&compatgroups=%s&enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(compatgroups), http_util.encodeURIComponent(enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_compatrouter_impl_compat_switching_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_compatrouter_impl_routing_config(post, apply, delete, action, location, propertylist, id, compat_path, new_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.compatrouter.impl.RoutingConfig?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&id=%s&compatPath=%s&newPath=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(id), http_util.encodeURIComponent(compat_path), http_util.encodeURIComponent(new_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_compatrouter_impl_routing_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_compatrouter_impl_switch_mapping_config(post, apply, delete, action, location, propertylist, group, ids)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.compatrouter.impl.SwitchMappingConfig?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&group=%s&ids=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(group), http_util.encodeURIComponent(ids));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_compatrouter_impl_switch_mapping_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_conf_impl_runtime_aware_configuration_resource_resolving(post, apply, delete, action, location, propertylist, enabled, fallback_paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.conf.impl.RuntimeAwareConfigurationResourceResolvingStrategy?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s&fallbackPaths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(fallback_paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_conf_impl_runtime_aware_configuration_resource_resolving_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_contexthub_impl_context_hub_impl(post, apply, delete, action, location, propertylist, com_adobe_granite_contexthub_silent_mode, com_adobe_granite_contexthub_show_ui)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.contexthub.impl.ContextHubImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.adobe.granite.contexthub.silent_mode=%s&com.adobe.granite.contexthub.show_ui=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_adobe_granite_contexthub_silent_mode), http_util.encodeURIComponent(com_adobe_granite_contexthub_show_ui));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_contexthub_impl_context_hub_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_cors_impl_cors_policy_impl(post, apply, delete, action, location, propertylist, alloworigin, alloworiginregexp, allowedpaths, exposedheaders, maxage, supportedheaders, supportedmethods, supportscredentials)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.cors.impl.CORSPolicyImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&alloworigin=%s&alloworiginregexp=%s&allowedpaths=%s&exposedheaders=%s&maxage=%s&supportedheaders=%s&supportedmethods=%s&supportscredentials=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(alloworigin), http_util.encodeURIComponent(alloworiginregexp), http_util.encodeURIComponent(allowedpaths), http_util.encodeURIComponent(exposedheaders), http_util.encodeURIComponent(maxage), http_util.encodeURIComponent(supportedheaders), http_util.encodeURIComponent(supportedmethods), http_util.encodeURIComponent(supportscredentials));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_cors_impl_cors_policy_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_csrf_impl_csrf_filter(post, apply, delete, action, location, propertylist, filter_methods, filter_enable_safe_user_agents, filter_safe_user_agents, filter_excluded_paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.csrf.impl.CSRFFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&filter.methods=%s&filter.enable.safe.user.agents=%s&filter.safe.user.agents=%s&filter.excluded.paths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(filter_methods), http_util.encodeURIComponent(filter_enable_safe_user_agents), http_util.encodeURIComponent(filter_safe_user_agents), http_util.encodeURIComponent(filter_excluded_paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_csrf_impl_csrf_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_csrf_impl_csrf_servlet(post, apply, delete, action, location, propertylist, csrf_token_expires_in, sling_auth_requirements)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.csrf.impl.CSRFServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&csrf.token.expires.in=%s&sling.auth.requirements=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(csrf_token_expires_in), http_util.encodeURIComponent(sling_auth_requirements));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_csrf_impl_csrf_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_distribution_core_impl_crypto_distribution_transport_se(post, apply, delete, action, location, propertylist, name, username, encrypted_password)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.distribution.core.impl.CryptoDistributionTransportSecretProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&username=%s&encryptedPassword=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(username), http_util.encodeURIComponent(encrypted_password));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_distribution_core_impl_crypto_distribution_transport_se_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_distribution_core_impl_diff_diff_changes_observer(post, apply, delete, action, location, propertylist, enabled, agent_name, diff_path, observed_path, service_name, property_names, distribution_delay, service_user_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.distribution.core.impl.diff.DiffChangesObserver?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s&agentName=%s&diffPath=%s&observedPath=%s&serviceName=%s&propertyNames=%s&distributionDelay=%s&serviceUser.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(agent_name), http_util.encodeURIComponent(diff_path), http_util.encodeURIComponent(observed_path), http_util.encodeURIComponent(service_name), http_util.encodeURIComponent(property_names), http_util.encodeURIComponent(distribution_delay), http_util.encodeURIComponent(service_user_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_distribution_core_impl_diff_diff_changes_observer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_distribution_core_impl_diff_diff_event_listener(post, apply, delete, action, location, propertylist, diff_path, service_name, service_user_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.distribution.core.impl.diff.DiffEventListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&diffPath=%s&serviceName=%s&serviceUser.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(diff_path), http_util.encodeURIComponent(service_name), http_util.encodeURIComponent(service_user_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_distribution_core_impl_diff_diff_event_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_distribution_core_impl_distribution_to_replication_even(post, apply, delete, action, location, propertylist, importer_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.distribution.core.impl.DistributionToReplicationEventTransformer?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&importer.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(importer_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_distribution_core_impl_distribution_to_replication_even_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_distribution_core_impl_replication_adapters_replicat(post, apply, delete, action, location, propertylist, provider_name, forward_requests)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.distribution.core.impl.replication.adapters.ReplicationAgentProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&providerName=%s&forward.requests=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(provider_name), http_util.encodeURIComponent(forward_requests));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_distribution_core_impl_replication_adapters_replicat_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_distribution_core_impl_replication_distribution_trans(post, apply, delete, action, location, propertylist, forward_requests)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.distribution.core.impl.replication.DistributionTransportHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&forward.requests=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(forward_requests));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_distribution_core_impl_replication_distribution_trans_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_distribution_core_impl_transport_access_token_distribu(post, apply, delete, action, location, propertylist, name, service_name, user_id, access_token_provider_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.distribution.core.impl.transport.AccessTokenDistributionTransportSecretProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&serviceName=%s&userId=%s&accessTokenProvider.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(service_name), http_util.encodeURIComponent(user_id), http_util.encodeURIComponent(access_token_provider_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_distribution_core_impl_transport_access_token_distribu_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_frags_impl_check_http_header_flag(post, apply, delete, action, location, propertylist, feature_name, feature_description, http_header_name, http_header_valuepattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.frags.impl.CheckHttpHeaderFlag?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&feature.name=%s&feature.description=%s&http.header.name=%s&http.header.valuepattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(feature_name), http_util.encodeURIComponent(feature_description), http_util.encodeURIComponent(http_header_name), http_util.encodeURIComponent(http_header_valuepattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_frags_impl_check_http_header_flag_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_frags_impl_random_feature(post, apply, delete, action, location, propertylist, feature_name, feature_description, active_percentage, cookie_name, cookie_max_age)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.frags.impl.RandomFeature?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&feature.name=%s&feature.description=%s&active.percentage=%s&cookie.name=%s&cookie.maxAge=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(feature_name), http_util.encodeURIComponent(feature_description), http_util.encodeURIComponent(active_percentage), http_util.encodeURIComponent(cookie_name), http_util.encodeURIComponent(cookie_max_age));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_frags_impl_random_feature_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_httpcache_file_file_cache_store(post, apply, delete, action, location, propertylist, com_adobe_granite_httpcache_file_document_root, com_adobe_granite_httpcache_file_include_host)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.httpcache.file.FileCacheStore?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.adobe.granite.httpcache.file.documentRoot=%s&com.adobe.granite.httpcache.file.includeHost=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_adobe_granite_httpcache_file_document_root), http_util.encodeURIComponent(com_adobe_granite_httpcache_file_include_host));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_httpcache_file_file_cache_store_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_httpcache_impl_outer_cache_filter(post, apply, delete, action, location, propertylist, com_adobe_granite_httpcache_url_paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.httpcache.impl.OuterCacheFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.adobe.granite.httpcache.url.paths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_adobe_granite_httpcache_url_paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_httpcache_impl_outer_cache_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_i18n_impl_bundle_pseudo_translations(post, apply, delete, action, location, propertylist, pseudo_patterns)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.i18n.impl.bundle.PseudoTranslations?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&pseudo.patterns=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(pseudo_patterns));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_i18n_impl_bundle_pseudo_translations_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_i18n_impl_preferences_locale_resolver_service(post, apply, delete, action, location, propertylist, security_preferences_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.i18n.impl.PreferencesLocaleResolverService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&security.preferences.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(security_preferences_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_i18n_impl_preferences_locale_resolver_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_infocollector_info_collector(post, apply, delete, action, location, propertylist, granite_infocollector_include_thread_dumps, granite_infocollector_include_heap_dump)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.infocollector.InfoCollector?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&granite.infocollector.includeThreadDumps=%s&granite.infocollector.includeHeapDump=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(granite_infocollector_include_thread_dumps), http_util.encodeURIComponent(granite_infocollector_include_heap_dump));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_infocollector_info_collector_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_jetty_ssl_internal_granite_ssl_connector_factory(post, apply, delete, action, location, propertylist, com_adobe_granite_jetty_ssl_port, com_adobe_granite_jetty_ssl_keystore_user, com_adobe_granite_jetty_ssl_keystore_password, com_adobe_granite_jetty_ssl_ciphersuites_excluded, com_adobe_granite_jetty_ssl_ciphersuites_included, com_adobe_granite_jetty_ssl_client_certificate)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.jetty.ssl.internal.GraniteSslConnectorFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.adobe.granite.jetty.ssl.port=%s&com.adobe.granite.jetty.ssl.keystore.user=%s&com.adobe.granite.jetty.ssl.keystore.password=%s&com.adobe.granite.jetty.ssl.ciphersuites.excluded=%s&com.adobe.granite.jetty.ssl.ciphersuites.included=%s&com.adobe.granite.jetty.ssl.client.certificate=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_adobe_granite_jetty_ssl_port), http_util.encodeURIComponent(com_adobe_granite_jetty_ssl_keystore_user), http_util.encodeURIComponent(com_adobe_granite_jetty_ssl_keystore_password), http_util.encodeURIComponent(com_adobe_granite_jetty_ssl_ciphersuites_excluded), http_util.encodeURIComponent(com_adobe_granite_jetty_ssl_ciphersuites_included), http_util.encodeURIComponent(com_adobe_granite_jetty_ssl_client_certificate));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_jetty_ssl_internal_granite_ssl_connector_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_license_impl_license_check_filter(post, apply, delete, action, location, propertylist, check_internval, exclude_ids, encrypt_ping)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.license.impl.LicenseCheckFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&checkInternval=%s&excludeIds=%s&encryptPing=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(check_internval), http_util.encodeURIComponent(exclude_ids), http_util.encodeURIComponent(encrypt_ping));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_license_impl_license_check_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_logging_impl_log_analyser_impl(post, apply, delete, action, location, propertylist, messages_queue_size, logger_config, messages_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.logging.impl.LogAnalyserImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&messages.queue.size=%s&logger.config=%s&messages.size=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(messages_queue_size), http_util.encodeURIComponent(logger_config), http_util.encodeURIComponent(messages_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_logging_impl_log_analyser_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_logging_impl_log_error_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.logging.impl.LogErrorHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_logging_impl_log_error_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_maintenance_crx_impl_data_store_garbage_collection_task(post, apply, delete, action, location, propertylist, granite_maintenance_mandatory, job_topics)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.DataStoreGarbageCollectionTask?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&granite.maintenance.mandatory=%s&job.topics=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(granite_maintenance_mandatory), http_util.encodeURIComponent(job_topics));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_maintenance_crx_impl_data_store_garbage_collection_task_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_maintenance_crx_impl_lucene_binaries_cleanup_task(post, apply, delete, action, location, propertylist, job_topics)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.LuceneBinariesCleanupTask?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&job.topics=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(job_topics));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_maintenance_crx_impl_lucene_binaries_cleanup_task_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_maintenance_crx_impl_revision_cleanup_task(post, apply, delete, action, location, propertylist, full_gc_days)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.RevisionCleanupTask?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&full.gc.days=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(full_gc_days));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_maintenance_crx_impl_revision_cleanup_task_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_monitoring_impl_script_config_impl(post, apply, delete, action, location, propertylist, script_filename, script_display, script_path, script_platform, interval, jmxdomain)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.monitoring.impl.ScriptConfigImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&script.filename=%s&script.display=%s&script.path=%s&script.platform=%s&interval=%s&jmxdomain=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(script_filename), http_util.encodeURIComponent(script_display), http_util.encodeURIComponent(script_path), http_util.encodeURIComponent(script_platform), http_util.encodeURIComponent(interval), http_util.encodeURIComponent(jmxdomain));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_monitoring_impl_script_config_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_oauth_server_auth_impl_o_auth2_server_authentication_han(post, apply, delete, action, location, propertylist, path, jaas_control_flag, jaas_realm_name, jaas_ranking, oauth_offline_validation)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.oauth.server.auth.impl.OAuth2ServerAuthenticationHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path=%s&jaas.controlFlag=%s&jaas.realmName=%s&jaas.ranking=%s&oauth.offline.validation=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path), http_util.encodeURIComponent(jaas_control_flag), http_util.encodeURIComponent(jaas_realm_name), http_util.encodeURIComponent(jaas_ranking), http_util.encodeURIComponent(oauth_offline_validation));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_oauth_server_auth_impl_o_auth2_server_authentication_han_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_oauth_server_impl_access_token_cleanup_task(post, apply, delete, action, location, propertylist, scheduler_expression)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.oauth.server.impl.AccessTokenCleanupTask?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.expression=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_expression));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_oauth_server_impl_access_token_cleanup_task_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_oauth_server_impl_o_auth2_client_revocation_servlet(post, apply, delete, action, location, propertylist, oauth_client_revocation_active)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2ClientRevocationServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.client.revocation.active=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_client_revocation_active));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_oauth_server_impl_o_auth2_client_revocation_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_oauth_server_impl_o_auth2_revocation_endpoint_servlet(post, apply, delete, action, location, propertylist, sling_servlet_paths, oauth_revocation_active)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2RevocationEndpointServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.paths=%s&oauth.revocation.active=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_paths), http_util.encodeURIComponent(oauth_revocation_active));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_oauth_server_impl_o_auth2_revocation_endpoint_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_oauth_server_impl_o_auth2_token_endpoint_servlet(post, apply, delete, action, location, propertylist, oauth_issuer, oauth_access_token_expires_in, osgi_http_whiteboard_servlet_pattern, osgi_http_whiteboard_context_select)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2TokenEndpointServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.issuer=%s&oauth.access.token.expires.in=%s&osgi.http.whiteboard.servlet.pattern=%s&osgi.http.whiteboard.context.select=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_issuer), http_util.encodeURIComponent(oauth_access_token_expires_in), http_util.encodeURIComponent(osgi_http_whiteboard_servlet_pattern), http_util.encodeURIComponent(osgi_http_whiteboard_context_select));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_oauth_server_impl_o_auth2_token_endpoint_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_oauth_server_impl_o_auth2_token_revocation_servlet(post, apply, delete, action, location, propertylist, oauth_token_revocation_active)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2TokenRevocationServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&oauth.token.revocation.active=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(oauth_token_revocation_active));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_oauth_server_impl_o_auth2_token_revocation_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_offloading_impl_offloading_configurator(post, apply, delete, action, location, propertylist, offloading_transporter, offloading_cleanup_payload)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingConfigurator?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&offloading.transporter=%s&offloading.cleanup.payload=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(offloading_transporter), http_util.encodeURIComponent(offloading_cleanup_payload));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_offloading_impl_offloading_configurator_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_offloading_impl_offloading_job_cloner(post, apply, delete, action, location, propertylist, offloading_jobcloner_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingJobCloner?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&offloading.jobcloner.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(offloading_jobcloner_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_offloading_impl_offloading_job_cloner_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_offloading_impl_offloading_job_offloader(post, apply, delete, action, location, propertylist, offloading_offloader_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingJobOffloader?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&offloading.offloader.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(offloading_offloader_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_offloading_impl_offloading_job_offloader_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_offloading_impl_transporter_offloading_agent_manager(post, apply, delete, action, location, propertylist, offloading_agentmanager_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.offloading.impl.transporter.OffloadingAgentManager?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&offloading.agentmanager.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(offloading_agentmanager_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_offloading_impl_transporter_offloading_agent_manager_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_offloading_impl_transporter_offloading_default_transpo(post, apply, delete, action, location, propertylist, default_transport_agent_to_worker_prefix, default_transport_agent_to_master_prefix, default_transport_input_package, default_transport_output_package, default_transport_replication_synchronous, default_transport_contentpackage, offloading_transporter_default_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.offloading.impl.transporter.OffloadingDefaultTransporter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&default.transport.agent-to-worker.prefix=%s&default.transport.agent-to-master.prefix=%s&default.transport.input.package=%s&default.transport.output.package=%s&default.transport.replication.synchronous=%s&default.transport.contentpackage=%s&offloading.transporter.default.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(default_transport_agent_to_worker_prefix), http_util.encodeURIComponent(default_transport_agent_to_master_prefix), http_util.encodeURIComponent(default_transport_input_package), http_util.encodeURIComponent(default_transport_output_package), http_util.encodeURIComponent(default_transport_replication_synchronous), http_util.encodeURIComponent(default_transport_contentpackage), http_util.encodeURIComponent(offloading_transporter_default_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_offloading_impl_transporter_offloading_default_transpo_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_omnisearch_impl_core_omni_search_service_impl(post, apply, delete, action, location, propertylist, omnisearch_suggestion_requiretext_min, omnisearch_suggestion_spellcheck_require)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.omnisearch.impl.core.OmniSearchServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&omnisearch.suggestion.requiretext.min=%s&omnisearch.suggestion.spellcheck.require=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(omnisearch_suggestion_requiretext_min), http_util.encodeURIComponent(omnisearch_suggestion_spellcheck_require));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_omnisearch_impl_core_omni_search_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_optout_impl_opt_out_service_impl(post, apply, delete, action, location, propertylist, optout_cookies, optout_headers, optout_whitelist_cookies)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.optout.impl.OptOutServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&optout.cookies=%s&optout.headers=%s&optout.whitelist.cookies=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(optout_cookies), http_util.encodeURIComponent(optout_headers), http_util.encodeURIComponent(optout_whitelist_cookies));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_optout_impl_opt_out_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_queries_impl_hc_async_index_health_check(post, apply, delete, action, location, propertylist, indexing_critical_threshold, indexing_warn_threshold, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.queries.impl.hc.AsyncIndexHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&indexing.critical.threshold=%s&indexing.warn.threshold=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(indexing_critical_threshold), http_util.encodeURIComponent(indexing_warn_threshold), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_queries_impl_hc_async_index_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_queries_impl_hc_large_index_health_check(post, apply, delete, action, location, propertylist, large_index_critical_threshold, large_index_warn_threshold, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.queries.impl.hc.LargeIndexHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&large.index.critical.threshold=%s&large.index.warn.threshold=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(large_index_critical_threshold), http_util.encodeURIComponent(large_index_warn_threshold), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_queries_impl_hc_large_index_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_queries_impl_hc_queries_status_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueriesStatusHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_queries_impl_hc_queries_status_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_queries_impl_hc_query_health_check_metrics(post, apply, delete, action, location, propertylist, get_period)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueryHealthCheckMetrics?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&getPeriod=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(get_period));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_queries_impl_hc_query_health_check_metrics_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_queries_impl_hc_query_limits_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueryLimitsHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_queries_impl_hc_query_limits_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_replication_hc_impl_replication_queue_health_check(post, apply, delete, action, location, propertylist, number_of_retries_allowed, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.replication.hc.impl.ReplicationQueueHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&number.of.retries.allowed=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(number_of_retries_allowed), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_replication_hc_impl_replication_queue_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_replication_hc_impl_replication_transport_users_health_c(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.replication.hc.impl.ReplicationTransportUsersHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_replication_hc_impl_replication_transport_users_health_c_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_repository_hc_impl_authorizable_node_name_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.repository.hc.impl.AuthorizableNodeNameHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_repository_hc_impl_authorizable_node_name_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_repository_hc_impl_content_sling_sling_content_health_c(post, apply, delete, action, location, propertylist, hc_tags, exclude_search_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.repository.hc.impl.content.sling.SlingContentHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s&exclude.search.path=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(exclude_search_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_repository_hc_impl_content_sling_sling_content_health_c_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_repository_hc_impl_continuous_rgc_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.repository.hc.impl.ContinuousRGCHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_repository_hc_impl_continuous_rgc_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_repository_hc_impl_default_access_user_profile_health_che(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.repository.hc.impl.DefaultAccessUserProfileHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_repository_hc_impl_default_access_user_profile_health_che_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_repository_hc_impl_default_logins_health_check(post, apply, delete, action, location, propertylist, hc_tags, account_logins, console_logins)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.repository.hc.impl.DefaultLoginsHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s&account.logins=%s&console.logins=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(account_logins), http_util.encodeURIComponent(console_logins));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_repository_hc_impl_default_logins_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_repository_hc_impl_disk_space_health_check(post, apply, delete, action, location, propertylist, hc_tags, disk_space_warn_threshold, disk_space_error_threshold)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.repository.hc.impl.DiskSpaceHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s&disk.space.warn.threshold=%s&disk.space.error.threshold=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(disk_space_warn_threshold), http_util.encodeURIComponent(disk_space_error_threshold));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_repository_hc_impl_disk_space_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_repository_hc_impl_observation_queue_length_health_check(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.repository.hc.impl.ObservationQueueLengthHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_repository_hc_impl_observation_queue_length_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_repository_impl_commit_stats_config(post, apply, delete, action, location, propertylist, enabled, interval_seconds, commits_per_interval_threshold, max_location_length, max_details_shown, min_details_percentage, thread_matchers, max_greedy_depth, greedy_stack_matchers, stack_filters, stack_matchers, stack_categorizers, stack_shorteners)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.repository.impl.CommitStatsConfig?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s&intervalSeconds=%s&commitsPerIntervalThreshold=%s&maxLocationLength=%s&maxDetailsShown=%s&minDetailsPercentage=%s&threadMatchers=%s&maxGreedyDepth=%s&greedyStackMatchers=%s&stackFilters=%s&stackMatchers=%s&stackCategorizers=%s&stackShorteners=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(interval_seconds), http_util.encodeURIComponent(commits_per_interval_threshold), http_util.encodeURIComponent(max_location_length), http_util.encodeURIComponent(max_details_shown), http_util.encodeURIComponent(min_details_percentage), http_util.encodeURIComponent(thread_matchers), http_util.encodeURIComponent(max_greedy_depth), http_util.encodeURIComponent(greedy_stack_matchers), http_util.encodeURIComponent(stack_filters), http_util.encodeURIComponent(stack_matchers), http_util.encodeURIComponent(stack_categorizers), http_util.encodeURIComponent(stack_shorteners));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_repository_impl_commit_stats_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_repository_service_user_configuration(post, apply, delete, action, location, propertylist, service_ranking, serviceusers_simple_subject_population, serviceusers_list)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.repository.ServiceUserConfiguration?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&serviceusers.simpleSubjectPopulation=%s&serviceusers.list=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(serviceusers_simple_subject_population), http_util.encodeURIComponent(serviceusers_list));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_repository_service_user_configuration_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_requests_logging_impl_hc_requests_status_health_check_im(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.requests.logging.impl.hc.RequestsStatusHealthCheckImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_requests_logging_impl_hc_requests_status_health_check_im_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_resourcestatus_impl_composite_status_type(post, apply, delete, action, location, propertylist, name, types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.resourcestatus.impl.CompositeStatusType?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&types=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_resourcestatus_impl_composite_status_type_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_resourcestatus_impl_status_resource_provider_impl(post, apply, delete, action, location, propertylist, provider_root)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.resourcestatus.impl.StatusResourceProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&provider.root=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(provider_root));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_resourcestatus_impl_status_resource_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_rest_assets_impl_asset_content_disposition_filter(post, apply, delete, action, location, propertylist, mime_allow_empty, mime_allowed)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.rest.assets.impl.AssetContentDispositionFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&mime.allowEmpty=%s&mime.allowed=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(mime_allow_empty), http_util.encodeURIComponent(mime_allowed));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_rest_assets_impl_asset_content_disposition_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_rest_impl_api_endpoint_resource_provider_factory_impl(post, apply, delete, action, location, propertylist, provider_roots)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.rest.impl.ApiEndpointResourceProviderFactoryImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&provider.roots=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(provider_roots));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_rest_impl_api_endpoint_resource_provider_factory_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_rest_impl_servlet_default_get_servlet(post, apply, delete, action, location, propertylist, default_limit, use_absolute_uri)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.rest.impl.servlet.DefaultGETServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&default.limit=%s&use.absolute.uri=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(default_limit), http_util.encodeURIComponent(use_absolute_uri));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_rest_impl_servlet_default_get_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_security_user_ui_internal_servlets_ssl_configuration_s(post, apply, delete, action, location, propertylist, hc_tags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.security.user.ui.internal.servlets.SSLConfigurationServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.tags=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_tags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_security_user_ui_internal_servlets_ssl_configuration_s_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_security_user_user_properties_service(post, apply, delete, action, location, propertylist, adapter_condition, granite_userproperties_nodetypes, granite_userproperties_resourcetypes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.security.user.UserPropertiesService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&adapter.condition=%s&granite.userproperties.nodetypes=%s&granite.userproperties.resourcetypes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(adapter_condition), http_util.encodeURIComponent(granite_userproperties_nodetypes), http_util.encodeURIComponent(granite_userproperties_resourcetypes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_security_user_user_properties_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_socialgraph_impl_social_graph_factory_impl(post, apply, delete, action, location, propertylist, group2member_relationship_outgoing, group2member_excluded_outgoing, group2member_relationship_incoming, group2member_excluded_incoming)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.socialgraph.impl.SocialGraphFactoryImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&group2member.relationship.outgoing=%s&group2member.excluded.outgoing=%s&group2member.relationship.incoming=%s&group2member.excluded.incoming=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(group2member_relationship_outgoing), http_util.encodeURIComponent(group2member_excluded_outgoing), http_util.encodeURIComponent(group2member_relationship_incoming), http_util.encodeURIComponent(group2member_excluded_incoming));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_socialgraph_impl_social_graph_factory_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_system_monitoring_impl_system_stats_m_bean_impl(post, apply, delete, action, location, propertylist, scheduler_expression, jmx_objectname)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.system.monitoring.impl.SystemStatsMBeanImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.expression=%s&jmx.objectname=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_expression), http_util.encodeURIComponent(jmx_objectname));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_system_monitoring_impl_system_stats_m_bean_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_taskmanagement_impl_jcr_task_adapter_factory(post, apply, delete, action, location, propertylist, adapter_condition)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.taskmanagement.impl.jcr.TaskAdapterFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&adapter.condition=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(adapter_condition));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_taskmanagement_impl_jcr_task_adapter_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_taskmanagement_impl_jcr_task_archive_service(post, apply, delete, action, location, propertylist, archiving_enabled, scheduler_expression, archive_since_days_completed)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.taskmanagement.impl.jcr.TaskArchiveService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&archiving.enabled=%s&scheduler.expression=%s&archive.since.days.completed=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(archiving_enabled), http_util.encodeURIComponent(scheduler_expression), http_util.encodeURIComponent(archive_since_days_completed));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_taskmanagement_impl_jcr_task_archive_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_taskmanagement_impl_purge_task_purge_maintenance_task(post, apply, delete, action, location, propertylist, purge_completed, completed_age, purge_active, active_age, save_threshold)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.taskmanagement.impl.purge.TaskPurgeMaintenanceTask?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&purgeCompleted=%s&completedAge=%s&purgeActive=%s&activeAge=%s&saveThreshold=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(purge_completed), http_util.encodeURIComponent(completed_age), http_util.encodeURIComponent(purge_active), http_util.encodeURIComponent(active_age), http_util.encodeURIComponent(save_threshold));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_taskmanagement_impl_purge_task_purge_maintenance_task_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_taskmanagement_impl_service_task_manager_adapter_factor(post, apply, delete, action, location, propertylist, adapter_condition, taskmanager_admingroups)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.taskmanagement.impl.service.TaskManagerAdapterFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&adapter.condition=%s&taskmanager.admingroups=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(adapter_condition), http_util.encodeURIComponent(taskmanager_admingroups));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_taskmanagement_impl_service_task_manager_adapter_factor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_threaddump_thread_dump_collector(post, apply, delete, action, location, propertylist, scheduler_period, scheduler_run_on, granite_threaddump_enabled, granite_threaddump_dumps_per_file, granite_threaddump_enable_gzip_compression, granite_threaddump_enable_directories_compression, granite_threaddump_enable_j_stack, granite_threaddump_max_backup_days, granite_threaddump_backup_clean_trigger)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.threaddump.ThreadDumpCollector?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.period=%s&scheduler.runOn=%s&granite.threaddump.enabled=%s&granite.threaddump.dumpsPerFile=%s&granite.threaddump.enableGzipCompression=%s&granite.threaddump.enableDirectoriesCompression=%s&granite.threaddump.enableJStack=%s&granite.threaddump.maxBackupDays=%s&granite.threaddump.backupCleanTrigger=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_period), http_util.encodeURIComponent(scheduler_run_on), http_util.encodeURIComponent(granite_threaddump_enabled), http_util.encodeURIComponent(granite_threaddump_dumps_per_file), http_util.encodeURIComponent(granite_threaddump_enable_gzip_compression), http_util.encodeURIComponent(granite_threaddump_enable_directories_compression), http_util.encodeURIComponent(granite_threaddump_enable_j_stack), http_util.encodeURIComponent(granite_threaddump_max_backup_days), http_util.encodeURIComponent(granite_threaddump_backup_clean_trigger));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_threaddump_thread_dump_collector_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_translation_connector_msft_core_impl_microsoft_transl(post, apply, delete, action, location, propertylist, translation_factory, default_connector_label, default_connector_attribution, default_connector_workspace_id, default_connector_subscription_key, language_map_location, category_map_location, retry_attempts, timeout_count)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.translation.connector.msft.core.impl.MicrosoftTranslationServiceFactoryImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&translationFactory=%s&defaultConnectorLabel=%s&defaultConnectorAttribution=%s&defaultConnectorWorkspaceId=%s&defaultConnectorSubscriptionKey=%s&languageMapLocation=%s&categoryMapLocation=%s&retryAttempts=%s&timeoutCount=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(translation_factory), http_util.encodeURIComponent(default_connector_label), http_util.encodeURIComponent(default_connector_attribution), http_util.encodeURIComponent(default_connector_workspace_id), http_util.encodeURIComponent(default_connector_subscription_key), http_util.encodeURIComponent(language_map_location), http_util.encodeURIComponent(category_map_location), http_util.encodeURIComponent(retry_attempts), http_util.encodeURIComponent(timeout_count));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_translation_connector_msft_core_impl_microsoft_transl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_translation_core_impl_translation_manager_impl(post, apply, delete, action, location, propertylist, default_connector_name, default_category)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.translation.core.impl.TranslationManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&defaultConnectorName=%s&defaultCategory=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(default_connector_name), http_util.encodeURIComponent(default_category));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_translation_core_impl_translation_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_ui_clientlibs_impl_html_library_manager_impl(post, apply, delete, action, location, propertylist, htmllibmanager_timing, htmllibmanager_debug_init_js, htmllibmanager_minify, htmllibmanager_debug, htmllibmanager_gzip, htmllibmanager_max_data_uri_size, htmllibmanager_maxage, htmllibmanager_force_cq_url_info, htmllibmanager_defaultthemename, htmllibmanager_defaultuserthemename, htmllibmanager_clientmanager, htmllibmanager_path_list, htmllibmanager_excluded_path_list, htmllibmanager_processor_js, htmllibmanager_processor_css, htmllibmanager_longcache_patterns, htmllibmanager_longcache_format, htmllibmanager_use_file_system_output_cache, htmllibmanager_file_system_output_cache_location, htmllibmanager_disable_replacement)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.ui.clientlibs.impl.HtmlLibraryManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&htmllibmanager.timing=%s&htmllibmanager.debug.init.js=%s&htmllibmanager.minify=%s&htmllibmanager.debug=%s&htmllibmanager.gzip=%s&htmllibmanager.maxDataUriSize=%s&htmllibmanager.maxage=%s&htmllibmanager.forceCQUrlInfo=%s&htmllibmanager.defaultthemename=%s&htmllibmanager.defaultuserthemename=%s&htmllibmanager.clientmanager=%s&htmllibmanager.path.list=%s&htmllibmanager.excluded.path.list=%s&htmllibmanager.processor.js=%s&htmllibmanager.processor.css=%s&htmllibmanager.longcache.patterns=%s&htmllibmanager.longcache.format=%s&htmllibmanager.useFileSystemOutputCache=%s&htmllibmanager.fileSystemOutputCacheLocation=%s&htmllibmanager.disable.replacement=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(htmllibmanager_timing), http_util.encodeURIComponent(htmllibmanager_debug_init_js), http_util.encodeURIComponent(htmllibmanager_minify), http_util.encodeURIComponent(htmllibmanager_debug), http_util.encodeURIComponent(htmllibmanager_gzip), http_util.encodeURIComponent(htmllibmanager_max_data_uri_size), http_util.encodeURIComponent(htmllibmanager_maxage), http_util.encodeURIComponent(htmllibmanager_force_cq_url_info), http_util.encodeURIComponent(htmllibmanager_defaultthemename), http_util.encodeURIComponent(htmllibmanager_defaultuserthemename), http_util.encodeURIComponent(htmllibmanager_clientmanager), http_util.encodeURIComponent(htmllibmanager_path_list), http_util.encodeURIComponent(htmllibmanager_excluded_path_list), http_util.encodeURIComponent(htmllibmanager_processor_js), http_util.encodeURIComponent(htmllibmanager_processor_css), http_util.encodeURIComponent(htmllibmanager_longcache_patterns), http_util.encodeURIComponent(htmllibmanager_longcache_format), http_util.encodeURIComponent(htmllibmanager_use_file_system_output_cache), http_util.encodeURIComponent(htmllibmanager_file_system_output_cache_location), http_util.encodeURIComponent(htmllibmanager_disable_replacement));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_ui_clientlibs_impl_html_library_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_workflow_console_frags_workflow_withdraw_feature(post, apply, delete, action, location, propertylist, enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.workflow.console.frags.WorkflowWithdrawFeature?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_workflow_console_frags_workflow_withdraw_feature_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_workflow_console_publish_workflow_publish_event_service(post, apply, delete, action, location, propertylist, granite_workflow_workflow_publish_event_service_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.workflow.console.publish.WorkflowPublishEventService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&granite.workflow.WorkflowPublishEventService.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(granite_workflow_workflow_publish_event_service_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_workflow_console_publish_workflow_publish_event_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_workflow_core_jcr_workflow_bucket_manager(post, apply, delete, action, location, propertylist, bucket_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.workflow.core.jcr.WorkflowBucketManager?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&bucketSize=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(bucket_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_workflow_core_jcr_workflow_bucket_manager_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_workflow_core_job_external_process_job_handler(post, apply, delete, action, location, propertylist, default_timeout, max_timeout, default_period)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.workflow.core.job.ExternalProcessJobHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&default.timeout=%s&max.timeout=%s&default.period=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(default_timeout), http_util.encodeURIComponent(max_timeout), http_util.encodeURIComponent(default_period));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_workflow_core_job_external_process_job_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_workflow_core_job_job_handler(post, apply, delete, action, location, propertylist, job_topics, allow_self_process_termination)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.workflow.core.job.JobHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&job.topics=%s&allow.self.process.termination=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(job_topics), http_util.encodeURIComponent(allow_self_process_termination));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_workflow_core_job_job_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_workflow_core_offloading_workflow_offloading_job_consum(post, apply, delete, action, location, propertylist, job_topics)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.workflow.core.offloading.WorkflowOffloadingJobConsumer?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&job.topics=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(job_topics));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_workflow_core_offloading_workflow_offloading_job_consum_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_workflow_core_payload_map_cache(post, apply, delete, action, location, propertylist, get_system_workflow_models, get_package_root_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.workflow.core.PayloadMapCache?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&getSystemWorkflowModels=%s&getPackageRootPath=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(get_system_workflow_models), http_util.encodeURIComponent(get_package_root_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_workflow_core_payload_map_cache_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_workflow_core_payloadmap_payload_move_listener(post, apply, delete, action, location, propertylist, payload_move_white_list, payload_move_handle_from_workflow_process)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.workflow.core.payloadmap.PayloadMoveListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&payload.move.white.list=%s&payload.move.handle.from.workflow.process=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(payload_move_white_list), http_util.encodeURIComponent(payload_move_handle_from_workflow_process));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_workflow_core_payloadmap_payload_move_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_workflow_core_workflow_config(post, apply, delete, action, location, propertylist, cq_workflow_config_workflow_packages_root_path, cq_workflow_config_workflow_process_legacy_mode, cq_workflow_config_allow_locking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.workflow.core.WorkflowConfig?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.workflow.config.workflow.packages.root.path=%s&cq.workflow.config.workflow.process.legacy.mode=%s&cq.workflow.config.allow.locking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_workflow_config_workflow_packages_root_path), http_util.encodeURIComponent(cq_workflow_config_workflow_process_legacy_mode), http_util.encodeURIComponent(cq_workflow_config_allow_locking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_workflow_core_workflow_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_workflow_core_workflow_session_factory(post, apply, delete, action, location, propertylist, granite_workflowinbox_sort_property_name, granite_workflowinbox_sort_order, cq_workflow_job_retry, cq_workflow_superuser, granite_workflow_inbox_query_size, granite_workflow_admin_user_group_filter, granite_workflow_enforce_workitem_assignee_permissions, granite_workflow_enforce_workflow_initiator_permissions, granite_workflow_inject_tenant_id_in_job_topics, granite_workflow_max_purge_save_threshold, granite_workflow_max_purge_query_count)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.workflow.core.WorkflowSessionFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&granite.workflowinbox.sort.propertyName=%s&granite.workflowinbox.sort.order=%s&cq.workflow.job.retry=%s&cq.workflow.superuser=%s&granite.workflow.inboxQuerySize=%s&granite.workflow.adminUserGroupFilter=%s&granite.workflow.enforceWorkitemAssigneePermissions=%s&granite.workflow.enforceWorkflowInitiatorPermissions=%s&granite.workflow.injectTenantIdInJobTopics=%s&granite.workflow.maxPurgeSaveThreshold=%s&granite.workflow.maxPurgeQueryCount=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(granite_workflowinbox_sort_property_name), http_util.encodeURIComponent(granite_workflowinbox_sort_order), http_util.encodeURIComponent(cq_workflow_job_retry), http_util.encodeURIComponent(cq_workflow_superuser), http_util.encodeURIComponent(granite_workflow_inbox_query_size), http_util.encodeURIComponent(granite_workflow_admin_user_group_filter), http_util.encodeURIComponent(granite_workflow_enforce_workitem_assignee_permissions), http_util.encodeURIComponent(granite_workflow_enforce_workflow_initiator_permissions), http_util.encodeURIComponent(granite_workflow_inject_tenant_id_in_job_topics), http_util.encodeURIComponent(granite_workflow_max_purge_save_threshold), http_util.encodeURIComponent(granite_workflow_max_purge_query_count));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_workflow_core_workflow_session_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_granite_workflow_purge_scheduler(post, apply, delete, action, location, propertylist, scheduledpurge_name, scheduledpurge_workflow_status, scheduledpurge_model_ids, scheduledpurge_daysold)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.granite.workflow.purge.Scheduler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduledpurge.name=%s&scheduledpurge.workflowStatus=%s&scheduledpurge.modelIds=%s&scheduledpurge.daysold=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduledpurge_name), http_util.encodeURIComponent(scheduledpurge_workflow_status), http_util.encodeURIComponent(scheduledpurge_model_ids), http_util.encodeURIComponent(scheduledpurge_daysold));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_granite_workflow_purge_scheduler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_octopus_ncomm_bootstrap(post, apply, delete, action, location, propertylist, max_connections, max_requests, request_timeout, request_retries, launch_timeout)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.octopus.ncomm.bootstrap?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&maxConnections=%s&maxRequests=%s&requestTimeout=%s&requestRetries=%s&launchTimeout=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_connections), http_util.encodeURIComponent(max_requests), http_util.encodeURIComponent(request_timeout), http_util.encodeURIComponent(request_retries), http_util.encodeURIComponent(launch_timeout));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_octopus_ncomm_bootstrap_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_social_integrations_livefyre_user_pingforpull_impl_ping_pull_s(post, apply, delete, action, location, propertylist, communities_integration_livefyre_sling_event_filter)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.social.integrations.livefyre.user.pingforpull.impl.PingPullServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&communities.integration.livefyre.sling.event.filter=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(communities_integration_livefyre_sling_event_filter));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_social_integrations_livefyre_user_pingforpull_impl_ping_pull_s_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_adobe_xmp_worker_files_ncomm_xmp_files_n_comm(post, apply, delete, action, location, propertylist, max_connections, max_requests, request_timeout, log_dir)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.adobe.xmp.worker.files.ncomm.XMPFilesNComm?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&maxConnections=%s&maxRequests=%s&requestTimeout=%s&logDir=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_connections), http_util.encodeURIComponent(max_requests), http_util.encodeURIComponent(request_timeout), http_util.encodeURIComponent(log_dir));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_adobe_xmp_worker_files_ncomm_xmp_files_n_comm_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_commons_datasource_jdbcpool_jdbc_pool_service(post, apply, delete, action, location, propertylist, jdbc_driver_class, jdbc_connection_uri, jdbc_username, jdbc_password, jdbc_validation_query, default_readonly, default_autocommit, pool_size, pool_max_wait_msec, datasource_name, datasource_svc_properties)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.commons.datasource.jdbcpool.JdbcPoolService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&jdbc.driver.class=%s&jdbc.connection.uri=%s&jdbc.username=%s&jdbc.password=%s&jdbc.validation.query=%s&default.readonly=%s&default.autocommit=%s&pool.size=%s&pool.max.wait.msec=%s&datasource.name=%s&datasource.svc.properties=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(jdbc_driver_class), http_util.encodeURIComponent(jdbc_connection_uri), http_util.encodeURIComponent(jdbc_username), http_util.encodeURIComponent(jdbc_password), http_util.encodeURIComponent(jdbc_validation_query), http_util.encodeURIComponent(default_readonly), http_util.encodeURIComponent(default_autocommit), http_util.encodeURIComponent(pool_size), http_util.encodeURIComponent(pool_max_wait_msec), http_util.encodeURIComponent(datasource_name), http_util.encodeURIComponent(datasource_svc_properties));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_commons_datasource_jdbcpool_jdbc_pool_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_commons_httpclient(post, apply, delete, action, location, propertylist, proxy_enabled, proxy_host, proxy_user, proxy_password, proxy_ntlm_host, proxy_ntlm_domain, proxy_exceptions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.commons.httpclient?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&proxy.enabled=%s&proxy.host=%s&proxy.user=%s&proxy.password=%s&proxy.ntlm.host=%s&proxy.ntlm.domain=%s&proxy.exceptions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(proxy_enabled), http_util.encodeURIComponent(proxy_host), http_util.encodeURIComponent(proxy_user), http_util.encodeURIComponent(proxy_password), http_util.encodeURIComponent(proxy_ntlm_host), http_util.encodeURIComponent(proxy_ntlm_domain), http_util.encodeURIComponent(proxy_exceptions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_commons_httpclient_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_analytics_impl_store_properties_change_listener(post, apply, delete, action, location, propertylist, cq_store_listener_additional_store_paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.analytics.impl.StorePropertiesChangeListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.store.listener.additionalStorePaths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_store_listener_additional_store_paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_analytics_impl_store_properties_change_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_analytics_sitecatalyst_impl_exporter_classifications_exporte(post, apply, delete, action, location, propertylist, allowed_paths, cq_analytics_saint_exporter_pagesize)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.exporter.ClassificationsExporter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&allowed.paths=%s&cq.analytics.saint.exporter.pagesize=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(allowed_paths), http_util.encodeURIComponent(cq_analytics_saint_exporter_pagesize));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_analytics_sitecatalyst_impl_exporter_classifications_exporte_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_analytics_sitecatalyst_impl_importer_report_importer(post, apply, delete, action, location, propertylist, report_fetch_attempts, report_fetch_delay)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.importer.ReportImporter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&report.fetch.attempts=%s&report.fetch.delay=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(report_fetch_attempts), http_util.encodeURIComponent(report_fetch_delay));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_analytics_sitecatalyst_impl_importer_report_importer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_analytics_sitecatalyst_impl_sitecatalyst_adapter_factory(post, apply, delete, action, location, propertylist, cq_analytics_adapterfactory_contextstores)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.SitecatalystAdapterFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.analytics.adapterfactory.contextstores=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_analytics_adapterfactory_contextstores));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_analytics_sitecatalyst_impl_sitecatalyst_adapter_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_analytics_sitecatalyst_impl_sitecatalyst_http_client_impl(post, apply, delete, action, location, propertylist, cq_analytics_sitecatalyst_service_datacenter_url, devhostnamepatterns, connection_timeout, socket_timeout)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.SitecatalystHttpClientImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.analytics.sitecatalyst.service.datacenter.url=%s&devhostnamepatterns=%s&connection.timeout=%s&socket.timeout=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_analytics_sitecatalyst_service_datacenter_url), http_util.encodeURIComponent(devhostnamepatterns), http_util.encodeURIComponent(connection_timeout), http_util.encodeURIComponent(socket_timeout));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_analytics_sitecatalyst_impl_sitecatalyst_http_client_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_analytics_testandtarget_impl_account_options_updater(post, apply, delete, action, location, propertylist, cq_analytics_testandtarget_accountoptionsupdater_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.AccountOptionsUpdater?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.analytics.testandtarget.accountoptionsupdater.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_analytics_testandtarget_accountoptionsupdater_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_analytics_testandtarget_impl_account_options_updater_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_analytics_testandtarget_impl_delete_author_activity_listener(post, apply, delete, action, location, propertylist, cq_analytics_testandtarget_deleteauthoractivitylistener_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.DeleteAuthorActivityListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.analytics.testandtarget.deleteauthoractivitylistener.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_analytics_testandtarget_deleteauthoractivitylistener_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_analytics_testandtarget_impl_delete_author_activity_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_analytics_testandtarget_impl_push_author_campaign_page_listener(post, apply, delete, action, location, propertylist, cq_analytics_testandtarget_pushauthorcampaignpagelistener_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.PushAuthorCampaignPageListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.analytics.testandtarget.pushauthorcampaignpagelistener.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_analytics_testandtarget_pushauthorcampaignpagelistener_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_analytics_testandtarget_impl_push_author_campaign_page_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_analytics_testandtarget_impl_segment_importer(post, apply, delete, action, location, propertylist, cq_analytics_testandtarget_segmentimporter_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.SegmentImporter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.analytics.testandtarget.segmentimporter.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_analytics_testandtarget_segmentimporter_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_analytics_testandtarget_impl_segment_importer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_analytics_testandtarget_impl_service_web_service_impl(post, apply, delete, action, location, propertylist, endpoint_uri, connection_timeout, socket_timeout)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.service.WebServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&endpointUri=%s&connectionTimeout=%s&socketTimeout=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(endpoint_uri), http_util.encodeURIComponent(connection_timeout), http_util.encodeURIComponent(socket_timeout));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_analytics_testandtarget_impl_service_web_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_analytics_testandtarget_impl_servlets_admin_server_servlet(post, apply, delete, action, location, propertylist, testandtarget_endpoint_url)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.servlets.AdminServerServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&testandtarget.endpoint.url=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(testandtarget_endpoint_url));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_analytics_testandtarget_impl_servlets_admin_server_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_analytics_testandtarget_impl_testandtarget_http_client_impl(post, apply, delete, action, location, propertylist, cq_analytics_testandtarget_api_url, cq_analytics_testandtarget_timeout, cq_analytics_testandtarget_sockettimeout, cq_analytics_testandtarget_recommendations_url_replace, cq_analytics_testandtarget_recommendations_url_replacewith)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.TestandtargetHttpClientImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.analytics.testandtarget.api.url=%s&cq.analytics.testandtarget.timeout=%s&cq.analytics.testandtarget.sockettimeout=%s&cq.analytics.testandtarget.recommendations.url.replace=%s&cq.analytics.testandtarget.recommendations.url.replacewith=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_analytics_testandtarget_api_url), http_util.encodeURIComponent(cq_analytics_testandtarget_timeout), http_util.encodeURIComponent(cq_analytics_testandtarget_sockettimeout), http_util.encodeURIComponent(cq_analytics_testandtarget_recommendations_url_replace), http_util.encodeURIComponent(cq_analytics_testandtarget_recommendations_url_replacewith));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_analytics_testandtarget_impl_testandtarget_http_client_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_auth_impl_cug_cug_support_impl(post, apply, delete, action, location, propertylist, cug_exempted_principals, cug_enabled, cug_principals_regex, cug_principals_replacement)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.auth.impl.cug.CugSupportImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cug.exempted.principals=%s&cug.enabled=%s&cug.principals.regex=%s&cug.principals.replacement=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cug_exempted_principals), http_util.encodeURIComponent(cug_enabled), http_util.encodeURIComponent(cug_principals_regex), http_util.encodeURIComponent(cug_principals_replacement));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_auth_impl_cug_cug_support_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_auth_impl_login_selector_handler(post, apply, delete, action, location, propertylist, path, service_ranking, auth_loginselector_mappings, auth_loginselector_changepw_mappings, auth_loginselector_defaultloginpage, auth_loginselector_defaultchangepwpage, auth_loginselector_handle, auth_loginselector_handle_all_extensions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.auth.impl.LoginSelectorHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path=%s&service.ranking=%s&auth.loginselector.mappings=%s&auth.loginselector.changepw.mappings=%s&auth.loginselector.defaultloginpage=%s&auth.loginselector.defaultchangepwpage=%s&auth.loginselector.handle=%s&auth.loginselector.handle.all.extensions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(auth_loginselector_mappings), http_util.encodeURIComponent(auth_loginselector_changepw_mappings), http_util.encodeURIComponent(auth_loginselector_defaultloginpage), http_util.encodeURIComponent(auth_loginselector_defaultchangepwpage), http_util.encodeURIComponent(auth_loginselector_handle), http_util.encodeURIComponent(auth_loginselector_handle_all_extensions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_auth_impl_login_selector_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_commons_impl_externalizer_impl(post, apply, delete, action, location, propertylist, externalizer_domains, externalizer_host, externalizer_contextpath, externalizer_encodedpath)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.commons.impl.ExternalizerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&externalizer.domains=%s&externalizer.host=%s&externalizer.contextpath=%s&externalizer.encodedpath=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(externalizer_domains), http_util.encodeURIComponent(externalizer_host), http_util.encodeURIComponent(externalizer_contextpath), http_util.encodeURIComponent(externalizer_encodedpath));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_commons_impl_externalizer_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_commons_servlets_root_mapping_servlet(post, apply, delete, action, location, propertylist, rootmapping_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.commons.servlets.RootMappingServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&rootmapping.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(rootmapping_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_commons_servlets_root_mapping_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_compat_codeupgrade_impl_code_upgrade_execution_condition_checke(post, apply, delete, action, location, propertylist, codeupgradetasks, codeupgradetaskfilters)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.CodeUpgradeExecutionConditionChecker?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&codeupgradetasks=%s&codeupgradetaskfilters=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(codeupgradetasks), http_util.encodeURIComponent(codeupgradetaskfilters));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_compat_codeupgrade_impl_code_upgrade_execution_condition_checke_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_compat_codeupgrade_impl_upgrade_task_ignore_list(post, apply, delete, action, location, propertylist, upgrade_task_ignore_list)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.UpgradeTaskIgnoreList?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&upgradeTaskIgnoreList=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(upgrade_task_ignore_list));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_compat_codeupgrade_impl_upgrade_task_ignore_list_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_compat_codeupgrade_impl_version_range_task_ignorelist(post, apply, delete, action, location, propertylist, effective_bundle_list_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.VersionRangeTaskIgnorelist?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&effectiveBundleListPath=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(effective_bundle_list_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_compat_codeupgrade_impl_version_range_task_ignorelist_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_contentsync_impl_content_sync_manager_impl(post, apply, delete, action, location, propertylist, contentsync_fallback_authorizable, contentsync_fallback_updateuser)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.contentsync.impl.ContentSyncManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&contentsync.fallback.authorizable=%s&contentsync.fallback.updateuser=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(contentsync_fallback_authorizable), http_util.encodeURIComponent(contentsync_fallback_updateuser));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_contentsync_impl_content_sync_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_commons_handler_standard_image_handler(post, apply, delete, action, location, propertylist, large_file_threshold, large_comment_threshold, cq_dam_enable_ext_meta_extraction)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.commons.handler.StandardImageHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&large_file_threshold=%s&large_comment_threshold=%s&cq.dam.enable.ext.meta.extraction=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(large_file_threshold), http_util.encodeURIComponent(large_comment_threshold), http_util.encodeURIComponent(cq_dam_enable_ext_meta_extraction));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_commons_handler_standard_image_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_commons_metadata_xmp_filter_black_white(post, apply, delete, action, location, propertylist, xmp_filter_apply_whitelist, xmp_filter_whitelist, xmp_filter_apply_blacklist, xmp_filter_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.commons.metadata.XmpFilterBlackWhite?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&xmp.filter.apply_whitelist=%s&xmp.filter.whitelist=%s&xmp.filter.apply_blacklist=%s&xmp.filter.blacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(xmp_filter_apply_whitelist), http_util.encodeURIComponent(xmp_filter_whitelist), http_util.encodeURIComponent(xmp_filter_apply_blacklist), http_util.encodeURIComponent(xmp_filter_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_commons_metadata_xmp_filter_black_white_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_commons_util_impl_asset_cache_impl(post, apply, delete, action, location, propertylist, large_file_min, cache_apply, mime_types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.commons.util.impl.AssetCacheImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&large.file.min=%s&cache.apply=%s&mime.types=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(large_file_min), http_util.encodeURIComponent(cache_apply), http_util.encodeURIComponent(mime_types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_commons_util_impl_asset_cache_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_annotation_pdf_annotation_pdf_config(post, apply, delete, action, location, propertylist, cq_dam_config_annotation_pdf_document_width, cq_dam_config_annotation_pdf_document_height, cq_dam_config_annotation_pdf_document_padding_horizontal, cq_dam_config_annotation_pdf_document_padding_vertical, cq_dam_config_annotation_pdf_font_size, cq_dam_config_annotation_pdf_font_color, cq_dam_config_annotation_pdf_font_family, cq_dam_config_annotation_pdf_font_light, cq_dam_config_annotation_pdf_margin_text_image, cq_dam_config_annotation_pdf_min_image_height, cq_dam_config_annotation_pdf_review_status_width, cq_dam_config_annotation_pdf_review_status_color_approved, cq_dam_config_annotation_pdf_review_status_color_rejected, cq_dam_config_annotation_pdf_review_status_color_changes_requested, cq_dam_config_annotation_pdf_annotation_marker_width, cq_dam_config_annotation_pdf_asset_minheight)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.annotation.pdf.AnnotationPdfConfig?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.config.annotation.pdf.document.width=%s&cq.dam.config.annotation.pdf.document.height=%s&cq.dam.config.annotation.pdf.document.padding.horizontal=%s&cq.dam.config.annotation.pdf.document.padding.vertical=%s&cq.dam.config.annotation.pdf.font.size=%s&cq.dam.config.annotation.pdf.font.color=%s&cq.dam.config.annotation.pdf.font.family=%s&cq.dam.config.annotation.pdf.font.light=%s&cq.dam.config.annotation.pdf.marginTextImage=%s&cq.dam.config.annotation.pdf.minImageHeight=%s&cq.dam.config.annotation.pdf.reviewStatus.width=%s&cq.dam.config.annotation.pdf.reviewStatus.color.approved=%s&cq.dam.config.annotation.pdf.reviewStatus.color.rejected=%s&cq.dam.config.annotation.pdf.reviewStatus.color.changesRequested=%s&cq.dam.config.annotation.pdf.annotationMarker.width=%s&cq.dam.config.annotation.pdf.asset.minheight=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_document_width), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_document_height), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_document_padding_horizontal), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_document_padding_vertical), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_font_size), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_font_color), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_font_family), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_font_light), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_margin_text_image), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_min_image_height), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_review_status_width), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_review_status_color_approved), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_review_status_color_rejected), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_review_status_color_changes_requested), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_annotation_marker_width), http_util.encodeURIComponent(cq_dam_config_annotation_pdf_asset_minheight));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_annotation_pdf_annotation_pdf_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_asset_move_listener(post, apply, delete, action, location, propertylist, enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.AssetMoveListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_asset_move_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_assethome_asset_home_page_configuration(post, apply, delete, action, location, propertylist, is_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.assethome.AssetHomePageConfiguration?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&isEnabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(is_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_assethome_asset_home_page_configuration_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_assetlinkshare_adhoc_asset_share_proxy_servlet(post, apply, delete, action, location, propertylist, cq_dam_adhoc_asset_share_prezip_maxcontentsize)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.assetlinkshare.AdhocAssetShareProxyServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.adhoc.asset.share.prezip.maxcontentsize=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_adhoc_asset_share_prezip_maxcontentsize));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_assetlinkshare_adhoc_asset_share_proxy_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_cache_cq_buffered_image_cache(post, apply, delete, action, location, propertylist, cq_dam_image_cache_max_memory, cq_dam_image_cache_max_age, cq_dam_image_cache_max_dimension)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.cache.CQBufferedImageCache?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.image.cache.max.memory=%s&cq.dam.image.cache.max.age=%s&cq.dam.image.cache.max.dimension=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_image_cache_max_memory), http_util.encodeURIComponent(cq_dam_image_cache_max_age), http_util.encodeURIComponent(cq_dam_image_cache_max_dimension));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_cache_cq_buffered_image_cache_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_dam_change_event_listener(post, apply, delete, action, location, propertylist, changeeventlistener_observed_paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.DamChangeEventListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&changeeventlistener.observed.paths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(changeeventlistener_observed_paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_dam_change_event_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_dam_event_purge_service(post, apply, delete, action, location, propertylist, scheduler_expression, max_saved_activities, save_interval, enable_activity_purge, event_types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.DamEventPurgeService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.expression=%s&maxSavedActivities=%s&saveInterval=%s&enableActivityPurge=%s&eventTypes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_expression), http_util.encodeURIComponent(max_saved_activities), http_util.encodeURIComponent(save_interval), http_util.encodeURIComponent(enable_activity_purge), http_util.encodeURIComponent(event_types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_dam_event_purge_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_dam_event_recorder_impl(post, apply, delete, action, location, propertylist, event_filter, event_queue_length, eventrecorder_enabled, eventrecorder_blacklist, eventrecorder_eventtypes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.DamEventRecorderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.filter=%s&event.queue.length=%s&eventrecorder.enabled=%s&eventrecorder.blacklist=%s&eventrecorder.eventtypes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_filter), http_util.encodeURIComponent(event_queue_length), http_util.encodeURIComponent(eventrecorder_enabled), http_util.encodeURIComponent(eventrecorder_blacklist), http_util.encodeURIComponent(eventrecorder_eventtypes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_dam_event_recorder_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_event_dam_event_audit_listener(post, apply, delete, action, location, propertylist, event_filter, enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.event.DamEventAuditListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.filter=%s&enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_filter), http_util.encodeURIComponent(enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_event_dam_event_audit_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_expiry_notification_job_impl(post, apply, delete, action, location, propertylist, cq_dam_expiry_notification_scheduler_istimebased, cq_dam_expiry_notification_scheduler_timebased_rule, cq_dam_expiry_notification_scheduler_period_rule, send_email, asset_expired_limit, prior_notification_seconds, cq_dam_expiry_notification_url_protocol)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.ExpiryNotificationJobImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.expiry.notification.scheduler.istimebased=%s&cq.dam.expiry.notification.scheduler.timebased.rule=%s&cq.dam.expiry.notification.scheduler.period.rule=%s&send_email=%s&asset_expired_limit=%s&prior_notification_seconds=%s&cq.dam.expiry.notification.url.protocol=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_expiry_notification_scheduler_istimebased), http_util.encodeURIComponent(cq_dam_expiry_notification_scheduler_timebased_rule), http_util.encodeURIComponent(cq_dam_expiry_notification_scheduler_period_rule), http_util.encodeURIComponent(send_email), http_util.encodeURIComponent(asset_expired_limit), http_util.encodeURIComponent(prior_notification_seconds), http_util.encodeURIComponent(cq_dam_expiry_notification_url_protocol));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_expiry_notification_job_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_foldermetadataschema_folder_metadata_schema_feat(post, apply, delete, action, location, propertylist, is_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.foldermetadataschema.FolderMetadataSchemaFeatureFlag?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&isEnabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(is_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_foldermetadataschema_folder_metadata_schema_feat_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_gfx_commons_gfx_renderer(post, apply, delete, action, location, propertylist, skip_bufferedcache)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.gfx.CommonsGfxRenderer?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&skip.bufferedcache=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(skip_bufferedcache));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_gfx_commons_gfx_renderer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_handler_eps_format_handler(post, apply, delete, action, location, propertylist, mimetype)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.handler.EPSFormatHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&mimetype=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(mimetype));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_handler_eps_format_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_handler_indesign_format_handler(post, apply, delete, action, location, propertylist, mimetype)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.handler.IndesignFormatHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&mimetype=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(mimetype));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_handler_indesign_format_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_handler_jpeg_handler(post, apply, delete, action, location, propertylist, cq_dam_enable_ext_meta_extraction, large_file_threshold, large_comment_threshold)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.handler.JpegHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.enable.ext.meta.extraction=%s&large_file_threshold=%s&large_comment_threshold=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_enable_ext_meta_extraction), http_util.encodeURIComponent(large_file_threshold), http_util.encodeURIComponent(large_comment_threshold));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_handler_jpeg_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_handler_xmp_n_comm_xmp_handler(post, apply, delete, action, location, propertylist, xmphandler_cq_formats)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.handler.xmp.NCommXMPHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&xmphandler.cq.formats=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(xmphandler_cq_formats));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_handler_xmp_n_comm_xmp_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_jmx_asset_index_update_monitor(post, apply, delete, action, location, propertylist, jmx_objectname, property_measure_enabled, property_name, property_max_wait_ms, property_max_rate, fulltext_measure_enabled, fulltext_name, fulltext_max_wait_ms, fulltext_max_rate)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetIndexUpdateMonitor?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&jmx.objectname=%s&property.measure.enabled=%s&property.name=%s&property.max.wait.ms=%s&property.max.rate=%s&fulltext.measure.enabled=%s&fulltext.name=%s&fulltext.max.wait.ms=%s&fulltext.max.rate=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(jmx_objectname), http_util.encodeURIComponent(property_measure_enabled), http_util.encodeURIComponent(property_name), http_util.encodeURIComponent(property_max_wait_ms), http_util.encodeURIComponent(property_max_rate), http_util.encodeURIComponent(fulltext_measure_enabled), http_util.encodeURIComponent(fulltext_name), http_util.encodeURIComponent(fulltext_max_wait_ms), http_util.encodeURIComponent(fulltext_max_rate));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_jmx_asset_index_update_monitor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_jmx_asset_migration_m_bean_impl(post, apply, delete, action, location, propertylist, jmx_objectname)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetMigrationMBeanImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&jmx.objectname=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(jmx_objectname));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_jmx_asset_migration_m_bean_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_jmx_asset_update_monitor_impl(post, apply, delete, action, location, propertylist, jmx_objectname, active)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetUpdateMonitorImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&jmx.objectname=%s&active=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(jmx_objectname), http_util.encodeURIComponent(active));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_jmx_asset_update_monitor_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_jobs_metadataexport_async_metadata_export_config(post, apply, delete, action, location, propertylist, operation, email_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.jobs.metadataexport.AsyncMetadataExportConfigProviderService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&operation=%s&emailEnabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(operation), http_util.encodeURIComponent(email_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_jobs_metadataexport_async_metadata_export_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_jobs_metadataimport_async_metadata_import_config(post, apply, delete, action, location, propertylist, operation, operation_icon, topic_name, email_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.jobs.metadataimport.AsyncMetadataImportConfigProviderService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&operation=%s&operationIcon=%s&topicName=%s&emailEnabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(operation), http_util.encodeURIComponent(operation_icon), http_util.encodeURIComponent(topic_name), http_util.encodeURIComponent(email_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_jobs_metadataimport_async_metadata_import_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_lightbox_lightbox_servlet(post, apply, delete, action, location, propertylist, sling_servlet_paths, sling_servlet_methods, cq_dam_enable_anonymous)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.lightbox.LightboxServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.paths=%s&sling.servlet.methods=%s&cq.dam.enable.anonymous=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_paths), http_util.encodeURIComponent(sling_servlet_methods), http_util.encodeURIComponent(cq_dam_enable_anonymous));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_lightbox_lightbox_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_metadata_editor_select_component_handler(post, apply, delete, action, location, propertylist, granitedata)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.metadata.editor.SelectComponentHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&granite:data=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(granitedata));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_metadata_editor_select_component_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_mime_type_asset_upload_restriction_helper(post, apply, delete, action, location, propertylist, cq_dam_allow_all_mime, cq_dam_allowed_asset_mimes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.mimeType.AssetUploadRestrictionHelper?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.allow.all.mime=%s&cq.dam.allowed.asset.mimes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_allow_all_mime), http_util.encodeURIComponent(cq_dam_allowed_asset_mimes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_mime_type_asset_upload_restriction_helper_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_mime_type_dam_mime_type_service_impl(post, apply, delete, action, location, propertylist, cq_dam_detect_asset_mime_from_content)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.mimeType.DamMimeTypeServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.detect.asset.mime.from.content=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_detect_asset_mime_from_content));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_mime_type_dam_mime_type_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_missing_metadata_notification_job(post, apply, delete, action, location, propertylist, cq_dam_missingmetadata_notification_scheduler_istimebased, cq_dam_missingmetadata_notification_scheduler_timebased_rule, cq_dam_missingmetadata_notification_scheduler_period_rule, cq_dam_missingmetadata_notification_recipient)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.MissingMetadataNotificationJob?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.missingmetadata.notification.scheduler.istimebased=%s&cq.dam.missingmetadata.notification.scheduler.timebased.rule=%s&cq.dam.missingmetadata.notification.scheduler.period.rule=%s&cq.dam.missingmetadata.notification.recipient=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_missingmetadata_notification_scheduler_istimebased), http_util.encodeURIComponent(cq_dam_missingmetadata_notification_scheduler_timebased_rule), http_util.encodeURIComponent(cq_dam_missingmetadata_notification_scheduler_period_rule), http_util.encodeURIComponent(cq_dam_missingmetadata_notification_recipient));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_missing_metadata_notification_job_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_process_send_transient_workflow_completed_email_pr(post, apply, delete, action, location, propertylist, process_label, notify_on_complete)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.process.SendTransientWorkflowCompletedEmailProcess?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&process.label=%s&Notify on Complete=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(process_label), http_util.encodeURIComponent(notify_on_complete));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_process_send_transient_workflow_completed_email_pr_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_process_text_extraction_process(post, apply, delete, action, location, propertylist, mime_types, max_extract)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.process.TextExtractionProcess?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&mimeTypes=%s&maxExtract=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(mime_types), http_util.encodeURIComponent(max_extract));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_process_text_extraction_process_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_rendition_maker_impl(post, apply, delete, action, location, propertylist, xmp_propagate, xmp_excludes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.RenditionMakerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&xmp.propagate=%s&xmp.excludes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(xmp_propagate), http_util.encodeURIComponent(xmp_excludes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_rendition_maker_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_reports_report_export_service(post, apply, delete, action, location, propertylist, query_batch_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.reports.ReportExportService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&queryBatchSize=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(query_batch_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_reports_report_export_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_reports_report_purge_service(post, apply, delete, action, location, propertylist, scheduler_expression, max_saved_reports, time_duration, enable_report_purge)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.reports.ReportPurgeService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.expression=%s&maxSavedReports=%s&timeDuration=%s&enableReportPurge=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_expression), http_util.encodeURIComponent(max_saved_reports), http_util.encodeURIComponent(time_duration), http_util.encodeURIComponent(enable_report_purge));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_reports_report_purge_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_asset_download_servlet(post, apply, delete, action, location, propertylist, enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetDownloadServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_asset_download_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_asset_status_servlet(post, apply, delete, action, location, propertylist, cq_dam_batch_status_maxassets)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetStatusServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.batch.status.maxassets=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_batch_status_maxassets));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_asset_status_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_asset_xmp_search_servlet(post, apply, delete, action, location, propertylist, cq_dam_batch_indesign_maxassets)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetXMPSearchServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.batch.indesign.maxassets=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_batch_indesign_maxassets));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_asset_xmp_search_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_batch_metadata_servlet(post, apply, delete, action, location, propertylist, cq_dam_batch_metadata_asset_default, cq_dam_batch_metadata_collection_default, cq_dam_batch_metadata_maxresources)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.BatchMetadataServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.batch.metadata.asset.default=%s&cq.dam.batch.metadata.collection.default=%s&cq.dam.batch.metadata.maxresources=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_batch_metadata_asset_default), http_util.encodeURIComponent(cq_dam_batch_metadata_collection_default), http_util.encodeURIComponent(cq_dam_batch_metadata_maxresources));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_batch_metadata_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_binary_provider_servlet(post, apply, delete, action, location, propertylist, sling_servlet_resource_types, sling_servlet_methods, cq_dam_drm_enable)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.BinaryProviderServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.resourceTypes=%s&sling.servlet.methods=%s&cq.dam.drm.enable=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_resource_types), http_util.encodeURIComponent(sling_servlet_methods), http_util.encodeURIComponent(cq_dam_drm_enable));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_binary_provider_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_collection_servlet(post, apply, delete, action, location, propertylist, cq_dam_batch_collection_properties, cq_dam_batch_collection_maxcollections)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CollectionServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.batch.collection.properties=%s&cq.dam.batch.collection.maxcollections=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_batch_collection_properties), http_util.encodeURIComponent(cq_dam_batch_collection_maxcollections));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_collection_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_collections_servlet(post, apply, delete, action, location, propertylist, cq_dam_batch_collections_properties, cq_dam_batch_collections_limit)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CollectionsServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.batch.collections.properties=%s&cq.dam.batch.collections.limit=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_batch_collections_properties), http_util.encodeURIComponent(cq_dam_batch_collections_limit));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_collections_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_companion_servlet(post, apply, delete, action, location, propertylist, more_info, mntoverlaydamguicontentassetsmoreinfo_htmlpath)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CompanionServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&More Info=%s&/mnt/overlay/dam/gui/content/assets/moreinfo.html/${path}=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(more_info), http_util.encodeURIComponent(mntoverlaydamguicontentassetsmoreinfo_htmlpath));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_companion_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_create_asset_servlet(post, apply, delete, action, location, propertylist, detect_duplicate)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CreateAssetServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&detect_duplicate=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(detect_duplicate));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_create_asset_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_dam_content_disposition_filter(post, apply, delete, action, location, propertylist, cq_mime_type_blacklist, cq_dam_empty_mime)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.DamContentDispositionFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.mime.type.blacklist=%s&cq.dam.empty.mime=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_mime_type_blacklist), http_util.encodeURIComponent(cq_dam_empty_mime));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_dam_content_disposition_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_guid_lookup_filter(post, apply, delete, action, location, propertylist, cq_dam_core_guidlookupfilter_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.GuidLookupFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.core.guidlookupfilter.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_core_guidlookupfilter_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_guid_lookup_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_health_check_servlet(post, apply, delete, action, location, propertylist, cq_dam_sync_workflow_id, cq_dam_sync_folder_types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.HealthCheckServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.sync.workflow.id=%s&cq.dam.sync.folder.types=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_sync_workflow_id), http_util.encodeURIComponent(cq_dam_sync_folder_types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_health_check_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_metadata_get_servlet(post, apply, delete, action, location, propertylist, sling_servlet_resource_types, sling_servlet_methods, sling_servlet_extensions, sling_servlet_selectors)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.MetadataGetServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.resourceTypes=%s&sling.servlet.methods=%s&sling.servlet.extensions=%s&sling.servlet.selectors=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_resource_types), http_util.encodeURIComponent(sling_servlet_methods), http_util.encodeURIComponent(sling_servlet_extensions), http_util.encodeURIComponent(sling_servlet_selectors));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_metadata_get_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_multiple_license_accept_servlet(post, apply, delete, action, location, propertylist, cq_dam_drm_enable)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.MultipleLicenseAcceptServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.drm.enable=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_drm_enable));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_multiple_license_accept_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_servlet_resource_collection_servlet(post, apply, delete, action, location, propertylist, sling_servlet_resource_types, sling_servlet_methods, sling_servlet_selectors, download_config, view_selector, send_email)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.servlet.ResourceCollectionServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.resourceTypes=%s&sling.servlet.methods=%s&sling.servlet.selectors=%s&download.config=%s&view.selector=%s&send_email=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_resource_types), http_util.encodeURIComponent(sling_servlet_methods), http_util.encodeURIComponent(sling_servlet_selectors), http_util.encodeURIComponent(download_config), http_util.encodeURIComponent(view_selector), http_util.encodeURIComponent(send_email));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_servlet_resource_collection_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_ui_preview_folder_preview_updater_impl(post, apply, delete, action, location, propertylist, create_preview_enabled, update_preview_enabled, queue_size, folder_preview_rendition_regex)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.ui.preview.FolderPreviewUpdaterImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&createPreviewEnabled=%s&updatePreviewEnabled=%s&queueSize=%s&folderPreviewRenditionRegex=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(create_preview_enabled), http_util.encodeURIComponent(update_preview_enabled), http_util.encodeURIComponent(queue_size), http_util.encodeURIComponent(folder_preview_rendition_regex));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_ui_preview_folder_preview_updater_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_impl_unzip_unzip_config(post, apply, delete, action, location, propertylist, cq_dam_config_unzip_maxuncompressedsize, cq_dam_config_unzip_encoding)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.impl.unzip.UnzipConfig?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.config.unzip.maxuncompressedsize=%s&cq.dam.config.unzip.encoding=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_config_unzip_maxuncompressedsize), http_util.encodeURIComponent(cq_dam_config_unzip_encoding));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_impl_unzip_unzip_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_process_exif_tool_extract_metadata_process(post, apply, delete, action, location, propertylist, process_label, cq_dam_enable_sha1)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.process.ExifToolExtractMetadataProcess?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&process.label=%s&cq.dam.enable.sha1=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(process_label), http_util.encodeURIComponent(cq_dam_enable_sha1));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_process_exif_tool_extract_metadata_process_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_process_extract_metadata_process(post, apply, delete, action, location, propertylist, process_label, cq_dam_enable_sha1)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.process.ExtractMetadataProcess?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&process.label=%s&cq.dam.enable.sha1=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(process_label), http_util.encodeURIComponent(cq_dam_enable_sha1));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_process_extract_metadata_process_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_core_process_metadata_processor_process(post, apply, delete, action, location, propertylist, process_label, cq_dam_enable_sha1, cq_dam_metadata_xssprotected_properties)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.core.process.MetadataProcessorProcess?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&process.label=%s&cq.dam.enable.sha1=%s&cq.dam.metadata.xssprotected.properties=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(process_label), http_util.encodeURIComponent(cq_dam_enable_sha1), http_util.encodeURIComponent(cq_dam_metadata_xssprotected_properties));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_core_process_metadata_processor_process_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_handler_ffmpeg_locator_impl(post, apply, delete, action, location, propertylist, executable_searchpath)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.handler.ffmpeg.LocatorImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&executable.searchpath=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(executable_searchpath));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_handler_ffmpeg_locator_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_handler_gibson_fontmanager_impl_font_manager_service_impl(post, apply, delete, action, location, propertylist, event_filter, fontmgr_system_font_dir, fontmgr_adobe_font_dir, fontmgr_customer_font_dir)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.handler.gibson.fontmanager.impl.FontManagerServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.filter=%s&fontmgr.system.font.dir=%s&fontmgr.adobe.font.dir=%s&fontmgr.customer.font.dir=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_filter), http_util.encodeURIComponent(fontmgr_system_font_dir), http_util.encodeURIComponent(fontmgr_adobe_font_dir), http_util.encodeURIComponent(fontmgr_customer_font_dir));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_handler_gibson_fontmanager_impl_font_manager_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_handler_standard_pdf_pdf_handler(post, apply, delete, action, location, propertylist, raster_annotation)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.handler.standard.pdf.PdfHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&raster.annotation=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(raster_annotation));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_handler_standard_pdf_pdf_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_handler_standard_ps_post_script_handler(post, apply, delete, action, location, propertylist, raster_annotation)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.handler.standard.ps.PostScriptHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&raster.annotation=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(raster_annotation));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_handler_standard_ps_post_script_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_handler_standard_psd_psd_handler(post, apply, delete, action, location, propertylist, large_file_threshold)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.handler.standard.psd.PsdHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&large_file_threshold=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(large_file_threshold));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_handler_standard_psd_psd_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_ids_impl_ids_job_processor(post, apply, delete, action, location, propertylist, enable_multisession, ids_cc_enable, enable_retry, enable_retry_scripterror, externalizer_domain_cqhost, externalizer_domain_http)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.ids.impl.IDSJobProcessor?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enable.multisession=%s&ids.cc.enable=%s&enable.retry=%s&enable.retry.scripterror=%s&externalizer.domain.cqhost=%s&externalizer.domain.http=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enable_multisession), http_util.encodeURIComponent(ids_cc_enable), http_util.encodeURIComponent(enable_retry), http_util.encodeURIComponent(enable_retry_scripterror), http_util.encodeURIComponent(externalizer_domain_cqhost), http_util.encodeURIComponent(externalizer_domain_http));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_ids_impl_ids_job_processor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_ids_impl_ids_pool_manager_impl(post, apply, delete, action, location, propertylist, max_errors_to_blacklist, retry_interval_to_whitelist, connect_timeout, socket_timeout, process_label, connection_use_max)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.ids.impl.IDSPoolManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&max.errors.to.blacklist=%s&retry.interval.to.whitelist=%s&connect.timeout=%s&socket.timeout=%s&process.label=%s&connection.use.max=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_errors_to_blacklist), http_util.encodeURIComponent(retry_interval_to_whitelist), http_util.encodeURIComponent(connect_timeout), http_util.encodeURIComponent(socket_timeout), http_util.encodeURIComponent(process_label), http_util.encodeURIComponent(connection_use_max));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_ids_impl_ids_pool_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_indd_impl_handler_indesign_xmp_handler(post, apply, delete, action, location, propertylist, process_label, extract_pages)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.indd.impl.handler.IndesignXMPHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&process.label=%s&extract.pages=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(process_label), http_util.encodeURIComponent(extract_pages));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_indd_impl_handler_indesign_xmp_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_indd_impl_servlet_snippet_creation_servlet(post, apply, delete, action, location, propertylist, snippetcreation_maxcollections)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.indd.impl.servlet.SnippetCreationServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&snippetcreation.maxcollections=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(snippetcreation_maxcollections));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_indd_impl_servlet_snippet_creation_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_indd_process_indd_media_extract_process(post, apply, delete, action, location, propertylist, process_label, cq_dam_indd_pages_regex, ids_job_decoupled, ids_job_workflow_model)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.indd.process.INDDMediaExtractProcess?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&process.label=%s&cq.dam.indd.pages.regex=%s&ids.job.decoupled=%s&ids.job.workflow.model=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(process_label), http_util.encodeURIComponent(cq_dam_indd_pages_regex), http_util.encodeURIComponent(ids_job_decoupled), http_util.encodeURIComponent(ids_job_workflow_model));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_indd_process_indd_media_extract_process_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_performance_internal_asset_performance_data_handler_impl(post, apply, delete, action, location, propertylist, batch_commit_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.performance.internal.AssetPerformanceDataHandlerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&batch.commit.size=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(batch_commit_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_performance_internal_asset_performance_data_handler_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_performance_internal_asset_performance_report_sync_job(post, apply, delete, action, location, propertylist, scheduler_expression)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.performance.internal.AssetPerformanceReportSyncJob?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.expression=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_expression));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_performance_internal_asset_performance_report_sync_job_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_pim_impl_sourcing_upload_process_product_assets_upload_pro(post, apply, delete, action, location, propertylist, delete_zip_file)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.pim.impl.sourcing.upload.process.ProductAssetsUploadProcess?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&delete.zip.file=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(delete_zip_file));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_pim_impl_sourcing_upload_process_product_assets_upload_pro_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_s7dam_common_analytics_impl_s7dam_dynamic_media_config_even(post, apply, delete, action, location, propertylist, cq_dam_s7dam_dynamicmediaconfigeventlistener_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.s7dam.common.analytics.impl.S7damDynamicMediaConfigEventListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.s7dam.dynamicmediaconfigeventlistener.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_s7dam_dynamicmediaconfigeventlistener_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_s7dam_common_analytics_impl_s7dam_dynamic_media_config_even_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_s7dam_common_analytics_impl_site_catalyst_report_runner(post, apply, delete, action, location, propertylist, scheduler_expression, scheduler_concurrent)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.s7dam.common.analytics.impl.SiteCatalystReportRunner?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.expression=%s&scheduler.concurrent=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_expression), http_util.encodeURIComponent(scheduler_concurrent));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_s7dam_common_analytics_impl_site_catalyst_report_runner_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_s7dam_common_post_servlets_set_create_handler(post, apply, delete, action, location, propertylist, sling_post_operation, sling_servlet_methods)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.s7dam.common.post.servlets.SetCreateHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.post.operation=%s&sling.servlet.methods=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_post_operation), http_util.encodeURIComponent(sling_servlet_methods));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_s7dam_common_post_servlets_set_create_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_s7dam_common_post_servlets_set_modify_handler(post, apply, delete, action, location, propertylist, sling_post_operation, sling_servlet_methods)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.s7dam.common.post.servlets.SetModifyHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.post.operation=%s&sling.servlet.methods=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_post_operation), http_util.encodeURIComponent(sling_servlet_methods));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_s7dam_common_post_servlets_set_modify_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_s7dam_common_process_video_thumbnail_download_process(post, apply, delete, action, location, propertylist, process_label)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.s7dam.common.process.VideoThumbnailDownloadProcess?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&process.label=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(process_label));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_s7dam_common_process_video_thumbnail_download_process_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_s7dam_common_s7dam_dam_change_event_listener(post, apply, delete, action, location, propertylist, cq_dam_s7dam_damchangeeventlistener_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.s7dam.common.S7damDamChangeEventListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.s7dam.damchangeeventlistener.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_s7dam_damchangeeventlistener_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_s7dam_common_s7dam_dam_change_event_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_s7dam_common_servlets_s7dam_product_info_servlet(post, apply, delete, action, location, propertylist, sling_servlet_paths, sling_servlet_methods)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.s7dam.common.servlets.S7damProductInfoServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.paths=%s&sling.servlet.methods=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_paths), http_util.encodeURIComponent(sling_servlet_methods));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_s7dam_common_servlets_s7dam_product_info_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_s7dam_common_video_impl_video_proxy_client_service_impl(post, apply, delete, action, location, propertylist, cq_dam_s7dam_videoproxyclientservice_multipartupload_minsize_name, cq_dam_s7dam_videoproxyclientservice_multipartupload_partsize_name, cq_dam_s7dam_videoproxyclientservice_multipartupload_numthread_name, cq_dam_s7dam_videoproxyclientservice_http_readtimeout_name, cq_dam_s7dam_videoproxyclientservice_http_connectiontimeout_name, cq_dam_s7dam_videoproxyclientservice_http_maxretrycount_name, cq_dam_s7dam_videoproxyclientservice_uploadprogress_interval_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.s7dam.common.video.impl.VideoProxyClientServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.s7dam.videoproxyclientservice.multipartupload.minsize.name=%s&cq.dam.s7dam.videoproxyclientservice.multipartupload.partsize.name=%s&cq.dam.s7dam.videoproxyclientservice.multipartupload.numthread.name=%s&cq.dam.s7dam.videoproxyclientservice.http.readtimeout.name=%s&cq.dam.s7dam.videoproxyclientservice.http.connectiontimeout.name=%s&cq.dam.s7dam.videoproxyclientservice.http.maxretrycount.name=%s&cq.dam.s7dam.videoproxyclientservice.uploadprogress.interval.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_s7dam_videoproxyclientservice_multipartupload_minsize_name), http_util.encodeURIComponent(cq_dam_s7dam_videoproxyclientservice_multipartupload_partsize_name), http_util.encodeURIComponent(cq_dam_s7dam_videoproxyclientservice_multipartupload_numthread_name), http_util.encodeURIComponent(cq_dam_s7dam_videoproxyclientservice_http_readtimeout_name), http_util.encodeURIComponent(cq_dam_s7dam_videoproxyclientservice_http_connectiontimeout_name), http_util.encodeURIComponent(cq_dam_s7dam_videoproxyclientservice_http_maxretrycount_name), http_util.encodeURIComponent(cq_dam_s7dam_videoproxyclientservice_uploadprogress_interval_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_s7dam_common_video_impl_video_proxy_client_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_scene7_impl_scene7_api_client_impl(post, apply, delete, action, location, propertylist, cq_dam_scene7_apiclient_recordsperpage_nofilter_name, cq_dam_scene7_apiclient_recordsperpage_withfilter_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7APIClientImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.scene7.apiclient.recordsperpage.nofilter.name=%s&cq.dam.scene7.apiclient.recordsperpage.withfilter.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_scene7_apiclient_recordsperpage_nofilter_name), http_util.encodeURIComponent(cq_dam_scene7_apiclient_recordsperpage_withfilter_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_scene7_impl_scene7_api_client_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_scene7_impl_scene7_asset_mime_type_service_impl(post, apply, delete, action, location, propertylist, cq_dam_scene7_assetmimetypeservice_mapping)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7AssetMimeTypeServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.scene7.assetmimetypeservice.mapping=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_scene7_assetmimetypeservice_mapping));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_scene7_impl_scene7_asset_mime_type_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_scene7_impl_scene7_configuration_event_listener(post, apply, delete, action, location, propertylist, cq_dam_scene7_configurationeventlistener_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7ConfigurationEventListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.scene7.configurationeventlistener.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_scene7_configurationeventlistener_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_scene7_impl_scene7_configuration_event_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_scene7_impl_scene7_dam_change_event_listener(post, apply, delete, action, location, propertylist, cq_dam_scene7_damchangeeventlistener_enabled, cq_dam_scene7_damchangeeventlistener_observed_paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7DamChangeEventListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.scene7.damchangeeventlistener.enabled=%s&cq.dam.scene7.damchangeeventlistener.observed.paths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_scene7_damchangeeventlistener_enabled), http_util.encodeURIComponent(cq_dam_scene7_damchangeeventlistener_observed_paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_scene7_impl_scene7_dam_change_event_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_scene7_impl_scene7_flash_templates_service_impl(post, apply, delete, action, location, propertylist, scene7_flash_templates_rti, scene7_flash_templates_rsi, scene7_flash_templates_rb, scene7_flash_templates_rurl, scene7_flash_template_url_format_parameter)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7FlashTemplatesServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scene7FlashTemplates.rti=%s&scene7FlashTemplates.rsi=%s&scene7FlashTemplates.rb=%s&scene7FlashTemplates.rurl=%s&scene7FlashTemplate.urlFormatParameter=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scene7_flash_templates_rti), http_util.encodeURIComponent(scene7_flash_templates_rsi), http_util.encodeURIComponent(scene7_flash_templates_rb), http_util.encodeURIComponent(scene7_flash_templates_rurl), http_util.encodeURIComponent(scene7_flash_template_url_format_parameter));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_scene7_impl_scene7_flash_templates_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_scene7_impl_scene7_upload_service_impl(post, apply, delete, action, location, propertylist, cq_dam_scene7_uploadservice_activejobtimeout_label, cq_dam_scene7_uploadservice_connectionmaxperroute_label)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7UploadServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.dam.scene7.uploadservice.activejobtimeout.label=%s&cq.dam.scene7.uploadservice.connectionmaxperroute.label=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_dam_scene7_uploadservice_activejobtimeout_label), http_util.encodeURIComponent(cq_dam_scene7_uploadservice_connectionmaxperroute_label));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_scene7_impl_scene7_upload_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_stock_integration_impl_cache_stock_cache_configuration_ser(post, apply, delete, action, location, propertylist, get_cache_expiration_unit, get_cache_expiration_value)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.stock.integration.impl.cache.StockCacheConfigurationServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&getCacheExpirationUnit=%s&getCacheExpirationValue=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(get_cache_expiration_unit), http_util.encodeURIComponent(get_cache_expiration_value));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_stock_integration_impl_cache_stock_cache_configuration_ser_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_stock_integration_impl_configuration_stock_configuration(post, apply, delete, action, location, propertylist, name, locale, ims_config)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.stock.integration.impl.configuration.StockConfigurationImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&locale=%s&imsConfig=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(locale), http_util.encodeURIComponent(ims_config));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_stock_integration_impl_configuration_stock_configuration_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_dam_video_impl_servlet_video_test_servlet(post, apply, delete, action, location, propertylist, enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.dam.video.impl.servlet.VideoTestServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_dam_video_impl_servlet_video_test_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_extwidget_servlets_image_sprite_servlet(post, apply, delete, action, location, propertylist, max_width, max_height)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.extwidget.servlets.ImageSpriteServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&maxWidth=%s&maxHeight=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_width), http_util.encodeURIComponent(max_height));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_extwidget_servlets_image_sprite_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_image_internal_font_font_helper(post, apply, delete, action, location, propertylist, fontpath, oversampling_factor)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.image.internal.font.FontHelper?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&fontpath=%s&oversamplingFactor=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(fontpath), http_util.encodeURIComponent(oversampling_factor));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_image_internal_font_font_helper_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_jcrclustersupport_cluster_start_level_controller(post, apply, delete, action, location, propertylist, cluster_level_enable, cluster_master_level, cluster_slave_level)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.jcrclustersupport.ClusterStartLevelController?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cluster.level.enable=%s&cluster.master.level=%s&cluster.slave.level=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cluster_level_enable), http_util.encodeURIComponent(cluster_master_level), http_util.encodeURIComponent(cluster_slave_level));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_jcrclustersupport_cluster_start_level_controller_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mailer_default_mail_service(post, apply, delete, action, location, propertylist, smtp_host, smtp_port, smtp_user, smtp_password, from_address, smtp_ssl, smtp_starttls, debug_email)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mailer.DefaultMailService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&smtp.host=%s&smtp.port=%s&smtp.user=%s&smtp.password=%s&from.address=%s&smtp.ssl=%s&smtp.starttls=%s&debug.email=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(smtp_host), http_util.encodeURIComponent(smtp_port), http_util.encodeURIComponent(smtp_user), http_util.encodeURIComponent(smtp_password), http_util.encodeURIComponent(from_address), http_util.encodeURIComponent(smtp_ssl), http_util.encodeURIComponent(smtp_starttls), http_util.encodeURIComponent(debug_email));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mailer_default_mail_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mailer_impl_cq_mailing_service(post, apply, delete, action, location, propertylist, max_recipient_count)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mailer.impl.CqMailingService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&max.recipient.count=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_recipient_count));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mailer_impl_cq_mailing_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mailer_impl_email_cq_email_template_factory(post, apply, delete, action, location, propertylist, mailer_email_charset)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mailer.impl.email.CqEmailTemplateFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&mailer.email.charset=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(mailer_email_charset));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mailer_impl_email_cq_email_template_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mailer_impl_email_cq_retriever_template_factory(post, apply, delete, action, location, propertylist, mailer_email_embed, mailer_email_charset, mailer_email_retriever_user_id, mailer_email_retriever_user_pwd)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mailer.impl.email.CqRetrieverTemplateFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&mailer.email.embed=%s&mailer.email.charset=%s&mailer.email.retrieverUserID=%s&mailer.email.retrieverUserPWD=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(mailer_email_embed), http_util.encodeURIComponent(mailer_email_charset), http_util.encodeURIComponent(mailer_email_retriever_user_id), http_util.encodeURIComponent(mailer_email_retriever_user_pwd));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mailer_impl_email_cq_retriever_template_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mcm_campaign_impl_integration_config_impl(post, apply, delete, action, location, propertylist, aem_mcm_campaign_form_constraints, aem_mcm_campaign_public_url, aem_mcm_campaign_relaxed_ssl)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mcm.campaign.impl.IntegrationConfigImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&aem.mcm.campaign.formConstraints=%s&aem.mcm.campaign.publicUrl=%s&aem.mcm.campaign.relaxedSSL=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(aem_mcm_campaign_form_constraints), http_util.encodeURIComponent(aem_mcm_campaign_public_url), http_util.encodeURIComponent(aem_mcm_campaign_relaxed_ssl));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mcm_campaign_impl_integration_config_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mcm_campaign_importer_personalized_text_handler_factory(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mcm.campaign.importer.PersonalizedTextHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mcm_campaign_importer_personalized_text_handler_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mcm_core_newsletter_newsletter_email_service_impl(post, apply, delete, action, location, propertylist, from_address, sender_host, max_bounce_count)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mcm.core.newsletter.NewsletterEmailServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&from.address=%s&sender.host=%s&max.bounce.count=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(from_address), http_util.encodeURIComponent(sender_host), http_util.encodeURIComponent(max_bounce_count));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mcm_core_newsletter_newsletter_email_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mcm_impl_mcm_configuration(post, apply, delete, action, location, propertylist, experience_indirection, touchpoint_indirection)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mcm.impl.MCMConfiguration?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&experience.indirection=%s&touchpoint.indirection=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(experience_indirection), http_util.encodeURIComponent(touchpoint_indirection));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mcm_impl_mcm_configuration_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mcm_landingpage_parser_taghandlers_cta_click_through_componen(post, apply, delete, action, location, propertylist, service_ranking, tagpattern, component_resource_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.ClickThroughComponentTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s&component.resourceType=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern), http_util.encodeURIComponent(component_resource_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mcm_landingpage_parser_taghandlers_cta_click_through_componen_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mcm_landingpage_parser_taghandlers_cta_graphical_click_throug(post, apply, delete, action, location, propertylist, service_ranking, tagpattern, component_resource_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.GraphicalClickThroughComponentTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s&component.resourceType=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern), http_util.encodeURIComponent(component_resource_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mcm_landingpage_parser_taghandlers_cta_graphical_click_throug_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mcm_landingpage_parser_taghandlers_cta_lead_form_cta_component(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.LeadFormCTAComponentTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mcm_landingpage_parser_taghandlers_cta_lead_form_cta_component_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mcm_landingpage_parser_taghandlers_mbox_m_box_experience_tag_ha(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.mbox.MBoxExperienceTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mcm_landingpage_parser_taghandlers_mbox_m_box_experience_tag_ha_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_mcm_landingpage_parser_taghandlers_mbox_target_component_tag_h(post, apply, delete, action, location, propertylist, service_ranking, tagpattern, component_resource_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.mbox.TargetComponentTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s&component.resourceType=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern), http_util.encodeURIComponent(component_resource_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_mcm_landingpage_parser_taghandlers_mbox_target_component_tag_h_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_notification_impl_notification_service_impl(post, apply, delete, action, location, propertylist, event_filter)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.notification.impl.NotificationServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.filter=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_filter));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_notification_impl_notification_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_personalization_impl_servlets_targeting_configuration_servlet(post, apply, delete, action, location, propertylist, forcelocation)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.personalization.impl.servlets.TargetingConfigurationServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&forcelocation=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(forcelocation));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_personalization_impl_servlets_targeting_configuration_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_polling_importer_impl_managed_poll_config_impl(post, apply, delete, action, location, propertylist, id, enabled, reference, interval, expression, source, target, login, password)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.polling.importer.impl.ManagedPollConfigImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&id=%s&enabled=%s&reference=%s&interval=%s&expression=%s&source=%s&target=%s&login=%s&password=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(id), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(reference), http_util.encodeURIComponent(interval), http_util.encodeURIComponent(expression), http_util.encodeURIComponent(source), http_util.encodeURIComponent(target), http_util.encodeURIComponent(login), http_util.encodeURIComponent(password));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_polling_importer_impl_managed_poll_config_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_polling_importer_impl_managed_polling_importer_impl(post, apply, delete, action, location, propertylist, importer_user)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.polling.importer.impl.ManagedPollingImporterImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&importer.user=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(importer_user));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_polling_importer_impl_managed_polling_importer_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_polling_importer_impl_polling_importer_impl(post, apply, delete, action, location, propertylist, importer_min_interval, importer_user, exclude_paths, include_paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.polling.importer.impl.PollingImporterImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&importer.min.interval=%s&importer.user=%s&exclude.paths=%s&include.paths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(importer_min_interval), http_util.encodeURIComponent(importer_user), http_util.encodeURIComponent(exclude_paths), http_util.encodeURIComponent(include_paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_polling_importer_impl_polling_importer_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_replication_audit_replication_event_listener(post, apply, delete, action, location, propertylist, service_ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.replication.audit.ReplicationEventListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_replication_audit_replication_event_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_replication_content_static_content_builder(post, apply, delete, action, location, propertylist, host, port)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.replication.content.StaticContentBuilder?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&host=%s&port=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(host), http_util.encodeURIComponent(port));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_replication_content_static_content_builder_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_replication_impl_agent_manager_impl(post, apply, delete, action, location, propertylist, job_topics, service_user_target, agent_provider_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.replication.impl.AgentManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&job.topics=%s&serviceUser.target=%s&agentProvider.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(job_topics), http_util.encodeURIComponent(service_user_target), http_util.encodeURIComponent(agent_provider_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_replication_impl_agent_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_replication_impl_content_durbo_binary_less_content_builder(post, apply, delete, action, location, propertylist, binary_threshold)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.replication.impl.content.durbo.BinaryLessContentBuilder?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&binary.threshold=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(binary_threshold));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_replication_impl_content_durbo_binary_less_content_builder_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_replication_impl_content_durbo_durbo_import_configuration_prov(post, apply, delete, action, location, propertylist, preserve_hierarchy_nodes, ignore_versioning, import_acl, save_threshold, preserve_user_paths, preserve_uuid, preserve_uuid_nodetypes, preserve_uuid_subtrees, auto_commit)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.replication.impl.content.durbo.DurboImportConfigurationProviderService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&preserve.hierarchy.nodes=%s&ignore.versioning=%s&import.acl=%s&save.threshold=%s&preserve.user.paths=%s&preserve.uuid=%s&preserve.uuid.nodetypes=%s&preserve.uuid.subtrees=%s&auto.commit=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(preserve_hierarchy_nodes), http_util.encodeURIComponent(ignore_versioning), http_util.encodeURIComponent(import_acl), http_util.encodeURIComponent(save_threshold), http_util.encodeURIComponent(preserve_user_paths), http_util.encodeURIComponent(preserve_uuid), http_util.encodeURIComponent(preserve_uuid_nodetypes), http_util.encodeURIComponent(preserve_uuid_subtrees), http_util.encodeURIComponent(auto_commit));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_replication_impl_content_durbo_durbo_import_configuration_prov_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_replication_impl_replication_content_factory_provider_impl(post, apply, delete, action, location, propertylist, replication_content_use_file_storage, replication_content_max_commit_attempts)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.replication.impl.ReplicationContentFactoryProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&replication.content.useFileStorage=%s&replication.content.maxCommitAttempts=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(replication_content_use_file_storage), http_util.encodeURIComponent(replication_content_max_commit_attempts));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_replication_impl_replication_content_factory_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_replication_impl_replication_receiver_impl(post, apply, delete, action, location, propertylist, receiver_tmpfile_threshold, receiver_packages_use_install)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.replication.impl.ReplicationReceiverImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&receiver.tmpfile.threshold=%s&receiver.packages.use.install=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(receiver_tmpfile_threshold), http_util.encodeURIComponent(receiver_packages_use_install));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_replication_impl_replication_receiver_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_replication_impl_replicator_impl(post, apply, delete, action, location, propertylist, distribute_events)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.replication.impl.ReplicatorImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&distribute_events=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(distribute_events));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_replication_impl_replicator_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_replication_impl_reverse_replicator(post, apply, delete, action, location, propertylist, scheduler_period)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.replication.impl.ReverseReplicator?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.period=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_period));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_replication_impl_reverse_replicator_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_replication_impl_transport_binary_less_transport_handler(post, apply, delete, action, location, propertylist, disabled_cipher_suites, enabled_cipher_suites)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.replication.impl.transport.BinaryLessTransportHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&disabled.cipher.suites=%s&enabled.cipher.suites=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(disabled_cipher_suites), http_util.encodeURIComponent(enabled_cipher_suites));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_replication_impl_transport_binary_less_transport_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_replication_impl_transport_http(post, apply, delete, action, location, propertylist, disabled_cipher_suites, enabled_cipher_suites)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.replication.impl.transport.Http?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&disabled.cipher.suites=%s&enabled.cipher.suites=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(disabled_cipher_suites), http_util.encodeURIComponent(enabled_cipher_suites));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_replication_impl_transport_http_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_reporting_impl_cache_cache_impl(post, apply, delete, action, location, propertylist, repcache_enable, repcache_ttl, repcache_max)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.reporting.impl.cache.CacheImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&repcache.enable=%s&repcache.ttl=%s&repcache.max=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(repcache_enable), http_util.encodeURIComponent(repcache_ttl), http_util.encodeURIComponent(repcache_max));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_reporting_impl_cache_cache_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_reporting_impl_config_service_impl(post, apply, delete, action, location, propertylist, repconf_timezone, repconf_locale, repconf_snapshots, repconf_repdir, repconf_hourofday, repconf_minofhour, repconf_maxrows, repconf_fakedata, repconf_snapshotuser, repconf_enforcesnapshotuser)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.reporting.impl.ConfigServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&repconf.timezone=%s&repconf.locale=%s&repconf.snapshots=%s&repconf.repdir=%s&repconf.hourofday=%s&repconf.minofhour=%s&repconf.maxrows=%s&repconf.fakedata=%s&repconf.snapshotuser=%s&repconf.enforcesnapshotuser=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(repconf_timezone), http_util.encodeURIComponent(repconf_locale), http_util.encodeURIComponent(repconf_snapshots), http_util.encodeURIComponent(repconf_repdir), http_util.encodeURIComponent(repconf_hourofday), http_util.encodeURIComponent(repconf_minofhour), http_util.encodeURIComponent(repconf_maxrows), http_util.encodeURIComponent(repconf_fakedata), http_util.encodeURIComponent(repconf_snapshotuser), http_util.encodeURIComponent(repconf_enforcesnapshotuser));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_reporting_impl_config_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_reporting_impl_r_log_analyzer(post, apply, delete, action, location, propertylist, request_log_output)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.reporting.impl.RLogAnalyzer?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&request.log.output=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(request_log_output));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_reporting_impl_r_log_analyzer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_rewriter_linkchecker_impl_link_checker_impl(post, apply, delete, action, location, propertylist, scheduler_period, scheduler_concurrent, service_bad_link_tolerance_interval, service_check_override_patterns, service_cache_broken_internal_links, service_special_link_prefix, service_special_link_patterns)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.period=%s&scheduler.concurrent=%s&service.bad_link_tolerance_interval=%s&service.check_override_patterns=%s&service.cache_broken_internal_links=%s&service.special_link_prefix=%s&service.special_link_patterns=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_period), http_util.encodeURIComponent(scheduler_concurrent), http_util.encodeURIComponent(service_bad_link_tolerance_interval), http_util.encodeURIComponent(service_check_override_patterns), http_util.encodeURIComponent(service_cache_broken_internal_links), http_util.encodeURIComponent(service_special_link_prefix), http_util.encodeURIComponent(service_special_link_patterns));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_rewriter_linkchecker_impl_link_checker_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_rewriter_linkchecker_impl_link_checker_task(post, apply, delete, action, location, propertylist, scheduler_period, scheduler_concurrent, good_link_test_interval, bad_link_test_interval, link_unused_interval, connection_timeout)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerTask?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.period=%s&scheduler.concurrent=%s&good_link_test_interval=%s&bad_link_test_interval=%s&link_unused_interval=%s&connection.timeout=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_period), http_util.encodeURIComponent(scheduler_concurrent), http_util.encodeURIComponent(good_link_test_interval), http_util.encodeURIComponent(bad_link_test_interval), http_util.encodeURIComponent(link_unused_interval), http_util.encodeURIComponent(connection_timeout));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_rewriter_linkchecker_impl_link_checker_task_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_rewriter_linkchecker_impl_link_checker_transformer_factory(post, apply, delete, action, location, propertylist, linkcheckertransformer_disable_rewriting, linkcheckertransformer_disable_checking, linkcheckertransformer_map_cache_size, linkcheckertransformer_strict_extension_check, linkcheckertransformer_strip_htmlt_extension, linkcheckertransformer_rewrite_elements, linkcheckertransformer_strip_extension_path_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerTransformerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&linkcheckertransformer.disableRewriting=%s&linkcheckertransformer.disableChecking=%s&linkcheckertransformer.mapCacheSize=%s&linkcheckertransformer.strictExtensionCheck=%s&linkcheckertransformer.stripHtmltExtension=%s&linkcheckertransformer.rewriteElements=%s&linkcheckertransformer.stripExtensionPathBlacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(linkcheckertransformer_disable_rewriting), http_util.encodeURIComponent(linkcheckertransformer_disable_checking), http_util.encodeURIComponent(linkcheckertransformer_map_cache_size), http_util.encodeURIComponent(linkcheckertransformer_strict_extension_check), http_util.encodeURIComponent(linkcheckertransformer_strip_htmlt_extension), http_util.encodeURIComponent(linkcheckertransformer_rewrite_elements), http_util.encodeURIComponent(linkcheckertransformer_strip_extension_path_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_rewriter_linkchecker_impl_link_checker_transformer_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_rewriter_linkchecker_impl_link_info_storage_impl(post, apply, delete, action, location, propertylist, service_max_links_per_host, service_save_external_link_references)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkInfoStorageImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.max_links_per_host=%s&service.save_external_link_references=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_max_links_per_host), http_util.encodeURIComponent(service_save_external_link_references));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_rewriter_linkchecker_impl_link_info_storage_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_rewriter_processor_impl_html_parser_factory(post, apply, delete, action, location, propertylist, htmlparser_process_tags, htmlparser_preserve_camel_case)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.rewriter.processor.impl.HtmlParserFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&htmlparser.processTags=%s&htmlparser.preserveCamelCase=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(htmlparser_process_tags), http_util.encodeURIComponent(htmlparser_preserve_camel_case));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_rewriter_processor_impl_html_parser_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_search_impl_builder_query_builder_impl(post, apply, delete, action, location, propertylist, excerpt_properties, cache_max_entries, cache_entry_lifetime, xpath_union)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.search.impl.builder.QueryBuilderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&excerpt.properties=%s&cache.max.entries=%s&cache.entry.lifetime=%s&xpath.union=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(excerpt_properties), http_util.encodeURIComponent(cache_max_entries), http_util.encodeURIComponent(cache_entry_lifetime), http_util.encodeURIComponent(xpath_union));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_search_impl_builder_query_builder_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_search_suggest_impl_suggestion_index_manager_impl(post, apply, delete, action, location, propertylist, path_builder_target, suggest_basepath)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.search.suggest.impl.SuggestionIndexManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&pathBuilder.target=%s&suggest.basepath=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path_builder_target), http_util.encodeURIComponent(suggest_basepath));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_search_suggest_impl_suggestion_index_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_searchpromote_impl_publish_search_promote_config_handler(post, apply, delete, action, location, propertylist, cq_searchpromote_confighandler_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.searchpromote.impl.PublishSearchPromoteConfigHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.searchpromote.confighandler.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_searchpromote_confighandler_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_searchpromote_impl_publish_search_promote_config_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_searchpromote_impl_search_promote_service_impl(post, apply, delete, action, location, propertylist, cq_searchpromote_configuration_server_uri, cq_searchpromote_configuration_environment, connection_timeout, socket_timeout)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.searchpromote.impl.SearchPromoteServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.searchpromote.configuration.server.uri=%s&cq.searchpromote.configuration.environment=%s&connection.timeout=%s&socket.timeout=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_searchpromote_configuration_server_uri), http_util.encodeURIComponent(cq_searchpromote_configuration_environment), http_util.encodeURIComponent(connection_timeout), http_util.encodeURIComponent(socket_timeout));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_searchpromote_impl_search_promote_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_security_acl_setup(post, apply, delete, action, location, propertylist, cq_aclsetup_rules)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.security.ACLSetup?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.aclsetup.rules=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_aclsetup_rules));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_security_acl_setup_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_statistics_impl_statistics_service_impl(post, apply, delete, action, location, propertylist, scheduler_period, scheduler_concurrent, path, workspace, keywords_path, async_entries)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.statistics.impl.StatisticsServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.period=%s&scheduler.concurrent=%s&path=%s&workspace=%s&keywordsPath=%s&asyncEntries=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_period), http_util.encodeURIComponent(scheduler_concurrent), http_util.encodeURIComponent(path), http_util.encodeURIComponent(workspace), http_util.encodeURIComponent(keywords_path), http_util.encodeURIComponent(async_entries));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_statistics_impl_statistics_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_tagging_impl_jcr_tag_manager_factory_impl(post, apply, delete, action, location, propertylist, validation_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.tagging.impl.JcrTagManagerFactoryImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&validation.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(validation_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_tagging_impl_jcr_tag_manager_factory_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_tagging_impl_search_tag_predicate_evaluator(post, apply, delete, action, location, propertylist, ignore_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.tagging.impl.search.TagPredicateEvaluator?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&ignore_path=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(ignore_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_tagging_impl_search_tag_predicate_evaluator_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_tagging_impl_tag_garbage_collector(post, apply, delete, action, location, propertylist, scheduler_expression)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.tagging.impl.TagGarbageCollector?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.expression=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_expression));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_tagging_impl_tag_garbage_collector_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_contentsync_impl_handler_pages_update_handler(post, apply, delete, action, location, propertylist, cq_pagesupdatehandler_imageresourcetypes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.contentsync.impl.handler.PagesUpdateHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.pagesupdatehandler.imageresourcetypes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_pagesupdatehandler_imageresourcetypes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_contentsync_impl_handler_pages_update_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_contentsync_impl_rewriter_path_rewriter_transformer_factor(post, apply, delete, action, location, propertylist, cq_contentsync_pathrewritertransformer_mapping_links, cq_contentsync_pathrewritertransformer_mapping_clientlibs, cq_contentsync_pathrewritertransformer_mapping_images, cq_contentsync_pathrewritertransformer_attribute_pattern, cq_contentsync_pathrewritertransformer_clientlibrary_pattern, cq_contentsync_pathrewritertransformer_clientlibrary_replace)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.contentsync.impl.rewriter.PathRewriterTransformerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.contentsync.pathrewritertransformer.mapping.links=%s&cq.contentsync.pathrewritertransformer.mapping.clientlibs=%s&cq.contentsync.pathrewritertransformer.mapping.images=%s&cq.contentsync.pathrewritertransformer.attribute.pattern=%s&cq.contentsync.pathrewritertransformer.clientlibrary.pattern=%s&cq.contentsync.pathrewritertransformer.clientlibrary.replace=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_contentsync_pathrewritertransformer_mapping_links), http_util.encodeURIComponent(cq_contentsync_pathrewritertransformer_mapping_clientlibs), http_util.encodeURIComponent(cq_contentsync_pathrewritertransformer_mapping_images), http_util.encodeURIComponent(cq_contentsync_pathrewritertransformer_attribute_pattern), http_util.encodeURIComponent(cq_contentsync_pathrewritertransformer_clientlibrary_pattern), http_util.encodeURIComponent(cq_contentsync_pathrewritertransformer_clientlibrary_replace));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_contentsync_impl_rewriter_path_rewriter_transformer_factor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_authoring_ui_mode_service_impl(post, apply, delete, action, location, propertylist, authoring_ui_mode_service_default)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.AuthoringUIModeServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&authoringUIModeService.default=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(authoring_ui_mode_service_default));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_authoring_ui_mode_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_commands_wcm_command_servlet(post, apply, delete, action, location, propertylist, wcmcommandservlet_delete_whitelist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.commands.WCMCommandServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&wcmcommandservlet.delete_whitelist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(wcmcommandservlet_delete_whitelist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_commands_wcm_command_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_devicedetection_device_identification_mode_impl(post, apply, delete, action, location, propertylist, dim_default_mode, dim_appcache_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.devicedetection.DeviceIdentificationModeImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&dim.default.mode=%s&dim.appcache.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(dim_default_mode), http_util.encodeURIComponent(dim_appcache_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_devicedetection_device_identification_mode_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_event_page_event_audit_listener(post, apply, delete, action, location, propertylist, configured)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.event.PageEventAuditListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&configured=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(configured));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_event_page_event_audit_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_event_page_post_processor(post, apply, delete, action, location, propertylist, paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.event.PagePostProcessor?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&paths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_event_page_post_processor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_event_repository_change_event_listener(post, apply, delete, action, location, propertylist, paths, excluded_paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.event.RepositoryChangeEventListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&paths=%s&excludedPaths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(paths), http_util.encodeURIComponent(excluded_paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_event_repository_change_event_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_event_template_post_processor(post, apply, delete, action, location, propertylist, paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.event.TemplatePostProcessor?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&paths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_event_template_post_processor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_language_manager_impl(post, apply, delete, action, location, propertylist, langmgr_list_path, langmgr_country_default)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.LanguageManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&langmgr.list.path=%s&langmgr.country.default=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(langmgr_list_path), http_util.encodeURIComponent(langmgr_country_default));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_language_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_link_checker_configuration_factory_impl(post, apply, delete, action, location, propertylist, link_expired_prefix, link_expired_remove, link_expired_suffix, link_invalid_prefix, link_invalid_remove, link_invalid_suffix, link_predated_prefix, link_predated_remove, link_predated_suffix, link_wcmmodes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.LinkCheckerConfigurationFactoryImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&link.expired.prefix=%s&link.expired.remove=%s&link.expired.suffix=%s&link.invalid.prefix=%s&link.invalid.remove=%s&link.invalid.suffix=%s&link.predated.prefix=%s&link.predated.remove=%s&link.predated.suffix=%s&link.wcmmodes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(link_expired_prefix), http_util.encodeURIComponent(link_expired_remove), http_util.encodeURIComponent(link_expired_suffix), http_util.encodeURIComponent(link_invalid_prefix), http_util.encodeURIComponent(link_invalid_remove), http_util.encodeURIComponent(link_invalid_suffix), http_util.encodeURIComponent(link_predated_prefix), http_util.encodeURIComponent(link_predated_remove), http_util.encodeURIComponent(link_predated_suffix), http_util.encodeURIComponent(link_wcmmodes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_link_checker_configuration_factory_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_page_page_info_aggregator_impl(post, apply, delete, action, location, propertylist, page_info_provider_property_regex_default, page_info_provider_property_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.page.PageInfoAggregatorImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&page.info.provider.property.regex.default=%s&page.info.provider.property.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(page_info_provider_property_regex_default), http_util.encodeURIComponent(page_info_provider_property_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_page_page_info_aggregator_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_page_page_manager_factory_impl(post, apply, delete, action, location, propertylist, illegal_char_mapping, page_sub_tree_activation_check)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.page.PageManagerFactoryImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&illegalCharMapping=%s&pageSubTreeActivationCheck=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(illegal_char_mapping), http_util.encodeURIComponent(page_sub_tree_activation_check));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_page_page_manager_factory_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_references_content_content_reference_config(post, apply, delete, action, location, propertylist, content_reference_config_resource_types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.references.content.ContentReferenceConfig?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&contentReferenceConfig.resourceTypes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(content_reference_config_resource_types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_references_content_content_reference_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_servlets_contentfinder_asset_view_handler(post, apply, delete, action, location, propertylist, dam_showexpired, dam_showhidden, tag_title_search, guess_total, dam_expiry_property)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.AssetViewHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&dam.showexpired=%s&dam.showhidden=%s&tagTitleSearch=%s&guessTotal=%s&dam.expiryProperty=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(dam_showexpired), http_util.encodeURIComponent(dam_showhidden), http_util.encodeURIComponent(tag_title_search), http_util.encodeURIComponent(guess_total), http_util.encodeURIComponent(dam_expiry_property));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_servlets_contentfinder_asset_view_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_servlets_contentfinder_connector_connector_vie(post, apply, delete, action, location, propertylist, item_resource_types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.connector.ConnectorViewHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&item.resource.types=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(item_resource_types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_servlets_contentfinder_connector_connector_vie_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_servlets_contentfinder_page_view_handler(post, apply, delete, action, location, propertylist, guess_total, tag_title_search)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.PageViewHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&guessTotal=%s&tagTitleSearch=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(guess_total), http_util.encodeURIComponent(tag_title_search));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_servlets_contentfinder_page_view_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_servlets_find_replace_servlet(post, apply, delete, action, location, propertylist, scope)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.FindReplaceServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scope=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scope));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_servlets_find_replace_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_servlets_reference_search_servlet(post, apply, delete, action, location, propertylist, referencesearchservlet_max_references_per_page, referencesearchservlet_max_pages)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.ReferenceSearchServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&referencesearchservlet.maxReferencesPerPage=%s&referencesearchservlet.maxPages=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(referencesearchservlet_max_references_per_page), http_util.encodeURIComponent(referencesearchservlet_max_pages));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_servlets_reference_search_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_servlets_thumbnail_servlet(post, apply, delete, action, location, propertylist, workspace, dimensions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.ThumbnailServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&workspace=%s&dimensions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(workspace), http_util.encodeURIComponent(dimensions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_servlets_thumbnail_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_utils_default_page_name_validator(post, apply, delete, action, location, propertylist, non_valid_chars)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.utils.DefaultPageNameValidator?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&nonValidChars=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(non_valid_chars));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_utils_default_page_name_validator_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_variants_page_variants_provider_impl(post, apply, delete, action, location, propertylist, default_externalizer_domain)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.variants.PageVariantsProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&default.externalizer.domain=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(default_externalizer_domain));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_variants_page_variants_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_version_manager_impl(post, apply, delete, action, location, propertylist, versionmanager_create_version_on_activation, versionmanager_purging_enabled, versionmanager_purge_paths, versionmanager_iv_paths, versionmanager_max_age_days, versionmanager_max_number_versions, versionmanager_min_number_versions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.VersionManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&versionmanager.createVersionOnActivation=%s&versionmanager.purgingEnabled=%s&versionmanager.purgePaths=%s&versionmanager.ivPaths=%s&versionmanager.maxAgeDays=%s&versionmanager.maxNumberVersions=%s&versionmanager.minNumberVersions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(versionmanager_create_version_on_activation), http_util.encodeURIComponent(versionmanager_purging_enabled), http_util.encodeURIComponent(versionmanager_purge_paths), http_util.encodeURIComponent(versionmanager_iv_paths), http_util.encodeURIComponent(versionmanager_max_age_days), http_util.encodeURIComponent(versionmanager_max_number_versions), http_util.encodeURIComponent(versionmanager_min_number_versions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_version_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_version_purge_task(post, apply, delete, action, location, propertylist, versionpurge_paths, versionpurge_recursive, versionpurge_max_versions, versionpurge_min_versions, versionpurge_max_age_days)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.VersionPurgeTask?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&versionpurge.paths=%s&versionpurge.recursive=%s&versionpurge.maxVersions=%s&versionpurge.minVersions=%s&versionpurge.maxAgeDays=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(versionpurge_paths), http_util.encodeURIComponent(versionpurge_recursive), http_util.encodeURIComponent(versionpurge_max_versions), http_util.encodeURIComponent(versionpurge_min_versions), http_util.encodeURIComponent(versionpurge_max_age_days));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_version_purge_task_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_warp_time_warp_filter(post, apply, delete, action, location, propertylist, filter_order, filter_scope)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.warp.TimeWarpFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&filter.order=%s&filter.scope=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(filter_order), http_util.encodeURIComponent(filter_scope));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_warp_time_warp_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_wcm_debug_filter(post, apply, delete, action, location, propertylist, wcmdbgfilter_enabled, wcmdbgfilter_jsp_debug)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.WCMDebugFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&wcmdbgfilter.enabled=%s&wcmdbgfilter.jspDebug=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(wcmdbgfilter_enabled), http_util.encodeURIComponent(wcmdbgfilter_jsp_debug));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_wcm_debug_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_impl_wcm_developer_mode_filter(post, apply, delete, action, location, propertylist, wcmdevmodefilter_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.impl.WCMDeveloperModeFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&wcmdevmodefilter.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(wcmdevmodefilter_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_impl_wcm_developer_mode_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_mvt_mvt_statistics_impl(post, apply, delete, action, location, propertylist, mvtstatistics_trackingurl)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.mvt.MVTStatisticsImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&mvtstatistics.trackingurl=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(mvtstatistics_trackingurl));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_mvt_mvt_statistics_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_stats_page_view_statistics_impl(post, apply, delete, action, location, propertylist, pageviewstatistics_trackingurl, pageviewstatistics_trackingscript_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.stats.PageViewStatisticsImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&pageviewstatistics.trackingurl=%s&pageviewstatistics.trackingscript.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(pageviewstatistics_trackingurl), http_util.encodeURIComponent(pageviewstatistics_trackingscript_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_stats_page_view_statistics_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_core_wcm_request_filter(post, apply, delete, action, location, propertylist, wcmfilter_mode)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.core.WCMRequestFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&wcmfilter.mode=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(wcmfilter_mode));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_core_wcm_request_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_design_package_importer(post, apply, delete, action, location, propertylist, extract_filter)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.DesignPackageImporter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&extract.filter=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(extract_filter));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_design_package_importer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_impl_canvas_builder_impl(post, apply, delete, action, location, propertylist, filepattern, build_page_nodes, build_client_libs, build_canvas_component)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.impl.CanvasBuilderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&filepattern=%s&build.page.nodes=%s&build.client.libs=%s&build.canvas.component=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(filepattern), http_util.encodeURIComponent(build_page_nodes), http_util.encodeURIComponent(build_client_libs), http_util.encodeURIComponent(build_canvas_component));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_impl_canvas_builder_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_impl_canvas_page_delete_handler(post, apply, delete, action, location, propertylist, min_thread_pool_size, max_thread_pool_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.impl.CanvasPageDeleteHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&minThreadPoolSize=%s&maxThreadPoolSize=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(min_thread_pool_size), http_util.encodeURIComponent(max_thread_pool_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_impl_canvas_page_delete_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_impl_entry_preprocessor_impl(post, apply, delete, action, location, propertylist, search_pattern, replace_pattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.impl.EntryPreprocessorImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&search.pattern=%s&replace.pattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(search_pattern), http_util.encodeURIComponent(replace_pattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_impl_entry_preprocessor_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_impl_mobile_canvas_builder_impl(post, apply, delete, action, location, propertylist, filepattern, device_groups, build_page_nodes, build_client_libs, build_canvas_component)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.impl.MobileCanvasBuilderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&filepattern=%s&device.groups=%s&build.page.nodes=%s&build.client.libs=%s&build.canvas.component=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(filepattern), http_util.encodeURIComponent(device_groups), http_util.encodeURIComponent(build_page_nodes), http_util.encodeURIComponent(build_client_libs), http_util.encodeURIComponent(build_canvas_component));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_impl_mobile_canvas_builder_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_canvas_compone(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.CanvasComponentTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_canvas_compone_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_default_compon(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.DefaultComponentTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_default_compon_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_default_tag_han(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.DefaultTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_default_tag_han_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_head_tag_handle(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.HeadTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_head_tag_handle_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_i_frame_tag_hand(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.IFrameTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_i_frame_tag_hand_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_image_componen(post, apply, delete, action, location, propertylist, service_ranking, tagpattern, component_resource_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ImageComponentTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s&component.resourceType=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern), http_util.encodeURIComponent(component_resource_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_image_componen_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_img_tag_handler(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ImgTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_img_tag_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_inline_script_t(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.InlineScriptTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_inline_script_t_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_link_tag_handle(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.LinkTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_link_tag_handle_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_meta_tag_handle(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.MetaTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_meta_tag_handle_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_non_script_tag_h(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.NonScriptTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_non_script_tag_h_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_parsys_compone(post, apply, delete, action, location, propertylist, service_ranking, tagpattern, component_resource_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ParsysComponentTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s&component.resourceType=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern), http_util.encodeURIComponent(component_resource_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_parsys_compone_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_script_tag_hand(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ScriptTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_script_tag_hand_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_style_tag_handl(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.StyleTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_style_tag_handl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_text_component(post, apply, delete, action, location, propertylist, service_ranking, tagpattern, component_resource_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TextComponentTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s&component.resourceType=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern), http_util.encodeURIComponent(component_resource_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_text_component_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_title_componen(post, apply, delete, action, location, propertylist, service_ranking, tagpattern, component_resource_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TitleComponentTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s&component.resourceType=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern), http_util.encodeURIComponent(component_resource_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_title_componen_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_designimporter_parser_taghandlers_factory_title_tag_handl(post, apply, delete, action, location, propertylist, service_ranking, tagpattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TitleTagHandlerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&tagpattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(tagpattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_designimporter_parser_taghandlers_factory_title_tag_handl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_foundation_forms_impl_form_chooser_servlet(post, apply, delete, action, location, propertylist, service_name, sling_servlet_resource_types, sling_servlet_selectors, sling_servlet_methods, forms_formchooserservlet_advansesearch_require)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormChooserServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.name=%s&sling.servlet.resourceTypes=%s&sling.servlet.selectors=%s&sling.servlet.methods=%s&forms.formchooserservlet.advansesearch.require=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_name), http_util.encodeURIComponent(sling_servlet_resource_types), http_util.encodeURIComponent(sling_servlet_selectors), http_util.encodeURIComponent(sling_servlet_methods), http_util.encodeURIComponent(forms_formchooserservlet_advansesearch_require));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_foundation_forms_impl_form_chooser_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_foundation_forms_impl_form_paragraph_post_processor(post, apply, delete, action, location, propertylist, forms_formparagraphpostprocessor_enabled, forms_formparagraphpostprocessor_formresourcetypes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormParagraphPostProcessor?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&forms.formparagraphpostprocessor.enabled=%s&forms.formparagraphpostprocessor.formresourcetypes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(forms_formparagraphpostprocessor_enabled), http_util.encodeURIComponent(forms_formparagraphpostprocessor_formresourcetypes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_foundation_forms_impl_form_paragraph_post_processor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_foundation_forms_impl_forms_handling_servlet(post, apply, delete, action, location, propertylist, name_whitelist, allow_expressions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormsHandlingServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name.whitelist=%s&allow.expressions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name_whitelist), http_util.encodeURIComponent(allow_expressions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_foundation_forms_impl_forms_handling_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_foundation_forms_impl_mail_servlet(post, apply, delete, action, location, propertylist, sling_servlet_resource_types, sling_servlet_selectors, resource_whitelist, resource_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.MailServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.resourceTypes=%s&sling.servlet.selectors=%s&resource.whitelist=%s&resource.blacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_resource_types), http_util.encodeURIComponent(sling_servlet_selectors), http_util.encodeURIComponent(resource_whitelist), http_util.encodeURIComponent(resource_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_foundation_forms_impl_mail_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_foundation_impl_adaptive_image_component_servlet(post, apply, delete, action, location, propertylist, adapt_supported_widths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.foundation.impl.AdaptiveImageComponentServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&adapt.supported.widths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(adapt_supported_widths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_foundation_impl_adaptive_image_component_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_foundation_impl_http_auth_handler(post, apply, delete, action, location, propertylist, path, auth_http_nologin, auth_http_realm, auth_default_loginpage, auth_cred_form, auth_cred_utf8)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.foundation.impl.HTTPAuthHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path=%s&auth.http.nologin=%s&auth.http.realm=%s&auth.default.loginpage=%s&auth.cred.form=%s&auth.cred.utf8=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path), http_util.encodeURIComponent(auth_http_nologin), http_util.encodeURIComponent(auth_http_realm), http_util.encodeURIComponent(auth_default_loginpage), http_util.encodeURIComponent(auth_cred_form), http_util.encodeURIComponent(auth_cred_utf8));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_foundation_impl_http_auth_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_foundation_impl_page_impressions_tracker(post, apply, delete, action, location, propertylist, sling_auth_requirements)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.foundation.impl.PageImpressionsTracker?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.auth.requirements=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_auth_requirements));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_foundation_impl_page_impressions_tracker_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_foundation_impl_page_redirect_servlet(post, apply, delete, action, location, propertylist, excluded_resource_types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.foundation.impl.PageRedirectServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&excluded.resource.types=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(excluded_resource_types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_foundation_impl_page_redirect_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_foundation_security_impl_default_attachment_type_blacklist(post, apply, delete, action, location, propertylist, default_attachment_type_blacklist, baseline_attachment_type_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.foundation.security.impl.DefaultAttachmentTypeBlacklistService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&default.attachment.type.blacklist=%s&baseline.attachment.type.blacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(default_attachment_type_blacklist), http_util.encodeURIComponent(baseline_attachment_type_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_foundation_security_impl_default_attachment_type_blacklist_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_foundation_security_impl_safer_sling_post_validator_impl(post, apply, delete, action, location, propertylist, parameter_whitelist, parameter_whitelist_prefixes, binary_parameter_whitelist, modifier_whitelist, operation_whitelist, operation_whitelist_prefixes, typehint_whitelist, resourcetype_whitelist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.foundation.security.impl.SaferSlingPostValidatorImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&parameter.whitelist=%s&parameter.whitelist.prefixes=%s&binary.parameter.whitelist=%s&modifier.whitelist=%s&operation.whitelist=%s&operation.whitelist.prefixes=%s&typehint.whitelist=%s&resourcetype.whitelist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(parameter_whitelist), http_util.encodeURIComponent(parameter_whitelist_prefixes), http_util.encodeURIComponent(binary_parameter_whitelist), http_util.encodeURIComponent(modifier_whitelist), http_util.encodeURIComponent(operation_whitelist), http_util.encodeURIComponent(operation_whitelist_prefixes), http_util.encodeURIComponent(typehint_whitelist), http_util.encodeURIComponent(resourcetype_whitelist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_foundation_security_impl_safer_sling_post_validator_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_mobile_core_impl_device_device_info_transformer_factory(post, apply, delete, action, location, propertylist, device_info_transformer_enabled, device_info_transformer_css_style)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.mobile.core.impl.device.DeviceInfoTransformerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&device.info.transformer.enabled=%s&device.info.transformer.css.style=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(device_info_transformer_enabled), http_util.encodeURIComponent(device_info_transformer_css_style));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_mobile_core_impl_device_device_info_transformer_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_mobile_core_impl_redirect_redirect_filter(post, apply, delete, action, location, propertylist, redirect_enabled, redirect_stats_enabled, redirect_extensions, redirect_paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.mobile.core.impl.redirect.RedirectFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&redirect.enabled=%s&redirect.stats.enabled=%s&redirect.extensions=%s&redirect.paths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(redirect_enabled), http_util.encodeURIComponent(redirect_stats_enabled), http_util.encodeURIComponent(redirect_extensions), http_util.encodeURIComponent(redirect_paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_mobile_core_impl_redirect_redirect_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_msm_impl_actions_content_copy_action_factory(post, apply, delete, action, location, propertylist, cq_wcm_msm_action_excludednodetypes, cq_wcm_msm_action_excludedparagraphitems, cq_wcm_msm_action_excludedprops, contentcopyaction_order_style)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentCopyActionFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.wcm.msm.action.excludednodetypes=%s&cq.wcm.msm.action.excludedparagraphitems=%s&cq.wcm.msm.action.excludedprops=%s&contentcopyaction.order.style=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_wcm_msm_action_excludednodetypes), http_util.encodeURIComponent(cq_wcm_msm_action_excludedparagraphitems), http_util.encodeURIComponent(cq_wcm_msm_action_excludedprops), http_util.encodeURIComponent(contentcopyaction_order_style));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_msm_impl_actions_content_copy_action_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_msm_impl_actions_content_delete_action_factory(post, apply, delete, action, location, propertylist, cq_wcm_msm_action_excludednodetypes, cq_wcm_msm_action_excludedparagraphitems, cq_wcm_msm_action_excludedprops)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentDeleteActionFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.wcm.msm.action.excludednodetypes=%s&cq.wcm.msm.action.excludedparagraphitems=%s&cq.wcm.msm.action.excludedprops=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_wcm_msm_action_excludednodetypes), http_util.encodeURIComponent(cq_wcm_msm_action_excludedparagraphitems), http_util.encodeURIComponent(cq_wcm_msm_action_excludedprops));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_msm_impl_actions_content_delete_action_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_msm_impl_actions_content_update_action_factory(post, apply, delete, action, location, propertylist, cq_wcm_msm_action_excludednodetypes, cq_wcm_msm_action_excludedparagraphitems, cq_wcm_msm_action_excludedprops, cq_wcm_msm_action_ignored_mixin)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentUpdateActionFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.wcm.msm.action.excludednodetypes=%s&cq.wcm.msm.action.excludedparagraphitems=%s&cq.wcm.msm.action.excludedprops=%s&cq.wcm.msm.action.ignoredMixin=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_wcm_msm_action_excludednodetypes), http_util.encodeURIComponent(cq_wcm_msm_action_excludedparagraphitems), http_util.encodeURIComponent(cq_wcm_msm_action_excludedprops), http_util.encodeURIComponent(cq_wcm_msm_action_ignored_mixin));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_msm_impl_actions_content_update_action_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_msm_impl_actions_order_children_action_factory(post, apply, delete, action, location, propertylist, cq_wcm_msm_action_excludednodetypes, cq_wcm_msm_action_excludedparagraphitems, cq_wcm_msm_action_excludedprops)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.OrderChildrenActionFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.wcm.msm.action.excludednodetypes=%s&cq.wcm.msm.action.excludedparagraphitems=%s&cq.wcm.msm.action.excludedprops=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_wcm_msm_action_excludednodetypes), http_util.encodeURIComponent(cq_wcm_msm_action_excludedparagraphitems), http_util.encodeURIComponent(cq_wcm_msm_action_excludedprops));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_msm_impl_actions_order_children_action_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_msm_impl_actions_page_move_action_factory(post, apply, delete, action, location, propertylist, cq_wcm_msm_action_excludednodetypes, cq_wcm_msm_action_excludedparagraphitems, cq_wcm_msm_action_excludedprops, cq_wcm_msm_impl_actions_pagemove_prop_reference_update)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.PageMoveActionFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.wcm.msm.action.excludednodetypes=%s&cq.wcm.msm.action.excludedparagraphitems=%s&cq.wcm.msm.action.excludedprops=%s&cq.wcm.msm.impl.actions.pagemove.prop_referenceUpdate=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_wcm_msm_action_excludednodetypes), http_util.encodeURIComponent(cq_wcm_msm_action_excludedparagraphitems), http_util.encodeURIComponent(cq_wcm_msm_action_excludedprops), http_util.encodeURIComponent(cq_wcm_msm_impl_actions_pagemove_prop_reference_update));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_msm_impl_actions_page_move_action_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_msm_impl_actions_references_update_action_factory(post, apply, delete, action, location, propertylist, cq_wcm_msm_action_excludednodetypes, cq_wcm_msm_action_excludedparagraphitems, cq_wcm_msm_action_excludedprops, cq_wcm_msm_impl_action_referencesupdate_prop_update_nested)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ReferencesUpdateActionFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.wcm.msm.action.excludednodetypes=%s&cq.wcm.msm.action.excludedparagraphitems=%s&cq.wcm.msm.action.excludedprops=%s&cq.wcm.msm.impl.action.referencesupdate.prop_updateNested=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_wcm_msm_action_excludednodetypes), http_util.encodeURIComponent(cq_wcm_msm_action_excludedparagraphitems), http_util.encodeURIComponent(cq_wcm_msm_action_excludedprops), http_util.encodeURIComponent(cq_wcm_msm_impl_action_referencesupdate_prop_update_nested));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_msm_impl_actions_references_update_action_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_msm_impl_actions_version_copy_action_factory(post, apply, delete, action, location, propertylist, cq_wcm_msm_action_excludednodetypes, cq_wcm_msm_action_excludedparagraphitems, cq_wcm_msm_action_excludedprops)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.VersionCopyActionFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.wcm.msm.action.excludednodetypes=%s&cq.wcm.msm.action.excludedparagraphitems=%s&cq.wcm.msm.action.excludedprops=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_wcm_msm_action_excludednodetypes), http_util.encodeURIComponent(cq_wcm_msm_action_excludedparagraphitems), http_util.encodeURIComponent(cq_wcm_msm_action_excludedprops));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_msm_impl_actions_version_copy_action_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_msm_impl_live_relationship_manager_impl(post, apply, delete, action, location, propertylist, liverelationshipmgr_relationsconfig_default)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.msm.impl.LiveRelationshipManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&liverelationshipmgr.relationsconfig.default=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(liverelationshipmgr_relationsconfig_default));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_msm_impl_live_relationship_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_msm_impl_rollout_manager_impl(post, apply, delete, action, location, propertylist, event_filter, rolloutmgr_excludedprops_default, rolloutmgr_excludedparagraphprops_default, rolloutmgr_excludednodetypes_default, rolloutmgr_threadpool_maxsize, rolloutmgr_threadpool_maxshutdowntime, rolloutmgr_threadpool_priority, rolloutmgr_commit_size, rolloutmgr_conflicthandling_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.msm.impl.RolloutManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.filter=%s&rolloutmgr.excludedprops.default=%s&rolloutmgr.excludedparagraphprops.default=%s&rolloutmgr.excludednodetypes.default=%s&rolloutmgr.threadpool.maxsize=%s&rolloutmgr.threadpool.maxshutdowntime=%s&rolloutmgr.threadpool.priority=%s&rolloutmgr.commit.size=%s&rolloutmgr.conflicthandling.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_filter), http_util.encodeURIComponent(rolloutmgr_excludedprops_default), http_util.encodeURIComponent(rolloutmgr_excludedparagraphprops_default), http_util.encodeURIComponent(rolloutmgr_excludednodetypes_default), http_util.encodeURIComponent(rolloutmgr_threadpool_maxsize), http_util.encodeURIComponent(rolloutmgr_threadpool_maxshutdowntime), http_util.encodeURIComponent(rolloutmgr_threadpool_priority), http_util.encodeURIComponent(rolloutmgr_commit_size), http_util.encodeURIComponent(rolloutmgr_conflicthandling_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_msm_impl_rollout_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_msm_impl_servlets_audit_log_servlet(post, apply, delete, action, location, propertylist, auditlogservlet_default_events_count, auditlogservlet_default_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.msm.impl.servlets.AuditLogServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&auditlogservlet.default.events.count=%s&auditlogservlet.default.path=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(auditlogservlet_default_events_count), http_util.encodeURIComponent(auditlogservlet_default_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_msm_impl_servlets_audit_log_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_notification_email_impl_email_channel(post, apply, delete, action, location, propertylist, email_from)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.notification.email.impl.EmailChannel?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&email.from=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(email_from));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_notification_email_impl_email_channel_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_notification_impl_notification_manager_impl(post, apply, delete, action, location, propertylist, event_topics)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.notification.impl.NotificationManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.topics=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_topics));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_notification_impl_notification_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_scripting_impl_bvp_manager(post, apply, delete, action, location, propertylist, com_day_cq_wcm_scripting_bvp_script_engines)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.scripting.impl.BVPManager?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&com.day.cq.wcm.scripting.bvp.script.engines=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(com_day_cq_wcm_scripting_bvp_script_engines));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_scripting_impl_bvp_manager_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_undo_undo_config(post, apply, delete, action, location, propertylist, cq_wcm_undo_enabled, cq_wcm_undo_path, cq_wcm_undo_validity, cq_wcm_undo_steps, cq_wcm_undo_persistence, cq_wcm_undo_persistence_mode, cq_wcm_undo_markermode, cq_wcm_undo_whitelist, cq_wcm_undo_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.undo.UndoConfig?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cq.wcm.undo.enabled=%s&cq.wcm.undo.path=%s&cq.wcm.undo.validity=%s&cq.wcm.undo.steps=%s&cq.wcm.undo.persistence=%s&cq.wcm.undo.persistence.mode=%s&cq.wcm.undo.markermode=%s&cq.wcm.undo.whitelist=%s&cq.wcm.undo.blacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cq_wcm_undo_enabled), http_util.encodeURIComponent(cq_wcm_undo_path), http_util.encodeURIComponent(cq_wcm_undo_validity), http_util.encodeURIComponent(cq_wcm_undo_steps), http_util.encodeURIComponent(cq_wcm_undo_persistence), http_util.encodeURIComponent(cq_wcm_undo_persistence_mode), http_util.encodeURIComponent(cq_wcm_undo_markermode), http_util.encodeURIComponent(cq_wcm_undo_whitelist), http_util.encodeURIComponent(cq_wcm_undo_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_undo_undo_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_webservicesupport_impl_replication_event_listener(post, apply, delete, action, location, propertylist, flush_agents)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.webservicesupport.impl.ReplicationEventListener?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&Flush agents=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(flush_agents));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_webservicesupport_impl_replication_event_listener_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_workflow_impl_wcm_workflow_service_impl(post, apply, delete, action, location, propertylist, event_filter, min_thread_pool_size, max_thread_pool_size, cq_wcm_workflow_terminate_on_activate, cq_wcm_worklfow_terminate_exclusion_list)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.workflow.impl.WcmWorkflowServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&event.filter=%s&minThreadPoolSize=%s&maxThreadPoolSize=%s&cq.wcm.workflow.terminate.on.activate=%s&cq.wcm.worklfow.terminate.exclusion.list=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(event_filter), http_util.encodeURIComponent(min_thread_pool_size), http_util.encodeURIComponent(max_thread_pool_size), http_util.encodeURIComponent(cq_wcm_workflow_terminate_on_activate), http_util.encodeURIComponent(cq_wcm_worklfow_terminate_exclusion_list));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_workflow_impl_wcm_workflow_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_wcm_workflow_impl_workflow_package_info_provider(post, apply, delete, action, location, propertylist, workflowpackageinfoprovider_filter, workflowpackageinfoprovider_filter_rootpath)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.wcm.workflow.impl.WorkflowPackageInfoProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&workflowpackageinfoprovider.filter=%s&workflowpackageinfoprovider.filter.rootpath=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(workflowpackageinfoprovider_filter), http_util.encodeURIComponent(workflowpackageinfoprovider_filter_rootpath));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_wcm_workflow_impl_workflow_package_info_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_widget_impl_html_library_manager_impl(post, apply, delete, action, location, propertylist, htmllibmanager_clientmanager, htmllibmanager_debug, htmllibmanager_debug_console, htmllibmanager_debug_init_js, htmllibmanager_defaultthemename, htmllibmanager_defaultuserthemename, htmllibmanager_firebuglite_path, htmllibmanager_force_cq_url_info, htmllibmanager_gzip, htmllibmanager_maxage, htmllibmanager_max_data_uri_size, htmllibmanager_minify, htmllibmanager_path_list, htmllibmanager_timing)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.widget.impl.HtmlLibraryManagerImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&htmllibmanager.clientmanager=%s&htmllibmanager.debug=%s&htmllibmanager.debug.console=%s&htmllibmanager.debug.init.js=%s&htmllibmanager.defaultthemename=%s&htmllibmanager.defaultuserthemename=%s&htmllibmanager.firebuglite.path=%s&htmllibmanager.forceCQUrlInfo=%s&htmllibmanager.gzip=%s&htmllibmanager.maxage=%s&htmllibmanager.maxDataUriSize=%s&htmllibmanager.minify=%s&htmllibmanager.path.list=%s&htmllibmanager.timing=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(htmllibmanager_clientmanager), http_util.encodeURIComponent(htmllibmanager_debug), http_util.encodeURIComponent(htmllibmanager_debug_console), http_util.encodeURIComponent(htmllibmanager_debug_init_js), http_util.encodeURIComponent(htmllibmanager_defaultthemename), http_util.encodeURIComponent(htmllibmanager_defaultuserthemename), http_util.encodeURIComponent(htmllibmanager_firebuglite_path), http_util.encodeURIComponent(htmllibmanager_force_cq_url_info), http_util.encodeURIComponent(htmllibmanager_gzip), http_util.encodeURIComponent(htmllibmanager_maxage), http_util.encodeURIComponent(htmllibmanager_max_data_uri_size), http_util.encodeURIComponent(htmllibmanager_minify), http_util.encodeURIComponent(htmllibmanager_path_list), http_util.encodeURIComponent(htmllibmanager_timing));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_widget_impl_html_library_manager_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_widget_impl_widget_extension_provider_impl(post, apply, delete, action, location, propertylist, extendable_widgets, widgetextensionprovider_debug)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.widget.impl.WidgetExtensionProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&extendable.widgets=%s&widgetextensionprovider.debug=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(extendable_widgets), http_util.encodeURIComponent(widgetextensionprovider_debug));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_widget_impl_widget_extension_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_workflow_impl_email_e_mail_notification_service(post, apply, delete, action, location, propertylist, from_address, host_prefix, notify_onabort, notify_oncomplete, notify_oncontainercomplete, notify_useronly)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.workflow.impl.email.EMailNotificationService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&from.address=%s&host.prefix=%s&notify.onabort=%s&notify.oncomplete=%s&notify.oncontainercomplete=%s&notify.useronly=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(from_address), http_util.encodeURIComponent(host_prefix), http_util.encodeURIComponent(notify_onabort), http_util.encodeURIComponent(notify_oncomplete), http_util.encodeURIComponent(notify_oncontainercomplete), http_util.encodeURIComponent(notify_useronly));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_workflow_impl_email_e_mail_notification_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_cq_workflow_impl_email_task_e_mail_notification_service(post, apply, delete, action, location, propertylist, notify_onupdate, notify_oncomplete)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.cq.workflow.impl.email.TaskEMailNotificationService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&notify.onupdate=%s&notify.oncomplete=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(notify_onupdate), http_util.encodeURIComponent(notify_oncomplete));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_cq_workflow_impl_email_task_e_mail_notification_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_crx_security_token_impl_impl_token_authentication_handler(post, apply, delete, action, location, propertylist, path, token_required_attr, token_alternate_url, token_encapsulated, skip_token_refresh)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.crx.security.token.impl.impl.TokenAuthenticationHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path=%s&token.required.attr=%s&token.alternate.url=%s&token.encapsulated=%s&skip.token.refresh=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path), http_util.encodeURIComponent(token_required_attr), http_util.encodeURIComponent(token_alternate_url), http_util.encodeURIComponent(token_encapsulated), http_util.encodeURIComponent(skip_token_refresh));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_crx_security_token_impl_impl_token_authentication_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:com_day_crx_security_token_impl_token_cleanup_task(post, apply, delete, action, location, propertylist, enable_token_cleanup_task, scheduler_expression, batch_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/com.day.crx.security.token.impl.TokenCleanupTask?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enable.token.cleanup.task=%s&scheduler.expression=%s&batch.size=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enable_token_cleanup_task), http_util.encodeURIComponent(scheduler_expression), http_util.encodeURIComponent(batch_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_com_day_crx_security_token_impl_token_cleanup_task_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:guide_localization_service(post, apply, delete, action, location, propertylist, supported_locales, localizable_properties)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/Guide Localization Service?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&supportedLocales=%s&Localizable Properties=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(supported_locales), http_util.encodeURIComponent(localizable_properties));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_guide_localization_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:messaging_user_component_factory(post, apply, delete, action, location, propertylist, priority)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/MessagingUserComponentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&priority=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(priority));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_messaging_user_component_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_aries_jmx_framework_state_config(post, apply, delete, action, location, propertylist, attribute_change_notification_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.aries.jmx.framework.StateConfig?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&attributeChangeNotificationEnabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(attribute_change_notification_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_aries_jmx_framework_state_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_eventadmin_impl_event_admin(post, apply, delete, action, location, propertylist, org_apache_felix_eventadmin_thread_pool_size, org_apache_felix_eventadmin_async_to_sync_thread_ratio, org_apache_felix_eventadmin_timeout, org_apache_felix_eventadmin_require_topic, org_apache_felix_eventadmin_ignore_timeout, org_apache_felix_eventadmin_ignore_topic)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.eventadmin.impl.EventAdmin?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&org.apache.felix.eventadmin.ThreadPoolSize=%s&org.apache.felix.eventadmin.AsyncToSyncThreadRatio=%s&org.apache.felix.eventadmin.Timeout=%s&org.apache.felix.eventadmin.RequireTopic=%s&org.apache.felix.eventadmin.IgnoreTimeout=%s&org.apache.felix.eventadmin.IgnoreTopic=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(org_apache_felix_eventadmin_thread_pool_size), http_util.encodeURIComponent(org_apache_felix_eventadmin_async_to_sync_thread_ratio), http_util.encodeURIComponent(org_apache_felix_eventadmin_timeout), http_util.encodeURIComponent(org_apache_felix_eventadmin_require_topic), http_util.encodeURIComponent(org_apache_felix_eventadmin_ignore_timeout), http_util.encodeURIComponent(org_apache_felix_eventadmin_ignore_topic));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_eventadmin_impl_event_admin_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_http(post, apply, delete, action, location, propertylist, org_apache_felix_http_host, org_apache_felix_http_enable, org_osgi_service_http_port, org_apache_felix_http_timeout, org_apache_felix_https_enable, org_osgi_service_http_port_secure, org_apache_felix_https_keystore, org_apache_felix_https_keystore_password, org_apache_felix_https_keystore_key_password, org_apache_felix_https_truststore, org_apache_felix_https_truststore_password, org_apache_felix_https_clientcertificate, org_apache_felix_http_context_path, org_apache_felix_http_mbeans, org_apache_felix_http_session_timeout, org_apache_felix_http_jetty_threadpool_max, org_apache_felix_http_jetty_acceptors, org_apache_felix_http_jetty_selectors, org_apache_felix_http_jetty_header_buffer_size, org_apache_felix_http_jetty_request_buffer_size, org_apache_felix_http_jetty_response_buffer_size, org_apache_felix_http_jetty_max_form_size, org_apache_felix_http_path_exclusions, org_apache_felix_https_jetty_ciphersuites_excluded, org_apache_felix_https_jetty_ciphersuites_included, org_apache_felix_http_jetty_send_server_header, org_apache_felix_https_jetty_protocols_included, org_apache_felix_https_jetty_protocols_excluded, org_apache_felix_proxy_load_balancer_connection_enable, org_apache_felix_https_jetty_renegotiate_allowed, org_apache_felix_https_jetty_session_cookie_http_only, org_apache_felix_https_jetty_session_cookie_secure, org_eclipse_jetty_servlet_session_id_path_parameter_name, org_eclipse_jetty_servlet_checking_remote_session_id_encoding, org_eclipse_jetty_servlet_session_cookie, org_eclipse_jetty_servlet_session_domain, org_eclipse_jetty_servlet_session_path, org_eclipse_jetty_servlet_max_age, org_apache_felix_http_name, org_apache_felix_jetty_gziphandler_enable, org_apache_felix_jetty_gzip_min_gzip_size, org_apache_felix_jetty_gzip_compression_level, org_apache_felix_jetty_gzip_inflate_buffer_size, org_apache_felix_jetty_gzip_sync_flush, org_apache_felix_jetty_gzip_excluded_user_agents, org_apache_felix_jetty_gzip_included_methods, org_apache_felix_jetty_gzip_excluded_methods, org_apache_felix_jetty_gzip_included_paths, org_apache_felix_jetty_gzip_excluded_paths, org_apache_felix_jetty_gzip_included_mime_types, org_apache_felix_jetty_gzip_excluded_mime_types, org_apache_felix_http_session_invalidate, org_apache_felix_http_session_uniqueid)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.http?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&org.apache.felix.http.host=%s&org.apache.felix.http.enable=%s&org.osgi.service.http.port=%s&org.apache.felix.http.timeout=%s&org.apache.felix.https.enable=%s&org.osgi.service.http.port.secure=%s&org.apache.felix.https.keystore=%s&org.apache.felix.https.keystore.password=%s&org.apache.felix.https.keystore.key.password=%s&org.apache.felix.https.truststore=%s&org.apache.felix.https.truststore.password=%s&org.apache.felix.https.clientcertificate=%s&org.apache.felix.http.context_path=%s&org.apache.felix.http.mbeans=%s&org.apache.felix.http.session.timeout=%s&org.apache.felix.http.jetty.threadpool.max=%s&org.apache.felix.http.jetty.acceptors=%s&org.apache.felix.http.jetty.selectors=%s&org.apache.felix.http.jetty.headerBufferSize=%s&org.apache.felix.http.jetty.requestBufferSize=%s&org.apache.felix.http.jetty.responseBufferSize=%s&org.apache.felix.http.jetty.maxFormSize=%s&org.apache.felix.http.path_exclusions=%s&org.apache.felix.https.jetty.ciphersuites.excluded=%s&org.apache.felix.https.jetty.ciphersuites.included=%s&org.apache.felix.http.jetty.sendServerHeader=%s&org.apache.felix.https.jetty.protocols.included=%s&org.apache.felix.https.jetty.protocols.excluded=%s&org.apache.felix.proxy.load.balancer.connection.enable=%s&org.apache.felix.https.jetty.renegotiateAllowed=%s&org.apache.felix.https.jetty.session.cookie.httpOnly=%s&org.apache.felix.https.jetty.session.cookie.secure=%s&org.eclipse.jetty.servlet.SessionIdPathParameterName=%s&org.eclipse.jetty.servlet.CheckingRemoteSessionIdEncoding=%s&org.eclipse.jetty.servlet.SessionCookie=%s&org.eclipse.jetty.servlet.SessionDomain=%s&org.eclipse.jetty.servlet.SessionPath=%s&org.eclipse.jetty.servlet.MaxAge=%s&org.apache.felix.http.name=%s&org.apache.felix.jetty.gziphandler.enable=%s&org.apache.felix.jetty.gzip.minGzipSize=%s&org.apache.felix.jetty.gzip.compressionLevel=%s&org.apache.felix.jetty.gzip.inflateBufferSize=%s&org.apache.felix.jetty.gzip.syncFlush=%s&org.apache.felix.jetty.gzip.excludedUserAgents=%s&org.apache.felix.jetty.gzip.includedMethods=%s&org.apache.felix.jetty.gzip.excludedMethods=%s&org.apache.felix.jetty.gzip.includedPaths=%s&org.apache.felix.jetty.gzip.excludedPaths=%s&org.apache.felix.jetty.gzip.includedMimeTypes=%s&org.apache.felix.jetty.gzip.excludedMimeTypes=%s&org.apache.felix.http.session.invalidate=%s&org.apache.felix.http.session.uniqueid=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(org_apache_felix_http_host), http_util.encodeURIComponent(org_apache_felix_http_enable), http_util.encodeURIComponent(org_osgi_service_http_port), http_util.encodeURIComponent(org_apache_felix_http_timeout), http_util.encodeURIComponent(org_apache_felix_https_enable), http_util.encodeURIComponent(org_osgi_service_http_port_secure), http_util.encodeURIComponent(org_apache_felix_https_keystore), http_util.encodeURIComponent(org_apache_felix_https_keystore_password), http_util.encodeURIComponent(org_apache_felix_https_keystore_key_password), http_util.encodeURIComponent(org_apache_felix_https_truststore), http_util.encodeURIComponent(org_apache_felix_https_truststore_password), http_util.encodeURIComponent(org_apache_felix_https_clientcertificate), http_util.encodeURIComponent(org_apache_felix_http_context_path), http_util.encodeURIComponent(org_apache_felix_http_mbeans), http_util.encodeURIComponent(org_apache_felix_http_session_timeout), http_util.encodeURIComponent(org_apache_felix_http_jetty_threadpool_max), http_util.encodeURIComponent(org_apache_felix_http_jetty_acceptors), http_util.encodeURIComponent(org_apache_felix_http_jetty_selectors), http_util.encodeURIComponent(org_apache_felix_http_jetty_header_buffer_size), http_util.encodeURIComponent(org_apache_felix_http_jetty_request_buffer_size), http_util.encodeURIComponent(org_apache_felix_http_jetty_response_buffer_size), http_util.encodeURIComponent(org_apache_felix_http_jetty_max_form_size), http_util.encodeURIComponent(org_apache_felix_http_path_exclusions), http_util.encodeURIComponent(org_apache_felix_https_jetty_ciphersuites_excluded), http_util.encodeURIComponent(org_apache_felix_https_jetty_ciphersuites_included), http_util.encodeURIComponent(org_apache_felix_http_jetty_send_server_header), http_util.encodeURIComponent(org_apache_felix_https_jetty_protocols_included), http_util.encodeURIComponent(org_apache_felix_https_jetty_protocols_excluded), http_util.encodeURIComponent(org_apache_felix_proxy_load_balancer_connection_enable), http_util.encodeURIComponent(org_apache_felix_https_jetty_renegotiate_allowed), http_util.encodeURIComponent(org_apache_felix_https_jetty_session_cookie_http_only), http_util.encodeURIComponent(org_apache_felix_https_jetty_session_cookie_secure), http_util.encodeURIComponent(org_eclipse_jetty_servlet_session_id_path_parameter_name), http_util.encodeURIComponent(org_eclipse_jetty_servlet_checking_remote_session_id_encoding), http_util.encodeURIComponent(org_eclipse_jetty_servlet_session_cookie), http_util.encodeURIComponent(org_eclipse_jetty_servlet_session_domain), http_util.encodeURIComponent(org_eclipse_jetty_servlet_session_path), http_util.encodeURIComponent(org_eclipse_jetty_servlet_max_age), http_util.encodeURIComponent(org_apache_felix_http_name), http_util.encodeURIComponent(org_apache_felix_jetty_gziphandler_enable), http_util.encodeURIComponent(org_apache_felix_jetty_gzip_min_gzip_size), http_util.encodeURIComponent(org_apache_felix_jetty_gzip_compression_level), http_util.encodeURIComponent(org_apache_felix_jetty_gzip_inflate_buffer_size), http_util.encodeURIComponent(org_apache_felix_jetty_gzip_sync_flush), http_util.encodeURIComponent(org_apache_felix_jetty_gzip_excluded_user_agents), http_util.encodeURIComponent(org_apache_felix_jetty_gzip_included_methods), http_util.encodeURIComponent(org_apache_felix_jetty_gzip_excluded_methods), http_util.encodeURIComponent(org_apache_felix_jetty_gzip_included_paths), http_util.encodeURIComponent(org_apache_felix_jetty_gzip_excluded_paths), http_util.encodeURIComponent(org_apache_felix_jetty_gzip_included_mime_types), http_util.encodeURIComponent(org_apache_felix_jetty_gzip_excluded_mime_types), http_util.encodeURIComponent(org_apache_felix_http_session_invalidate), http_util.encodeURIComponent(org_apache_felix_http_session_uniqueid));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_http_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_http_sslfilter_ssl_filter(post, apply, delete, action, location, propertylist, ssl_forward_header, ssl_forward_value, ssl_forward_cert_header, rewrite_absolute_urls)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.http.sslfilter.SslFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&ssl-forward.header=%s&ssl-forward.value=%s&ssl-forward-cert.header=%s&rewrite.absolute.urls=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(ssl_forward_header), http_util.encodeURIComponent(ssl_forward_value), http_util.encodeURIComponent(ssl_forward_cert_header), http_util.encodeURIComponent(rewrite_absolute_urls));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_http_sslfilter_ssl_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_jaas_configuration_factory(post, apply, delete, action, location, propertylist, jaas_control_flag, jaas_ranking, jaas_realm_name, jaas_classname, jaas_options)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.jaas.Configuration.factory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&jaas.controlFlag=%s&jaas.ranking=%s&jaas.realmName=%s&jaas.classname=%s&jaas.options=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(jaas_control_flag), http_util.encodeURIComponent(jaas_ranking), http_util.encodeURIComponent(jaas_realm_name), http_util.encodeURIComponent(jaas_classname), http_util.encodeURIComponent(jaas_options));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_jaas_configuration_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_jaas_configuration_spi(post, apply, delete, action, location, propertylist, jaas_default_realm_name, jaas_config_provider_name, jaas_global_config_policy)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.jaas.ConfigurationSpi?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&jaas.defaultRealmName=%s&jaas.configProviderName=%s&jaas.globalConfigPolicy=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(jaas_default_realm_name), http_util.encodeURIComponent(jaas_config_provider_name), http_util.encodeURIComponent(jaas_global_config_policy));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_jaas_configuration_spi_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_scr_scr_service(post, apply, delete, action, location, propertylist, ds_loglevel, ds_factory_enabled, ds_delayed_keep_instances, ds_lock_timeout_milliseconds, ds_stop_timeout_milliseconds, ds_global_extender)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.scr.ScrService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&ds.loglevel=%s&ds.factory.enabled=%s&ds.delayed.keepInstances=%s&ds.lock.timeout.milliseconds=%s&ds.stop.timeout.milliseconds=%s&ds.global.extender=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(ds_loglevel), http_util.encodeURIComponent(ds_factory_enabled), http_util.encodeURIComponent(ds_delayed_keep_instances), http_util.encodeURIComponent(ds_lock_timeout_milliseconds), http_util.encodeURIComponent(ds_stop_timeout_milliseconds), http_util.encodeURIComponent(ds_global_extender));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_scr_scr_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_systemready_impl_components_check(post, apply, delete, action, location, propertylist, components_list, type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.systemready.impl.ComponentsCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&components.list=%s&type=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(components_list), http_util.encodeURIComponent(type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_systemready_impl_components_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_systemready_impl_framework_start_check(post, apply, delete, action, location, propertylist, timeout, target_start_level, target_start_level_prop_name, type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.systemready.impl.FrameworkStartCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&timeout=%s&target.start.level=%s&target.start.level.prop.name=%s&type=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(timeout), http_util.encodeURIComponent(target_start_level), http_util.encodeURIComponent(target_start_level_prop_name), http_util.encodeURIComponent(type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_systemready_impl_framework_start_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_systemready_impl_services_check(post, apply, delete, action, location, propertylist, services_list, type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.systemready.impl.ServicesCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&services.list=%s&type=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(services_list), http_util.encodeURIComponent(type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_systemready_impl_services_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_systemready_impl_servlet_system_alive_servlet(post, apply, delete, action, location, propertylist, osgi_http_whiteboard_servlet_pattern, osgi_http_whiteboard_context_select)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.systemready.impl.servlet.SystemAliveServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&osgi.http.whiteboard.servlet.pattern=%s&osgi.http.whiteboard.context.select=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(osgi_http_whiteboard_servlet_pattern), http_util.encodeURIComponent(osgi_http_whiteboard_context_select));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_systemready_impl_servlet_system_alive_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_systemready_impl_servlet_system_ready_servlet(post, apply, delete, action, location, propertylist, osgi_http_whiteboard_servlet_pattern, osgi_http_whiteboard_context_select)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.systemready.impl.servlet.SystemReadyServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&osgi.http.whiteboard.servlet.pattern=%s&osgi.http.whiteboard.context.select=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(osgi_http_whiteboard_servlet_pattern), http_util.encodeURIComponent(osgi_http_whiteboard_context_select));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_systemready_impl_servlet_system_ready_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_systemready_system_ready_monitor(post, apply, delete, action, location, propertylist, poll_interval)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.systemready.SystemReadyMonitor?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&poll.interval=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(poll_interval));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_systemready_system_ready_monitor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_webconsole_internal_servlet_osgi_manager(post, apply, delete, action, location, propertylist, manager_root, http_service_filter, default_render, realm, username, password, category, locale, loglevel, plugins)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.webconsole.internal.servlet.OsgiManager?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&manager.root=%s&http.service.filter=%s&default.render=%s&realm=%s&username=%s&password=%s&category=%s&locale=%s&loglevel=%s&plugins=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(manager_root), http_util.encodeURIComponent(http_service_filter), http_util.encodeURIComponent(default_render), http_util.encodeURIComponent(realm), http_util.encodeURIComponent(username), http_util.encodeURIComponent(password), http_util.encodeURIComponent(category), http_util.encodeURIComponent(locale), http_util.encodeURIComponent(loglevel), http_util.encodeURIComponent(plugins));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_webconsole_internal_servlet_osgi_manager_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_webconsole_plugins_event_internal_plugin_servlet(post, apply, delete, action, location, propertylist, max_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.webconsole.plugins.event.internal.PluginServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&max.size=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_webconsole_plugins_event_internal_plugin_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_felix_webconsole_plugins_memoryusage_internal_memory_usage_co(post, apply, delete, action, location, propertylist, felix_memoryusage_dump_threshold, felix_memoryusage_dump_interval, felix_memoryusage_dump_location)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.felix.webconsole.plugins.memoryusage.internal.MemoryUsageConfigurator?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&felix.memoryusage.dump.threshold=%s&felix.memoryusage.dump.interval=%s&felix.memoryusage.dump.location=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(felix_memoryusage_dump_threshold), http_util.encodeURIComponent(felix_memoryusage_dump_interval), http_util.encodeURIComponent(felix_memoryusage_dump_location));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_felix_webconsole_plugins_memoryusage_internal_memory_usage_co_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_http_proxyconfigurator(post, apply, delete, action, location, propertylist, proxy_enabled, proxy_host, proxy_port, proxy_user, proxy_password, proxy_exceptions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.http.proxyconfigurator?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&proxy.enabled=%s&proxy.host=%s&proxy.port=%s&proxy.user=%s&proxy.password=%s&proxy.exceptions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(proxy_enabled), http_util.encodeURIComponent(proxy_host), http_util.encodeURIComponent(proxy_port), http_util.encodeURIComponent(proxy_user), http_util.encodeURIComponent(proxy_password), http_util.encodeURIComponent(proxy_exceptions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_http_proxyconfigurator_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_blob_datastore_data_store_text_provider(post, apply, delete, action, location, propertylist, dir)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.blob.datastore.DataStoreTextProviderService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&dir=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(dir));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_blob_datastore_data_store_text_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_blob_datastore_file_data_store(post, apply, delete, action, location, propertylist, path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.blob.datastore.FileDataStore?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_blob_datastore_file_data_store_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_document_document_node_store_service(post, apply, delete, action, location, propertylist, mongouri, db, socket_keep_alive, cache, node_cache_percentage, prev_doc_cache_percentage, children_cache_percentage, diff_cache_percentage, cache_segment_count, cache_stack_move_distance, blob_cache_size, persistent_cache, journal_cache, custom_blob_store, journal_gc_interval, journal_gc_max_age, prefetch_external_changes, role, version_gc_max_age_in_secs, version_gc_expression, version_gc_time_limit_in_secs, blob_gc_max_age_in_secs, blob_track_snapshot_interval_in_secs, repository_home, max_replication_lag_in_secs, document_store_type, bundling_disabled, update_limit, persistent_cache_includes, lease_check_mode)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&mongouri=%s&db=%s&socketKeepAlive=%s&cache=%s&nodeCachePercentage=%s&prevDocCachePercentage=%s&childrenCachePercentage=%s&diffCachePercentage=%s&cacheSegmentCount=%s&cacheStackMoveDistance=%s&blobCacheSize=%s&persistentCache=%s&journalCache=%s&customBlobStore=%s&journalGCInterval=%s&journalGCMaxAge=%s&prefetchExternalChanges=%s&role=%s&versionGcMaxAgeInSecs=%s&versionGCExpression=%s&versionGCTimeLimitInSecs=%s&blobGcMaxAgeInSecs=%s&blobTrackSnapshotIntervalInSecs=%s&repository.home=%s&maxReplicationLagInSecs=%s&documentStoreType=%s&bundlingDisabled=%s&updateLimit=%s&persistentCacheIncludes=%s&leaseCheckMode=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(mongouri), http_util.encodeURIComponent(db), http_util.encodeURIComponent(socket_keep_alive), http_util.encodeURIComponent(cache), http_util.encodeURIComponent(node_cache_percentage), http_util.encodeURIComponent(prev_doc_cache_percentage), http_util.encodeURIComponent(children_cache_percentage), http_util.encodeURIComponent(diff_cache_percentage), http_util.encodeURIComponent(cache_segment_count), http_util.encodeURIComponent(cache_stack_move_distance), http_util.encodeURIComponent(blob_cache_size), http_util.encodeURIComponent(persistent_cache), http_util.encodeURIComponent(journal_cache), http_util.encodeURIComponent(custom_blob_store), http_util.encodeURIComponent(journal_gc_interval), http_util.encodeURIComponent(journal_gc_max_age), http_util.encodeURIComponent(prefetch_external_changes), http_util.encodeURIComponent(role), http_util.encodeURIComponent(version_gc_max_age_in_secs), http_util.encodeURIComponent(version_gc_expression), http_util.encodeURIComponent(version_gc_time_limit_in_secs), http_util.encodeURIComponent(blob_gc_max_age_in_secs), http_util.encodeURIComponent(blob_track_snapshot_interval_in_secs), http_util.encodeURIComponent(repository_home), http_util.encodeURIComponent(max_replication_lag_in_secs), http_util.encodeURIComponent(document_store_type), http_util.encodeURIComponent(bundling_disabled), http_util.encodeURIComponent(update_limit), http_util.encodeURIComponent(persistent_cache_includes), http_util.encodeURIComponent(lease_check_mode));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_document_document_node_store_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_document_document_node_store_service_pre(post, apply, delete, action, location, propertylist, persistent_cache_includes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreServicePreset?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&persistentCacheIncludes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(persistent_cache_includes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_document_document_node_store_service_pre_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_document_secondary_secondary_store_cac(post, apply, delete, action, location, propertylist, included_paths, enable_async_observer, observer_queue_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.secondary.SecondaryStoreCacheService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&includedPaths=%s&enableAsyncObserver=%s&observerQueueSize=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(included_paths), http_util.encodeURIComponent(enable_async_observer), http_util.encodeURIComponent(observer_queue_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_document_secondary_secondary_store_cac_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_index_async_indexer_service(post, apply, delete, action, location, propertylist, async_configs, lease_time_out_minutes, failing_index_timeout_seconds, error_warn_interval_seconds)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.AsyncIndexerService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&asyncConfigs=%s&leaseTimeOutMinutes=%s&failingIndexTimeoutSeconds=%s&errorWarnIntervalSeconds=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(async_configs), http_util.encodeURIComponent(lease_time_out_minutes), http_util.encodeURIComponent(failing_index_timeout_seconds), http_util.encodeURIComponent(error_warn_interval_seconds));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_index_async_indexer_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_index_lucene_lucene_index_provider_serv(post, apply, delete, action, location, propertylist, disabled, debug, local_index_dir, enable_open_index_async, thread_pool_size, prefetch_index_files, extracted_text_cache_size_in_mb, extracted_text_cache_expiry_in_secs, always_use_pre_extracted_cache, boolean_clause_limit, enable_hybrid_indexing, hybrid_queue_size, disable_stored_index_definition, deleted_blobs_collection_enabled, prop_index_cleaner_interval_in_secs, enable_single_blob_index_files)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexProviderService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&disabled=%s&debug=%s&localIndexDir=%s&enableOpenIndexAsync=%s&threadPoolSize=%s&prefetchIndexFiles=%s&extractedTextCacheSizeInMB=%s&extractedTextCacheExpiryInSecs=%s&alwaysUsePreExtractedCache=%s&booleanClauseLimit=%s&enableHybridIndexing=%s&hybridQueueSize=%s&disableStoredIndexDefinition=%s&deletedBlobsCollectionEnabled=%s&propIndexCleanerIntervalInSecs=%s&enableSingleBlobIndexFiles=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(disabled), http_util.encodeURIComponent(debug), http_util.encodeURIComponent(local_index_dir), http_util.encodeURIComponent(enable_open_index_async), http_util.encodeURIComponent(thread_pool_size), http_util.encodeURIComponent(prefetch_index_files), http_util.encodeURIComponent(extracted_text_cache_size_in_mb), http_util.encodeURIComponent(extracted_text_cache_expiry_in_secs), http_util.encodeURIComponent(always_use_pre_extracted_cache), http_util.encodeURIComponent(boolean_clause_limit), http_util.encodeURIComponent(enable_hybrid_indexing), http_util.encodeURIComponent(hybrid_queue_size), http_util.encodeURIComponent(disable_stored_index_definition), http_util.encodeURIComponent(deleted_blobs_collection_enabled), http_util.encodeURIComponent(prop_index_cleaner_interval_in_secs), http_util.encodeURIComponent(enable_single_blob_index_files));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_index_lucene_lucene_index_provider_serv_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_index_solr_osgi_embedded_solr_server_co(post, apply, delete, action, location, propertylist, solr_home_path, solr_core_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.EmbeddedSolrServerConfigurationProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&solr.home.path=%s&solr.core.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(solr_home_path), http_util.encodeURIComponent(solr_core_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_index_solr_osgi_embedded_solr_server_co_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_index_solr_osgi_node_state_solr_servers(post, apply, delete, action, location, propertylist, enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.NodeStateSolrServersObserverService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_index_solr_osgi_node_state_solr_servers_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_index_solr_osgi_oak_solr_configuration(post, apply, delete, action, location, propertylist, path_desc_field, path_child_field, path_parent_field, path_exact_field, catch_all_field, collapsed_path_field, path_depth_field, commit_policy, rows, path_restrictions, property_restrictions, primarytypes_restrictions, ignored_properties, used_properties, type_mappings, property_mappings, collapse_jcrcontent_nodes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.OakSolrConfigurationProviderService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path.desc.field=%s&path.child.field=%s&path.parent.field=%s&path.exact.field=%s&catch.all.field=%s&collapsed.path.field=%s&path.depth.field=%s&commit.policy=%s&rows=%s&path.restrictions=%s&property.restrictions=%s&primarytypes.restrictions=%s&ignored.properties=%s&used.properties=%s&type.mappings=%s&property.mappings=%s&collapse.jcrcontent.nodes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path_desc_field), http_util.encodeURIComponent(path_child_field), http_util.encodeURIComponent(path_parent_field), http_util.encodeURIComponent(path_exact_field), http_util.encodeURIComponent(catch_all_field), http_util.encodeURIComponent(collapsed_path_field), http_util.encodeURIComponent(path_depth_field), http_util.encodeURIComponent(commit_policy), http_util.encodeURIComponent(rows), http_util.encodeURIComponent(path_restrictions), http_util.encodeURIComponent(property_restrictions), http_util.encodeURIComponent(primarytypes_restrictions), http_util.encodeURIComponent(ignored_properties), http_util.encodeURIComponent(used_properties), http_util.encodeURIComponent(type_mappings), http_util.encodeURIComponent(property_mappings), http_util.encodeURIComponent(collapse_jcrcontent_nodes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_index_solr_osgi_oak_solr_configuration_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_index_solr_osgi_remote_solr_server_conf(post, apply, delete, action, location, propertylist, solr_http_url, solr_zk_host, solr_collection, solr_socket_timeout, solr_connection_timeout, solr_shards_no, solr_replication_factor, solr_conf_dir)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.RemoteSolrServerConfigurationProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&solr.http.url=%s&solr.zk.host=%s&solr.collection=%s&solr.socket.timeout=%s&solr.connection.timeout=%s&solr.shards.no=%s&solr.replication.factor=%s&solr.conf.dir=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(solr_http_url), http_util.encodeURIComponent(solr_zk_host), http_util.encodeURIComponent(solr_collection), http_util.encodeURIComponent(solr_socket_timeout), http_util.encodeURIComponent(solr_connection_timeout), http_util.encodeURIComponent(solr_shards_no), http_util.encodeURIComponent(solr_replication_factor), http_util.encodeURIComponent(solr_conf_dir));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_index_solr_osgi_remote_solr_server_conf_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_index_solr_osgi_solr_query_index_provid(post, apply, delete, action, location, propertylist, query_aggregation)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.SolrQueryIndexProviderService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&query.aggregation=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(query_aggregation));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_index_solr_osgi_solr_query_index_provid_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_index_solr_osgi_solr_server_provider_se(post, apply, delete, action, location, propertylist, server_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.SolrServerProviderService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&server.type=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(server_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_index_solr_osgi_solr_server_provider_se_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_metric_statistics_provider_factory(post, apply, delete, action, location, propertylist, provider_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.metric.StatisticsProviderFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&providerType=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(provider_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_metric_statistics_provider_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_plugins_observation_change_collector_provider(post, apply, delete, action, location, propertylist, max_items, max_path_depth, enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.plugins.observation.ChangeCollectorProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&maxItems=%s&maxPathDepth=%s&enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_items), http_util.encodeURIComponent(max_path_depth), http_util.encodeURIComponent(enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_plugins_observation_change_collector_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_query_query_engine_settings_service(post, apply, delete, action, location, propertylist, query_limit_in_memory, query_limit_reads, query_fail_traversal, fast_query_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.query.QueryEngineSettingsService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&queryLimitInMemory=%s&queryLimitReads=%s&queryFailTraversal=%s&fastQuerySize=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(query_limit_in_memory), http_util.encodeURIComponent(query_limit_reads), http_util.encodeURIComponent(query_fail_traversal), http_util.encodeURIComponent(fast_query_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_query_query_engine_settings_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_security_authentication_authentication_config(post, apply, delete, action, location, propertylist, org_apache_jackrabbit_oak_authentication_app_name, org_apache_jackrabbit_oak_authentication_config_spi_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.AuthenticationConfigurationImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&org.apache.jackrabbit.oak.authentication.appName=%s&org.apache.jackrabbit.oak.authentication.configSpiName=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(org_apache_jackrabbit_oak_authentication_app_name), http_util.encodeURIComponent(org_apache_jackrabbit_oak_authentication_config_spi_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_security_authentication_authentication_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_security_authentication_ldap_impl_ldap_identi(post, apply, delete, action, location, propertylist, provider_name, host_name, host_port, host_ssl, host_tls, host_no_cert_check, bind_dn, bind_password, search_timeout, admin_pool_max_active, admin_pool_lookup_on_validate, user_pool_max_active, user_pool_lookup_on_validate, user_base_dn, user_objectclass, user_id_attribute, user_extra_filter, user_make_dn_path, group_base_dn, group_objectclass, group_name_attribute, group_extra_filter, group_make_dn_path, group_member_attribute, use_uid_for_ext_id, customattributes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&provider.name=%s&host.name=%s&host.port=%s&host.ssl=%s&host.tls=%s&host.noCertCheck=%s&bind.dn=%s&bind.password=%s&searchTimeout=%s&adminPool.maxActive=%s&adminPool.lookupOnValidate=%s&userPool.maxActive=%s&userPool.lookupOnValidate=%s&user.baseDN=%s&user.objectclass=%s&user.idAttribute=%s&user.extraFilter=%s&user.makeDnPath=%s&group.baseDN=%s&group.objectclass=%s&group.nameAttribute=%s&group.extraFilter=%s&group.makeDnPath=%s&group.memberAttribute=%s&useUidForExtId=%s&customattributes=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(provider_name), http_util.encodeURIComponent(host_name), http_util.encodeURIComponent(host_port), http_util.encodeURIComponent(host_ssl), http_util.encodeURIComponent(host_tls), http_util.encodeURIComponent(host_no_cert_check), http_util.encodeURIComponent(bind_dn), http_util.encodeURIComponent(bind_password), http_util.encodeURIComponent(search_timeout), http_util.encodeURIComponent(admin_pool_max_active), http_util.encodeURIComponent(admin_pool_lookup_on_validate), http_util.encodeURIComponent(user_pool_max_active), http_util.encodeURIComponent(user_pool_lookup_on_validate), http_util.encodeURIComponent(user_base_dn), http_util.encodeURIComponent(user_objectclass), http_util.encodeURIComponent(user_id_attribute), http_util.encodeURIComponent(user_extra_filter), http_util.encodeURIComponent(user_make_dn_path), http_util.encodeURIComponent(group_base_dn), http_util.encodeURIComponent(group_objectclass), http_util.encodeURIComponent(group_name_attribute), http_util.encodeURIComponent(group_extra_filter), http_util.encodeURIComponent(group_make_dn_path), http_util.encodeURIComponent(group_member_attribute), http_util.encodeURIComponent(use_uid_for_ext_id), http_util.encodeURIComponent(customattributes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_security_authentication_ldap_impl_ldap_identi_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_security_authentication_token_token_configura(post, apply, delete, action, location, propertylist, token_expiration, token_length, token_refresh, token_cleanup_threshold, password_hash_algorithm, password_hash_iterations, password_salt_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.token.TokenConfigurationImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&tokenExpiration=%s&tokenLength=%s&tokenRefresh=%s&tokenCleanupThreshold=%s&passwordHashAlgorithm=%s&passwordHashIterations=%s&passwordSaltSize=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(token_expiration), http_util.encodeURIComponent(token_length), http_util.encodeURIComponent(token_refresh), http_util.encodeURIComponent(token_cleanup_threshold), http_util.encodeURIComponent(password_hash_algorithm), http_util.encodeURIComponent(password_hash_iterations), http_util.encodeURIComponent(password_salt_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_security_authentication_token_token_configura_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_security_authorization_authorization_configur(post, apply, delete, action, location, propertylist, permissions_jr2, import_behavior, read_paths, administrative_principals, configuration_ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.security.authorization.AuthorizationConfigurationImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&permissionsJr2=%s&importBehavior=%s&readPaths=%s&administrativePrincipals=%s&configurationRanking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(permissions_jr2), http_util.encodeURIComponent(import_behavior), http_util.encodeURIComponent(read_paths), http_util.encodeURIComponent(administrative_principals), http_util.encodeURIComponent(configuration_ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_security_authorization_authorization_configur_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_security_internal_security_provider_registrati(post, apply, delete, action, location, propertylist, required_service_pids, authorization_composition_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.security.internal.SecurityProviderRegistration?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&requiredServicePids=%s&authorizationCompositionType=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(required_service_pids), http_util.encodeURIComponent(authorization_composition_type));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_security_internal_security_provider_registrati_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_security_user_random_authorizable_node_name(post, apply, delete, action, location, propertylist, length)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.security.user.RandomAuthorizableNodeName?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&length=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(length));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_security_user_random_authorizable_node_name_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_security_user_user_configuration_impl(post, apply, delete, action, location, propertylist, users_path, groups_path, system_relative_path, default_depth, import_behavior, password_hash_algorithm, password_hash_iterations, password_salt_size, omit_admin_pw, support_auto_save, password_max_age, initial_password_change, password_history_size, password_expiry_for_admin, cache_expiration, enable_rfc7613_usercase_mapped_profile)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.security.user.UserConfigurationImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&usersPath=%s&groupsPath=%s&systemRelativePath=%s&defaultDepth=%s&importBehavior=%s&passwordHashAlgorithm=%s&passwordHashIterations=%s&passwordSaltSize=%s&omitAdminPw=%s&supportAutoSave=%s&passwordMaxAge=%s&initialPasswordChange=%s&passwordHistorySize=%s&passwordExpiryForAdmin=%s&cacheExpiration=%s&enableRFC7613UsercaseMappedProfile=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(users_path), http_util.encodeURIComponent(groups_path), http_util.encodeURIComponent(system_relative_path), http_util.encodeURIComponent(default_depth), http_util.encodeURIComponent(import_behavior), http_util.encodeURIComponent(password_hash_algorithm), http_util.encodeURIComponent(password_hash_iterations), http_util.encodeURIComponent(password_salt_size), http_util.encodeURIComponent(omit_admin_pw), http_util.encodeURIComponent(support_auto_save), http_util.encodeURIComponent(password_max_age), http_util.encodeURIComponent(initial_password_change), http_util.encodeURIComponent(password_history_size), http_util.encodeURIComponent(password_expiry_for_admin), http_util.encodeURIComponent(cache_expiration), http_util.encodeURIComponent(enable_rfc7613_usercase_mapped_profile));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_security_user_user_configuration_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_segment_azure_azure_segment_store_service(post, apply, delete, action, location, propertylist, account_name, container_name, access_key, root_path, connection_url)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.segment.azure.AzureSegmentStoreService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&accountName=%s&containerName=%s&accessKey=%s&rootPath=%s&connectionURL=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(account_name), http_util.encodeURIComponent(container_name), http_util.encodeURIComponent(access_key), http_util.encodeURIComponent(root_path), http_util.encodeURIComponent(connection_url));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_segment_azure_azure_segment_store_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_segment_segment_node_store_factory(post, apply, delete, action, location, propertylist, repository_home, tarmk_mode, tarmk_size, segment_cache_size, string_cache_size, template_cache_size, string_deduplication_cache_size, template_deduplication_cache_size, node_deduplication_cache_size, pause_compaction, compaction_retry_count, compaction_force_timeout, compaction_size_delta_estimation, compaction_disable_estimation, compaction_retained_generations, compaction_memory_threshold, compaction_progress_log, standby, custom_blob_store, custom_segment_store, split_persistence, repository_backup_dir, blob_gc_max_age_in_secs, blob_track_snapshot_interval_in_secs, role, register_descriptors, dispatch_changes)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&repository.home=%s&tarmk.mode=%s&tarmk.size=%s&segmentCache.size=%s&stringCache.size=%s&templateCache.size=%s&stringDeduplicationCache.size=%s&templateDeduplicationCache.size=%s&nodeDeduplicationCache.size=%s&pauseCompaction=%s&compaction.retryCount=%s&compaction.force.timeout=%s&compaction.sizeDeltaEstimation=%s&compaction.disableEstimation=%s&compaction.retainedGenerations=%s&compaction.memoryThreshold=%s&compaction.progressLog=%s&standby=%s&customBlobStore=%s&customSegmentStore=%s&splitPersistence=%s&repository.backup.dir=%s&blobGcMaxAgeInSecs=%s&blobTrackSnapshotIntervalInSecs=%s&role=%s&registerDescriptors=%s&dispatchChanges=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(repository_home), http_util.encodeURIComponent(tarmk_mode), http_util.encodeURIComponent(tarmk_size), http_util.encodeURIComponent(segment_cache_size), http_util.encodeURIComponent(string_cache_size), http_util.encodeURIComponent(template_cache_size), http_util.encodeURIComponent(string_deduplication_cache_size), http_util.encodeURIComponent(template_deduplication_cache_size), http_util.encodeURIComponent(node_deduplication_cache_size), http_util.encodeURIComponent(pause_compaction), http_util.encodeURIComponent(compaction_retry_count), http_util.encodeURIComponent(compaction_force_timeout), http_util.encodeURIComponent(compaction_size_delta_estimation), http_util.encodeURIComponent(compaction_disable_estimation), http_util.encodeURIComponent(compaction_retained_generations), http_util.encodeURIComponent(compaction_memory_threshold), http_util.encodeURIComponent(compaction_progress_log), http_util.encodeURIComponent(standby), http_util.encodeURIComponent(custom_blob_store), http_util.encodeURIComponent(custom_segment_store), http_util.encodeURIComponent(split_persistence), http_util.encodeURIComponent(repository_backup_dir), http_util.encodeURIComponent(blob_gc_max_age_in_secs), http_util.encodeURIComponent(blob_track_snapshot_interval_in_secs), http_util.encodeURIComponent(role), http_util.encodeURIComponent(register_descriptors), http_util.encodeURIComponent(dispatch_changes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_segment_segment_node_store_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_segment_segment_node_store_monitor_service(post, apply, delete, action, location, propertylist, commits_tracker_writer_groups)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreMonitorService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&commitsTrackerWriterGroups=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(commits_tracker_writer_groups));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_segment_segment_node_store_monitor_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_segment_segment_node_store_service(post, apply, delete, action, location, propertylist, repository_home, tarmk_mode, tarmk_size, segment_cache_size, string_cache_size, template_cache_size, string_deduplication_cache_size, template_deduplication_cache_size, node_deduplication_cache_size, pause_compaction, compaction_retry_count, compaction_force_timeout, compaction_size_delta_estimation, compaction_disable_estimation, compaction_retained_generations, compaction_memory_threshold, compaction_progress_log, standby, custom_blob_store, custom_segment_store, split_persistence, repository_backup_dir, blob_gc_max_age_in_secs, blob_track_snapshot_interval_in_secs)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&repository.home=%s&tarmk.mode=%s&tarmk.size=%s&segmentCache.size=%s&stringCache.size=%s&templateCache.size=%s&stringDeduplicationCache.size=%s&templateDeduplicationCache.size=%s&nodeDeduplicationCache.size=%s&pauseCompaction=%s&compaction.retryCount=%s&compaction.force.timeout=%s&compaction.sizeDeltaEstimation=%s&compaction.disableEstimation=%s&compaction.retainedGenerations=%s&compaction.memoryThreshold=%s&compaction.progressLog=%s&standby=%s&customBlobStore=%s&customSegmentStore=%s&splitPersistence=%s&repository.backup.dir=%s&blobGcMaxAgeInSecs=%s&blobTrackSnapshotIntervalInSecs=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(repository_home), http_util.encodeURIComponent(tarmk_mode), http_util.encodeURIComponent(tarmk_size), http_util.encodeURIComponent(segment_cache_size), http_util.encodeURIComponent(string_cache_size), http_util.encodeURIComponent(template_cache_size), http_util.encodeURIComponent(string_deduplication_cache_size), http_util.encodeURIComponent(template_deduplication_cache_size), http_util.encodeURIComponent(node_deduplication_cache_size), http_util.encodeURIComponent(pause_compaction), http_util.encodeURIComponent(compaction_retry_count), http_util.encodeURIComponent(compaction_force_timeout), http_util.encodeURIComponent(compaction_size_delta_estimation), http_util.encodeURIComponent(compaction_disable_estimation), http_util.encodeURIComponent(compaction_retained_generations), http_util.encodeURIComponent(compaction_memory_threshold), http_util.encodeURIComponent(compaction_progress_log), http_util.encodeURIComponent(standby), http_util.encodeURIComponent(custom_blob_store), http_util.encodeURIComponent(custom_segment_store), http_util.encodeURIComponent(split_persistence), http_util.encodeURIComponent(repository_backup_dir), http_util.encodeURIComponent(blob_gc_max_age_in_secs), http_util.encodeURIComponent(blob_track_snapshot_interval_in_secs));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_segment_segment_node_store_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_segment_standby_store_standby_store_service(post, apply, delete, action, location, propertylist, org_apache_sling_installer_configuration_persist, mode, port, primary_host, interval, primary_allowed_client_ip_ranges, secure, standby_readtimeout, standby_autoclean)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.segment.standby.store.StandbyStoreService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&org.apache.sling.installer.configuration.persist=%s&mode=%s&port=%s&primary.host=%s&interval=%s&primary.allowed-client-ip-ranges=%s&secure=%s&standby.readtimeout=%s&standby.autoclean=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(org_apache_sling_installer_configuration_persist), http_util.encodeURIComponent(mode), http_util.encodeURIComponent(port), http_util.encodeURIComponent(primary_host), http_util.encodeURIComponent(interval), http_util.encodeURIComponent(primary_allowed_client_ip_ranges), http_util.encodeURIComponent(secure), http_util.encodeURIComponent(standby_readtimeout), http_util.encodeURIComponent(standby_autoclean));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_segment_standby_store_standby_store_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_spi_security_authentication_external_impl_de(post, apply, delete, action, location, propertylist, handler_name, user_expiration_time, user_auto_membership, user_property_mapping, user_path_prefix, user_membership_exp_time, user_membership_nesting_depth, user_dynamic_membership, user_disable_missing, group_expiration_time, group_auto_membership, group_property_mapping, group_path_prefix, enable_rfc7613_usercase_mapped_profile)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.DefaultSyncHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&handler.name=%s&user.expirationTime=%s&user.autoMembership=%s&user.propertyMapping=%s&user.pathPrefix=%s&user.membershipExpTime=%s&user.membershipNestingDepth=%s&user.dynamicMembership=%s&user.disableMissing=%s&group.expirationTime=%s&group.autoMembership=%s&group.propertyMapping=%s&group.pathPrefix=%s&enableRFC7613UsercaseMappedProfile=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(handler_name), http_util.encodeURIComponent(user_expiration_time), http_util.encodeURIComponent(user_auto_membership), http_util.encodeURIComponent(user_property_mapping), http_util.encodeURIComponent(user_path_prefix), http_util.encodeURIComponent(user_membership_exp_time), http_util.encodeURIComponent(user_membership_nesting_depth), http_util.encodeURIComponent(user_dynamic_membership), http_util.encodeURIComponent(user_disable_missing), http_util.encodeURIComponent(group_expiration_time), http_util.encodeURIComponent(group_auto_membership), http_util.encodeURIComponent(group_property_mapping), http_util.encodeURIComponent(group_path_prefix), http_util.encodeURIComponent(enable_rfc7613_usercase_mapped_profile));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_spi_security_authentication_external_impl_de_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_spi_security_authentication_external_impl_ex(post, apply, delete, action, location, propertylist, jaas_ranking, jaas_control_flag, jaas_realm_name, idp_name, sync_handler_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.ExternalLoginModuleFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&jaas.ranking=%s&jaas.controlFlag=%s&jaas.realmName=%s&idp.name=%s&sync.handlerName=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(jaas_ranking), http_util.encodeURIComponent(jaas_control_flag), http_util.encodeURIComponent(jaas_realm_name), http_util.encodeURIComponent(idp_name), http_util.encodeURIComponent(sync_handler_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_spi_security_authentication_external_impl_ex_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_spi_security_authentication_external_impl_pr(post, apply, delete, action, location, propertylist, protect_external_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.principal.ExternalPrincipalConfiguration?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&protectExternalId=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(protect_external_id));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_spi_security_authentication_external_impl_pr_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_spi_security_authorization_cug_impl_cug_confi(post, apply, delete, action, location, propertylist, cug_supported_paths, cug_enabled, configuration_ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authorization.cug.impl.CugConfiguration?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&cugSupportedPaths=%s&cugEnabled=%s&configurationRanking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(cug_supported_paths), http_util.encodeURIComponent(cug_enabled), http_util.encodeURIComponent(configuration_ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_spi_security_authorization_cug_impl_cug_confi_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_spi_security_authorization_cug_impl_cug_exclu(post, apply, delete, action, location, propertylist, principal_names)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authorization.cug.impl.CugExcludeImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&principalNames=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(principal_names));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_spi_security_authorization_cug_impl_cug_exclu_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_oak_spi_security_user_action_default_authorizable(post, apply, delete, action, location, propertylist, enabled_actions, user_privilege_names, group_privilege_names, constraint)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.user.action.DefaultAuthorizableActionProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabledActions=%s&userPrivilegeNames=%s&groupPrivilegeNames=%s&constraint=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled_actions), http_util.encodeURIComponent(user_privilege_names), http_util.encodeURIComponent(group_privilege_names), http_util.encodeURIComponent(constraint));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_oak_spi_security_user_action_default_authorizable_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_vault_packaging_impl_packaging_impl(post, apply, delete, action, location, propertylist, package_roots)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.vault.packaging.impl.PackagingImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&packageRoots=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(package_roots));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_vault_packaging_impl_packaging_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_jackrabbit_vault_packaging_registry_impl_fs_package_registry(post, apply, delete, action, location, propertylist, home_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.jackrabbit.vault.packaging.registry.impl.FSPackageRegistry?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&homePath=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(home_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_jackrabbit_vault_packaging_registry_impl_fs_package_registry_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_auth_core_impl_logout_servlet(post, apply, delete, action, location, propertylist, sling_servlet_methods, sling_servlet_paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.auth.core.impl.LogoutServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.methods=%s&sling.servlet.paths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_methods), http_util.encodeURIComponent(sling_servlet_paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_auth_core_impl_logout_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_caconfig_impl_configuration_bindings_value_provider(post, apply, delete, action, location, propertylist, enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.caconfig.impl.ConfigurationBindingsValueProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_caconfig_impl_configuration_bindings_value_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_caconfig_impl_configuration_resolver_impl(post, apply, delete, action, location, propertylist, config_bucket_names)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.caconfig.impl.ConfigurationResolverImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&configBucketNames=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(config_bucket_names));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_caconfig_impl_configuration_resolver_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_caconfig_impl_def_default_configuration_inheritance_stra(post, apply, delete, action, location, propertylist, enabled, config_property_inheritance_property_names)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.caconfig.impl.def.DefaultConfigurationInheritanceStrategy?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s&configPropertyInheritancePropertyNames=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(config_property_inheritance_property_names));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_caconfig_impl_def_default_configuration_inheritance_stra_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_caconfig_impl_def_default_configuration_persistence_stra(post, apply, delete, action, location, propertylist, enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.caconfig.impl.def.DefaultConfigurationPersistenceStrategy?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_caconfig_impl_def_default_configuration_persistence_stra_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_caconfig_impl_override_osgi_configuration_override_provi(post, apply, delete, action, location, propertylist, description, overrides, enabled, service_ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.caconfig.impl.override.OsgiConfigurationOverrideProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&description=%s&overrides=%s&enabled=%s&service.ranking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(description), http_util.encodeURIComponent(overrides), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(service_ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_caconfig_impl_override_osgi_configuration_override_provi_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_caconfig_impl_override_system_property_configuration_ove(post, apply, delete, action, location, propertylist, enabled, service_ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.caconfig.impl.override.SystemPropertyConfigurationOverrideProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s&service.ranking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(service_ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_caconfig_impl_override_system_property_configuration_ove_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_caconfig_management_impl_configuration_management_setti(post, apply, delete, action, location, propertylist, ignore_property_name_regex, config_collection_properties_resource_names)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.caconfig.management.impl.ConfigurationManagementSettingsImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&ignorePropertyNameRegex=%s&configCollectionPropertiesResourceNames=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(ignore_property_name_regex), http_util.encodeURIComponent(config_collection_properties_resource_names));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_caconfig_management_impl_configuration_management_setti_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_caconfig_resource_impl_def_default_configuration_resour(post, apply, delete, action, location, propertylist, enabled, config_path, fallback_paths, config_collection_inheritance_property_names)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.caconfig.resource.impl.def.DefaultConfigurationResourceResolvingStrategy?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s&configPath=%s&fallbackPaths=%s&configCollectionInheritancePropertyNames=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(config_path), http_util.encodeURIComponent(fallback_paths), http_util.encodeURIComponent(config_collection_inheritance_property_names));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_caconfig_resource_impl_def_default_configuration_resour_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_caconfig_resource_impl_def_default_context_path_strategy(post, apply, delete, action, location, propertylist, enabled, config_ref_resource_names, config_ref_property_names, service_ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.caconfig.resource.impl.def.DefaultContextPathStrategy?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&enabled=%s&configRefResourceNames=%s&configRefPropertyNames=%s&service.ranking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(config_ref_resource_names), http_util.encodeURIComponent(config_ref_property_names), http_util.encodeURIComponent(service_ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_caconfig_resource_impl_def_default_context_path_strategy_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_commons_html_internal_tagsoup_html_parser(post, apply, delete, action, location, propertylist, parser_features)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.commons.html.internal.TagsoupHtmlParser?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&parser.features=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(parser_features));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_commons_html_internal_tagsoup_html_parser_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_commons_log_log_manager(post, apply, delete, action, location, propertylist, org_apache_sling_commons_log_level, org_apache_sling_commons_log_file, org_apache_sling_commons_log_file_number, org_apache_sling_commons_log_file_size, org_apache_sling_commons_log_pattern, org_apache_sling_commons_log_configuration_file, org_apache_sling_commons_log_packaging_data_enabled, org_apache_sling_commons_log_max_caller_data_depth, org_apache_sling_commons_log_max_old_file_count_in_dump, org_apache_sling_commons_log_num_of_lines)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.commons.log.LogManager?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&org.apache.sling.commons.log.level=%s&org.apache.sling.commons.log.file=%s&org.apache.sling.commons.log.file.number=%s&org.apache.sling.commons.log.file.size=%s&org.apache.sling.commons.log.pattern=%s&org.apache.sling.commons.log.configurationFile=%s&org.apache.sling.commons.log.packagingDataEnabled=%s&org.apache.sling.commons.log.maxCallerDataDepth=%s&org.apache.sling.commons.log.maxOldFileCountInDump=%s&org.apache.sling.commons.log.numOfLines=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(org_apache_sling_commons_log_level), http_util.encodeURIComponent(org_apache_sling_commons_log_file), http_util.encodeURIComponent(org_apache_sling_commons_log_file_number), http_util.encodeURIComponent(org_apache_sling_commons_log_file_size), http_util.encodeURIComponent(org_apache_sling_commons_log_pattern), http_util.encodeURIComponent(org_apache_sling_commons_log_configuration_file), http_util.encodeURIComponent(org_apache_sling_commons_log_packaging_data_enabled), http_util.encodeURIComponent(org_apache_sling_commons_log_max_caller_data_depth), http_util.encodeURIComponent(org_apache_sling_commons_log_max_old_file_count_in_dump), http_util.encodeURIComponent(org_apache_sling_commons_log_num_of_lines));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_commons_log_log_manager_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_commons_log_log_manager_factory_config(post, apply, delete, action, location, propertylist, org_apache_sling_commons_log_level, org_apache_sling_commons_log_file, org_apache_sling_commons_log_pattern, org_apache_sling_commons_log_names, org_apache_sling_commons_log_additiv)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.commons.log.LogManager.factory.config?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&org.apache.sling.commons.log.level=%s&org.apache.sling.commons.log.file=%s&org.apache.sling.commons.log.pattern=%s&org.apache.sling.commons.log.names=%s&org.apache.sling.commons.log.additiv=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(org_apache_sling_commons_log_level), http_util.encodeURIComponent(org_apache_sling_commons_log_file), http_util.encodeURIComponent(org_apache_sling_commons_log_pattern), http_util.encodeURIComponent(org_apache_sling_commons_log_names), http_util.encodeURIComponent(org_apache_sling_commons_log_additiv));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_commons_log_log_manager_factory_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_commons_log_log_manager_factory_writer(post, apply, delete, action, location, propertylist, org_apache_sling_commons_log_file, org_apache_sling_commons_log_file_number, org_apache_sling_commons_log_file_size, org_apache_sling_commons_log_file_buffered)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.commons.log.LogManager.factory.writer?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&org.apache.sling.commons.log.file=%s&org.apache.sling.commons.log.file.number=%s&org.apache.sling.commons.log.file.size=%s&org.apache.sling.commons.log.file.buffered=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(org_apache_sling_commons_log_file), http_util.encodeURIComponent(org_apache_sling_commons_log_file_number), http_util.encodeURIComponent(org_apache_sling_commons_log_file_size), http_util.encodeURIComponent(org_apache_sling_commons_log_file_buffered));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_commons_log_log_manager_factory_writer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_commons_metrics_internal_log_reporter(post, apply, delete, action, location, propertylist, period, time_unit, level, logger_name, prefix, pattern, registry_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.commons.metrics.internal.LogReporter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&period=%s&timeUnit=%s&level=%s&loggerName=%s&prefix=%s&pattern=%s&registryName=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(period), http_util.encodeURIComponent(time_unit), http_util.encodeURIComponent(level), http_util.encodeURIComponent(logger_name), http_util.encodeURIComponent(prefix), http_util.encodeURIComponent(pattern), http_util.encodeURIComponent(registry_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_commons_metrics_internal_log_reporter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_commons_metrics_rrd4j_impl_codahale_metrics_reporter(post, apply, delete, action, location, propertylist, datasources, step, archives, path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.commons.metrics.rrd4j.impl.CodahaleMetricsReporter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&datasources=%s&step=%s&archives=%s&path=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(datasources), http_util.encodeURIComponent(step), http_util.encodeURIComponent(archives), http_util.encodeURIComponent(path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_commons_metrics_rrd4j_impl_codahale_metrics_reporter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_commons_mime_internal_mime_type_service_impl(post, apply, delete, action, location, propertylist, mime_types)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.commons.mime.internal.MimeTypeServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&mime.types=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(mime_types));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_commons_mime_internal_mime_type_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_commons_scheduler_impl_quartz_scheduler(post, apply, delete, action, location, propertylist, pool_name, allowed_pool_names, scheduler_useleaderforsingle, metrics_filters, slow_threshold_millis)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.commons.scheduler.impl.QuartzScheduler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&poolName=%s&allowedPoolNames=%s&scheduler.useleaderforsingle=%s&metrics.filters=%s&slowThresholdMillis=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(pool_name), http_util.encodeURIComponent(allowed_pool_names), http_util.encodeURIComponent(scheduler_useleaderforsingle), http_util.encodeURIComponent(metrics_filters), http_util.encodeURIComponent(slow_threshold_millis));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_commons_scheduler_impl_quartz_scheduler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_commons_scheduler_impl_scheduler_health_check(post, apply, delete, action, location, propertylist, max_quartz_job_duration_acceptable)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.commons.scheduler.impl.SchedulerHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&max.quartzJob.duration.acceptable=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_quartz_job_duration_acceptable));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_commons_scheduler_impl_scheduler_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_commons_threads_impl_default_thread_pool_factory(post, apply, delete, action, location, propertylist, name, min_pool_size, max_pool_size, queue_size, max_thread_age, keep_alive_time, block_policy, shutdown_graceful, daemon, shutdown_wait_time, priority)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.commons.threads.impl.DefaultThreadPool.factory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&minPoolSize=%s&maxPoolSize=%s&queueSize=%s&maxThreadAge=%s&keepAliveTime=%s&blockPolicy=%s&shutdownGraceful=%s&daemon=%s&shutdownWaitTime=%s&priority=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(min_pool_size), http_util.encodeURIComponent(max_pool_size), http_util.encodeURIComponent(queue_size), http_util.encodeURIComponent(max_thread_age), http_util.encodeURIComponent(keep_alive_time), http_util.encodeURIComponent(block_policy), http_util.encodeURIComponent(shutdown_graceful), http_util.encodeURIComponent(daemon), http_util.encodeURIComponent(shutdown_wait_time), http_util.encodeURIComponent(priority));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_commons_threads_impl_default_thread_pool_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_datasource_data_source_factory(post, apply, delete, action, location, propertylist, datasource_name, datasource_svc_prop_name, driver_class_name, url, username, password, default_auto_commit, default_read_only, default_transaction_isolation, default_catalog, max_active, max_idle, min_idle, initial_size, max_wait, max_age, test_on_borrow, test_on_return, test_while_idle, validation_query, validation_query_timeout, time_between_eviction_runs_millis, min_evictable_idle_time_millis, connection_properties, init_sql, jdbc_interceptors, validation_interval, log_validation_errors, datasource_svc_properties)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.datasource.DataSourceFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&datasource.name=%s&datasource.svc.prop.name=%s&driverClassName=%s&url=%s&username=%s&password=%s&defaultAutoCommit=%s&defaultReadOnly=%s&defaultTransactionIsolation=%s&defaultCatalog=%s&maxActive=%s&maxIdle=%s&minIdle=%s&initialSize=%s&maxWait=%s&maxAge=%s&testOnBorrow=%s&testOnReturn=%s&testWhileIdle=%s&validationQuery=%s&validationQueryTimeout=%s&timeBetweenEvictionRunsMillis=%s&minEvictableIdleTimeMillis=%s&connectionProperties=%s&initSQL=%s&jdbcInterceptors=%s&validationInterval=%s&logValidationErrors=%s&datasource.svc.properties=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(datasource_name), http_util.encodeURIComponent(datasource_svc_prop_name), http_util.encodeURIComponent(driver_class_name), http_util.encodeURIComponent(url), http_util.encodeURIComponent(username), http_util.encodeURIComponent(password), http_util.encodeURIComponent(default_auto_commit), http_util.encodeURIComponent(default_read_only), http_util.encodeURIComponent(default_transaction_isolation), http_util.encodeURIComponent(default_catalog), http_util.encodeURIComponent(max_active), http_util.encodeURIComponent(max_idle), http_util.encodeURIComponent(min_idle), http_util.encodeURIComponent(initial_size), http_util.encodeURIComponent(max_wait), http_util.encodeURIComponent(max_age), http_util.encodeURIComponent(test_on_borrow), http_util.encodeURIComponent(test_on_return), http_util.encodeURIComponent(test_while_idle), http_util.encodeURIComponent(validation_query), http_util.encodeURIComponent(validation_query_timeout), http_util.encodeURIComponent(time_between_eviction_runs_millis), http_util.encodeURIComponent(min_evictable_idle_time_millis), http_util.encodeURIComponent(connection_properties), http_util.encodeURIComponent(init_sql), http_util.encodeURIComponent(jdbc_interceptors), http_util.encodeURIComponent(validation_interval), http_util.encodeURIComponent(log_validation_errors), http_util.encodeURIComponent(datasource_svc_properties));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_datasource_data_source_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_datasource_jndi_data_source_factory(post, apply, delete, action, location, propertylist, datasource_name, datasource_svc_prop_name, datasource_jndi_name, jndi_properties)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.datasource.JNDIDataSourceFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&datasource.name=%s&datasource.svc.prop.name=%s&datasource.jndi.name=%s&jndi.properties=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(datasource_name), http_util.encodeURIComponent(datasource_svc_prop_name), http_util.encodeURIComponent(datasource_jndi_name), http_util.encodeURIComponent(jndi_properties));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_datasource_jndi_data_source_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_discovery_oak_config(post, apply, delete, action, location, propertylist, connector_ping_timeout, connector_ping_interval, discovery_lite_check_interval, cluster_sync_service_timeout, cluster_sync_service_interval, enable_sync_token, min_event_delay, socket_connect_timeout, so_timeout, topology_connector_urls, topology_connector_whitelist, auto_stop_local_loop_enabled, gzip_connector_requests_enabled, hmac_enabled, enable_encryption, shared_key, hmac_shared_key_ttl, backoff_standby_factor, backoff_stable_factor)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.discovery.oak.Config?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&connectorPingTimeout=%s&connectorPingInterval=%s&discoveryLiteCheckInterval=%s&clusterSyncServiceTimeout=%s&clusterSyncServiceInterval=%s&enableSyncToken=%s&minEventDelay=%s&socketConnectTimeout=%s&soTimeout=%s&topologyConnectorUrls=%s&topologyConnectorWhitelist=%s&autoStopLocalLoopEnabled=%s&gzipConnectorRequestsEnabled=%s&hmacEnabled=%s&enableEncryption=%s&sharedKey=%s&hmacSharedKeyTTL=%s&backoffStandbyFactor=%s&backoffStableFactor=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(connector_ping_timeout), http_util.encodeURIComponent(connector_ping_interval), http_util.encodeURIComponent(discovery_lite_check_interval), http_util.encodeURIComponent(cluster_sync_service_timeout), http_util.encodeURIComponent(cluster_sync_service_interval), http_util.encodeURIComponent(enable_sync_token), http_util.encodeURIComponent(min_event_delay), http_util.encodeURIComponent(socket_connect_timeout), http_util.encodeURIComponent(so_timeout), http_util.encodeURIComponent(topology_connector_urls), http_util.encodeURIComponent(topology_connector_whitelist), http_util.encodeURIComponent(auto_stop_local_loop_enabled), http_util.encodeURIComponent(gzip_connector_requests_enabled), http_util.encodeURIComponent(hmac_enabled), http_util.encodeURIComponent(enable_encryption), http_util.encodeURIComponent(shared_key), http_util.encodeURIComponent(hmac_shared_key_ttl), http_util.encodeURIComponent(backoff_standby_factor), http_util.encodeURIComponent(backoff_stable_factor));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_discovery_oak_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_discovery_oak_synchronized_clocks_health_check(post, apply, delete, action, location, propertylist, hc_name, hc_tags, hc_mbean_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.discovery.oak.SynchronizedClocksHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.name=%s&hc.tags=%s&hc.mbean.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_name), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(hc_mbean_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_discovery_oak_synchronized_clocks_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_agent_impl_forward_distribution_agent_facto(post, apply, delete, action, location, propertylist, name, title, details, enabled, service_name, log_level, allowed_roots, queue_processing_enabled, package_importer_endpoints, passive_queues, priority_queues, retry_strategy, retry_attempts, request_authorization_strategy_target, transport_secret_provider_target, package_builder_target, triggers_target, queue_provider, async_delivery, http_conn_timeout)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.agent.impl.ForwardDistributionAgentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&title=%s&details=%s&enabled=%s&serviceName=%s&log.level=%s&allowed.roots=%s&queue.processing.enabled=%s&packageImporter.endpoints=%s&passiveQueues=%s&priorityQueues=%s&retry.strategy=%s&retry.attempts=%s&requestAuthorizationStrategy.target=%s&transportSecretProvider.target=%s&packageBuilder.target=%s&triggers.target=%s&queue.provider=%s&async.delivery=%s&http.conn.timeout=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(title), http_util.encodeURIComponent(details), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(service_name), http_util.encodeURIComponent(log_level), http_util.encodeURIComponent(allowed_roots), http_util.encodeURIComponent(queue_processing_enabled), http_util.encodeURIComponent(package_importer_endpoints), http_util.encodeURIComponent(passive_queues), http_util.encodeURIComponent(priority_queues), http_util.encodeURIComponent(retry_strategy), http_util.encodeURIComponent(retry_attempts), http_util.encodeURIComponent(request_authorization_strategy_target), http_util.encodeURIComponent(transport_secret_provider_target), http_util.encodeURIComponent(package_builder_target), http_util.encodeURIComponent(triggers_target), http_util.encodeURIComponent(queue_provider), http_util.encodeURIComponent(async_delivery), http_util.encodeURIComponent(http_conn_timeout));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_agent_impl_forward_distribution_agent_facto_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_agent_impl_privilege_distribution_request_a(post, apply, delete, action, location, propertylist, name, jcr_privilege)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.agent.impl.PrivilegeDistributionRequestAuthorizationStrategyFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&jcrPrivilege=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(jcr_privilege));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_agent_impl_privilege_distribution_request_a_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_agent_impl_queue_distribution_agent_factory(post, apply, delete, action, location, propertylist, name, title, details, enabled, service_name, log_level, allowed_roots, request_authorization_strategy_target, queue_provider_factory_target, package_builder_target, triggers_target, priority_queues)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.agent.impl.QueueDistributionAgentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&title=%s&details=%s&enabled=%s&serviceName=%s&log.level=%s&allowed.roots=%s&requestAuthorizationStrategy.target=%s&queueProviderFactory.target=%s&packageBuilder.target=%s&triggers.target=%s&priorityQueues=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(title), http_util.encodeURIComponent(details), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(service_name), http_util.encodeURIComponent(log_level), http_util.encodeURIComponent(allowed_roots), http_util.encodeURIComponent(request_authorization_strategy_target), http_util.encodeURIComponent(queue_provider_factory_target), http_util.encodeURIComponent(package_builder_target), http_util.encodeURIComponent(triggers_target), http_util.encodeURIComponent(priority_queues));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_agent_impl_queue_distribution_agent_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_agent_impl_reverse_distribution_agent_facto(post, apply, delete, action, location, propertylist, name, title, details, enabled, service_name, log_level, queue_processing_enabled, package_exporter_endpoints, pull_items, http_conn_timeout, request_authorization_strategy_target, transport_secret_provider_target, package_builder_target, triggers_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.agent.impl.ReverseDistributionAgentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&title=%s&details=%s&enabled=%s&serviceName=%s&log.level=%s&queue.processing.enabled=%s&packageExporter.endpoints=%s&pull.items=%s&http.conn.timeout=%s&requestAuthorizationStrategy.target=%s&transportSecretProvider.target=%s&packageBuilder.target=%s&triggers.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(title), http_util.encodeURIComponent(details), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(service_name), http_util.encodeURIComponent(log_level), http_util.encodeURIComponent(queue_processing_enabled), http_util.encodeURIComponent(package_exporter_endpoints), http_util.encodeURIComponent(pull_items), http_util.encodeURIComponent(http_conn_timeout), http_util.encodeURIComponent(request_authorization_strategy_target), http_util.encodeURIComponent(transport_secret_provider_target), http_util.encodeURIComponent(package_builder_target), http_util.encodeURIComponent(triggers_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_agent_impl_reverse_distribution_agent_facto_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_agent_impl_simple_distribution_agent_factor(post, apply, delete, action, location, propertylist, name, title, details, enabled, service_name, log_level, queue_processing_enabled, package_exporter_target, package_importer_target, request_authorization_strategy_target, triggers_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.agent.impl.SimpleDistributionAgentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&title=%s&details=%s&enabled=%s&serviceName=%s&log.level=%s&queue.processing.enabled=%s&packageExporter.target=%s&packageImporter.target=%s&requestAuthorizationStrategy.target=%s&triggers.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(title), http_util.encodeURIComponent(details), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(service_name), http_util.encodeURIComponent(log_level), http_util.encodeURIComponent(queue_processing_enabled), http_util.encodeURIComponent(package_exporter_target), http_util.encodeURIComponent(package_importer_target), http_util.encodeURIComponent(request_authorization_strategy_target), http_util.encodeURIComponent(triggers_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_agent_impl_simple_distribution_agent_factor_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_agent_impl_sync_distribution_agent_factory(post, apply, delete, action, location, propertylist, name, title, details, enabled, service_name, log_level, queue_processing_enabled, passive_queues, package_exporter_endpoints, package_importer_endpoints, retry_strategy, retry_attempts, pull_items, http_conn_timeout, request_authorization_strategy_target, transport_secret_provider_target, package_builder_target, triggers_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.agent.impl.SyncDistributionAgentFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&title=%s&details=%s&enabled=%s&serviceName=%s&log.level=%s&queue.processing.enabled=%s&passiveQueues=%s&packageExporter.endpoints=%s&packageImporter.endpoints=%s&retry.strategy=%s&retry.attempts=%s&pull.items=%s&http.conn.timeout=%s&requestAuthorizationStrategy.target=%s&transportSecretProvider.target=%s&packageBuilder.target=%s&triggers.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(title), http_util.encodeURIComponent(details), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(service_name), http_util.encodeURIComponent(log_level), http_util.encodeURIComponent(queue_processing_enabled), http_util.encodeURIComponent(passive_queues), http_util.encodeURIComponent(package_exporter_endpoints), http_util.encodeURIComponent(package_importer_endpoints), http_util.encodeURIComponent(retry_strategy), http_util.encodeURIComponent(retry_attempts), http_util.encodeURIComponent(pull_items), http_util.encodeURIComponent(http_conn_timeout), http_util.encodeURIComponent(request_authorization_strategy_target), http_util.encodeURIComponent(transport_secret_provider_target), http_util.encodeURIComponent(package_builder_target), http_util.encodeURIComponent(triggers_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_agent_impl_sync_distribution_agent_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_monitor_distribution_queue_health_check(post, apply, delete, action, location, propertylist, hc_name, hc_tags, hc_mbean_name, number_of_retries_allowed)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.monitor.DistributionQueueHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.name=%s&hc.tags=%s&hc.mbean.name=%s&numberOfRetriesAllowed=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_name), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(hc_mbean_name), http_util.encodeURIComponent(number_of_retries_allowed));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_monitor_distribution_queue_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_packaging_impl_exporter_agent_distributio(post, apply, delete, action, location, propertylist, name, queue, drop_invalid_items, agent_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.AgentDistributionPackageExporterFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&queue=%s&drop.invalid.items=%s&agent.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(queue), http_util.encodeURIComponent(drop_invalid_items), http_util.encodeURIComponent(agent_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_packaging_impl_exporter_agent_distributio_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_packaging_impl_exporter_local_distributio(post, apply, delete, action, location, propertylist, name, package_builder_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.LocalDistributionPackageExporterFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&packageBuilder.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(package_builder_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_packaging_impl_exporter_local_distributio_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_packaging_impl_exporter_remote_distributi(post, apply, delete, action, location, propertylist, name, endpoints, pull_items, package_builder_target, transport_secret_provider_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.RemoteDistributionPackageExporterFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&endpoints=%s&pull.items=%s&packageBuilder.target=%s&transportSecretProvider.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(endpoints), http_util.encodeURIComponent(pull_items), http_util.encodeURIComponent(package_builder_target), http_util.encodeURIComponent(transport_secret_provider_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_packaging_impl_exporter_remote_distributi_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_packaging_impl_importer_local_distributio(post, apply, delete, action, location, propertylist, name, package_builder_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.LocalDistributionPackageImporterFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&packageBuilder.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(package_builder_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_packaging_impl_importer_local_distributio_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_packaging_impl_importer_remote_distributi(post, apply, delete, action, location, propertylist, name, endpoints, transport_secret_provider_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.RemoteDistributionPackageImporterFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&endpoints=%s&transportSecretProvider.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(endpoints), http_util.encodeURIComponent(transport_secret_provider_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_packaging_impl_importer_remote_distributi_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_packaging_impl_importer_repository_distri(post, apply, delete, action, location, propertylist, name, service_name, path, privilege_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.RepositoryDistributionPackageImporterFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&service.name=%s&path=%s&privilege.name=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(service_name), http_util.encodeURIComponent(path), http_util.encodeURIComponent(privilege_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_packaging_impl_importer_repository_distri_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_resources_impl_distribution_configuration(post, apply, delete, action, location, propertylist, provider_roots, kind)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.resources.impl.DistributionConfigurationResourceProviderFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&provider.roots=%s&kind=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(provider_roots), http_util.encodeURIComponent(kind));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_resources_impl_distribution_configuration_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_resources_impl_distribution_service_resour(post, apply, delete, action, location, propertylist, provider_roots, kind)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.resources.impl.DistributionServiceResourceProviderFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&provider.roots=%s&kind=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(provider_roots), http_util.encodeURIComponent(kind));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_resources_impl_distribution_service_resour_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_serialization_impl_distribution_package_bu(post, apply, delete, action, location, propertylist, name, type, format_target, temp_fs_folder, file_threshold, memory_unit, use_off_heap_memory, digest_algorithm, monitoring_queue_size, cleanup_delay, package_filters, property_filters)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.serialization.impl.DistributionPackageBuilderFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&type=%s&format.target=%s&tempFsFolder=%s&fileThreshold=%s&memoryUnit=%s&useOffHeapMemory=%s&digestAlgorithm=%s&monitoringQueueSize=%s&cleanupDelay=%s&package.filters=%s&property.filters=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(type), http_util.encodeURIComponent(format_target), http_util.encodeURIComponent(temp_fs_folder), http_util.encodeURIComponent(file_threshold), http_util.encodeURIComponent(memory_unit), http_util.encodeURIComponent(use_off_heap_memory), http_util.encodeURIComponent(digest_algorithm), http_util.encodeURIComponent(monitoring_queue_size), http_util.encodeURIComponent(cleanup_delay), http_util.encodeURIComponent(package_filters), http_util.encodeURIComponent(property_filters));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_serialization_impl_distribution_package_bu_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_serialization_impl_vlt_vault_distribution(post, apply, delete, action, location, propertylist, name, type, import_mode, acl_handling, package_roots, package_filters, property_filters, temp_fs_folder, use_binary_references, auto_save_threshold, cleanup_delay, file_threshold, MEGA_BYTES, use_off_heap_memory, digest_algorithm, monitoring_queue_size, paths_mapping, strict_import)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.serialization.impl.vlt.VaultDistributionPackageBuilderFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&type=%s&importMode=%s&aclHandling=%s&package.roots=%s&package.filters=%s&property.filters=%s&tempFsFolder=%s&useBinaryReferences=%s&autoSaveThreshold=%s&cleanupDelay=%s&fileThreshold=%s&MEGA_BYTES=%s&useOffHeapMemory=%s&digestAlgorithm=%s&monitoringQueueSize=%s&pathsMapping=%s&strictImport=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(type), http_util.encodeURIComponent(import_mode), http_util.encodeURIComponent(acl_handling), http_util.encodeURIComponent(package_roots), http_util.encodeURIComponent(package_filters), http_util.encodeURIComponent(property_filters), http_util.encodeURIComponent(temp_fs_folder), http_util.encodeURIComponent(use_binary_references), http_util.encodeURIComponent(auto_save_threshold), http_util.encodeURIComponent(cleanup_delay), http_util.encodeURIComponent(file_threshold), http_util.encodeURIComponent(MEGA_BYTES), http_util.encodeURIComponent(use_off_heap_memory), http_util.encodeURIComponent(digest_algorithm), http_util.encodeURIComponent(monitoring_queue_size), http_util.encodeURIComponent(paths_mapping), http_util.encodeURIComponent(strict_import));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_serialization_impl_vlt_vault_distribution_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_transport_impl_user_credentials_distributi(post, apply, delete, action, location, propertylist, name, username, password)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.transport.impl.UserCredentialsDistributionTransportSecretProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&username=%s&password=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(username), http_util.encodeURIComponent(password));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_transport_impl_user_credentials_distributi_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_trigger_impl_distribution_event_distribute(post, apply, delete, action, location, propertylist, name, path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.trigger.impl.DistributionEventDistributeDistributionTriggerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&path=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_trigger_impl_distribution_event_distribute_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_trigger_impl_jcr_event_distribution_trigger(post, apply, delete, action, location, propertylist, name, path, ignored_paths_patterns, service_name, deep)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.trigger.impl.JcrEventDistributionTriggerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&path=%s&ignoredPathsPatterns=%s&serviceName=%s&deep=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(path), http_util.encodeURIComponent(ignored_paths_patterns), http_util.encodeURIComponent(service_name), http_util.encodeURIComponent(deep));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_trigger_impl_jcr_event_distribution_trigger_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_trigger_impl_persisted_jcr_event_distributi(post, apply, delete, action, location, propertylist, name, path, service_name, nuggets_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.trigger.impl.PersistedJcrEventDistributionTriggerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&path=%s&serviceName=%s&nuggetsPath=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(path), http_util.encodeURIComponent(service_name), http_util.encodeURIComponent(nuggets_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_trigger_impl_persisted_jcr_event_distributi_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_trigger_impl_remote_event_distribution_trig(post, apply, delete, action, location, propertylist, name, endpoint, transport_secret_provider_target)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.trigger.impl.RemoteEventDistributionTriggerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&endpoint=%s&transportSecretProvider.target=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(endpoint), http_util.encodeURIComponent(transport_secret_provider_target));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_trigger_impl_remote_event_distribution_trig_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_trigger_impl_resource_event_distribution_tr(post, apply, delete, action, location, propertylist, name, path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.trigger.impl.ResourceEventDistributionTriggerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&path=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_trigger_impl_resource_event_distribution_tr_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_distribution_trigger_impl_scheduled_distribution_trigge(post, apply, delete, action, location, propertylist, name, path, seconds, service_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.distribution.trigger.impl.ScheduledDistributionTriggerFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&path=%s&seconds=%s&serviceName=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(path), http_util.encodeURIComponent(seconds), http_util.encodeURIComponent(service_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_distribution_trigger_impl_scheduled_distribution_trigge_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_engine_impl_auth_sling_authenticator(post, apply, delete, action, location, propertylist, osgi_http_whiteboard_context_select, osgi_http_whiteboard_listener, auth_sudo_cookie, auth_sudo_parameter, auth_annonymous, sling_auth_requirements, sling_auth_anonymous_user, sling_auth_anonymous_password, auth_http, auth_http_realm, auth_uri_suffix)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.engine.impl.auth.SlingAuthenticator?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&osgi.http.whiteboard.context.select=%s&osgi.http.whiteboard.listener=%s&auth.sudo.cookie=%s&auth.sudo.parameter=%s&auth.annonymous=%s&sling.auth.requirements=%s&sling.auth.anonymous.user=%s&sling.auth.anonymous.password=%s&auth.http=%s&auth.http.realm=%s&auth.uri.suffix=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(osgi_http_whiteboard_context_select), http_util.encodeURIComponent(osgi_http_whiteboard_listener), http_util.encodeURIComponent(auth_sudo_cookie), http_util.encodeURIComponent(auth_sudo_parameter), http_util.encodeURIComponent(auth_annonymous), http_util.encodeURIComponent(sling_auth_requirements), http_util.encodeURIComponent(sling_auth_anonymous_user), http_util.encodeURIComponent(sling_auth_anonymous_password), http_util.encodeURIComponent(auth_http), http_util.encodeURIComponent(auth_http_realm), http_util.encodeURIComponent(auth_uri_suffix));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_engine_impl_auth_sling_authenticator_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_engine_impl_debug_request_progress_tracker_log_filter(post, apply, delete, action, location, propertylist, extensions, min_duration_ms, max_duration_ms, compact_log_format)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.engine.impl.debug.RequestProgressTrackerLogFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&extensions=%s&minDurationMs=%s&maxDurationMs=%s&compactLogFormat=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(extensions), http_util.encodeURIComponent(min_duration_ms), http_util.encodeURIComponent(max_duration_ms), http_util.encodeURIComponent(compact_log_format));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_engine_impl_debug_request_progress_tracker_log_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_engine_impl_log_request_logger(post, apply, delete, action, location, propertylist, request_log_output, request_log_outputtype, request_log_enabled, access_log_output, access_log_outputtype, access_log_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.engine.impl.log.RequestLogger?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&request.log.output=%s&request.log.outputtype=%s&request.log.enabled=%s&access.log.output=%s&access.log.outputtype=%s&access.log.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(request_log_output), http_util.encodeURIComponent(request_log_outputtype), http_util.encodeURIComponent(request_log_enabled), http_util.encodeURIComponent(access_log_output), http_util.encodeURIComponent(access_log_outputtype), http_util.encodeURIComponent(access_log_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_engine_impl_log_request_logger_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_engine_impl_log_request_logger_service(post, apply, delete, action, location, propertylist, request_log_service_format, request_log_service_output, request_log_service_outputtype, request_log_service_onentry)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.engine.impl.log.RequestLoggerService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&request.log.service.format=%s&request.log.service.output=%s&request.log.service.outputtype=%s&request.log.service.onentry=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(request_log_service_format), http_util.encodeURIComponent(request_log_service_output), http_util.encodeURIComponent(request_log_service_outputtype), http_util.encodeURIComponent(request_log_service_onentry));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_engine_impl_log_request_logger_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_engine_impl_sling_main_servlet(post, apply, delete, action, location, propertylist, sling_max_calls, sling_max_inclusions, sling_trace_allow, sling_max_record_requests, sling_store_pattern_requests, sling_serverinfo, sling_additional_response_headers)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.engine.impl.SlingMainServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.max.calls=%s&sling.max.inclusions=%s&sling.trace.allow=%s&sling.max.record.requests=%s&sling.store.pattern.requests=%s&sling.serverinfo=%s&sling.additional.response.headers=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_max_calls), http_util.encodeURIComponent(sling_max_inclusions), http_util.encodeURIComponent(sling_trace_allow), http_util.encodeURIComponent(sling_max_record_requests), http_util.encodeURIComponent(sling_store_pattern_requests), http_util.encodeURIComponent(sling_serverinfo), http_util.encodeURIComponent(sling_additional_response_headers));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_engine_impl_sling_main_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_engine_parameters(post, apply, delete, action, location, propertylist, sling_default_parameter_encoding, sling_default_max_parameters, file_location, file_threshold, file_max, request_max, sling_default_parameter_check_for_additional_container_parameters)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.engine.parameters?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.default.parameter.encoding=%s&sling.default.max.parameters=%s&file.location=%s&file.threshold=%s&file.max=%s&request.max=%s&sling.default.parameter.checkForAdditionalContainerParameters=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_default_parameter_encoding), http_util.encodeURIComponent(sling_default_max_parameters), http_util.encodeURIComponent(file_location), http_util.encodeURIComponent(file_threshold), http_util.encodeURIComponent(file_max), http_util.encodeURIComponent(request_max), http_util.encodeURIComponent(sling_default_parameter_check_for_additional_container_parameters));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_engine_parameters_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_event_impl_eventing_thread_pool(post, apply, delete, action, location, propertylist, min_pool_size)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.event.impl.EventingThreadPool?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&minPoolSize=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(min_pool_size));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_event_impl_eventing_thread_pool_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_event_impl_jobs_default_job_manager(post, apply, delete, action, location, propertylist, queue_priority, queue_retries, queue_retrydelay, queue_maxparallel)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.event.impl.jobs.DefaultJobManager?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&queue.priority=%s&queue.retries=%s&queue.retrydelay=%s&queue.maxparallel=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(queue_priority), http_util.encodeURIComponent(queue_retries), http_util.encodeURIComponent(queue_retrydelay), http_util.encodeURIComponent(queue_maxparallel));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_event_impl_jobs_default_job_manager_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_event_impl_jobs_jcr_persistence_handler(post, apply, delete, action, location, propertylist, job_consumermanager_disable_distribution, startup_delay, cleanup_period)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.event.impl.jobs.jcr.PersistenceHandler?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&job.consumermanager.disableDistribution=%s&startup.delay=%s&cleanup.period=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(job_consumermanager_disable_distribution), http_util.encodeURIComponent(startup_delay), http_util.encodeURIComponent(cleanup_period));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_event_impl_jobs_jcr_persistence_handler_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_event_impl_jobs_job_consumer_manager(post, apply, delete, action, location, propertylist, org_apache_sling_installer_configuration_persist, job_consumermanager_whitelist, job_consumermanager_blacklist)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.event.impl.jobs.JobConsumerManager?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&org.apache.sling.installer.configuration.persist=%s&job.consumermanager.whitelist=%s&job.consumermanager.blacklist=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(org_apache_sling_installer_configuration_persist), http_util.encodeURIComponent(job_consumermanager_whitelist), http_util.encodeURIComponent(job_consumermanager_blacklist));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_event_impl_jobs_job_consumer_manager_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_event_jobs_queue_configuration(post, apply, delete, action, location, propertylist, queue_name, queue_topics, queue_type, queue_priority, queue_retries, queue_retrydelay, queue_maxparallel, queue_keep_jobs, queue_prefer_run_on_creation_instance, queue_thread_pool_size, service_ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.event.jobs.QueueConfiguration?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&queue.name=%s&queue.topics=%s&queue.type=%s&queue.priority=%s&queue.retries=%s&queue.retrydelay=%s&queue.maxparallel=%s&queue.keepJobs=%s&queue.preferRunOnCreationInstance=%s&queue.threadPoolSize=%s&service.ranking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(queue_name), http_util.encodeURIComponent(queue_topics), http_util.encodeURIComponent(queue_type), http_util.encodeURIComponent(queue_priority), http_util.encodeURIComponent(queue_retries), http_util.encodeURIComponent(queue_retrydelay), http_util.encodeURIComponent(queue_maxparallel), http_util.encodeURIComponent(queue_keep_jobs), http_util.encodeURIComponent(queue_prefer_run_on_creation_instance), http_util.encodeURIComponent(queue_thread_pool_size), http_util.encodeURIComponent(service_ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_event_jobs_queue_configuration_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_extensions_webconsolesecurityprovider_internal_sling_w(post, apply, delete, action, location, propertylist, users, groups)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.extensions.webconsolesecurityprovider.internal.SlingWebConsoleSecurityProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&users=%s&groups=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(users), http_util.encodeURIComponent(groups));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_extensions_webconsolesecurityprovider_internal_sling_w_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_featureflags_feature(post, apply, delete, action, location, propertylist, name, description, enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.featureflags.Feature?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&description=%s&enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(description), http_util.encodeURIComponent(enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_featureflags_feature_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_featureflags_impl_configured_feature(post, apply, delete, action, location, propertylist, name, description, enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.featureflags.impl.ConfiguredFeature?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&name=%s&description=%s&enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(name), http_util.encodeURIComponent(description), http_util.encodeURIComponent(enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_featureflags_impl_configured_feature_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_hapi_impl_h_api_util_impl(post, apply, delete, action, location, propertylist, org_apache_sling_hapi_tools_resourcetype, org_apache_sling_hapi_tools_collectionresourcetype, org_apache_sling_hapi_tools_searchpaths, org_apache_sling_hapi_tools_externalurl, org_apache_sling_hapi_tools_enabled)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.hapi.impl.HApiUtilImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&org.apache.sling.hapi.tools.resourcetype=%s&org.apache.sling.hapi.tools.collectionresourcetype=%s&org.apache.sling.hapi.tools.searchpaths=%s&org.apache.sling.hapi.tools.externalurl=%s&org.apache.sling.hapi.tools.enabled=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(org_apache_sling_hapi_tools_resourcetype), http_util.encodeURIComponent(org_apache_sling_hapi_tools_collectionresourcetype), http_util.encodeURIComponent(org_apache_sling_hapi_tools_searchpaths), http_util.encodeURIComponent(org_apache_sling_hapi_tools_externalurl), http_util.encodeURIComponent(org_apache_sling_hapi_tools_enabled));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_hapi_impl_h_api_util_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_hc_core_impl_composite_health_check(post, apply, delete, action, location, propertylist, hc_name, hc_tags, hc_mbean_name, filter_tags, filter_combine_tags_with_or)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.hc.core.impl.CompositeHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.name=%s&hc.tags=%s&hc.mbean.name=%s&filter.tags=%s&filter.combineTagsWithOr=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_name), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(hc_mbean_name), http_util.encodeURIComponent(filter_tags), http_util.encodeURIComponent(filter_combine_tags_with_or));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_hc_core_impl_composite_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_hc_core_impl_executor_health_check_executor_impl(post, apply, delete, action, location, propertylist, timeout_in_ms, long_running_future_threshold_for_critical_ms, result_cache_ttl_in_ms)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.hc.core.impl.executor.HealthCheckExecutorImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&timeoutInMs=%s&longRunningFutureThresholdForCriticalMs=%s&resultCacheTtlInMs=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(timeout_in_ms), http_util.encodeURIComponent(long_running_future_threshold_for_critical_ms), http_util.encodeURIComponent(result_cache_ttl_in_ms));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_hc_core_impl_executor_health_check_executor_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_hc_core_impl_jmx_attribute_health_check(post, apply, delete, action, location, propertylist, hc_name, hc_tags, hc_mbean_name, mbean_name, attribute_name, attribute_value_constraint)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.hc.core.impl.JmxAttributeHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.name=%s&hc.tags=%s&hc.mbean.name=%s&mbean.name=%s&attribute.name=%s&attribute.value.constraint=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_name), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(hc_mbean_name), http_util.encodeURIComponent(mbean_name), http_util.encodeURIComponent(attribute_name), http_util.encodeURIComponent(attribute_value_constraint));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_hc_core_impl_jmx_attribute_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_hc_core_impl_scriptable_health_check(post, apply, delete, action, location, propertylist, hc_name, hc_tags, hc_mbean_name, expression, language_extension)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.hc.core.impl.ScriptableHealthCheck?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&hc.name=%s&hc.tags=%s&hc.mbean.name=%s&expression=%s&language.extension=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(hc_name), http_util.encodeURIComponent(hc_tags), http_util.encodeURIComponent(hc_mbean_name), http_util.encodeURIComponent(expression), http_util.encodeURIComponent(language_extension));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_hc_core_impl_scriptable_health_check_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_hc_core_impl_servlet_health_check_executor_servlet(post, apply, delete, action, location, propertylist, servlet_path, disabled, cors_access_control_allow_origin)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.hc.core.impl.servlet.HealthCheckExecutorServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&servletPath=%s&disabled=%s&cors.accessControlAllowOrigin=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(servlet_path), http_util.encodeURIComponent(disabled), http_util.encodeURIComponent(cors_access_control_allow_origin));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_hc_core_impl_servlet_health_check_executor_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_hc_core_impl_servlet_result_txt_verbose_serializer(post, apply, delete, action, location, propertylist, total_width, col_width_name, col_width_result, col_width_timing)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.hc.core.impl.servlet.ResultTxtVerboseSerializer?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&totalWidth=%s&colWidthName=%s&colWidthResult=%s&colWidthTiming=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(total_width), http_util.encodeURIComponent(col_width_name), http_util.encodeURIComponent(col_width_result), http_util.encodeURIComponent(col_width_timing));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_hc_core_impl_servlet_result_txt_verbose_serializer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_i18n_impl_i18_n_filter(post, apply, delete, action, location, propertylist, service_ranking, sling_filter_scope)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.i18n.impl.I18NFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&sling.filter.scope=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(sling_filter_scope));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_i18n_impl_i18_n_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_i18n_impl_jcr_resource_bundle_provider(post, apply, delete, action, location, propertylist, locale_default, preload_bundles, invalidation_delay)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.i18n.impl.JcrResourceBundleProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&locale.default=%s&preload.bundles=%s&invalidation.delay=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(locale_default), http_util.encodeURIComponent(preload_bundles), http_util.encodeURIComponent(invalidation_delay));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_i18n_impl_jcr_resource_bundle_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_installer_provider_jcr_impl_jcr_installer(post, apply, delete, action, location, propertylist, handler_schemes, sling_jcrinstall_folder_name_regexp, sling_jcrinstall_folder_max_depth, sling_jcrinstall_search_path, sling_jcrinstall_new_config_path, sling_jcrinstall_signal_path, sling_jcrinstall_enable_writeback)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.installer.provider.jcr.impl.JcrInstaller?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&handler.schemes=%s&sling.jcrinstall.folder.name.regexp=%s&sling.jcrinstall.folder.max.depth=%s&sling.jcrinstall.search.path=%s&sling.jcrinstall.new.config.path=%s&sling.jcrinstall.signal.path=%s&sling.jcrinstall.enable.writeback=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(handler_schemes), http_util.encodeURIComponent(sling_jcrinstall_folder_name_regexp), http_util.encodeURIComponent(sling_jcrinstall_folder_max_depth), http_util.encodeURIComponent(sling_jcrinstall_search_path), http_util.encodeURIComponent(sling_jcrinstall_new_config_path), http_util.encodeURIComponent(sling_jcrinstall_signal_path), http_util.encodeURIComponent(sling_jcrinstall_enable_writeback));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_installer_provider_jcr_impl_jcr_installer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_base_internal_login_admin_whitelist(post, apply, delete, action, location, propertylist, whitelist_bypass, whitelist_bundles_regexp)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.base.internal.LoginAdminWhitelist?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&whitelist.bypass=%s&whitelist.bundles.regexp=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(whitelist_bypass), http_util.encodeURIComponent(whitelist_bundles_regexp));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_base_internal_login_admin_whitelist_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_base_internal_login_admin_whitelist_fragment(post, apply, delete, action, location, propertylist, whitelist_name, whitelist_bundles)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.base.internal.LoginAdminWhitelist.fragment?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&whitelist.name=%s&whitelist.bundles=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(whitelist_name), http_util.encodeURIComponent(whitelist_bundles));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_base_internal_login_admin_whitelist_fragment_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_davex_impl_servlets_sling_dav_ex_servlet(post, apply, delete, action, location, propertylist, alias, dav_create_absolute_uri, dav_protectedhandlers)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&alias=%s&dav.create-absolute-uri=%s&dav.protectedhandlers=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(alias), http_util.encodeURIComponent(dav_create_absolute_uri), http_util.encodeURIComponent(dav_protectedhandlers));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_davex_impl_servlets_sling_dav_ex_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_jackrabbit_server_jndi_registration_support(post, apply, delete, action, location, propertylist, java_naming_factory_initial, java_naming_provider_url)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.jackrabbit.server.JndiRegistrationSupport?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&java.naming.factory.initial=%s&java.naming.provider.url=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(java_naming_factory_initial), http_util.encodeURIComponent(java_naming_provider_url));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_jackrabbit_server_jndi_registration_support_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_jackrabbit_server_rmi_registration_support(post, apply, delete, action, location, propertylist, port)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.jackrabbit.server.RmiRegistrationSupport?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&port=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(port));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_jackrabbit_server_rmi_registration_support_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_repoinit_impl_repository_initializer(post, apply, delete, action, location, propertylist, references)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.repoinit.impl.RepositoryInitializer?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&references=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(references));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_repoinit_impl_repository_initializer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_repoinit_repository_initializer(post, apply, delete, action, location, propertylist, references, scripts)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.repoinit.RepositoryInitializer?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&references=%s&scripts=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(references), http_util.encodeURIComponent(scripts));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_repoinit_repository_initializer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_resource_internal_jcr_resource_resolver_factory_impl(post, apply, delete, action, location, propertylist, resource_resolver_searchpath, resource_resolver_manglenamespaces, resource_resolver_allow_direct, resource_resolver_required_providers, resource_resolver_required_providernames, resource_resolver_virtual, resource_resolver_mapping, resource_resolver_map_location, resource_resolver_map_observation, resource_resolver_default_vanity_redirect_status, resource_resolver_enable_vanitypath, resource_resolver_vanitypath_max_entries, resource_resolver_vanitypath_max_entries_startup, resource_resolver_vanitypath_bloomfilter_max_bytes, resource_resolver_optimize_alias_resolution, resource_resolver_vanitypath_whitelist, resource_resolver_vanitypath_blacklist, resource_resolver_vanity_precedence, resource_resolver_providerhandling_paranoid, resource_resolver_log_closing, resource_resolver_log_unclosed)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.resource.internal.JcrResourceResolverFactoryImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&resource.resolver.searchpath=%s&resource.resolver.manglenamespaces=%s&resource.resolver.allowDirect=%s&resource.resolver.required.providers=%s&resource.resolver.required.providernames=%s&resource.resolver.virtual=%s&resource.resolver.mapping=%s&resource.resolver.map.location=%s&resource.resolver.map.observation=%s&resource.resolver.default.vanity.redirect.status=%s&resource.resolver.enable.vanitypath=%s&resource.resolver.vanitypath.maxEntries=%s&resource.resolver.vanitypath.maxEntries.startup=%s&resource.resolver.vanitypath.bloomfilter.maxBytes=%s&resource.resolver.optimize.alias.resolution=%s&resource.resolver.vanitypath.whitelist=%s&resource.resolver.vanitypath.blacklist=%s&resource.resolver.vanity.precedence=%s&resource.resolver.providerhandling.paranoid=%s&resource.resolver.log.closing=%s&resource.resolver.log.unclosed=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(resource_resolver_searchpath), http_util.encodeURIComponent(resource_resolver_manglenamespaces), http_util.encodeURIComponent(resource_resolver_allow_direct), http_util.encodeURIComponent(resource_resolver_required_providers), http_util.encodeURIComponent(resource_resolver_required_providernames), http_util.encodeURIComponent(resource_resolver_virtual), http_util.encodeURIComponent(resource_resolver_mapping), http_util.encodeURIComponent(resource_resolver_map_location), http_util.encodeURIComponent(resource_resolver_map_observation), http_util.encodeURIComponent(resource_resolver_default_vanity_redirect_status), http_util.encodeURIComponent(resource_resolver_enable_vanitypath), http_util.encodeURIComponent(resource_resolver_vanitypath_max_entries), http_util.encodeURIComponent(resource_resolver_vanitypath_max_entries_startup), http_util.encodeURIComponent(resource_resolver_vanitypath_bloomfilter_max_bytes), http_util.encodeURIComponent(resource_resolver_optimize_alias_resolution), http_util.encodeURIComponent(resource_resolver_vanitypath_whitelist), http_util.encodeURIComponent(resource_resolver_vanitypath_blacklist), http_util.encodeURIComponent(resource_resolver_vanity_precedence), http_util.encodeURIComponent(resource_resolver_providerhandling_paranoid), http_util.encodeURIComponent(resource_resolver_log_closing), http_util.encodeURIComponent(resource_resolver_log_unclosed));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_resource_internal_jcr_resource_resolver_factory_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_resource_internal_jcr_system_user_validator(post, apply, delete, action, location, propertylist, allow_only_system_user)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.resource.internal.JcrSystemUserValidator?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&allow.only.system.user=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(allow_only_system_user));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_resource_internal_jcr_system_user_validator_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_resourcesecurity_impl_resource_access_gate_factory(post, apply, delete, action, location, propertylist, path, checkpath_prefix, jcr_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.resourcesecurity.impl.ResourceAccessGateFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&path=%s&checkpath.prefix=%s&jcrPath=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(path), http_util.encodeURIComponent(checkpath_prefix), http_util.encodeURIComponent(jcr_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_resourcesecurity_impl_resource_access_gate_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_webdav_impl_handler_default_handler_service(post, apply, delete, action, location, propertylist, service_ranking, type_collections, type_noncollections, type_content)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.webdav.impl.handler.DefaultHandlerService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&type.collections=%s&type.noncollections=%s&type.content=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(type_collections), http_util.encodeURIComponent(type_noncollections), http_util.encodeURIComponent(type_content));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_webdav_impl_handler_default_handler_service_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_webdav_impl_handler_dir_listing_export_handler_servic(post, apply, delete, action, location, propertylist, service_ranking)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.webdav.impl.handler.DirListingExportHandlerService?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_webdav_impl_handler_dir_listing_export_handler_servic_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jcr_webdav_impl_servlets_simple_web_dav_servlet(post, apply, delete, action, location, propertylist, dav_root, dav_create_absolute_uri, dav_realm, collection_types, filter_prefixes, filter_types, filter_uris, type_collections, type_noncollections, type_content)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jcr.webdav.impl.servlets.SimpleWebDavServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&dav.root=%s&dav.create-absolute-uri=%s&dav.realm=%s&collection.types=%s&filter.prefixes=%s&filter.types=%s&filter.uris=%s&type.collections=%s&type.noncollections=%s&type.content=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(dav_root), http_util.encodeURIComponent(dav_create_absolute_uri), http_util.encodeURIComponent(dav_realm), http_util.encodeURIComponent(collection_types), http_util.encodeURIComponent(filter_prefixes), http_util.encodeURIComponent(filter_types), http_util.encodeURIComponent(filter_uris), http_util.encodeURIComponent(type_collections), http_util.encodeURIComponent(type_noncollections), http_util.encodeURIComponent(type_content));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jcr_webdav_impl_servlets_simple_web_dav_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_jmx_provider_impl_jmx_resource_provider(post, apply, delete, action, location, propertylist, provider_roots)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.jmx.provider.impl.JMXResourceProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&provider.roots=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(provider_roots));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_jmx_provider_impl_jmx_resource_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_models_impl_model_adapter_factory(post, apply, delete, action, location, propertylist, osgi_http_whiteboard_listener, osgi_http_whiteboard_context_select, max_recursion_depth, cleanup_job_period)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.models.impl.ModelAdapterFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&osgi.http.whiteboard.listener=%s&osgi.http.whiteboard.context.select=%s&max.recursion.depth=%s&cleanup.job.period=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(osgi_http_whiteboard_listener), http_util.encodeURIComponent(osgi_http_whiteboard_context_select), http_util.encodeURIComponent(max_recursion_depth), http_util.encodeURIComponent(cleanup_job_period));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_models_impl_model_adapter_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_models_jacksonexporter_impl_resource_module_provider(post, apply, delete, action, location, propertylist, max_recursion_levels)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.models.jacksonexporter.impl.ResourceModuleProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&max.recursion.levels=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(max_recursion_levels));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_models_jacksonexporter_impl_resource_module_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_resource_inventory_impl_resource_inventory_printer_facto(post, apply, delete, action, location, propertylist, felix_inventory_printer_name, felix_inventory_printer_title, path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.resource.inventory.impl.ResourceInventoryPrinterFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&felix.inventory.printer.name=%s&felix.inventory.printer.title=%s&path=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(felix_inventory_printer_name), http_util.encodeURIComponent(felix_inventory_printer_title), http_util.encodeURIComponent(path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_resource_inventory_impl_resource_inventory_printer_facto_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_resourcemerger_impl_merged_resource_provider_factory(post, apply, delete, action, location, propertylist, merge_root, merge_read_only)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.resourcemerger.impl.MergedResourceProviderFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&merge.root=%s&merge.readOnly=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(merge_root), http_util.encodeURIComponent(merge_read_only));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_resourcemerger_impl_merged_resource_provider_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_resourcemerger_picker_overriding(post, apply, delete, action, location, propertylist, merge_root, merge_read_only)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.resourcemerger.picker.overriding?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&merge.root=%s&merge.readOnly=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(merge_root), http_util.encodeURIComponent(merge_read_only));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_resourcemerger_picker_overriding_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_scripting_core_impl_script_cache_impl(post, apply, delete, action, location, propertylist, org_apache_sling_scripting_cache_size, org_apache_sling_scripting_cache_additional_extensions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.scripting.core.impl.ScriptCacheImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&org.apache.sling.scripting.cache.size=%s&org.apache.sling.scripting.cache.additional_extensions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(org_apache_sling_scripting_cache_size), http_util.encodeURIComponent(org_apache_sling_scripting_cache_additional_extensions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_scripting_core_impl_script_cache_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_scripting_core_impl_scripting_resource_resolver_provider(post, apply, delete, action, location, propertylist, log_stacktrace_onclose)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.scripting.core.impl.ScriptingResourceResolverProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&log.stacktrace.onclose=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(log_stacktrace_onclose));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_scripting_core_impl_scripting_resource_resolver_provider_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_scripting_java_impl_java_script_engine_factory(post, apply, delete, action, location, propertylist, java_classdebuginfo, java_java_encoding, java_compiler_source_vm, java_compiler_target_vm)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.scripting.java.impl.JavaScriptEngineFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&java.classdebuginfo=%s&java.javaEncoding=%s&java.compilerSourceVM=%s&java.compilerTargetVM=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(java_classdebuginfo), http_util.encodeURIComponent(java_java_encoding), http_util.encodeURIComponent(java_compiler_source_vm), http_util.encodeURIComponent(java_compiler_target_vm));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_scripting_java_impl_java_script_engine_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_scripting_javascript_internal_rhino_java_script_engine_fa(post, apply, delete, action, location, propertylist, org_apache_sling_scripting_javascript_rhino_opt_level)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.scripting.javascript.internal.RhinoJavaScriptEngineFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&org.apache.sling.scripting.javascript.rhino.optLevel=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(org_apache_sling_scripting_javascript_rhino_opt_level));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_scripting_javascript_internal_rhino_java_script_engine_fa_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_scripting_jsp_jsp_script_engine_factory(post, apply, delete, action, location, propertylist, jasper_compiler_target_vm, jasper_compiler_source_vm, jasper_classdebuginfo, jasper_enable_pooling, jasper_ie_class_id, jasper_gen_string_as_char_array, jasper_keepgenerated, jasper_mappedfile, jasper_trim_spaces, jasper_display_source_fragments, default_is_session)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.scripting.jsp.JspScriptEngineFactory?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&jasper.compilerTargetVM=%s&jasper.compilerSourceVM=%s&jasper.classdebuginfo=%s&jasper.enablePooling=%s&jasper.ieClassId=%s&jasper.genStringAsCharArray=%s&jasper.keepgenerated=%s&jasper.mappedfile=%s&jasper.trimSpaces=%s&jasper.displaySourceFragments=%s&default.is.session=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(jasper_compiler_target_vm), http_util.encodeURIComponent(jasper_compiler_source_vm), http_util.encodeURIComponent(jasper_classdebuginfo), http_util.encodeURIComponent(jasper_enable_pooling), http_util.encodeURIComponent(jasper_ie_class_id), http_util.encodeURIComponent(jasper_gen_string_as_char_array), http_util.encodeURIComponent(jasper_keepgenerated), http_util.encodeURIComponent(jasper_mappedfile), http_util.encodeURIComponent(jasper_trim_spaces), http_util.encodeURIComponent(jasper_display_source_fragments), http_util.encodeURIComponent(default_is_session));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_scripting_jsp_jsp_script_engine_factory_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_scripting_sightly_js_impl_jsapi_sly_bindings_values_prov(post, apply, delete, action, location, propertylist, org_apache_sling_scripting_sightly_js_bindings)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.scripting.sightly.js.impl.jsapi.SlyBindingsValuesProvider?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&org.apache.sling.scripting.sightly.js.bindings=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(org_apache_sling_scripting_sightly_js_bindings));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_scripting_sightly_js_impl_jsapi_sly_bindings_values_prov_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_security_impl_content_disposition_filter(post, apply, delete, action, location, propertylist, sling_content_disposition_paths, sling_content_disposition_excluded_paths, sling_content_disposition_all_paths)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.security.impl.ContentDispositionFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.content.disposition.paths=%s&sling.content.disposition.excluded.paths=%s&sling.content.disposition.all.paths=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_content_disposition_paths), http_util.encodeURIComponent(sling_content_disposition_excluded_paths), http_util.encodeURIComponent(sling_content_disposition_all_paths));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_security_impl_content_disposition_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_security_impl_referrer_filter(post, apply, delete, action, location, propertylist, allow_empty, allow_hosts, allow_hosts_regexp, filter_methods, exclude_agents_regexp)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.security.impl.ReferrerFilter?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&allow.empty=%s&allow.hosts=%s&allow.hosts.regexp=%s&filter.methods=%s&exclude.agents.regexp=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(allow_empty), http_util.encodeURIComponent(allow_hosts), http_util.encodeURIComponent(allow_hosts_regexp), http_util.encodeURIComponent(filter_methods), http_util.encodeURIComponent(exclude_agents_regexp));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_security_impl_referrer_filter_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_serviceusermapping_impl_service_user_mapper_impl(post, apply, delete, action, location, propertylist, user_mapping, user_default, user_enable_default_mapping, require_validation)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.serviceusermapping.impl.ServiceUserMapperImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&user.mapping=%s&user.default=%s&user.enable.default.mapping=%s&require.validation=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(user_mapping), http_util.encodeURIComponent(user_default), http_util.encodeURIComponent(user_enable_default_mapping), http_util.encodeURIComponent(require_validation));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_serviceusermapping_impl_service_user_mapper_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_serviceusermapping_impl_service_user_mapper_impl_amended(post, apply, delete, action, location, propertylist, service_ranking, user_mapping)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.serviceusermapping.impl.ServiceUserMapperImpl.amended?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&service.ranking=%s&user.mapping=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(user_mapping));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_serviceusermapping_impl_service_user_mapper_impl_amended_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_servlets_get_default_get_servlet(post, apply, delete, action, location, propertylist, aliases, index, index_files, enable_html, enable_json, enable_txt, enable_xml, json_maximumresults, ecma_suport)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.servlets.get.DefaultGetServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&aliases=%s&index=%s&index.files=%s&enable.html=%s&enable.json=%s&enable.txt=%s&enable.xml=%s&json.maximumresults=%s&ecmaSuport=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(aliases), http_util.encodeURIComponent(index), http_util.encodeURIComponent(index_files), http_util.encodeURIComponent(enable_html), http_util.encodeURIComponent(enable_json), http_util.encodeURIComponent(enable_txt), http_util.encodeURIComponent(enable_xml), http_util.encodeURIComponent(json_maximumresults), http_util.encodeURIComponent(ecma_suport));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_servlets_get_default_get_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_servlets_get_impl_version_version_info_servlet(post, apply, delete, action, location, propertylist, sling_servlet_selectors, ecma_suport)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.servlets.get.impl.version.VersionInfoServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.servlet.selectors=%s&ecmaSuport=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_servlet_selectors), http_util.encodeURIComponent(ecma_suport));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_servlets_get_impl_version_version_info_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_servlets_post_impl_helper_chunk_clean_up_task(post, apply, delete, action, location, propertylist, scheduler_expression, scheduler_concurrent, chunk_cleanup_age)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.servlets.post.impl.helper.ChunkCleanUpTask?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&scheduler.expression=%s&scheduler.concurrent=%s&chunk.cleanup.age=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(scheduler_expression), http_util.encodeURIComponent(scheduler_concurrent), http_util.encodeURIComponent(chunk_cleanup_age));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_servlets_post_impl_helper_chunk_clean_up_task_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_servlets_post_impl_sling_post_servlet(post, apply, delete, action, location, propertylist, servlet_post_date_formats, servlet_post_node_name_hints, servlet_post_node_name_max_length, servlet_post_checkin_new_versionable_nodes, servlet_post_auto_checkout, servlet_post_auto_checkin, servlet_post_ignore_pattern)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.servlets.post.impl.SlingPostServlet?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&servlet.post.dateFormats=%s&servlet.post.nodeNameHints=%s&servlet.post.nodeNameMaxLength=%s&servlet.post.checkinNewVersionableNodes=%s&servlet.post.autoCheckout=%s&servlet.post.autoCheckin=%s&servlet.post.ignorePattern=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(servlet_post_date_formats), http_util.encodeURIComponent(servlet_post_node_name_hints), http_util.encodeURIComponent(servlet_post_node_name_max_length), http_util.encodeURIComponent(servlet_post_checkin_new_versionable_nodes), http_util.encodeURIComponent(servlet_post_auto_checkout), http_util.encodeURIComponent(servlet_post_auto_checkin), http_util.encodeURIComponent(servlet_post_ignore_pattern));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_servlets_post_impl_sling_post_servlet_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_servlets_resolver_sling_servlet_resolver(post, apply, delete, action, location, propertylist, servletresolver_servlet_root, servletresolver_cache_size, servletresolver_paths, servletresolver_default_extensions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.servlets.resolver.SlingServletResolver?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&servletresolver.servletRoot=%s&servletresolver.cacheSize=%s&servletresolver.paths=%s&servletresolver.defaultExtensions=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(servletresolver_servlet_root), http_util.encodeURIComponent(servletresolver_cache_size), http_util.encodeURIComponent(servletresolver_paths), http_util.encodeURIComponent(servletresolver_default_extensions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_servlets_resolver_sling_servlet_resolver_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_settings_impl_sling_settings_service_impl(post, apply, delete, action, location, propertylist, sling_name, sling_description)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.settings.impl.SlingSettingsServiceImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&sling.name=%s&sling.description=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(sling_name), http_util.encodeURIComponent(sling_description));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_settings_impl_sling_settings_service_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_startupfilter_impl_startup_filter_impl(post, apply, delete, action, location, propertylist, active_by_default, default_message)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.startupfilter.impl.StartupFilterImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&active.by.default=%s&default.message=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(active_by_default), http_util.encodeURIComponent(default_message));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_startupfilter_impl_startup_filter_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_tenant_internal_tenant_provider_impl(post, apply, delete, action, location, propertylist, tenant_root, tenant_path_matcher)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.tenant.internal.TenantProviderImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&tenant.root=%s&tenant.path.matcher=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(tenant_root), http_util.encodeURIComponent(tenant_path_matcher));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_tenant_internal_tenant_provider_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_tracer_internal_log_tracer(post, apply, delete, action, location, propertylist, tracer_sets, enabled, servlet_enabled, recording_cache_size_in_mb, recording_cache_duration_in_secs, recording_compression_enabled, gzip_response)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.tracer.internal.LogTracer?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&tracerSets=%s&enabled=%s&servletEnabled=%s&recordingCacheSizeInMB=%s&recordingCacheDurationInSecs=%s&recordingCompressionEnabled=%s&gzipResponse=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(tracer_sets), http_util.encodeURIComponent(enabled), http_util.encodeURIComponent(servlet_enabled), http_util.encodeURIComponent(recording_cache_size_in_mb), http_util.encodeURIComponent(recording_cache_duration_in_secs), http_util.encodeURIComponent(recording_compression_enabled), http_util.encodeURIComponent(gzip_response));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_tracer_internal_log_tracer_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function configmgr_api:org_apache_sling_xss_impl_xss_filter_impl(post, apply, delete, action, location, propertylist, policy_path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		path = string.format("%s/system/console/configMgr/org.apache.sling.xss.impl.XSSFilterImpl?post=%s&apply=%s&delete=%s&action=%s&$location=%s&propertylist=%s&policyPath=%s",
			self.basePath, http_util.encodeURIComponent(post), http_util.encodeURIComponent(apply), http_util.encodeURIComponent(delete), http_util.encodeURIComponent(action), http_util.encodeURIComponent(location), http_util.encodeURIComponent(propertylist), http_util.encodeURIComponent(policy_path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	-- ref: https://openapi-generator.tech/pull/6252#issuecomment-321199879
	--local var_accept = { "application/json", "text/plain" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapi-client_org_apache_sling_xss_impl_xss_filter_impl_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

return {
	new = new_configmgr_api;
}

