note
 description:"[
		Adobe Experience Manager OSGI config (AEM) API
 		Swagger AEM OSGI is an OpenAPI specification for Adobe Experience Manager (AEM) OSGI Configurations API
  		OpenAPI spec version: 1.0.0-pre.0
 	    Contact: opensource@shinesolutions.com

  	NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel openapi generator", "src=https://openapi-generator.tech", "protocol=uri"

class
	CONFIGMGR_API

inherit

    API_I


feature -- API Access


	adaptive_form_and_interactive_communication_web_channel_configuration (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; show_placeholder: BOOLEAN; maximum_cache_entries: INTEGER_32; af_scripting_compatversion: STRING_32; make_file_name_unique: BOOLEAN; generating_compliant_data: BOOLEAN): detachable ADAPTIVE_FORM_AND_INTERACTIVE_COMMUNICATION_WEB_CHANNEL_CONFIGURATION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: show_placeholder  (optional)
			-- 
			-- argument: maximum_cache_entries  (optional)
			-- 
			-- argument: af_scripting_compatversion  (optional)
			-- 
			-- argument: make_file_name_unique  (optional)
			-- 
			-- argument: generating_compliant_data  (optional)
			-- 
			-- 
			-- Result ADAPTIVE_FORM_AND_INTERACTIVE_COMMUNICATION_WEB_CHANNEL_CONFIGURATION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/Adaptive Form and Interactive Communication Web Channel Configuration"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "showPlaceholder", show_placeholder));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maximumCacheEntries", maximum_cache_entries));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "af.scripting.compatversion", af_scripting_compatversion));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "makeFileNameUnique", make_file_name_unique));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "generatingCompliantData", generating_compliant_data));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ADAPTIVE_FORM_AND_INTERACTIVE_COMMUNICATION_WEB_CHANNEL_CONFIGURATION_INFO } l_response.data ({ ADAPTIVE_FORM_AND_INTERACTIVE_COMMUNICATION_WEB_CHANNEL_CONFIGURATION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	adaptive_form_and_interactive_communication_web_channel_theme_configur (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; font_list: detachable LIST [STRING_32]): detachable ADAPTIVE_FORM_AND_INTERACTIVE_COMMUNICATION_WEB_CHANNEL_THEME_CONFIGUR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: font_list  (optional)
			-- 
			-- 
			-- Result ADAPTIVE_FORM_AND_INTERACTIVE_COMMUNICATION_WEB_CHANNEL_THEME_CONFIGUR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/Adaptive Form and Interactive Communication Web Channel Theme Configuration"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fontList", font_list));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ADAPTIVE_FORM_AND_INTERACTIVE_COMMUNICATION_WEB_CHANNEL_THEME_CONFIGUR_INFO } l_response.data ({ ADAPTIVE_FORM_AND_INTERACTIVE_COMMUNICATION_WEB_CHANNEL_THEME_CONFIGUR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	analytics_component_query_cache_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_analytics_component_query_cache_size: INTEGER_32): detachable ANALYTICS_COMPONENT_QUERY_CACHE_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_analytics_component_query_cache_size  (optional)
			-- 
			-- 
			-- Result ANALYTICS_COMPONENT_QUERY_CACHE_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/Analytics Component Query Cache Service"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.analytics.component.query.cache.size", cq_analytics_component_query_cache_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ANALYTICS_COMPONENT_QUERY_CACHE_SERVICE_INFO } l_response.data ({ ANALYTICS_COMPONENT_QUERY_CACHE_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	apache_sling_health_check_result_ht_ml_serializer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; style_string: STRING_32): detachable APACHE_SLING_HEALTH_CHECK_RESULT_HTML_SERIALIZER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: style_string  (optional)
			-- 
			-- 
			-- Result APACHE_SLING_HEALTH_CHECK_RESULT_HTML_SERIALIZER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/Apache Sling Health Check Result HTML Serializer"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "styleString", style_string));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { APACHE_SLING_HEALTH_CHECK_RESULT_HTML_SERIALIZER_INFO } l_response.data ({ APACHE_SLING_HEALTH_CHECK_RESULT_HTML_SERIALIZER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_aem_formsndocuments_config_ae_mforms_manager_configuration (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; forms_manager_config_include_oo_tb_templates: BOOLEAN; forms_manager_config_include_deprecated_templates: BOOLEAN): detachable COM_ADOBE_AEM_FORMSNDOCUMENTS_CONFIG_AEM_FORMS_MANAGER_CONFIGURATION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: forms_manager_config_include_oo_tb_templates  (optional)
			-- 
			-- argument: forms_manager_config_include_deprecated_templates  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_AEM_FORMSNDOCUMENTS_CONFIG_AEM_FORMS_MANAGER_CONFIGURATION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.aem.formsndocuments.config.AEMFormsManagerConfiguration"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "formsManagerConfig.includeOOTBTemplates", forms_manager_config_include_oo_tb_templates));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "formsManagerConfig.includeDeprecatedTemplates", forms_manager_config_include_deprecated_templates));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_AEM_FORMSNDOCUMENTS_CONFIG_AEM_FORMS_MANAGER_CONFIGURATION_INFO } l_response.data ({ COM_ADOBE_AEM_FORMSNDOCUMENTS_CONFIG_AEM_FORMS_MANAGER_CONFIGURATION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_aem_transaction_core_impl_transaction_recorder (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; is_transaction_recording_enabled: BOOLEAN): detachable COM_ADOBE_AEM_TRANSACTION_CORE_IMPL_TRANSACTION_RECORDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: is_transaction_recording_enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_AEM_TRANSACTION_CORE_IMPL_TRANSACTION_RECORDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.aem.transaction.core.impl.TransactionRecorder"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "isTransactionRecordingEnabled", is_transaction_recording_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_AEM_TRANSACTION_CORE_IMPL_TRANSACTION_RECORDER_INFO } l_response.data ({ COM_ADOBE_AEM_TRANSACTION_CORE_IMPL_TRANSACTION_RECORDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_aem_upgrade_prechecks_hc_impl_deprecate_indexes_hc (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_name: STRING_32; hc_tags: detachable LIST [STRING_32]; hc_mbean_name: STRING_32): detachable COM_ADOBE_AEM_UPGRADE_PRECHECKS_HC_IMPL_DEPRECATE_INDEXES_HC_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_name  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: hc_mbean_name  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_AEM_UPGRADE_PRECHECKS_HC_IMPL_DEPRECATE_INDEXES_HC_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.aem.upgrade.prechecks.hc.impl.DeprecateIndexesHC"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.name", hc_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.mbean.name", hc_mbean_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_AEM_UPGRADE_PRECHECKS_HC_IMPL_DEPRECATE_INDEXES_HC_INFO } l_response.data ({ COM_ADOBE_AEM_UPGRADE_PRECHECKS_HC_IMPL_DEPRECATE_INDEXES_HC_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_aem_upgrade_prechecks_hc_impl_replication_agents_disabled_hc (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_name: STRING_32; hc_tags: detachable LIST [STRING_32]; hc_mbean_name: STRING_32): detachable COM_ADOBE_AEM_UPGRADE_PRECHECKS_HC_IMPL_REPLICATION_AGENTS_DISABLED_HC_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_name  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: hc_mbean_name  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_AEM_UPGRADE_PRECHECKS_HC_IMPL_REPLICATION_AGENTS_DISABLED_HC_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.aem.upgrade.prechecks.hc.impl.ReplicationAgentsDisabledHC"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.name", hc_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.mbean.name", hc_mbean_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_AEM_UPGRADE_PRECHECKS_HC_IMPL_REPLICATION_AGENTS_DISABLED_HC_INFO } l_response.data ({ COM_ADOBE_AEM_UPGRADE_PRECHECKS_HC_IMPL_REPLICATION_AGENTS_DISABLED_HC_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_aem_upgrade_prechecks_mbean_impl_pre_upgrade_tasks_mbean_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; pre_upgrade_maintenance_tasks: detachable LIST [STRING_32]; pre_upgrade_hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_AEM_UPGRADE_PRECHECKS_MBEAN_IMPL_PRE_UPGRADE_TASKS_M_BEAN_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: pre_upgrade_maintenance_tasks  (optional)
			-- 
			-- argument: pre_upgrade_hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_AEM_UPGRADE_PRECHECKS_MBEAN_IMPL_PRE_UPGRADE_TASKS_M_BEAN_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.aem.upgrade.prechecks.mbean.impl.PreUpgradeTasksMBeanImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "pre-upgrade.maintenance.tasks", pre_upgrade_maintenance_tasks));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "pre-upgrade.hc.tags", pre_upgrade_hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_AEM_UPGRADE_PRECHECKS_MBEAN_IMPL_PRE_UPGRADE_TASKS_M_BEAN_IMPL_INFO } l_response.data ({ COM_ADOBE_AEM_UPGRADE_PRECHECKS_MBEAN_IMPL_PRE_UPGRADE_TASKS_M_BEAN_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_aem_upgrade_prechecks_tasks_impl_consistency_check_task_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; root_path: STRING_32; fix_inconsistencies: BOOLEAN): detachable COM_ADOBE_AEM_UPGRADE_PRECHECKS_TASKS_IMPL_CONSISTENCY_CHECK_TASK_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: root_path  (optional)
			-- 
			-- argument: fix_inconsistencies  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_AEM_UPGRADE_PRECHECKS_TASKS_IMPL_CONSISTENCY_CHECK_TASK_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.aem.upgrade.prechecks.tasks.impl.ConsistencyCheckTaskImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "root.path", root_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "fix.inconsistencies", fix_inconsistencies));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_AEM_UPGRADE_PRECHECKS_TASKS_IMPL_CONSISTENCY_CHECK_TASK_IMPL_INFO } l_response.data ({ COM_ADOBE_AEM_UPGRADE_PRECHECKS_TASKS_IMPL_CONSISTENCY_CHECK_TASK_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_account_api_account_management_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_accountmanager_token_validity_period: INTEGER_32; cq_accountmanager_config_requestnewaccount_mail: STRING_32; cq_accountmanager_config_requestnewpwd_mail: STRING_32): detachable COM_ADOBE_CQ_ACCOUNT_API_ACCOUNT_MANAGEMENT_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_accountmanager_token_validity_period  (optional)
			-- 
			-- argument: cq_accountmanager_config_requestnewaccount_mail  (optional)
			-- 
			-- argument: cq_accountmanager_config_requestnewpwd_mail  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_ACCOUNT_API_ACCOUNT_MANAGEMENT_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.account.api.AccountManagementService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.accountmanager.token.validity.period", cq_accountmanager_token_validity_period));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.accountmanager.config.requestnewaccount.mail", cq_accountmanager_config_requestnewaccount_mail));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.accountmanager.config.requestnewpwd.mail", cq_accountmanager_config_requestnewpwd_mail));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_ACCOUNT_API_ACCOUNT_MANAGEMENT_SERVICE_INFO } l_response.data ({ COM_ADOBE_CQ_ACCOUNT_API_ACCOUNT_MANAGEMENT_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_account_impl_account_management_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_accountmanager_config_informnewaccount_mail: STRING_32; cq_accountmanager_config_informnewpwd_mail: STRING_32): detachable COM_ADOBE_CQ_ACCOUNT_IMPL_ACCOUNT_MANAGEMENT_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_accountmanager_config_informnewaccount_mail  (optional)
			-- 
			-- argument: cq_accountmanager_config_informnewpwd_mail  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_ACCOUNT_IMPL_ACCOUNT_MANAGEMENT_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.account.impl.AccountManagementServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.accountmanager.config.informnewaccount.mail", cq_accountmanager_config_informnewaccount_mail));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.accountmanager.config.informnewpwd.mail", cq_accountmanager_config_informnewpwd_mail));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_ACCOUNT_IMPL_ACCOUNT_MANAGEMENT_SERVLET_INFO } l_response.data ({ COM_ADOBE_CQ_ACCOUNT_IMPL_ACCOUNT_MANAGEMENT_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_address_impl_location_location_list_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_address_location_default_max_results: INTEGER_32): detachable COM_ADOBE_CQ_ADDRESS_IMPL_LOCATION_LOCATION_LIST_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_address_location_default_max_results  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_ADDRESS_IMPL_LOCATION_LOCATION_LIST_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.address.impl.location.LocationListServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.address.location.default.maxResults", cq_address_location_default_max_results));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_ADDRESS_IMPL_LOCATION_LOCATION_LIST_SERVLET_INFO } l_response.data ({ COM_ADOBE_CQ_ADDRESS_IMPL_LOCATION_LOCATION_LIST_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_audit_purge_dam (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; auditlog_rule_name: STRING_32; auditlog_rule_contentpath: STRING_32; auditlog_rule_minimumage: INTEGER_32; auditlog_rule_types: STRING_32): detachable COM_ADOBE_CQ_AUDIT_PURGE_DAM_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: auditlog_rule_name  (optional)
			-- 
			-- argument: auditlog_rule_contentpath  (optional)
			-- 
			-- argument: auditlog_rule_minimumage  (optional)
			-- 
			-- argument: auditlog_rule_types  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_AUDIT_PURGE_DAM_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.audit.purge.Dam"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlog.rule.name", auditlog_rule_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlog.rule.contentpath", auditlog_rule_contentpath));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlog.rule.minimumage", auditlog_rule_minimumage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlog.rule.types", auditlog_rule_types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_AUDIT_PURGE_DAM_INFO } l_response.data ({ COM_ADOBE_CQ_AUDIT_PURGE_DAM_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_audit_purge_pages (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; auditlog_rule_name: STRING_32; auditlog_rule_contentpath: STRING_32; auditlog_rule_minimumage: INTEGER_32; auditlog_rule_types: STRING_32): detachable COM_ADOBE_CQ_AUDIT_PURGE_PAGES_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: auditlog_rule_name  (optional)
			-- 
			-- argument: auditlog_rule_contentpath  (optional)
			-- 
			-- argument: auditlog_rule_minimumage  (optional)
			-- 
			-- argument: auditlog_rule_types  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_AUDIT_PURGE_PAGES_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.audit.purge.Pages"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlog.rule.name", auditlog_rule_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlog.rule.contentpath", auditlog_rule_contentpath));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlog.rule.minimumage", auditlog_rule_minimumage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlog.rule.types", auditlog_rule_types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_AUDIT_PURGE_PAGES_INFO } l_response.data ({ COM_ADOBE_CQ_AUDIT_PURGE_PAGES_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_audit_purge_replication (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; auditlog_rule_name: STRING_32; auditlog_rule_contentpath: STRING_32; auditlog_rule_minimumage: INTEGER_32; auditlog_rule_types: STRING_32): detachable COM_ADOBE_CQ_AUDIT_PURGE_REPLICATION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: auditlog_rule_name  (optional)
			-- 
			-- argument: auditlog_rule_contentpath  (optional)
			-- 
			-- argument: auditlog_rule_minimumage  (optional)
			-- 
			-- argument: auditlog_rule_types  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_AUDIT_PURGE_REPLICATION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.audit.purge.Replication"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlog.rule.name", auditlog_rule_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlog.rule.contentpath", auditlog_rule_contentpath));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlog.rule.minimumage", auditlog_rule_minimumage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlog.rule.types", auditlog_rule_types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_AUDIT_PURGE_REPLICATION_INFO } l_response.data ({ COM_ADOBE_CQ_AUDIT_PURGE_REPLICATION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_cdn_rewriter_impl_aw_scloud_front_rewriter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; keypair_id: STRING_32; keypair_alias: STRING_32; cdnrewriter_attributes: detachable LIST [STRING_32]; cdn_rewriter_distribution_domain: STRING_32): detachable COM_ADOBE_CQ_CDN_REWRITER_IMPL_AWS_CLOUD_FRONT_REWRITER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: keypair_id  (optional)
			-- 
			-- argument: keypair_alias  (optional)
			-- 
			-- argument: cdnrewriter_attributes  (optional)
			-- 
			-- argument: cdn_rewriter_distribution_domain  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_CDN_REWRITER_IMPL_AWS_CLOUD_FRONT_REWRITER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.AWSCloudFrontRewriter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "keypair.id", keypair_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "keypair.alias", keypair_alias));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cdnrewriter.attributes", cdnrewriter_attributes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cdn.rewriter.distribution.domain", cdn_rewriter_distribution_domain));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_CDN_REWRITER_IMPL_AWS_CLOUD_FRONT_REWRITER_INFO } l_response.data ({ COM_ADOBE_CQ_CDN_REWRITER_IMPL_AWS_CLOUD_FRONT_REWRITER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_cdn_rewriter_impl_cd_nconfig_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cdn_config_distribution_domain: STRING_32; cdn_config_enable_rewriting: BOOLEAN; cdn_config_path_prefixes: detachable LIST [STRING_32]; cdn_config_cdnttl: INTEGER_32; cdn_config_application_protocol: STRING_32): detachable COM_ADOBE_CQ_CDN_REWRITER_IMPL_CDN_CONFIG_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cdn_config_distribution_domain  (optional)
			-- 
			-- argument: cdn_config_enable_rewriting  (optional)
			-- 
			-- argument: cdn_config_path_prefixes  (optional)
			-- 
			-- argument: cdn_config_cdnttl  (optional)
			-- 
			-- argument: cdn_config_application_protocol  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_CDN_REWRITER_IMPL_CDN_CONFIG_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.CDNConfigServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cdn.config.distribution.domain", cdn_config_distribution_domain));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cdn.config.enable.rewriting", cdn_config_enable_rewriting));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cdn.config.path.prefixes", cdn_config_path_prefixes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cdn.config.cdnttl", cdn_config_cdnttl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cdn.config.application.protocol", cdn_config_application_protocol));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_CDN_REWRITER_IMPL_CDN_CONFIG_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_CDN_REWRITER_IMPL_CDN_CONFIG_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_cdn_rewriter_impl_cd_nrewriter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; cdnrewriter_attributes: detachable LIST [STRING_32]; cdn_rewriter_distribution_domain: STRING_32): detachable COM_ADOBE_CQ_CDN_REWRITER_IMPL_CDN_REWRITER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: cdnrewriter_attributes  (optional)
			-- 
			-- argument: cdn_rewriter_distribution_domain  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_CDN_REWRITER_IMPL_CDN_REWRITER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.CDNRewriter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cdnrewriter.attributes", cdnrewriter_attributes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cdn.rewriter.distribution.domain", cdn_rewriter_distribution_domain));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_CDN_REWRITER_IMPL_CDN_REWRITER_INFO } l_response.data ({ COM_ADOBE_CQ_CDN_REWRITER_IMPL_CDN_REWRITER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_cloudconfig_core_impl_configuration_replication_event_handle (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; flush_agents: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_CLOUDCONFIG_CORE_IMPL_CONFIGURATION_REPLICATION_EVENT_HANDLE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: flush_agents  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_CLOUDCONFIG_CORE_IMPL_CONFIGURATION_REPLICATION_EVENT_HANDLE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.cloudconfig.core.impl.ConfigurationReplicationEventHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "flush.agents", flush_agents));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_CLOUDCONFIG_CORE_IMPL_CONFIGURATION_REPLICATION_EVENT_HANDLE_INFO } l_response.data ({ COM_ADOBE_CQ_CLOUDCONFIG_CORE_IMPL_CONFIGURATION_REPLICATION_EVENT_HANDLE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_commerce_impl_asset_dynamic_image_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_commerce_asset_handler_active: BOOLEAN; cq_commerce_asset_handler_name: STRING_32): detachable COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_DYNAMIC_IMAGE_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_commerce_asset_handler_active  (optional)
			-- 
			-- argument: cq_commerce_asset_handler_name  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_DYNAMIC_IMAGE_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.commerce.impl.asset.DynamicImageHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.commerce.asset.handler.active", cq_commerce_asset_handler_active));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.commerce.asset.handler.name", cq_commerce_asset_handler_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_DYNAMIC_IMAGE_HANDLER_INFO } l_response.data ({ COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_DYNAMIC_IMAGE_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_commerce_impl_asset_product_asset_handler_provider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_commerce_asset_handler_fallback: STRING_32): detachable COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_PRODUCT_ASSET_HANDLER_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_commerce_asset_handler_fallback  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_PRODUCT_ASSET_HANDLER_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.commerce.impl.asset.ProductAssetHandlerProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.commerce.asset.handler.fallback", cq_commerce_asset_handler_fallback));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_PRODUCT_ASSET_HANDLER_PROVIDER_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_PRODUCT_ASSET_HANDLER_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_commerce_impl_asset_static_image_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_commerce_asset_handler_active: BOOLEAN; cq_commerce_asset_handler_name: STRING_32): detachable COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_STATIC_IMAGE_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_commerce_asset_handler_active  (optional)
			-- 
			-- argument: cq_commerce_asset_handler_name  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_STATIC_IMAGE_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.commerce.impl.asset.StaticImageHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.commerce.asset.handler.active", cq_commerce_asset_handler_active));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.commerce.asset.handler.name", cq_commerce_asset_handler_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_STATIC_IMAGE_HANDLER_INFO } l_response.data ({ COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_STATIC_IMAGE_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_commerce_impl_asset_video_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_commerce_asset_handler_active: BOOLEAN; cq_commerce_asset_handler_name: STRING_32): detachable COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_VIDEO_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_commerce_asset_handler_active  (optional)
			-- 
			-- argument: cq_commerce_asset_handler_name  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_VIDEO_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.commerce.impl.asset.VideoHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.commerce.asset.handler.active", cq_commerce_asset_handler_active));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.commerce.asset.handler.name", cq_commerce_asset_handler_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_VIDEO_HANDLER_INFO } l_response.data ({ COM_ADOBE_CQ_COMMERCE_IMPL_ASSET_VIDEO_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_commerce_impl_promotion_promotion_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_commerce_promotion_root: STRING_32): detachable COM_ADOBE_CQ_COMMERCE_IMPL_PROMOTION_PROMOTION_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_commerce_promotion_root  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_COMMERCE_IMPL_PROMOTION_PROMOTION_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.commerce.impl.promotion.PromotionManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.commerce.promotion.root", cq_commerce_promotion_root));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_COMMERCE_IMPL_PROMOTION_PROMOTION_MANAGER_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_COMMERCE_IMPL_PROMOTION_PROMOTION_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_commerce_pim_impl_cataloggenerator_catalog_generator_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_commerce_cataloggenerator_bucketsize: INTEGER_32; cq_commerce_cataloggenerator_bucketname: STRING_32; cq_commerce_cataloggenerator_excludedtemplateproperties: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_COMMERCE_PIM_IMPL_CATALOGGENERATOR_CATALOG_GENERATOR_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_commerce_cataloggenerator_bucketsize  (optional)
			-- 
			-- argument: cq_commerce_cataloggenerator_bucketname  (optional)
			-- 
			-- argument: cq_commerce_cataloggenerator_excludedtemplateproperties  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_COMMERCE_PIM_IMPL_CATALOGGENERATOR_CATALOG_GENERATOR_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.commerce.pim.impl.cataloggenerator.CatalogGeneratorImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.commerce.cataloggenerator.bucketsize", cq_commerce_cataloggenerator_bucketsize));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.commerce.cataloggenerator.bucketname", cq_commerce_cataloggenerator_bucketname));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.commerce.cataloggenerator.excludedtemplateproperties", cq_commerce_cataloggenerator_excludedtemplateproperties));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_COMMERCE_PIM_IMPL_CATALOGGENERATOR_CATALOG_GENERATOR_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_COMMERCE_PIM_IMPL_CATALOGGENERATOR_CATALOG_GENERATOR_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_commerce_pim_impl_page_event_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_commerce_pageeventlistener_enabled: BOOLEAN): detachable COM_ADOBE_CQ_COMMERCE_PIM_IMPL_PAGE_EVENT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_commerce_pageeventlistener_enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_COMMERCE_PIM_IMPL_PAGE_EVENT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.commerce.pim.impl.PageEventListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.commerce.pageeventlistener.enabled", cq_commerce_pageeventlistener_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_COMMERCE_PIM_IMPL_PAGE_EVENT_LISTENER_INFO } l_response.data ({ COM_ADOBE_CQ_COMMERCE_PIM_IMPL_PAGE_EVENT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_commerce_pim_impl_productfeed_product_feed_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; feed_generator_algorithm: STRING_32): detachable COM_ADOBE_CQ_COMMERCE_PIM_IMPL_PRODUCTFEED_PRODUCT_FEED_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: feed_generator_algorithm  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_COMMERCE_PIM_IMPL_PRODUCTFEED_PRODUCT_FEED_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.commerce.pim.impl.productfeed.ProductFeedServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "Feed generator algorithm", feed_generator_algorithm));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_COMMERCE_PIM_IMPL_PRODUCTFEED_PRODUCT_FEED_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_COMMERCE_PIM_IMPL_PRODUCTFEED_PRODUCT_FEED_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_contentinsight_impl_reporting_services_settings_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; reportingservices_url: STRING_32): detachable COM_ADOBE_CQ_CONTENTINSIGHT_IMPL_REPORTING_SERVICES_SETTINGS_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: reportingservices_url  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_CONTENTINSIGHT_IMPL_REPORTING_SERVICES_SETTINGS_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.contentinsight.impl.ReportingServicesSettingsProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "reportingservices.url", reportingservices_url));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_CONTENTINSIGHT_IMPL_REPORTING_SERVICES_SETTINGS_PROVIDER_INFO } l_response.data ({ COM_ADOBE_CQ_CONTENTINSIGHT_IMPL_REPORTING_SERVICES_SETTINGS_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_contentinsight_impl_servlets_bright_edge_proxy_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; brightedge_url: STRING_32): detachable COM_ADOBE_CQ_CONTENTINSIGHT_IMPL_SERVLETS_BRIGHT_EDGE_PROXY_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: brightedge_url  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_CONTENTINSIGHT_IMPL_SERVLETS_BRIGHT_EDGE_PROXY_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.contentinsight.impl.servlets.BrightEdgeProxyServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "brightedge.url", brightedge_url));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_CONTENTINSIGHT_IMPL_SERVLETS_BRIGHT_EDGE_PROXY_SERVLET_INFO } l_response.data ({ COM_ADOBE_CQ_CONTENTINSIGHT_IMPL_SERVLETS_BRIGHT_EDGE_PROXY_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_contentinsight_impl_servlets_reporting_services_proxy_servle (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; reportingservices_proxy_whitelist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_CONTENTINSIGHT_IMPL_SERVLETS_REPORTING_SERVICES_PROXY_SERVLE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: reportingservices_proxy_whitelist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_CONTENTINSIGHT_IMPL_SERVLETS_REPORTING_SERVICES_PROXY_SERVLE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.contentinsight.impl.servlets.ReportingServicesProxyServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "reportingservices.proxy.whitelist", reportingservices_proxy_whitelist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_CONTENTINSIGHT_IMPL_SERVLETS_REPORTING_SERVICES_PROXY_SERVLE_INFO } l_response.data ({ COM_ADOBE_CQ_CONTENTINSIGHT_IMPL_SERVLETS_REPORTING_SERVICES_PROXY_SERVLE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_cfm_impl_component_component_config_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; dam_cfm_component_resource_type: STRING_32; dam_cfm_component_file_reference_prop: STRING_32; dam_cfm_component_elements_prop: STRING_32; dam_cfm_component_variation_prop: STRING_32): detachable COM_ADOBE_CQ_DAM_CFM_IMPL_COMPONENT_COMPONENT_CONFIG_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: dam_cfm_component_resource_type  (optional)
			-- 
			-- argument: dam_cfm_component_file_reference_prop  (optional)
			-- 
			-- argument: dam_cfm_component_elements_prop  (optional)
			-- 
			-- argument: dam_cfm_component_variation_prop  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_CFM_IMPL_COMPONENT_COMPONENT_CONFIG_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.component.ComponentConfigImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dam.cfm.component.resourceType", dam_cfm_component_resource_type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dam.cfm.component.fileReferenceProp", dam_cfm_component_file_reference_prop));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dam.cfm.component.elementsProp", dam_cfm_component_elements_prop));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dam.cfm.component.variationProp", dam_cfm_component_variation_prop));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_CFM_IMPL_COMPONENT_COMPONENT_CONFIG_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_CFM_IMPL_COMPONENT_COMPONENT_CONFIG_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_cfm_impl_conf_feature_config_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; dam_cfm_resource_types: detachable LIST [STRING_32]; dam_cfm_reference_properties: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_DAM_CFM_IMPL_CONF_FEATURE_CONFIG_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: dam_cfm_resource_types  (optional)
			-- 
			-- argument: dam_cfm_reference_properties  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_CFM_IMPL_CONF_FEATURE_CONFIG_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.conf.FeatureConfigImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "dam.cfm.resourceTypes", dam_cfm_resource_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "dam.cfm.referenceProperties", dam_cfm_reference_properties));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_CFM_IMPL_CONF_FEATURE_CONFIG_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_CFM_IMPL_CONF_FEATURE_CONFIG_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_cfm_impl_content_rewriter_asset_processor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; pipeline_type: STRING_32): detachable COM_ADOBE_CQ_DAM_CFM_IMPL_CONTENT_REWRITER_ASSET_PROCESSOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: pipeline_type  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_CFM_IMPL_CONTENT_REWRITER_ASSET_PROCESSOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.AssetProcessor"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pipeline.type", pipeline_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_CFM_IMPL_CONTENT_REWRITER_ASSET_PROCESSOR_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_CFM_IMPL_CONTENT_REWRITER_ASSET_PROCESSOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_cfm_impl_content_rewriter_par_range_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; pipeline_type: STRING_32): detachable COM_ADOBE_CQ_DAM_CFM_IMPL_CONTENT_REWRITER_PAR_RANGE_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: pipeline_type  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_CFM_IMPL_CONTENT_REWRITER_PAR_RANGE_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.ParRangeFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pipeline.type", pipeline_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_CFM_IMPL_CONTENT_REWRITER_PAR_RANGE_FILTER_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_CFM_IMPL_CONTENT_REWRITER_PAR_RANGE_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_cfm_impl_content_rewriter_payload_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; pipeline_type: STRING_32): detachable COM_ADOBE_CQ_DAM_CFM_IMPL_CONTENT_REWRITER_PAYLOAD_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: pipeline_type  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_CFM_IMPL_CONTENT_REWRITER_PAYLOAD_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.PayloadFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pipeline.type", pipeline_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_CFM_IMPL_CONTENT_REWRITER_PAYLOAD_FILTER_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_CFM_IMPL_CONTENT_REWRITER_PAYLOAD_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_dm_process_image_ptiff_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_memory: INTEGER_32): detachable COM_ADOBE_CQ_DAM_DM_PROCESS_IMAGE_P_TIFF_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_memory  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_DM_PROCESS_IMAGE_P_TIFF_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.dm.process.image.PTiffManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxMemory", max_memory));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_DM_PROCESS_IMAGE_P_TIFF_MANAGER_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_DM_PROCESS_IMAGE_P_TIFF_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_ips_impl_replication_trigger_replicate_on_modify_worker (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; dmreplicateonmodify_enabled: BOOLEAN; dmreplicateonmodify_forcesyncdeletes: BOOLEAN): detachable COM_ADOBE_CQ_DAM_IPS_IMPL_REPLICATION_TRIGGER_REPLICATE_ON_MODIFY_WORKER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: dmreplicateonmodify_enabled  (optional)
			-- 
			-- argument: dmreplicateonmodify_forcesyncdeletes  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_IPS_IMPL_REPLICATION_TRIGGER_REPLICATE_ON_MODIFY_WORKER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.ips.impl.replication.trigger.ReplicateOnModifyWorker"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dmreplicateonmodify.enabled", dmreplicateonmodify_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dmreplicateonmodify.forcesyncdeletes", dmreplicateonmodify_forcesyncdeletes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_IPS_IMPL_REPLICATION_TRIGGER_REPLICATE_ON_MODIFY_WORKER_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_IPS_IMPL_REPLICATION_TRIGGER_REPLICATE_ON_MODIFY_WORKER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_mac_sync_helper_impl_ma_csync_client_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_adobe_dam_mac_sync_client_so_timeout: INTEGER_32): detachable COM_ADOBE_CQ_DAM_MAC_SYNC_HELPER_IMPL_MAC_SYNC_CLIENT_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_adobe_dam_mac_sync_client_so_timeout  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_MAC_SYNC_HELPER_IMPL_MAC_SYNC_CLIENT_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.mac.sync.helper.impl.MACSyncClientImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.dam.mac.sync.client.so.timeout", com_adobe_dam_mac_sync_client_so_timeout));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_MAC_SYNC_HELPER_IMPL_MAC_SYNC_CLIENT_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_MAC_SYNC_HELPER_IMPL_MAC_SYNC_CLIENT_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_mac_sync_impl_da_msync_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_adobe_cq_dam_mac_sync_damsyncservice_registered_paths: detachable LIST [STRING_32]; com_adobe_cq_dam_mac_sync_damsyncservice_sync_renditions: BOOLEAN; com_adobe_cq_dam_mac_sync_damsyncservice_replicate_thread_wait_ms: INTEGER_32; com_adobe_cq_dam_mac_sync_damsyncservice_platform: STRING_32): detachable COM_ADOBE_CQ_DAM_MAC_SYNC_IMPL_DAM_SYNC_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_adobe_cq_dam_mac_sync_damsyncservice_registered_paths  (optional)
			-- 
			-- argument: com_adobe_cq_dam_mac_sync_damsyncservice_sync_renditions  (optional)
			-- 
			-- argument: com_adobe_cq_dam_mac_sync_damsyncservice_replicate_thread_wait_ms  (optional)
			-- 
			-- argument: com_adobe_cq_dam_mac_sync_damsyncservice_platform  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_MAC_SYNC_IMPL_DAM_SYNC_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.mac.sync.impl.DAMSyncServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "com.adobe.cq.dam.mac.sync.damsyncservice.registered_paths", com_adobe_cq_dam_mac_sync_damsyncservice_registered_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.dam.mac.sync.damsyncservice.sync.renditions", com_adobe_cq_dam_mac_sync_damsyncservice_sync_renditions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.dam.mac.sync.damsyncservice.replicate.thread.wait.ms", com_adobe_cq_dam_mac_sync_damsyncservice_replicate_thread_wait_ms));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.dam.mac.sync.damsyncservice.platform", com_adobe_cq_dam_mac_sync_damsyncservice_platform));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_MAC_SYNC_IMPL_DAM_SYNC_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_MAC_SYNC_IMPL_DAM_SYNC_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_processor_nui_impl_nui_asset_processor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; nui_enabled: BOOLEAN; nui_service_url: STRING_32; nui_api_key: STRING_32): detachable COM_ADOBE_CQ_DAM_PROCESSOR_NUI_IMPL_NUI_ASSET_PROCESSOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: nui_enabled  (optional)
			-- 
			-- argument: nui_service_url  (optional)
			-- 
			-- argument: nui_api_key  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_PROCESSOR_NUI_IMPL_NUI_ASSET_PROCESSOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.processor.nui.impl.NuiAssetProcessor"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "nuiEnabled", nui_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "nuiServiceUrl", nui_service_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "nuiApiKey", nui_api_key));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_PROCESSOR_NUI_IMPL_NUI_ASSET_PROCESSOR_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_PROCESSOR_NUI_IMPL_NUI_ASSET_PROCESSOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_s7imaging_impl_is_image_server_component (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; tcp_port: STRING_32; allow_remote_access: BOOLEAN; max_render_rgn_pixels: STRING_32; max_message_size: STRING_32; random_access_url_timeout: INTEGER_32; worker_threads: INTEGER_32): detachable COM_ADOBE_CQ_DAM_S7IMAGING_IMPL_IS_IMAGE_SERVER_COMPONENT_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: tcp_port  (optional)
			-- 
			-- argument: allow_remote_access  (optional)
			-- 
			-- argument: max_render_rgn_pixels  (optional)
			-- 
			-- argument: max_message_size  (optional)
			-- 
			-- argument: random_access_url_timeout  (optional)
			-- 
			-- argument: worker_threads  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_S7IMAGING_IMPL_IS_IMAGE_SERVER_COMPONENT_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.s7imaging.impl.is.ImageServerComponent"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "TcpPort", tcp_port));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "AllowRemoteAccess", allow_remote_access));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "MaxRenderRgnPixels", max_render_rgn_pixels));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "MaxMessageSize", max_message_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "RandomAccessUrlTimeout", random_access_url_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "WorkerThreads", worker_threads));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_S7IMAGING_IMPL_IS_IMAGE_SERVER_COMPONENT_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_S7IMAGING_IMPL_IS_IMAGE_SERVER_COMPONENT_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_s7imaging_impl_ps_platform_server_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cache_enable: BOOLEAN; cache_root_paths: detachable LIST [STRING_32]; cache_max_size: INTEGER_32; cache_max_entries: INTEGER_32): detachable COM_ADOBE_CQ_DAM_S7IMAGING_IMPL_PS_PLATFORM_SERVER_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cache_enable  (optional)
			-- 
			-- argument: cache_root_paths  (optional)
			-- 
			-- argument: cache_max_size  (optional)
			-- 
			-- argument: cache_max_entries  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_S7IMAGING_IMPL_PS_PLATFORM_SERVER_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.s7imaging.impl.ps.PlatformServerServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.enable", cache_enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cache.rootPaths", cache_root_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.maxSize", cache_max_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.maxEntries", cache_max_entries));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_S7IMAGING_IMPL_PS_PLATFORM_SERVER_SERVLET_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_S7IMAGING_IMPL_PS_PLATFORM_SERVER_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_webdav_impl_io_asset_io_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; path_prefix: STRING_32; create_version: BOOLEAN): detachable COM_ADOBE_CQ_DAM_WEBDAV_IMPL_IO_ASSET_IO_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: path_prefix  (optional)
			-- 
			-- argument: create_version  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_WEBDAV_IMPL_IO_ASSET_IO_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.AssetIOHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pathPrefix", path_prefix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "createVersion", create_version));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_WEBDAV_IMPL_IO_ASSET_IO_HANDLER_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_WEBDAV_IMPL_IO_ASSET_IO_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_webdav_impl_io_dam_webdav_version_linking_job (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_webdav_version_linking_enable: BOOLEAN; cq_dam_webdav_version_linking_scheduler_period: INTEGER_32; cq_dam_webdav_version_linking_staging_timeout: INTEGER_32): detachable COM_ADOBE_CQ_DAM_WEBDAV_IMPL_IO_DAM_WEBDAV_VERSION_LINKING_JOB_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_webdav_version_linking_enable  (optional)
			-- 
			-- argument: cq_dam_webdav_version_linking_scheduler_period  (optional)
			-- 
			-- argument: cq_dam_webdav_version_linking_staging_timeout  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_WEBDAV_IMPL_IO_DAM_WEBDAV_VERSION_LINKING_JOB_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.DamWebdavVersionLinkingJob"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.webdav.version.linking.enable", cq_dam_webdav_version_linking_enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.webdav.version.linking.scheduler.period", cq_dam_webdav_version_linking_scheduler_period));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.webdav.version.linking.staging.timeout", cq_dam_webdav_version_linking_staging_timeout));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_WEBDAV_IMPL_IO_DAM_WEBDAV_VERSION_LINKING_JOB_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_WEBDAV_IMPL_IO_DAM_WEBDAV_VERSION_LINKING_JOB_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dam_webdav_impl_io_special_files_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_day_cq_dam_core_impl_io__special_files_handler_filepatters: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_DAM_WEBDAV_IMPL_IO_SPECIAL_FILES_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_day_cq_dam_core_impl_io__special_files_handler_filepatters  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DAM_WEBDAV_IMPL_IO_SPECIAL_FILES_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.SpecialFilesHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "com.day.cq.dam.core.impl.io.SpecialFilesHandler.filepatters", com_day_cq_dam_core_impl_io__special_files_handler_filepatters));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DAM_WEBDAV_IMPL_IO_SPECIAL_FILES_HANDLER_INFO } l_response.data ({ COM_ADOBE_CQ_DAM_WEBDAV_IMPL_IO_SPECIAL_FILES_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_deserfw_impl_deserialization_firewall_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; firewall_deserialization_whitelist: detachable LIST [STRING_32]; firewall_deserialization_blacklist: detachable LIST [STRING_32]; firewall_deserialization_diagnostics: STRING_32): detachable COM_ADOBE_CQ_DESERFW_IMPL_DESERIALIZATION_FIREWALL_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: firewall_deserialization_whitelist  (optional)
			-- 
			-- argument: firewall_deserialization_blacklist  (optional)
			-- 
			-- argument: firewall_deserialization_diagnostics  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DESERFW_IMPL_DESERIALIZATION_FIREWALL_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.deserfw.impl.DeserializationFirewallImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "firewall.deserialization.whitelist", firewall_deserialization_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "firewall.deserialization.blacklist", firewall_deserialization_blacklist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "firewall.deserialization.diagnostics", firewall_deserialization_diagnostics));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DESERFW_IMPL_DESERIALIZATION_FIREWALL_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_DESERFW_IMPL_DESERIALIZATION_FIREWALL_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dtm_impl_service_dt_mweb_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; connection_timeout: INTEGER_32; socket_timeout: INTEGER_32): detachable COM_ADOBE_CQ_DTM_IMPL_SERVICE_DTM_WEB_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: connection_timeout  (optional)
			-- 
			-- argument: socket_timeout  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DTM_IMPL_SERVICE_DTM_WEB_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dtm.impl.service.DTMWebServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connection.timeout", connection_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "socket.timeout", socket_timeout));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DTM_IMPL_SERVICE_DTM_WEB_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_DTM_IMPL_SERVICE_DTM_WEB_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dtm_impl_servlets_dt_mdeploy_hook_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; dtm_staging_ip_whitelist: detachable LIST [STRING_32]; dtm_production_ip_whitelist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_DTM_IMPL_SERVLETS_DTM_DEPLOY_HOOK_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: dtm_staging_ip_whitelist  (optional)
			-- 
			-- argument: dtm_production_ip_whitelist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DTM_IMPL_SERVLETS_DTM_DEPLOY_HOOK_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dtm.impl.servlets.DTMDeployHookServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "dtm.staging.ip.whitelist", dtm_staging_ip_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "dtm.production.ip.whitelist", dtm_production_ip_whitelist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DTM_IMPL_SERVLETS_DTM_DEPLOY_HOOK_SERVLET_INFO } l_response.data ({ COM_ADOBE_CQ_DTM_IMPL_SERVLETS_DTM_DEPLOY_HOOK_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_dtm_reactor_impl_service_web_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; endpoint_uri: STRING_32; connection_timeout: INTEGER_32; socket_timeout: INTEGER_32): detachable COM_ADOBE_CQ_DTM_REACTOR_IMPL_SERVICE_WEB_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: endpoint_uri  (optional)
			-- 
			-- argument: connection_timeout  (optional)
			-- 
			-- argument: socket_timeout  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_DTM_REACTOR_IMPL_SERVICE_WEB_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.dtm.reactor.impl.service.WebServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endpointUri", endpoint_uri));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connectionTimeout", connection_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "socketTimeout", socket_timeout));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_DTM_REACTOR_IMPL_SERVICE_WEB_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_DTM_REACTOR_IMPL_SERVICE_WEB_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_experiencelog_impl_experience_log_config_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN; disabled_for_groups: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_EXPERIENCELOG_IMPL_EXPERIENCE_LOG_CONFIG_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: disabled_for_groups  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_EXPERIENCELOG_IMPL_EXPERIENCE_LOG_CONFIG_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.experiencelog.impl.ExperienceLogConfigServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "disabledForGroups", disabled_for_groups));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_EXPERIENCELOG_IMPL_EXPERIENCE_LOG_CONFIG_SERVLET_INFO } l_response.data ({ COM_ADOBE_CQ_EXPERIENCELOG_IMPL_EXPERIENCE_LOG_CONFIG_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_hc_content_packages_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_name: STRING_32; hc_tags: detachable LIST [STRING_32]; hc_mbean_name: STRING_32; package_names: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_HC_CONTENT_PACKAGES_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_name  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: hc_mbean_name  (optional)
			-- 
			-- argument: package_names  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_HC_CONTENT_PACKAGES_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.hc.ContentPackagesHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.name", hc_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.mbean.name", hc_mbean_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "package.names", package_names));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_HC_CONTENT_PACKAGES_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_CQ_HC_CONTENT_PACKAGES_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_history_impl_history_request_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; history_request_filter_excluded_selectors: detachable LIST [STRING_32]; history_request_filter_excluded_extensions: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_HISTORY_IMPL_HISTORY_REQUEST_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: history_request_filter_excluded_selectors  (optional)
			-- 
			-- argument: history_request_filter_excluded_extensions  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_HISTORY_IMPL_HISTORY_REQUEST_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.history.impl.HistoryRequestFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "history.requestFilter.excludedSelectors", history_request_filter_excluded_selectors));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "history.requestFilter.excludedExtensions", history_request_filter_excluded_extensions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_HISTORY_IMPL_HISTORY_REQUEST_FILTER_INFO } l_response.data ({ COM_ADOBE_CQ_HISTORY_IMPL_HISTORY_REQUEST_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_history_impl_history_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; history_service_resource_types: detachable LIST [STRING_32]; history_service_path_filter: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_HISTORY_IMPL_HISTORY_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: history_service_resource_types  (optional)
			-- 
			-- argument: history_service_path_filter  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_HISTORY_IMPL_HISTORY_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.history.impl.HistoryServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "history.service.resourceTypes", history_service_resource_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "history.service.pathFilter", history_service_path_filter));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_HISTORY_IMPL_HISTORY_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_HISTORY_IMPL_HISTORY_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_inbox_impl_typeprovider_item_type_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; inbox_impl_typeprovider_registrypaths: detachable LIST [STRING_32]; inbox_impl_typeprovider_legacypaths: detachable LIST [STRING_32]; inbox_impl_typeprovider_defaulturl_failureitem: STRING_32; inbox_impl_typeprovider_defaulturl_workitem: STRING_32; inbox_impl_typeprovider_defaulturl_task: STRING_32): detachable COM_ADOBE_CQ_INBOX_IMPL_TYPEPROVIDER_ITEM_TYPE_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: inbox_impl_typeprovider_registrypaths  (optional)
			-- 
			-- argument: inbox_impl_typeprovider_legacypaths  (optional)
			-- 
			-- argument: inbox_impl_typeprovider_defaulturl_failureitem  (optional)
			-- 
			-- argument: inbox_impl_typeprovider_defaulturl_workitem  (optional)
			-- 
			-- argument: inbox_impl_typeprovider_defaulturl_task  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_INBOX_IMPL_TYPEPROVIDER_ITEM_TYPE_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.inbox.impl.typeprovider.ItemTypeProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "inbox.impl.typeprovider.registrypaths", inbox_impl_typeprovider_registrypaths));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "inbox.impl.typeprovider.legacypaths", inbox_impl_typeprovider_legacypaths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "inbox.impl.typeprovider.defaulturl.failureitem", inbox_impl_typeprovider_defaulturl_failureitem));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "inbox.impl.typeprovider.defaulturl.workitem", inbox_impl_typeprovider_defaulturl_workitem));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "inbox.impl.typeprovider.defaulturl.task", inbox_impl_typeprovider_defaulturl_task));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_INBOX_IMPL_TYPEPROVIDER_ITEM_TYPE_PROVIDER_INFO } l_response.data ({ COM_ADOBE_CQ_INBOX_IMPL_TYPEPROVIDER_ITEM_TYPE_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_projects_impl_servlet_project_image_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; image_quality: STRING_32; image_supported_resolutions: STRING_32): detachable COM_ADOBE_CQ_PROJECTS_IMPL_SERVLET_PROJECT_IMAGE_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: image_quality  (optional)
			-- 
			-- argument: image_supported_resolutions  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_PROJECTS_IMPL_SERVLET_PROJECT_IMAGE_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.projects.impl.servlet.ProjectImageServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "image.quality", image_quality));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "image.supported.resolutions", image_supported_resolutions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_PROJECTS_IMPL_SERVLET_PROJECT_IMAGE_SERVLET_INFO } l_response.data ({ COM_ADOBE_CQ_PROJECTS_IMPL_SERVLET_PROJECT_IMAGE_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_projects_purge_scheduler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduledpurge_name: STRING_32; scheduledpurge_purge_active: BOOLEAN; scheduledpurge_templates: detachable LIST [STRING_32]; scheduledpurge_purge_groups: BOOLEAN; scheduledpurge_purge_assets: BOOLEAN; scheduledpurge_terminate_running_workflows: BOOLEAN; scheduledpurge_daysold: INTEGER_32; scheduledpurge_save_threshold: INTEGER_32): detachable COM_ADOBE_CQ_PROJECTS_PURGE_SCHEDULER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduledpurge_name  (optional)
			-- 
			-- argument: scheduledpurge_purge_active  (optional)
			-- 
			-- argument: scheduledpurge_templates  (optional)
			-- 
			-- argument: scheduledpurge_purge_groups  (optional)
			-- 
			-- argument: scheduledpurge_purge_assets  (optional)
			-- 
			-- argument: scheduledpurge_terminate_running_workflows  (optional)
			-- 
			-- argument: scheduledpurge_daysold  (optional)
			-- 
			-- argument: scheduledpurge_save_threshold  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_PROJECTS_PURGE_SCHEDULER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.projects.purge.Scheduler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduledpurge.name", scheduledpurge_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduledpurge.purgeActive", scheduledpurge_purge_active));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "scheduledpurge.templates", scheduledpurge_templates));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduledpurge.purgeGroups", scheduledpurge_purge_groups));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduledpurge.purgeAssets", scheduledpurge_purge_assets));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduledpurge.terminateRunningWorkflows", scheduledpurge_terminate_running_workflows));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduledpurge.daysold", scheduledpurge_daysold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduledpurge.saveThreshold", scheduledpurge_save_threshold));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_PROJECTS_PURGE_SCHEDULER_INFO } l_response.data ({ COM_ADOBE_CQ_PROJECTS_PURGE_SCHEDULER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_scheduled_exporter_impl_scheduled_exporter_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; include_paths: detachable LIST [STRING_32]; exporter_user: STRING_32): detachable COM_ADOBE_CQ_SCHEDULED_EXPORTER_IMPL_SCHEDULED_EXPORTER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: include_paths  (optional)
			-- 
			-- argument: exporter_user  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCHEDULED_EXPORTER_IMPL_SCHEDULED_EXPORTER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.scheduled.exporter.impl.ScheduledExporterImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "include.paths", include_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "exporter.user", exporter_user));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCHEDULED_EXPORTER_IMPL_SCHEDULED_EXPORTER_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SCHEDULED_EXPORTER_IMPL_SCHEDULED_EXPORTER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_screens_analytics_impl_screens_analytics_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_adobe_cq_screens_analytics_impl_url: STRING_32; com_adobe_cq_screens_analytics_impl_apikey: STRING_32; com_adobe_cq_screens_analytics_impl_project: STRING_32; com_adobe_cq_screens_analytics_impl_environment: STRING_32; com_adobe_cq_screens_analytics_impl_send_frequency: INTEGER_32): detachable COM_ADOBE_CQ_SCREENS_ANALYTICS_IMPL_SCREENS_ANALYTICS_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_adobe_cq_screens_analytics_impl_url  (optional)
			-- 
			-- argument: com_adobe_cq_screens_analytics_impl_apikey  (optional)
			-- 
			-- argument: com_adobe_cq_screens_analytics_impl_project  (optional)
			-- 
			-- argument: com_adobe_cq_screens_analytics_impl_environment  (optional)
			-- 
			-- argument: com_adobe_cq_screens_analytics_impl_send_frequency  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCREENS_ANALYTICS_IMPL_SCREENS_ANALYTICS_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.screens.analytics.impl.ScreensAnalyticsServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.analytics.impl.url", com_adobe_cq_screens_analytics_impl_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.analytics.impl.apikey", com_adobe_cq_screens_analytics_impl_apikey));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.analytics.impl.project", com_adobe_cq_screens_analytics_impl_project));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.analytics.impl.environment", com_adobe_cq_screens_analytics_impl_environment));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.analytics.impl.sendFrequency", com_adobe_cq_screens_analytics_impl_send_frequency));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCREENS_ANALYTICS_IMPL_SCREENS_ANALYTICS_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SCREENS_ANALYTICS_IMPL_SCREENS_ANALYTICS_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_screens_device_impl_device_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_adobe_aem_screens_player_pingfrequency: INTEGER_32; com_adobe_aem_screens_device_pasword_specialchars: STRING_32; com_adobe_aem_screens_device_pasword_minlowercasechars: INTEGER_32; com_adobe_aem_screens_device_pasword_minuppercasechars: INTEGER_32; com_adobe_aem_screens_device_pasword_minnumberchars: INTEGER_32; com_adobe_aem_screens_device_pasword_minspecialchars: INTEGER_32; com_adobe_aem_screens_device_pasword_minlength: INTEGER_32): detachable COM_ADOBE_CQ_SCREENS_DEVICE_IMPL_DEVICE_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_adobe_aem_screens_player_pingfrequency  (optional)
			-- 
			-- argument: com_adobe_aem_screens_device_pasword_specialchars  (optional)
			-- 
			-- argument: com_adobe_aem_screens_device_pasword_minlowercasechars  (optional)
			-- 
			-- argument: com_adobe_aem_screens_device_pasword_minuppercasechars  (optional)
			-- 
			-- argument: com_adobe_aem_screens_device_pasword_minnumberchars  (optional)
			-- 
			-- argument: com_adobe_aem_screens_device_pasword_minspecialchars  (optional)
			-- 
			-- argument: com_adobe_aem_screens_device_pasword_minlength  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCREENS_DEVICE_IMPL_DEVICE_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.screens.device.impl.DeviceService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.aem.screens.player.pingfrequency", com_adobe_aem_screens_player_pingfrequency));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.aem.screens.device.pasword.specialchars", com_adobe_aem_screens_device_pasword_specialchars));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.aem.screens.device.pasword.minlowercasechars", com_adobe_aem_screens_device_pasword_minlowercasechars));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.aem.screens.device.pasword.minuppercasechars", com_adobe_aem_screens_device_pasword_minuppercasechars));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.aem.screens.device.pasword.minnumberchars", com_adobe_aem_screens_device_pasword_minnumberchars));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.aem.screens.device.pasword.minspecialchars", com_adobe_aem_screens_device_pasword_minspecialchars));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.aem.screens.device.pasword.minlength", com_adobe_aem_screens_device_pasword_minlength));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCREENS_DEVICE_IMPL_DEVICE_SERVICE_INFO } l_response.data ({ COM_ADOBE_CQ_SCREENS_DEVICE_IMPL_DEVICE_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_screens_device_registration_impl_registration_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; device_registration_timeout: INTEGER_32): detachable COM_ADOBE_CQ_SCREENS_DEVICE_REGISTRATION_IMPL_REGISTRATION_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: device_registration_timeout  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCREENS_DEVICE_REGISTRATION_IMPL_REGISTRATION_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.screens.device.registration.impl.RegistrationServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "deviceRegistrationTimeout", device_registration_timeout));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCREENS_DEVICE_REGISTRATION_IMPL_REGISTRATION_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SCREENS_DEVICE_REGISTRATION_IMPL_REGISTRATION_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_screens_impl_handler_channels_update_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_pagesupdatehandler_imageresourcetypes: detachable LIST [STRING_32]; cq_pagesupdatehandler_productresourcetypes: detachable LIST [STRING_32]; cq_pagesupdatehandler_videoresourcetypes: detachable LIST [STRING_32]; cq_pagesupdatehandler_dynamicsequenceresourcetypes: detachable LIST [STRING_32]; cq_pagesupdatehandler_previewmodepaths: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SCREENS_IMPL_HANDLER_CHANNELS_UPDATE_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_pagesupdatehandler_imageresourcetypes  (optional)
			-- 
			-- argument: cq_pagesupdatehandler_productresourcetypes  (optional)
			-- 
			-- argument: cq_pagesupdatehandler_videoresourcetypes  (optional)
			-- 
			-- argument: cq_pagesupdatehandler_dynamicsequenceresourcetypes  (optional)
			-- 
			-- argument: cq_pagesupdatehandler_previewmodepaths  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCREENS_IMPL_HANDLER_CHANNELS_UPDATE_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.screens.impl.handler.ChannelsUpdateHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.pagesupdatehandler.imageresourcetypes", cq_pagesupdatehandler_imageresourcetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.pagesupdatehandler.productresourcetypes", cq_pagesupdatehandler_productresourcetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.pagesupdatehandler.videoresourcetypes", cq_pagesupdatehandler_videoresourcetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.pagesupdatehandler.dynamicsequenceresourcetypes", cq_pagesupdatehandler_dynamicsequenceresourcetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.pagesupdatehandler.previewmodepaths", cq_pagesupdatehandler_previewmodepaths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCREENS_IMPL_HANDLER_CHANNELS_UPDATE_HANDLER_INFO } l_response.data ({ COM_ADOBE_CQ_SCREENS_IMPL_HANDLER_CHANNELS_UPDATE_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_screens_impl_jobs_distributed_devices_stati_update_job (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_expression: STRING_32): detachable COM_ADOBE_CQ_SCREENS_IMPL_JOBS_DISTRIBUTED_DEVICES_STATI_UPDATE_JOB_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCREENS_IMPL_JOBS_DISTRIBUTED_DEVICES_STATI_UPDATE_JOB_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.screens.impl.jobs.DistributedDevicesStatiUpdateJob"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCREENS_IMPL_JOBS_DISTRIBUTED_DEVICES_STATI_UPDATE_JOB_INFO } l_response.data ({ COM_ADOBE_CQ_SCREENS_IMPL_JOBS_DISTRIBUTED_DEVICES_STATI_UPDATE_JOB_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_screens_impl_remote_impl_distributed_http_client_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_adobe_aem_screens_impl_remote_request_timeout: INTEGER_32): detachable COM_ADOBE_CQ_SCREENS_IMPL_REMOTE_IMPL_DISTRIBUTED_HTTP_CLIENT_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_adobe_aem_screens_impl_remote_request_timeout  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCREENS_IMPL_REMOTE_IMPL_DISTRIBUTED_HTTP_CLIENT_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.screens.impl.remote.impl.DistributedHttpClientImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.aem.screens.impl.remote.request_timeout", com_adobe_aem_screens_impl_remote_request_timeout));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCREENS_IMPL_REMOTE_IMPL_DISTRIBUTED_HTTP_CLIENT_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SCREENS_IMPL_REMOTE_IMPL_DISTRIBUTED_HTTP_CLIENT_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_screens_impl_screens_channel_post_processor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; screens_channels_properties_to_remove: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SCREENS_IMPL_SCREENS_CHANNEL_POST_PROCESSOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: screens_channels_properties_to_remove  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCREENS_IMPL_SCREENS_CHANNEL_POST_PROCESSOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.screens.impl.ScreensChannelPostProcessor"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "screens.channels.properties.to.remove", screens_channels_properties_to_remove));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCREENS_IMPL_SCREENS_CHANNEL_POST_PROCESSOR_INFO } l_response.data ({ COM_ADOBE_CQ_SCREENS_IMPL_SCREENS_CHANNEL_POST_PROCESSOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_screens_monitoring_impl_screens_monitoring_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_project_path: detachable LIST [STRING_32]; com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_schedule_frequency: STRING_32; com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_ping_timeout: INTEGER_32; com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_recipients: STRING_32; com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_smtpserver: STRING_32; com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_smtpport: INTEGER_32; com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_usetls: BOOLEAN; com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_username: STRING_32; com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_password: STRING_32): detachable COM_ADOBE_CQ_SCREENS_MONITORING_IMPL_SCREENS_MONITORING_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_project_path  (optional)
			-- 
			-- argument: com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_schedule_frequency  (optional)
			-- 
			-- argument: com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_ping_timeout  (optional)
			-- 
			-- argument: com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_recipients  (optional)
			-- 
			-- argument: com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_smtpserver  (optional)
			-- 
			-- argument: com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_smtpport  (optional)
			-- 
			-- argument: com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_usetls  (optional)
			-- 
			-- argument: com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_username  (optional)
			-- 
			-- argument: com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_password  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCREENS_MONITORING_IMPL_SCREENS_MONITORING_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.projectPath", com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_project_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.scheduleFrequency", com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_schedule_frequency));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.pingTimeout", com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_ping_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.recipients", com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_recipients));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpserver", com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_smtpserver));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpport", com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_smtpport));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.usetls", com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_usetls));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.username", com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_username));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.password", com_adobe_cq_screens_monitoring_impl__screens_monitoring_service_impl_password));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCREENS_MONITORING_IMPL_SCREENS_MONITORING_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SCREENS_MONITORING_IMPL_SCREENS_MONITORING_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_screens_mq_activemq_impl_artemis_jm_sprovider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; global_size: INTEGER_32; max_disk_usage: INTEGER_32; persistence_enabled: BOOLEAN; thread_pool_max_size: INTEGER_32; scheduled_thread_pool_max_size: INTEGER_32; graceful_shutdown_timeout: INTEGER_32; queues: detachable LIST [STRING_32]; topics: detachable LIST [STRING_32]; addresses_max_delivery_attempts: INTEGER_32; addresses_expiry_delay: INTEGER_32; addresses_address_full_message_policy: STRING_32; addresses_max_size_bytes: INTEGER_32; addresses_page_size_bytes: INTEGER_32; addresses_page_cache_max_size: INTEGER_32; cluster_user: STRING_32; cluster_password: STRING_32; cluster_call_timeout: INTEGER_32; cluster_call_failover_timeout: INTEGER_32; cluster_client_failure_check_period: INTEGER_32; cluster_notification_attempts: INTEGER_32; cluster_notification_interval: INTEGER_32; id_cache_size: INTEGER_32; cluster_confirmation_window_size: INTEGER_32; cluster_connection_ttl: INTEGER_32; cluster_duplicate_detection: BOOLEAN; cluster_initial_connect_attempts: INTEGER_32; cluster_max_retry_interval: INTEGER_32; cluster_min_large_message_size: INTEGER_32; cluster_producer_window_size: INTEGER_32; cluster_reconnect_attempts: INTEGER_32; cluster_retry_interval: INTEGER_32; cluster_retry_interval_multiplier: REAL_32): detachable COM_ADOBE_CQ_SCREENS_MQ_ACTIVEMQ_IMPL_ARTEMIS_JMS_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: global_size  (optional)
			-- 
			-- argument: max_disk_usage  (optional)
			-- 
			-- argument: persistence_enabled  (optional)
			-- 
			-- argument: thread_pool_max_size  (optional)
			-- 
			-- argument: scheduled_thread_pool_max_size  (optional)
			-- 
			-- argument: graceful_shutdown_timeout  (optional)
			-- 
			-- argument: queues  (optional)
			-- 
			-- argument: topics  (optional)
			-- 
			-- argument: addresses_max_delivery_attempts  (optional)
			-- 
			-- argument: addresses_expiry_delay  (optional)
			-- 
			-- argument: addresses_address_full_message_policy  (optional)
			-- 
			-- argument: addresses_max_size_bytes  (optional)
			-- 
			-- argument: addresses_page_size_bytes  (optional)
			-- 
			-- argument: addresses_page_cache_max_size  (optional)
			-- 
			-- argument: cluster_user  (optional)
			-- 
			-- argument: cluster_password  (optional)
			-- 
			-- argument: cluster_call_timeout  (optional)
			-- 
			-- argument: cluster_call_failover_timeout  (optional)
			-- 
			-- argument: cluster_client_failure_check_period  (optional)
			-- 
			-- argument: cluster_notification_attempts  (optional)
			-- 
			-- argument: cluster_notification_interval  (optional)
			-- 
			-- argument: id_cache_size  (optional)
			-- 
			-- argument: cluster_confirmation_window_size  (optional)
			-- 
			-- argument: cluster_connection_ttl  (optional)
			-- 
			-- argument: cluster_duplicate_detection  (optional)
			-- 
			-- argument: cluster_initial_connect_attempts  (optional)
			-- 
			-- argument: cluster_max_retry_interval  (optional)
			-- 
			-- argument: cluster_min_large_message_size  (optional)
			-- 
			-- argument: cluster_producer_window_size  (optional)
			-- 
			-- argument: cluster_reconnect_attempts  (optional)
			-- 
			-- argument: cluster_retry_interval  (optional)
			-- 
			-- argument: cluster_retry_interval_multiplier  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCREENS_MQ_ACTIVEMQ_IMPL_ARTEMIS_JMS_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.screens.mq.activemq.impl.ArtemisJMSProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "global.size", global_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "max.disk.usage", max_disk_usage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "persistence.enabled", persistence_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "thread.pool.max.size", thread_pool_max_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduled.thread.pool.max.size", scheduled_thread_pool_max_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "graceful.shutdown.timeout", graceful_shutdown_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "queues", queues));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "topics", topics));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "addresses.max.delivery.attempts", addresses_max_delivery_attempts));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "addresses.expiry.delay", addresses_expiry_delay));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "addresses.address.full.message.policy", addresses_address_full_message_policy));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "addresses.max.size.bytes", addresses_max_size_bytes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "addresses.page.size.bytes", addresses_page_size_bytes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "addresses.page.cache.max.size", addresses_page_cache_max_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.user", cluster_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.password", cluster_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.call.timeout", cluster_call_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.call.failover.timeout", cluster_call_failover_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.client.failure.check.period", cluster_client_failure_check_period));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.notification.attempts", cluster_notification_attempts));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.notification.interval", cluster_notification_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id.cache.size", id_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.confirmation.window.size", cluster_confirmation_window_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.connection.ttl", cluster_connection_ttl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.duplicate.detection", cluster_duplicate_detection));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.initial.connect.attempts", cluster_initial_connect_attempts));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.max.retry.interval", cluster_max_retry_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.min.large.message.size", cluster_min_large_message_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.producer.window.size", cluster_producer_window_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.reconnect.attempts", cluster_reconnect_attempts));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.retry.interval", cluster_retry_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.retry.interval.multiplier", cluster_retry_interval_multiplier));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCREENS_MQ_ACTIVEMQ_IMPL_ARTEMIS_JMS_PROVIDER_INFO } l_response.data ({ COM_ADOBE_CQ_SCREENS_MQ_ACTIVEMQ_IMPL_ARTEMIS_JMS_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_screens_offlinecontent_impl_bulk_offline_update_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_adobe_cq_screens_offlinecontent_impl__bulk_offline_update_service_impl_project_path: detachable LIST [STRING_32]; com_adobe_cq_screens_offlinecontent_impl__bulk_offline_update_service_impl_schedule_frequency: STRING_32): detachable COM_ADOBE_CQ_SCREENS_OFFLINECONTENT_IMPL_BULK_OFFLINE_UPDATE_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_adobe_cq_screens_offlinecontent_impl__bulk_offline_update_service_impl_project_path  (optional)
			-- 
			-- argument: com_adobe_cq_screens_offlinecontent_impl__bulk_offline_update_service_impl_schedule_frequency  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCREENS_OFFLINECONTENT_IMPL_BULK_OFFLINE_UPDATE_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.projectPath", com_adobe_cq_screens_offlinecontent_impl__bulk_offline_update_service_impl_project_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.scheduleFrequency", com_adobe_cq_screens_offlinecontent_impl__bulk_offline_update_service_impl_schedule_frequency));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCREENS_OFFLINECONTENT_IMPL_BULK_OFFLINE_UPDATE_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SCREENS_OFFLINECONTENT_IMPL_BULK_OFFLINE_UPDATE_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_screens_offlinecontent_impl_offline_content_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; disable_smart_sync: BOOLEAN): detachable COM_ADOBE_CQ_SCREENS_OFFLINECONTENT_IMPL_OFFLINE_CONTENT_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: disable_smart_sync  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCREENS_OFFLINECONTENT_IMPL_OFFLINE_CONTENT_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.screens.offlinecontent.impl.OfflineContentServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "disableSmartSync", disable_smart_sync));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCREENS_OFFLINECONTENT_IMPL_OFFLINE_CONTENT_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SCREENS_OFFLINECONTENT_IMPL_OFFLINE_CONTENT_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_screens_segmentation_impl_segmentation_feature_flag (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enable_data_triggered_content: BOOLEAN): detachable COM_ADOBE_CQ_SCREENS_SEGMENTATION_IMPL_SEGMENTATION_FEATURE_FLAG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enable_data_triggered_content  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SCREENS_SEGMENTATION_IMPL_SEGMENTATION_FEATURE_FLAG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.screens.segmentation.impl.SegmentationFeatureFlag"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableDataTriggeredContent", enable_data_triggered_content));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SCREENS_SEGMENTATION_IMPL_SEGMENTATION_FEATURE_FLAG_INFO } l_response.data ({ COM_ADOBE_CQ_SCREENS_SEGMENTATION_IMPL_SEGMENTATION_FEATURE_FLAG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_security_hc_bundles_impl_html_library_manager_config_health_ch (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SECURITY_HC_BUNDLES_IMPL_HTML_LIBRARY_MANAGER_CONFIG_HEALTH_CH_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SECURITY_HC_BUNDLES_IMPL_HTML_LIBRARY_MANAGER_CONFIG_HEALTH_CH_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.security.hc.bundles.impl.HtmlLibraryManagerConfigHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SECURITY_HC_BUNDLES_IMPL_HTML_LIBRARY_MANAGER_CONFIG_HEALTH_CH_INFO } l_response.data ({ COM_ADOBE_CQ_SECURITY_HC_BUNDLES_IMPL_HTML_LIBRARY_MANAGER_CONFIG_HEALTH_CH_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_security_hc_bundles_impl_wcm_filter_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SECURITY_HC_BUNDLES_IMPL_WCM_FILTER_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SECURITY_HC_BUNDLES_IMPL_WCM_FILTER_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.security.hc.bundles.impl.WcmFilterHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SECURITY_HC_BUNDLES_IMPL_WCM_FILTER_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_CQ_SECURITY_HC_BUNDLES_IMPL_WCM_FILTER_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_security_hc_dispatcher_impl_dispatcher_access_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]; dispatcher_address: STRING_32; dispatcher_filter_allowed: detachable LIST [STRING_32]; dispatcher_filter_blocked: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SECURITY_HC_DISPATCHER_IMPL_DISPATCHER_ACCESS_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: dispatcher_address  (optional)
			-- 
			-- argument: dispatcher_filter_allowed  (optional)
			-- 
			-- argument: dispatcher_filter_blocked  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SECURITY_HC_DISPATCHER_IMPL_DISPATCHER_ACCESS_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.security.hc.dispatcher.impl.DispatcherAccessHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dispatcher.address", dispatcher_address));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "dispatcher.filter.allowed", dispatcher_filter_allowed));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "dispatcher.filter.blocked", dispatcher_filter_blocked));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SECURITY_HC_DISPATCHER_IMPL_DISPATCHER_ACCESS_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_CQ_SECURITY_HC_DISPATCHER_IMPL_DISPATCHER_ACCESS_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_security_hc_packages_impl_example_content_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SECURITY_HC_PACKAGES_IMPL_EXAMPLE_CONTENT_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SECURITY_HC_PACKAGES_IMPL_EXAMPLE_CONTENT_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.security.hc.packages.impl.ExampleContentHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SECURITY_HC_PACKAGES_IMPL_EXAMPLE_CONTENT_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_CQ_SECURITY_HC_PACKAGES_IMPL_EXAMPLE_CONTENT_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_security_hc_webserver_impl_clickjacking_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]; webserver_address: STRING_32): detachable COM_ADOBE_CQ_SECURITY_HC_WEBSERVER_IMPL_CLICKJACKING_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: webserver_address  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SECURITY_HC_WEBSERVER_IMPL_CLICKJACKING_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.security.hc.webserver.impl.ClickjackingHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "webserver.address", webserver_address));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SECURITY_HC_WEBSERVER_IMPL_CLICKJACKING_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_CQ_SECURITY_HC_WEBSERVER_IMPL_CLICKJACKING_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_accountverification_impl_account_management_config_im (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enable: BOOLEAN; ttl1: INTEGER_32; ttl2: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_ACCOUNTVERIFICATION_IMPL_ACCOUNT_MANAGEMENT_CONFIG_IM_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enable  (optional)
			-- 
			-- argument: ttl1  (optional)
			-- 
			-- argument: ttl2  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_ACCOUNTVERIFICATION_IMPL_ACCOUNT_MANAGEMENT_CONFIG_IM_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.accountverification.impl.AccountManagementConfigImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable", enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ttl1", ttl1));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ttl2", ttl2));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_ACCOUNTVERIFICATION_IMPL_ACCOUNT_MANAGEMENT_CONFIG_IM_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_ACCOUNTVERIFICATION_IMPL_ACCOUNT_MANAGEMENT_CONFIG_IM_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_activitystreams_client_impl_social_activity_componen (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; priority: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_CLIENT_IMPL_SOCIAL_ACTIVITY_COMPONEN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: priority  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_CLIENT_IMPL_SOCIAL_ACTIVITY_COMPONEN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.activitystreams.client.impl.SocialActivityComponentFactoryImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priority", priority));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_CLIENT_IMPL_SOCIAL_ACTIVITY_COMPONEN_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_CLIENT_IMPL_SOCIAL_ACTIVITY_COMPONEN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_activitystreams_client_impl_social_activity_stream_co (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; priority: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_CLIENT_IMPL_SOCIAL_ACTIVITY_STREAM_CO_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: priority  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_CLIENT_IMPL_SOCIAL_ACTIVITY_STREAM_CO_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.activitystreams.client.impl.SocialActivityStreamComponentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priority", priority));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_CLIENT_IMPL_SOCIAL_ACTIVITY_STREAM_CO_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_CLIENT_IMPL_SOCIAL_ACTIVITY_STREAM_CO_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_activitystreams_listener_impl_event_listener_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_topics: STRING_32; event_filter: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_EVENT_LISTENER_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_topics  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_EVENT_LISTENER_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.EventListenerHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.topics", event_topics));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_EVENT_LISTENER_HANDLER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_EVENT_LISTENER_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_activitystreams_listener_impl_moderation_event_exten (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; accepted: BOOLEAN; ranked: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_MODERATION_EVENT_EXTEN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: accepted  (optional)
			-- 
			-- argument: ranked  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_MODERATION_EVENT_EXTEN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.ModerationEventExtension"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "accepted", accepted));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ranked", ranked));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_MODERATION_EVENT_EXTEN_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_MODERATION_EVENT_EXTEN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_activitystreams_listener_impl_rating_event_activity_s (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; ranking: INTEGER_32; enable: BOOLEAN): detachable COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_RATING_EVENT_ACTIVITY_S_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: ranking  (optional)
			-- 
			-- argument: enable  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_RATING_EVENT_ACTIVITY_S_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.RatingEventActivitySuppressor"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ranking", ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable", enable));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_RATING_EVENT_ACTIVITY_S_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_RATING_EVENT_ACTIVITY_S_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_activitystreams_listener_impl_resource_activity_stre (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; stream_path: STRING_32; stream_name: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_RESOURCE_ACTIVITY_STRE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: stream_path  (optional)
			-- 
			-- argument: stream_name  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_RESOURCE_ACTIVITY_STRE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.ResourceActivityStreamProviderFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "streamPath", stream_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "streamName", stream_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_RESOURCE_ACTIVITY_STRE_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_ACTIVITYSTREAMS_LISTENER_IMPL_RESOURCE_ACTIVITY_STRE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_calendar_client_endpoints_impl_calendar_operations_i (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_retry: INTEGER_32; field_whitelist: detachable LIST [STRING_32]; attachment_type_blacklist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_CALENDAR_CLIENT_ENDPOINTS_IMPL_CALENDAR_OPERATIONS_I_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_retry  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- argument: attachment_type_blacklist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_CALENDAR_CLIENT_ENDPOINTS_IMPL_CALENDAR_OPERATIONS_I_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.calendar.client.endpoints.impl.CalendarOperationsImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "MaxRetry", max_retry));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "attachmentTypeBlacklist", attachment_type_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_CALENDAR_CLIENT_ENDPOINTS_IMPL_CALENDAR_OPERATIONS_I_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_CALENDAR_CLIENT_ENDPOINTS_IMPL_CALENDAR_OPERATIONS_I_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_calendar_client_operationextensions_event_attachmen (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; attachment_type_blacklist: STRING_32; extension_order: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_CALENDAR_CLIENT_OPERATIONEXTENSIONS_EVENT_ATTACHMEN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: attachment_type_blacklist  (optional)
			-- 
			-- argument: extension_order  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_CALENDAR_CLIENT_OPERATIONEXTENSIONS_EVENT_ATTACHMEN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.calendar.client.operationextensions.EventAttachment"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "attachmentTypeBlacklist", attachment_type_blacklist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "extension.order", extension_order));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_CALENDAR_CLIENT_OPERATIONEXTENSIONS_EVENT_ATTACHMEN_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_CALENDAR_CLIENT_OPERATIONEXTENSIONS_EVENT_ATTACHMEN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_calendar_servlets_time_zone_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; timezones_expirytime: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_CALENDAR_SERVLETS_TIME_ZONE_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: timezones_expirytime  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_CALENDAR_SERVLETS_TIME_ZONE_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.calendar.servlets.TimeZoneServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "timezones.expirytime", timezones_expirytime));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_CALENDAR_SERVLETS_TIME_ZONE_SERVLET_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_CALENDAR_SERVLETS_TIME_ZONE_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_comments_endpoints_impl_comment_delete_event (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; ranking: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_ENDPOINTS_IMPL_COMMENT_DELETE_EVENT_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: ranking  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_ENDPOINTS_IMPL_COMMENT_DELETE_EVENT_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.CommentDeleteEventActivitySuppressor"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ranking", ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_ENDPOINTS_IMPL_COMMENT_DELETE_EVENT_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_ENDPOINTS_IMPL_COMMENT_DELETE_EVENT_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_comments_endpoints_impl_comment_operation_se (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]; attachment_type_blacklist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_ENDPOINTS_IMPL_COMMENT_OPERATION_SE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- argument: attachment_type_blacklist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_ENDPOINTS_IMPL_COMMENT_OPERATION_SE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.CommentOperationService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "attachmentTypeBlacklist", attachment_type_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_ENDPOINTS_IMPL_COMMENT_OPERATION_SE_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_ENDPOINTS_IMPL_COMMENT_OPERATION_SE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_comments_endpoints_impl_translation_operati (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]; attachment_type_blacklist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_ENDPOINTS_IMPL_TRANSLATION_OPERATI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- argument: attachment_type_blacklist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_ENDPOINTS_IMPL_TRANSLATION_OPERATI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.TranslationOperationService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "attachmentTypeBlacklist", attachment_type_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_ENDPOINTS_IMPL_TRANSLATION_OPERATI_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_ENDPOINTS_IMPL_TRANSLATION_OPERATI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_comments_listing_impl_search_comment_social_c (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; num_user_limit: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_LISTING_IMPL_SEARCH_COMMENT_SOCIAL_C_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: num_user_limit  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_LISTING_IMPL_SEARCH_COMMENT_SOCIAL_C_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.comments.listing.impl.SearchCommentSocialComponentListProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "numUserLimit", num_user_limit));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_LISTING_IMPL_SEARCH_COMMENT_SOCIAL_C_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_LISTING_IMPL_SEARCH_COMMENT_SOCIAL_C_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_comments_scheduler_impl_search_scheduled_pos (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enable_scheduled_posts_search: BOOLEAN; number_of_minutes: INTEGER_32; max_search_limit: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_SCHEDULER_IMPL_SEARCH_SCHEDULED_POS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enable_scheduled_posts_search  (optional)
			-- 
			-- argument: number_of_minutes  (optional)
			-- 
			-- argument: max_search_limit  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_SCHEDULER_IMPL_SEARCH_SCHEDULED_POS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.comments.scheduler.impl.SearchScheduledPosts"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableScheduledPostsSearch", enable_scheduled_posts_search));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "numberOfMinutes", number_of_minutes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxSearchLimit", max_search_limit));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_SCHEDULER_IMPL_SEARCH_SCHEDULED_POS_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_COMMENTS_SCHEDULER_IMPL_SEARCH_SCHEDULED_POS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_cors_co_rs_authentication_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cors_enabling: BOOLEAN): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_CORS_CORS_AUTHENTICATION_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cors_enabling  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_CORS_CORS_AUTHENTICATION_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.cors.CORSAuthenticationFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cors.enabling", cors_enabling));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_CORS_CORS_AUTHENTICATION_FILTER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_CORS_CORS_AUTHENTICATION_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_android_email_client_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; priority_order: INTEGER_32; reply_email_patterns: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_ANDROID_EMAIL_CLIENT_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: priority_order  (optional)
			-- 
			-- argument: reply_email_patterns  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_ANDROID_EMAIL_CLIENT_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.AndroidEmailClientProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priorityOrder", priority_order));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "replyEmailPatterns", reply_email_patterns));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_ANDROID_EMAIL_CLIENT_PROVIDER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_ANDROID_EMAIL_CLIENT_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_comment_email_builder_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; context_path: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_COMMENT_EMAIL_BUILDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: context_path  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_COMMENT_EMAIL_BUILDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CommentEmailBuilderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "context.path", context_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_COMMENT_EMAIL_BUILDER_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_COMMENT_EMAIL_BUILDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_comment_email_event_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_topics: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_COMMENT_EMAIL_EVENT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_topics  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_COMMENT_EMAIL_EVENT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CommentEmailEventListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.topics", event_topics));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_COMMENT_EMAIL_EVENT_LISTENER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_COMMENT_EMAIL_EVENT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_custom_email_client_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; priority_order: INTEGER_32; reply_email_patterns: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_CUSTOM_EMAIL_CLIENT_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: priority_order  (optional)
			-- 
			-- argument: reply_email_patterns  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_CUSTOM_EMAIL_CLIENT_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CustomEmailClientProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priorityOrder", priority_order));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "replyEmailPatterns", reply_email_patterns));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_CUSTOM_EMAIL_CLIENT_PROVIDER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_CUSTOM_EMAIL_CLIENT_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_email_quoted_text_patterns_imp (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; pattern_time: STRING_32; pattern_newline: STRING_32; pattern_day_of_month: STRING_32; pattern_month: STRING_32; pattern_year: STRING_32; pattern_date: STRING_32; pattern_date_time: STRING_32; pattern_email: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_EMAIL_QUOTED_TEXT_PATTERNS_IMP_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: pattern_time  (optional)
			-- 
			-- argument: pattern_newline  (optional)
			-- 
			-- argument: pattern_day_of_month  (optional)
			-- 
			-- argument: pattern_month  (optional)
			-- 
			-- argument: pattern_year  (optional)
			-- 
			-- argument: pattern_date  (optional)
			-- 
			-- argument: pattern_date_time  (optional)
			-- 
			-- argument: pattern_email  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_EMAIL_QUOTED_TEXT_PATTERNS_IMP_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailQuotedTextPatternsImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pattern.time", pattern_time));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pattern.newline", pattern_newline));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pattern.dayOfMonth", pattern_day_of_month));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pattern.month", pattern_month));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pattern.year", pattern_year));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pattern.date", pattern_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pattern.dateTime", pattern_date_time));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pattern.email", pattern_email));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_EMAIL_QUOTED_TEXT_PATTERNS_IMP_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_EMAIL_QUOTED_TEXT_PATTERNS_IMP_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_email_reply_configuration_imp (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; email_name: STRING_32; email_create_post_from_reply: BOOLEAN; email_add_comment_id_to: STRING_32; email_subject_maximum_length: INTEGER_32; email_reply_to_address: STRING_32; email_reply_to_delimiter: STRING_32; email_tracker_id_prefix_in_subject: STRING_32; email_tracker_id_prefix_in_body: STRING_32; email_as_ht_ml: BOOLEAN; email_default_user_name: STRING_32; email_templates_root_path: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_EMAIL_REPLY_CONFIGURATION_IMP_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: email_name  (optional)
			-- 
			-- argument: email_create_post_from_reply  (optional)
			-- 
			-- argument: email_add_comment_id_to  (optional)
			-- 
			-- argument: email_subject_maximum_length  (optional)
			-- 
			-- argument: email_reply_to_address  (optional)
			-- 
			-- argument: email_reply_to_delimiter  (optional)
			-- 
			-- argument: email_tracker_id_prefix_in_subject  (optional)
			-- 
			-- argument: email_tracker_id_prefix_in_body  (optional)
			-- 
			-- argument: email_as_ht_ml  (optional)
			-- 
			-- argument: email_default_user_name  (optional)
			-- 
			-- argument: email_templates_root_path  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_EMAIL_REPLY_CONFIGURATION_IMP_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailReplyConfigurationImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "email.name", email_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "email.createPostFromReply", email_create_post_from_reply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "email.addCommentIdTo", email_add_comment_id_to));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "email.subjectMaximumLength", email_subject_maximum_length));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "email.replyToAddress", email_reply_to_address));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "email.replyToDelimiter", email_reply_to_delimiter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "email.trackerIdPrefixInSubject", email_tracker_id_prefix_in_subject));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "email.trackerIdPrefixInBody", email_tracker_id_prefix_in_body));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "email.asHTML", email_as_ht_ml));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "email.defaultUserName", email_default_user_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "email.templates.rootPath", email_templates_root_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_EMAIL_REPLY_CONFIGURATION_IMP_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_EMAIL_REPLY_CONFIGURATION_IMP_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_email_reply_importer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; connect_protocol: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_EMAIL_REPLY_IMPORTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: connect_protocol  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_EMAIL_REPLY_IMPORTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailReplyImporter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connectProtocol", connect_protocol));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_EMAIL_REPLY_IMPORTER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_EMAIL_REPLY_IMPORTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_gmail_email_client_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; priority_order: INTEGER_32; reply_email_patterns: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_GMAIL_EMAIL_CLIENT_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: priority_order  (optional)
			-- 
			-- argument: reply_email_patterns  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_GMAIL_EMAIL_CLIENT_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.GmailEmailClientProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priorityOrder", priority_order));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "replyEmailPatterns", reply_email_patterns));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_GMAIL_EMAIL_CLIENT_PROVIDER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_GMAIL_EMAIL_CLIENT_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_io_semail_client_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; priority_order: INTEGER_32; reply_email_patterns: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_IOS_EMAIL_CLIENT_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: priority_order  (optional)
			-- 
			-- argument: reply_email_patterns  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_IOS_EMAIL_CLIENT_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.IOSEmailClientProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priorityOrder", priority_order));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "replyEmailPatterns", reply_email_patterns));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_IOS_EMAIL_CLIENT_PROVIDER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_IOS_EMAIL_CLIENT_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_macmail_email_client_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; priority_order: INTEGER_32; reply_email_patterns: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_MACMAIL_EMAIL_CLIENT_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: priority_order  (optional)
			-- 
			-- argument: reply_email_patterns  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_MACMAIL_EMAIL_CLIENT_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.MacmailEmailClientProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priorityOrder", priority_order));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "replyEmailPatterns", reply_email_patterns));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_MACMAIL_EMAIL_CLIENT_PROVIDER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_MACMAIL_EMAIL_CLIENT_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_out_look_email_client_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; priority_order: INTEGER_32; reply_email_patterns: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_OUT_LOOK_EMAIL_CLIENT_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: priority_order  (optional)
			-- 
			-- argument: reply_email_patterns  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_OUT_LOOK_EMAIL_CLIENT_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.OutLookEmailClientProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priorityOrder", priority_order));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "replyEmailPatterns", reply_email_patterns));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_OUT_LOOK_EMAIL_CLIENT_PROVIDER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_OUT_LOOK_EMAIL_CLIENT_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_unknown_email_client_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; reply_email_patterns: detachable LIST [STRING_32]; priority_order: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_UNKNOWN_EMAIL_CLIENT_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: reply_email_patterns  (optional)
			-- 
			-- argument: priority_order  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_UNKNOWN_EMAIL_CLIENT_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.UnknownEmailClientProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "replyEmailPatterns", reply_email_patterns));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priorityOrder", priority_order));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_UNKNOWN_EMAIL_CLIENT_PROVIDER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_UNKNOWN_EMAIL_CLIENT_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_emailreply_impl_yahoo_email_client_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; priority_order: INTEGER_32; reply_email_patterns: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_YAHOO_EMAIL_CLIENT_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: priority_order  (optional)
			-- 
			-- argument: reply_email_patterns  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_YAHOO_EMAIL_CLIENT_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.YahooEmailClientProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priorityOrder", priority_order));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "replyEmailPatterns", reply_email_patterns));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_YAHOO_EMAIL_CLIENT_PROVIDER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_EMAILREPLY_IMPL_YAHOO_EMAIL_CLIENT_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_maintainance_impl_delete_temp_ug_cimage_upload (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; number_of_days: INTEGER_32; age_of_file: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_MAINTAINANCE_IMPL_DELETE_TEMP_UGC_IMAGE_UPLOAD_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: number_of_days  (optional)
			-- 
			-- argument: age_of_file  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_MAINTAINANCE_IMPL_DELETE_TEMP_UGC_IMAGE_UPLOAD_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.maintainance.impl.DeleteTempUGCImageUploads"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "numberOfDays", number_of_days));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ageOfFile", age_of_file));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_MAINTAINANCE_IMPL_DELETE_TEMP_UGC_IMAGE_UPLOAD_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_MAINTAINANCE_IMPL_DELETE_TEMP_UGC_IMAGE_UPLOAD_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_ugclimiter_impl_ug_climiter_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_topics: STRING_32; event_filter: STRING_32; verbs: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_UGCLIMITER_IMPL_UGC_LIMITER_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_topics  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- argument: verbs  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_UGCLIMITER_IMPL_UGC_LIMITER_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.ugclimiter.impl.UGCLimiterServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.topics", event_topics));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "verbs", verbs));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_UGCLIMITER_IMPL_UGC_LIMITER_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_UGCLIMITER_IMPL_UGC_LIMITER_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_commons_ugclimitsconfig_impl_community_user_ug_climit (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enable: BOOLEAN; u_gc_limit: INTEGER_32; ugc_limit_duration: INTEGER_32; domains: detachable LIST [STRING_32]; to_list: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_COMMONS_UGCLIMITSCONFIG_IMPL_COMMUNITY_USER_UGC_LIMIT_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enable  (optional)
			-- 
			-- argument: u_gc_limit  (optional)
			-- 
			-- argument: ugc_limit_duration  (optional)
			-- 
			-- argument: domains  (optional)
			-- 
			-- argument: to_list  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_COMMONS_UGCLIMITSCONFIG_IMPL_COMMUNITY_USER_UGC_LIMIT_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.commons.ugclimitsconfig.impl.CommunityUserUGCLimitsConfigImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable", enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "UGCLimit", u_gc_limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ugcLimitDuration", ugc_limit_duration));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "domains", domains));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "toList", to_list));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_COMMONS_UGCLIMITSCONFIG_IMPL_COMMUNITY_USER_UGC_LIMIT_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_COMMONS_UGCLIMITSCONFIG_IMPL_COMMUNITY_USER_UGC_LIMIT_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_connect_oauth_impl_facebook_provider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_provider_id: STRING_32; oauth_cloud_config_root: STRING_32; provider_config_root: STRING_32; provider_config_create_tags_enabled: BOOLEAN; provider_config_user_folder: STRING_32; provider_config_facebook_fetch_fields: BOOLEAN; provider_config_facebook_fields: detachable LIST [STRING_32]; provider_config_refresh_userdata_enabled: BOOLEAN): detachable COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_FACEBOOK_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_provider_id  (optional)
			-- 
			-- argument: oauth_cloud_config_root  (optional)
			-- 
			-- argument: provider_config_root  (optional)
			-- 
			-- argument: provider_config_create_tags_enabled  (optional)
			-- 
			-- argument: provider_config_user_folder  (optional)
			-- 
			-- argument: provider_config_facebook_fetch_fields  (optional)
			-- 
			-- argument: provider_config_facebook_fields  (optional)
			-- 
			-- argument: provider_config_refresh_userdata_enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_FACEBOOK_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.FacebookProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.id", oauth_provider_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.cloud.config.root", oauth_cloud_config_root));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.config.root", provider_config_root));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.config.create.tags.enabled", provider_config_create_tags_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.config.user.folder", provider_config_user_folder));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.config.facebook.fetch.fields", provider_config_facebook_fetch_fields));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "provider.config.facebook.fields", provider_config_facebook_fields));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.config.refresh.userdata.enabled", provider_config_refresh_userdata_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_FACEBOOK_PROVIDER_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_FACEBOOK_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_connect_oauth_impl_social_oauth_authentication_handle (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path: detachable LIST [STRING_32]; service_ranking: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_SOCIAL_O_AUTH_AUTHENTICATION_HANDLE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_SOCIAL_O_AUTH_AUTHENTICATION_HANDLE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.SocialOAuthAuthenticationHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_SOCIAL_O_AUTH_AUTHENTICATION_HANDLE_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_SOCIAL_O_AUTH_AUTHENTICATION_HANDLE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_connect_oauth_impl_social_oauth_user_profile_mapper (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; facebook: detachable LIST [STRING_32]; twitter: detachable LIST [STRING_32]; provider_config_user_folder: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_SOCIAL_O_AUTH_USER_PROFILE_MAPPER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: facebook  (optional)
			-- 
			-- argument: twitter  (optional)
			-- 
			-- argument: provider_config_user_folder  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_SOCIAL_O_AUTH_USER_PROFILE_MAPPER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.SocialOAuthUserProfileMapper"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "facebook", facebook));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "twitter", twitter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.config.user.folder", provider_config_user_folder));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_SOCIAL_O_AUTH_USER_PROFILE_MAPPER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_SOCIAL_O_AUTH_USER_PROFILE_MAPPER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_connect_oauth_impl_twitter_provider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_provider_id: STRING_32; oauth_cloud_config_root: STRING_32; provider_config_root: STRING_32; provider_config_user_folder: STRING_32; provider_config_twitter_enable_params: BOOLEAN; provider_config_twitter_params: detachable LIST [STRING_32]; provider_config_refresh_userdata_enabled: BOOLEAN): detachable COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_TWITTER_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_provider_id  (optional)
			-- 
			-- argument: oauth_cloud_config_root  (optional)
			-- 
			-- argument: provider_config_root  (optional)
			-- 
			-- argument: provider_config_user_folder  (optional)
			-- 
			-- argument: provider_config_twitter_enable_params  (optional)
			-- 
			-- argument: provider_config_twitter_params  (optional)
			-- 
			-- argument: provider_config_refresh_userdata_enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_TWITTER_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.TwitterProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.id", oauth_provider_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.cloud.config.root", oauth_cloud_config_root));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.config.root", provider_config_root));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.config.user.folder", provider_config_user_folder));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.config.twitter.enable.params", provider_config_twitter_enable_params));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "provider.config.twitter.params", provider_config_twitter_params));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.config.refresh.userdata.enabled", provider_config_refresh_userdata_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_TWITTER_PROVIDER_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_CONNECT_OAUTH_IMPL_TWITTER_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_content_fragments_services_impl_communities_fragmen (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_social_content_fragments_services_enabled: BOOLEAN; cq_social_content_fragments_services_wait_time_seconds: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_CONTENT_FRAGMENTS_SERVICES_IMPL_COMMUNITIES_FRAGMEN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_social_content_fragments_services_enabled  (optional)
			-- 
			-- argument: cq_social_content_fragments_services_wait_time_seconds  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_CONTENT_FRAGMENTS_SERVICES_IMPL_COMMUNITIES_FRAGMEN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.content.fragments.services.impl.CommunitiesFragmentCreationServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.social.content.fragments.services.enabled", cq_social_content_fragments_services_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.social.content.fragments.services.waitTimeSeconds", cq_social_content_fragments_services_wait_time_seconds));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_CONTENT_FRAGMENTS_SERVICES_IMPL_COMMUNITIES_FRAGMEN_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_CONTENT_FRAGMENTS_SERVICES_IMPL_COMMUNITIES_FRAGMEN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_datastore_as_impl_as_resource_provider_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; version_id: STRING_32; cache_on: BOOLEAN; concurrency_level: INTEGER_32; cache_start_size: INTEGER_32; cache_ttl: INTEGER_32; cache_size: INTEGER_32; time_limit: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_DATASTORE_AS_IMPL_AS_RESOURCE_PROVIDER_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: version_id  (optional)
			-- 
			-- argument: cache_on  (optional)
			-- 
			-- argument: concurrency_level  (optional)
			-- 
			-- argument: cache_start_size  (optional)
			-- 
			-- argument: cache_ttl  (optional)
			-- 
			-- argument: cache_size  (optional)
			-- 
			-- argument: time_limit  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_DATASTORE_AS_IMPL_AS_RESOURCE_PROVIDER_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.datastore.as.impl.ASResourceProviderFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "version.id", version_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.on", cache_on));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "concurrency.level", concurrency_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.start.size", cache_start_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.ttl", cache_ttl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.size", cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "time.limit", time_limit));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_DATASTORE_AS_IMPL_AS_RESOURCE_PROVIDER_FACTORY_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_DATASTORE_AS_IMPL_AS_RESOURCE_PROVIDER_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_datastore_op_impl_social_ms_resource_provider_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; solr_zk_timeout: STRING_32; solr_commit: STRING_32; cache_on: BOOLEAN; concurrency_level: INTEGER_32; cache_start_size: INTEGER_32; cache_ttl: INTEGER_32; cache_size: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_DATASTORE_OP_IMPL_SOCIAL_MS_RESOURCE_PROVIDER_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: solr_zk_timeout  (optional)
			-- 
			-- argument: solr_commit  (optional)
			-- 
			-- argument: cache_on  (optional)
			-- 
			-- argument: concurrency_level  (optional)
			-- 
			-- argument: cache_start_size  (optional)
			-- 
			-- argument: cache_ttl  (optional)
			-- 
			-- argument: cache_size  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_DATASTORE_OP_IMPL_SOCIAL_MS_RESOURCE_PROVIDER_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.datastore.op.impl.SocialMSResourceProviderFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.zk.timeout", solr_zk_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.commit", solr_commit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.on", cache_on));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "concurrency.level", concurrency_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.start.size", cache_start_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.ttl", cache_ttl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.size", cache_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_DATASTORE_OP_IMPL_SOCIAL_MS_RESOURCE_PROVIDER_FACTORY_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_DATASTORE_OP_IMPL_SOCIAL_MS_RESOURCE_PROVIDER_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_datastore_rdb_impl_social_rd_bresource_provider_factor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; solr_zk_timeout: STRING_32; solr_commit: STRING_32; cache_on: BOOLEAN; concurrency_level: INTEGER_32; cache_start_size: INTEGER_32; cache_ttl: INTEGER_32; cache_size: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_DATASTORE_RDB_IMPL_SOCIAL_RDB_RESOURCE_PROVIDER_FACTOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: solr_zk_timeout  (optional)
			-- 
			-- argument: solr_commit  (optional)
			-- 
			-- argument: cache_on  (optional)
			-- 
			-- argument: concurrency_level  (optional)
			-- 
			-- argument: cache_start_size  (optional)
			-- 
			-- argument: cache_ttl  (optional)
			-- 
			-- argument: cache_size  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_DATASTORE_RDB_IMPL_SOCIAL_RDB_RESOURCE_PROVIDER_FACTOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.datastore.rdb.impl.SocialRDBResourceProviderFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.zk.timeout", solr_zk_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.commit", solr_commit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.on", cache_on));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "concurrency.level", concurrency_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.start.size", cache_start_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.ttl", cache_ttl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.size", cache_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_DATASTORE_RDB_IMPL_SOCIAL_RDB_RESOURCE_PROVIDER_FACTOR_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_DATASTORE_RDB_IMPL_SOCIAL_RDB_RESOURCE_PROVIDER_FACTOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_enablement_adaptors_enablement_learning_path_adaptor_f (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; is_member_check: BOOLEAN): detachable COM_ADOBE_CQ_SOCIAL_ENABLEMENT_ADAPTORS_ENABLEMENT_LEARNING_PATH_ADAPTOR_F_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: is_member_check  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_ENABLEMENT_ADAPTORS_ENABLEMENT_LEARNING_PATH_ADAPTOR_F_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.enablement.adaptors.EnablementLearningPathAdaptorFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "isMemberCheck", is_member_check));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_ENABLEMENT_ADAPTORS_ENABLEMENT_LEARNING_PATH_ADAPTOR_F_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_ENABLEMENT_ADAPTORS_ENABLEMENT_LEARNING_PATH_ADAPTOR_F_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_enablement_adaptors_enablement_resource_adaptor_facto (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; is_member_check: BOOLEAN): detachable COM_ADOBE_CQ_SOCIAL_ENABLEMENT_ADAPTORS_ENABLEMENT_RESOURCE_ADAPTOR_FACTO_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: is_member_check  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_ENABLEMENT_ADAPTORS_ENABLEMENT_RESOURCE_ADAPTOR_FACTO_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.enablement.adaptors.EnablementResourceAdaptorFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "isMemberCheck", is_member_check));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_ENABLEMENT_ADAPTORS_ENABLEMENT_RESOURCE_ADAPTOR_FACTO_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_ENABLEMENT_ADAPTORS_ENABLEMENT_RESOURCE_ADAPTOR_FACTO_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_enablement_learningpath_endpoints_impl_enablement_l (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_ENABLEMENT_LEARNINGPATH_ENDPOINTS_IMPL_ENABLEMENT_L_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_ENABLEMENT_LEARNINGPATH_ENDPOINTS_IMPL_ENABLEMENT_L_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.enablement.learningpath.endpoints.impl.EnablementLearningPathModelOperationService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_ENABLEMENT_LEARNINGPATH_ENDPOINTS_IMPL_ENABLEMENT_L_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_ENABLEMENT_LEARNINGPATH_ENDPOINTS_IMPL_ENABLEMENT_L_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_enablement_resource_endpoints_impl_enablement_resou (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_ENABLEMENT_RESOURCE_ENDPOINTS_IMPL_ENABLEMENT_RESOU_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_ENABLEMENT_RESOURCE_ENDPOINTS_IMPL_ENABLEMENT_RESOU_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.enablement.resource.endpoints.impl.EnablementResourceModelOperationService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_ENABLEMENT_RESOURCE_ENDPOINTS_IMPL_ENABLEMENT_RESOU_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_ENABLEMENT_RESOURCE_ENDPOINTS_IMPL_ENABLEMENT_RESOU_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_enablement_services_impl_author_marker_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_ENABLEMENT_SERVICES_IMPL_AUTHOR_MARKER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_ENABLEMENT_SERVICES_IMPL_AUTHOR_MARKER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.enablement.services.impl.AuthorMarkerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_ENABLEMENT_SERVICES_IMPL_AUTHOR_MARKER_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_ENABLEMENT_SERVICES_IMPL_AUTHOR_MARKER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_filelibrary_client_endpoints_filelibrary_download_ge (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_selectors: STRING_32; sling_servlet_extensions: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_FILELIBRARY_CLIENT_ENDPOINTS_FILELIBRARY_DOWNLOAD_GE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_selectors  (optional)
			-- 
			-- argument: sling_servlet_extensions  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_FILELIBRARY_CLIENT_ENDPOINTS_FILELIBRARY_DOWNLOAD_GE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.filelibrary.client.endpoints.FilelibraryDownloadGetServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.selectors", sling_servlet_selectors));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.extensions", sling_servlet_extensions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_FILELIBRARY_CLIENT_ENDPOINTS_FILELIBRARY_DOWNLOAD_GE_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_FILELIBRARY_CLIENT_ENDPOINTS_FILELIBRARY_DOWNLOAD_GE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_filelibrary_client_endpoints_impl_file_library_opera (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]; attachment_type_blacklist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_FILELIBRARY_CLIENT_ENDPOINTS_IMPL_FILE_LIBRARY_OPERA_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- argument: attachment_type_blacklist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_FILELIBRARY_CLIENT_ENDPOINTS_IMPL_FILE_LIBRARY_OPERA_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.filelibrary.client.endpoints.impl.FileLibraryOperationsService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "attachmentTypeBlacklist", attachment_type_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_FILELIBRARY_CLIENT_ENDPOINTS_IMPL_FILE_LIBRARY_OPERA_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_FILELIBRARY_CLIENT_ENDPOINTS_IMPL_FILE_LIBRARY_OPERA_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_forum_client_endpoints_impl_forum_operations_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]; attachment_type_blacklist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_FORUM_CLIENT_ENDPOINTS_IMPL_FORUM_OPERATIONS_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- argument: attachment_type_blacklist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_FORUM_CLIENT_ENDPOINTS_IMPL_FORUM_OPERATIONS_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.forum.client.endpoints.impl.ForumOperationsService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "attachmentTypeBlacklist", attachment_type_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_FORUM_CLIENT_ENDPOINTS_IMPL_FORUM_OPERATIONS_SERVICE_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_FORUM_CLIENT_ENDPOINTS_IMPL_FORUM_OPERATIONS_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_forum_dispatcher_impl_flush_operations (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; extension_order: INTEGER_32; flush_forumontopic: BOOLEAN): detachable COM_ADOBE_CQ_SOCIAL_FORUM_DISPATCHER_IMPL_FLUSH_OPERATIONS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: extension_order  (optional)
			-- 
			-- argument: flush_forumontopic  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_FORUM_DISPATCHER_IMPL_FLUSH_OPERATIONS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.forum.dispatcher.impl.FlushOperations"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "extension.order", extension_order));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "flush.forumontopic", flush_forumontopic));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_FORUM_DISPATCHER_IMPL_FLUSH_OPERATIONS_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_FORUM_DISPATCHER_IMPL_FLUSH_OPERATIONS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_group_client_impl_community_group_collection_componen (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; group_listing_pagination_enable: BOOLEAN; group_listing_lazyloading_enable: BOOLEAN; page_size: INTEGER_32; priority: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_GROUP_CLIENT_IMPL_COMMUNITY_GROUP_COLLECTION_COMPONEN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: group_listing_pagination_enable  (optional)
			-- 
			-- argument: group_listing_lazyloading_enable  (optional)
			-- 
			-- argument: page_size  (optional)
			-- 
			-- argument: priority  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_GROUP_CLIENT_IMPL_COMMUNITY_GROUP_COLLECTION_COMPONEN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.group.client.impl.CommunityGroupCollectionComponentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "group.listing.pagination.enable", group_listing_pagination_enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "group.listing.lazyloading.enable", group_listing_lazyloading_enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "page.size", page_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priority", priority));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_GROUP_CLIENT_IMPL_COMMUNITY_GROUP_COLLECTION_COMPONEN_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_GROUP_CLIENT_IMPL_COMMUNITY_GROUP_COLLECTION_COMPONEN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_group_impl_group_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_wait_time: INTEGER_32; min_wait_between_retries: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_GROUP_IMPL_GROUP_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_wait_time  (optional)
			-- 
			-- argument: min_wait_between_retries  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_GROUP_IMPL_GROUP_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.group.impl.GroupServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxWaitTime", max_wait_time));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "minWaitBetweenRetries", min_wait_between_retries));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_GROUP_IMPL_GROUP_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_GROUP_IMPL_GROUP_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_handlebars_guava_template_cache_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; parameter_guava_cache_enabled: BOOLEAN; parameter_guava_cache_params: STRING_32; parameter_guava_cache_reload: BOOLEAN; service_ranking: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_HANDLEBARS_GUAVA_TEMPLATE_CACHE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: parameter_guava_cache_enabled  (optional)
			-- 
			-- argument: parameter_guava_cache_params  (optional)
			-- 
			-- argument: parameter_guava_cache_reload  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_HANDLEBARS_GUAVA_TEMPLATE_CACHE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.handlebars.GuavaTemplateCacheImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "parameter.guava.cache.enabled", parameter_guava_cache_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "parameter.guava.cache.params", parameter_guava_cache_params));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "parameter.guava.cache.reload", parameter_guava_cache_reload));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_HANDLEBARS_GUAVA_TEMPLATE_CACHE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_HANDLEBARS_GUAVA_TEMPLATE_CACHE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_ideation_client_endpoints_impl_ideation_operations_s (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]; attachment_type_blacklist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_IDEATION_CLIENT_ENDPOINTS_IMPL_IDEATION_OPERATIONS_S_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- argument: attachment_type_blacklist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_IDEATION_CLIENT_ENDPOINTS_IMPL_IDEATION_OPERATIONS_S_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.ideation.client.endpoints.impl.IdeationOperationsService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "attachmentTypeBlacklist", attachment_type_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_IDEATION_CLIENT_ENDPOINTS_IMPL_IDEATION_OPERATIONS_S_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_IDEATION_CLIENT_ENDPOINTS_IMPL_IDEATION_OPERATIONS_S_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_journal_client_endpoints_impl_journal_operations_ser (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]; attachment_type_blacklist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_JOURNAL_CLIENT_ENDPOINTS_IMPL_JOURNAL_OPERATIONS_SER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- argument: attachment_type_blacklist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_JOURNAL_CLIENT_ENDPOINTS_IMPL_JOURNAL_OPERATIONS_SER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.journal.client.endpoints.impl.JournalOperationsService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "attachmentTypeBlacklist", attachment_type_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_JOURNAL_CLIENT_ENDPOINTS_IMPL_JOURNAL_OPERATIONS_SER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_JOURNAL_CLIENT_ENDPOINTS_IMPL_JOURNAL_OPERATIONS_SER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_members_endpoints_impl_community_member_group_profile (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_MEMBERS_ENDPOINTS_IMPL_COMMUNITY_MEMBER_GROUP_PROFILE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_MEMBERS_ENDPOINTS_IMPL_COMMUNITY_MEMBER_GROUP_PROFILE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.members.endpoints.impl.CommunityMemberGroupProfileOperationService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_MEMBERS_ENDPOINTS_IMPL_COMMUNITY_MEMBER_GROUP_PROFILE_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_MEMBERS_ENDPOINTS_IMPL_COMMUNITY_MEMBER_GROUP_PROFILE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_members_endpoints_impl_community_member_user_profile_o (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_MEMBERS_ENDPOINTS_IMPL_COMMUNITY_MEMBER_USER_PROFILE_O_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_MEMBERS_ENDPOINTS_IMPL_COMMUNITY_MEMBER_USER_PROFILE_O_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.members.endpoints.impl.CommunityMemberUserProfileOperationService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_MEMBERS_ENDPOINTS_IMPL_COMMUNITY_MEMBER_USER_PROFILE_O_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_MEMBERS_ENDPOINTS_IMPL_COMMUNITY_MEMBER_USER_PROFILE_O_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_members_impl_community_member_group_profile_component_f (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; everyone_limit: INTEGER_32; priority: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_MEMBERS_IMPL_COMMUNITY_MEMBER_GROUP_PROFILE_COMPONENT_F_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: everyone_limit  (optional)
			-- 
			-- argument: priority  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_MEMBERS_IMPL_COMMUNITY_MEMBER_GROUP_PROFILE_COMPONENT_F_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.members.impl.CommunityMemberGroupProfileComponentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "everyoneLimit", everyone_limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priority", priority));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_MEMBERS_IMPL_COMMUNITY_MEMBER_GROUP_PROFILE_COMPONENT_F_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_MEMBERS_IMPL_COMMUNITY_MEMBER_GROUP_PROFILE_COMPONENT_F_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_messaging_client_endpoints_impl_messaging_operation (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; message_properties: detachable LIST [STRING_32]; message_box_size_limit: INTEGER_32; message_count_limit: INTEGER_32; notify_failure: BOOLEAN; failure_message_from: STRING_32; failure_template_path: STRING_32; max_retries: INTEGER_32; min_wait_between_retries: INTEGER_32; count_update_pool_size: INTEGER_32; inbox_path: STRING_32; sentitems_path: STRING_32; support_attachments: BOOLEAN; support_group_messaging: BOOLEAN; max_total_recipients: INTEGER_32; batch_size: INTEGER_32; max_total_attachment_size: INTEGER_32; attachment_type_blacklist: detachable LIST [STRING_32]; allowed_attachment_types: detachable LIST [STRING_32]; service_selector: STRING_32; field_whitelist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_MESSAGING_CLIENT_ENDPOINTS_IMPL_MESSAGING_OPERATION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: message_properties  (optional)
			-- 
			-- argument: message_box_size_limit  (optional)
			-- 
			-- argument: message_count_limit  (optional)
			-- 
			-- argument: notify_failure  (optional)
			-- 
			-- argument: failure_message_from  (optional)
			-- 
			-- argument: failure_template_path  (optional)
			-- 
			-- argument: max_retries  (optional)
			-- 
			-- argument: min_wait_between_retries  (optional)
			-- 
			-- argument: count_update_pool_size  (optional)
			-- 
			-- argument: inbox_path  (optional)
			-- 
			-- argument: sentitems_path  (optional)
			-- 
			-- argument: support_attachments  (optional)
			-- 
			-- argument: support_group_messaging  (optional)
			-- 
			-- argument: max_total_recipients  (optional)
			-- 
			-- argument: batch_size  (optional)
			-- 
			-- argument: max_total_attachment_size  (optional)
			-- 
			-- argument: attachment_type_blacklist  (optional)
			-- 
			-- argument: allowed_attachment_types  (optional)
			-- 
			-- argument: service_selector  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_MESSAGING_CLIENT_ENDPOINTS_IMPL_MESSAGING_OPERATION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.messaging.client.endpoints.impl.MessagingOperationsServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "message.properties", message_properties));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "messageBoxSizeLimit", message_box_size_limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "messageCountLimit", message_count_limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "notifyFailure", notify_failure));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "failureMessageFrom", failure_message_from));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "failureTemplatePath", failure_template_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxRetries", max_retries));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "minWaitBetweenRetries", min_wait_between_retries));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "countUpdatePoolSize", count_update_pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "inbox.path", inbox_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sentitems.path", sentitems_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "supportAttachments", support_attachments));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "supportGroupMessaging", support_group_messaging));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxTotalRecipients", max_total_recipients));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "batchSize", batch_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxTotalAttachmentSize", max_total_attachment_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "attachmentTypeBlacklist", attachment_type_blacklist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "allowedAttachmentTypes", allowed_attachment_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceSelector", service_selector));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_MESSAGING_CLIENT_ENDPOINTS_IMPL_MESSAGING_OPERATION_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_MESSAGING_CLIENT_ENDPOINTS_IMPL_MESSAGING_OPERATION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_moderation_dashboard_api_filter_group_social_componen (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; resource_type_filters: detachable LIST [STRING_32]; priority: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_API_FILTER_GROUP_SOCIAL_COMPONEN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: resource_type_filters  (optional)
			-- 
			-- argument: priority  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_API_FILTER_GROUP_SOCIAL_COMPONEN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.FilterGroupSocialComponentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resourceType.filters", resource_type_filters));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priority", priority));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_API_FILTER_GROUP_SOCIAL_COMPONEN_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_API_FILTER_GROUP_SOCIAL_COMPONEN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_moderation_dashboard_api_moderation_dashboard_social (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; priority: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_API_MODERATION_DASHBOARD_SOCIAL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: priority  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_API_MODERATION_DASHBOARD_SOCIAL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.ModerationDashboardSocialComponentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priority", priority));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_API_MODERATION_DASHBOARD_SOCIAL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_API_MODERATION_DASHBOARD_SOCIAL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_moderation_dashboard_api_user_details_social_componen (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; priority: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_API_USER_DETAILS_SOCIAL_COMPONEN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: priority  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_API_USER_DETAILS_SOCIAL_COMPONEN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.UserDetailsSocialComponentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priority", priority));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_API_USER_DETAILS_SOCIAL_COMPONEN_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_API_USER_DETAILS_SOCIAL_COMPONEN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_moderation_dashboard_internal_impl_filter_group_soci (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; resource_type_filters: detachable LIST [STRING_32]; priority: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_INTERNAL_IMPL_FILTER_GROUP_SOCI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: resource_type_filters  (optional)
			-- 
			-- argument: priority  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_INTERNAL_IMPL_FILTER_GROUP_SOCI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.internal.impl.FilterGroupSocialComponentFactoryV2"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resourceType.filters", resource_type_filters));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priority", priority));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_INTERNAL_IMPL_FILTER_GROUP_SOCI_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_MODERATION_DASHBOARD_INTERNAL_IMPL_FILTER_GROUP_SOCI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_notifications_impl_mentions_router (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_topics: STRING_32; event_filter: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_NOTIFICATIONS_IMPL_MENTIONS_ROUTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_topics  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_NOTIFICATIONS_IMPL_MENTIONS_ROUTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.notifications.impl.MentionsRouter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.topics", event_topics));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_NOTIFICATIONS_IMPL_MENTIONS_ROUTER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_NOTIFICATIONS_IMPL_MENTIONS_ROUTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_notifications_impl_notification_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_unread_notification_count: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_NOTIFICATIONS_IMPL_NOTIFICATION_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_unread_notification_count  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_NOTIFICATIONS_IMPL_NOTIFICATION_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.notifications.impl.NotificationManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "max.unread.notification.count", max_unread_notification_count));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_NOTIFICATIONS_IMPL_NOTIFICATION_MANAGER_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_NOTIFICATIONS_IMPL_NOTIFICATION_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_notifications_impl_notifications_router (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_topics: STRING_32; event_filter: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_NOTIFICATIONS_IMPL_NOTIFICATIONS_ROUTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_topics  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_NOTIFICATIONS_IMPL_NOTIFICATIONS_ROUTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.notifications.impl.NotificationsRouter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.topics", event_topics));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_NOTIFICATIONS_IMPL_NOTIFICATIONS_ROUTER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_NOTIFICATIONS_IMPL_NOTIFICATIONS_ROUTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_qna_client_endpoints_impl_qna_forum_operations_servic (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]; attachment_type_blacklist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_QNA_CLIENT_ENDPOINTS_IMPL_QNA_FORUM_OPERATIONS_SERVIC_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- argument: attachment_type_blacklist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_QNA_CLIENT_ENDPOINTS_IMPL_QNA_FORUM_OPERATIONS_SERVIC_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.qna.client.endpoints.impl.QnaForumOperationsService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "attachmentTypeBlacklist", attachment_type_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_QNA_CLIENT_ENDPOINTS_IMPL_QNA_FORUM_OPERATIONS_SERVIC_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_QNA_CLIENT_ENDPOINTS_IMPL_QNA_FORUM_OPERATIONS_SERVIC_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_reporting_analytics_services_impl_analytics_report_i (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_social_reporting_analytics_polling_importer_interval: INTEGER_32; cq_social_reporting_analytics_polling_importer_page_size: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_REPORTING_ANALYTICS_SERVICES_IMPL_ANALYTICS_REPORT_I_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_social_reporting_analytics_polling_importer_interval  (optional)
			-- 
			-- argument: cq_social_reporting_analytics_polling_importer_page_size  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_REPORTING_ANALYTICS_SERVICES_IMPL_ANALYTICS_REPORT_I_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.AnalyticsReportImporterServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.social.reporting.analytics.polling.importer.interval", cq_social_reporting_analytics_polling_importer_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.social.reporting.analytics.polling.importer.pageSize", cq_social_reporting_analytics_polling_importer_page_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_REPORTING_ANALYTICS_SERVICES_IMPL_ANALYTICS_REPORT_I_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_REPORTING_ANALYTICS_SERVICES_IMPL_ANALYTICS_REPORT_I_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_reporting_analytics_services_impl_analytics_report_m (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; report_fetch_delay: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_REPORTING_ANALYTICS_SERVICES_IMPL_ANALYTICS_REPORT_M_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: report_fetch_delay  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_REPORTING_ANALYTICS_SERVICES_IMPL_ANALYTICS_REPORT_M_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.AnalyticsReportManagementServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "report.fetch.delay", report_fetch_delay));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_REPORTING_ANALYTICS_SERVICES_IMPL_ANALYTICS_REPORT_M_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_REPORTING_ANALYTICS_SERVICES_IMPL_ANALYTICS_REPORT_M_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_reporting_analytics_services_impl_site_trend_report_s (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_social_console_analytics_sites_mapping: detachable LIST [STRING_32]; priority: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_REPORTING_ANALYTICS_SERVICES_IMPL_SITE_TREND_REPORT_S_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_social_console_analytics_sites_mapping  (optional)
			-- 
			-- argument: priority  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_REPORTING_ANALYTICS_SERVICES_IMPL_SITE_TREND_REPORT_S_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.SiteTrendReportSocialComponentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.social.console.analytics.sites.mapping", cq_social_console_analytics_sites_mapping));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priority", priority));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_REPORTING_ANALYTICS_SERVICES_IMPL_SITE_TREND_REPORT_S_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_REPORTING_ANALYTICS_SERVICES_IMPL_SITE_TREND_REPORT_S_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_review_client_endpoints_impl_review_operations_servi (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]; attachment_type_blacklist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_REVIEW_CLIENT_ENDPOINTS_IMPL_REVIEW_OPERATIONS_SERVI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- argument: attachment_type_blacklist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_REVIEW_CLIENT_ENDPOINTS_IMPL_REVIEW_OPERATIONS_SERVI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.review.client.endpoints.impl.ReviewOperationsService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "attachmentTypeBlacklist", attachment_type_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_REVIEW_CLIENT_ENDPOINTS_IMPL_REVIEW_OPERATIONS_SERVI_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_REVIEW_CLIENT_ENDPOINTS_IMPL_REVIEW_OPERATIONS_SERVI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_scf_core_operations_impl_social_operations_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_selectors: STRING_32; sling_servlet_extensions: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_SCF_CORE_OPERATIONS_IMPL_SOCIAL_OPERATIONS_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_selectors  (optional)
			-- 
			-- argument: sling_servlet_extensions  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_SCF_CORE_OPERATIONS_IMPL_SOCIAL_OPERATIONS_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.scf.core.operations.impl.SocialOperationsServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.selectors", sling_servlet_selectors));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.extensions", sling_servlet_extensions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_SCF_CORE_OPERATIONS_IMPL_SOCIAL_OPERATIONS_SERVLET_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_SCF_CORE_OPERATIONS_IMPL_SOCIAL_OPERATIONS_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_scf_endpoints_impl_default_social_get_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_selectors: detachable LIST [STRING_32]; sling_servlet_extensions: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_SCF_ENDPOINTS_IMPL_DEFAULT_SOCIAL_GET_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_selectors  (optional)
			-- 
			-- argument: sling_servlet_extensions  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_SCF_ENDPOINTS_IMPL_DEFAULT_SOCIAL_GET_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.scf.endpoints.impl.DefaultSocialGetServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.servlet.selectors", sling_servlet_selectors));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.extensions", sling_servlet_extensions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_SCF_ENDPOINTS_IMPL_DEFAULT_SOCIAL_GET_SERVLET_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_SCF_ENDPOINTS_IMPL_DEFAULT_SOCIAL_GET_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_scoring_impl_scoring_event_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_topics: STRING_32; event_filter: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_SCORING_IMPL_SCORING_EVENT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_topics  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_SCORING_IMPL_SCORING_EVENT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.scoring.impl.ScoringEventListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.topics", event_topics));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_SCORING_IMPL_SCORING_EVENT_LISTENER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_SCORING_IMPL_SCORING_EVENT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_serviceusers_internal_impl_service_user_wrapper_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enable_fallback: BOOLEAN): detachable COM_ADOBE_CQ_SOCIAL_SERVICEUSERS_INTERNAL_IMPL_SERVICE_USER_WRAPPER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enable_fallback  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_SERVICEUSERS_INTERNAL_IMPL_SERVICE_USER_WRAPPER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.serviceusers.internal.impl.ServiceUserWrapperImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableFallback", enable_fallback));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_SERVICEUSERS_INTERNAL_IMPL_SERVICE_USER_WRAPPER_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_SERVICEUSERS_INTERNAL_IMPL_SERVICE_USER_WRAPPER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_site_endpoints_impl_site_operation_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; field_whitelist: detachable LIST [STRING_32]; site_path_filters: detachable LIST [STRING_32]; site_package_group: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_SITE_ENDPOINTS_IMPL_SITE_OPERATION_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: field_whitelist  (optional)
			-- 
			-- argument: site_path_filters  (optional)
			-- 
			-- argument: site_package_group  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_SITE_ENDPOINTS_IMPL_SITE_OPERATION_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.site.endpoints.impl.SiteOperationService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fieldWhitelist", field_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sitePathFilters", site_path_filters));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sitePackageGroup", site_package_group));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_SITE_ENDPOINTS_IMPL_SITE_OPERATION_SERVICE_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_SITE_ENDPOINTS_IMPL_SITE_OPERATION_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_site_impl_analytics_component_configuration_service_im (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_social_console_analytics_components: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_SITE_IMPL_ANALYTICS_COMPONENT_CONFIGURATION_SERVICE_IM_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_social_console_analytics_components  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_SITE_IMPL_ANALYTICS_COMPONENT_CONFIGURATION_SERVICE_IM_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.site.impl.AnalyticsComponentConfigurationServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.social.console.analytics.components", cq_social_console_analytics_components));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_SITE_IMPL_ANALYTICS_COMPONENT_CONFIGURATION_SERVICE_IM_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_SITE_IMPL_ANALYTICS_COMPONENT_CONFIGURATION_SERVICE_IM_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_site_impl_site_configurator_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; components_using_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_SITE_IMPL_SITE_CONFIGURATOR_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: components_using_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_SITE_IMPL_SITE_CONFIGURATOR_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.site.impl.SiteConfiguratorImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "componentsUsingTags", components_using_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_SITE_IMPL_SITE_CONFIGURATOR_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_SITE_IMPL_SITE_CONFIGURATOR_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_srp_impl_social_solr_connector (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; srp_type: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_SRP_IMPL_SOCIAL_SOLR_CONNECTOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: srp_type  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_SRP_IMPL_SOCIAL_SOLR_CONNECTOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.srp.impl.SocialSolrConnector"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "srp.type", srp_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_SRP_IMPL_SOCIAL_SOLR_CONNECTOR_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_SRP_IMPL_SOCIAL_SOLR_CONNECTOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_sync_impl_diff_changes_observer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN; agent_name: STRING_32; diff_path: STRING_32; property_names: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_DIFF_CHANGES_OBSERVER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: agent_name  (optional)
			-- 
			-- argument: diff_path  (optional)
			-- 
			-- argument: property_names  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_DIFF_CHANGES_OBSERVER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.sync.impl.DiffChangesObserver"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "agentName", agent_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "diffPath", diff_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "propertyNames", property_names));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_DIFF_CHANGES_OBSERVER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_DIFF_CHANGES_OBSERVER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_sync_impl_group_sync_listener_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; nodetypes: detachable LIST [STRING_32]; ignorableprops: detachable LIST [STRING_32]; ignorablenodes: STRING_32; enabled: BOOLEAN; distfolders: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_GROUP_SYNC_LISTENER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: nodetypes  (optional)
			-- 
			-- argument: ignorableprops  (optional)
			-- 
			-- argument: ignorablenodes  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: distfolders  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_GROUP_SYNC_LISTENER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.sync.impl.GroupSyncListenerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "nodetypes", nodetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "ignorableprops", ignorableprops));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ignorablenodes", ignorablenodes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "distfolders", distfolders));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_GROUP_SYNC_LISTENER_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_GROUP_SYNC_LISTENER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_sync_impl_publisher_sync_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; active_run_modes: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_PUBLISHER_SYNC_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: active_run_modes  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_PUBLISHER_SYNC_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.sync.impl.PublisherSyncServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "activeRunModes", active_run_modes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_PUBLISHER_SYNC_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_PUBLISHER_SYNC_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_sync_impl_user_sync_listener_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; nodetypes: detachable LIST [STRING_32]; ignorableprops: detachable LIST [STRING_32]; ignorablenodes: detachable LIST [STRING_32]; enabled: BOOLEAN; distfolders: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_USER_SYNC_LISTENER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: nodetypes  (optional)
			-- 
			-- argument: ignorableprops  (optional)
			-- 
			-- argument: ignorablenodes  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: distfolders  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_USER_SYNC_LISTENER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.sync.impl.UserSyncListenerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "nodetypes", nodetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "ignorableprops", ignorableprops));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "ignorablenodes", ignorablenodes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "distfolders", distfolders));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_USER_SYNC_LISTENER_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_SYNC_IMPL_USER_SYNC_LISTENER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_translation_impl_translation_service_config_manager (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; translate_language: STRING_32; translate_display: STRING_32; translate_attribution: BOOLEAN; translate_caching: STRING_32; translate_smart_rendering: STRING_32; translate_caching_duration: STRING_32; translate_session_save_interval: STRING_32; translate_session_save_batch_limit: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_TRANSLATION_IMPL_TRANSLATION_SERVICE_CONFIG_MANAGER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: translate_language  (optional)
			-- 
			-- argument: translate_display  (optional)
			-- 
			-- argument: translate_attribution  (optional)
			-- 
			-- argument: translate_caching  (optional)
			-- 
			-- argument: translate_smart_rendering  (optional)
			-- 
			-- argument: translate_caching_duration  (optional)
			-- 
			-- argument: translate_session_save_interval  (optional)
			-- 
			-- argument: translate_session_save_batch_limit  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_TRANSLATION_IMPL_TRANSLATION_SERVICE_CONFIG_MANAGER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.translation.impl.TranslationServiceConfigManager"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "translate.language", translate_language));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "translate.display", translate_display));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "translate.attribution", translate_attribution));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "translate.caching", translate_caching));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "translate.smart.rendering", translate_smart_rendering));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "translate.caching.duration", translate_caching_duration));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "translate.session.save.interval", translate_session_save_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "translate.session.save.batchLimit", translate_session_save_batch_limit));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_TRANSLATION_IMPL_TRANSLATION_SERVICE_CONFIG_MANAGER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_TRANSLATION_IMPL_TRANSLATION_SERVICE_CONFIG_MANAGER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_translation_impl_ug_clanguage_detector (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_topics: STRING_32; event_filter: STRING_32; translate_listener_type: detachable LIST [STRING_32]; translate_property_list: detachable LIST [STRING_32]; pool_size: INTEGER_32; max_pool_size: INTEGER_32; queue_size: INTEGER_32; keep_alive_time: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_TRANSLATION_IMPL_UGC_LANGUAGE_DETECTOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_topics  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- argument: translate_listener_type  (optional)
			-- 
			-- argument: translate_property_list  (optional)
			-- 
			-- argument: pool_size  (optional)
			-- 
			-- argument: max_pool_size  (optional)
			-- 
			-- argument: queue_size  (optional)
			-- 
			-- argument: keep_alive_time  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_TRANSLATION_IMPL_UGC_LANGUAGE_DETECTOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.translation.impl.UGCLanguageDetector"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.topics", event_topics));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "translate.listener.type", translate_listener_type));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "translate.property.list", translate_property_list));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "poolSize", pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxPoolSize", max_pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queueSize", queue_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "keepAliveTime", keep_alive_time));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_TRANSLATION_IMPL_UGC_LANGUAGE_DETECTOR_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_TRANSLATION_IMPL_UGC_LANGUAGE_DETECTOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_ugcbase_dispatcher_impl_flush_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; thread_pool_size: INTEGER_32; delay_time: INTEGER_32; worker_sleep_time: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_UGCBASE_DISPATCHER_IMPL_FLUSH_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: thread_pool_size  (optional)
			-- 
			-- argument: delay_time  (optional)
			-- 
			-- argument: worker_sleep_time  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_UGCBASE_DISPATCHER_IMPL_FLUSH_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.ugcbase.dispatcher.impl.FlushServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "threadPoolSize", thread_pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delayTime", delay_time));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "workerSleepTime", worker_sleep_time));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_UGCBASE_DISPATCHER_IMPL_FLUSH_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_UGCBASE_DISPATCHER_IMPL_FLUSH_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_ugcbase_impl_aysnc_reverse_replicator_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; pool_size: INTEGER_32; max_pool_size: INTEGER_32; queue_size: INTEGER_32; keep_alive_time: INTEGER_32): detachable COM_ADOBE_CQ_SOCIAL_UGCBASE_IMPL_AYSNC_REVERSE_REPLICATOR_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: pool_size  (optional)
			-- 
			-- argument: max_pool_size  (optional)
			-- 
			-- argument: queue_size  (optional)
			-- 
			-- argument: keep_alive_time  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_UGCBASE_IMPL_AYSNC_REVERSE_REPLICATOR_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.AysncReverseReplicatorImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "poolSize", pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxPoolSize", max_pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queueSize", queue_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "keepAliveTime", keep_alive_time));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_UGCBASE_IMPL_AYSNC_REVERSE_REPLICATOR_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_UGCBASE_IMPL_AYSNC_REVERSE_REPLICATOR_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_ugcbase_impl_publisher_configuration_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; is_primary_publisher: BOOLEAN): detachable COM_ADOBE_CQ_SOCIAL_UGCBASE_IMPL_PUBLISHER_CONFIGURATION_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: is_primary_publisher  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_UGCBASE_IMPL_PUBLISHER_CONFIGURATION_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.PublisherConfigurationImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "isPrimaryPublisher", is_primary_publisher));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_UGCBASE_IMPL_PUBLISHER_CONFIGURATION_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_UGCBASE_IMPL_PUBLISHER_CONFIGURATION_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_ugcbase_impl_social_utils_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; legacy_cloud_ug_cpath_mapping: BOOLEAN): detachable COM_ADOBE_CQ_SOCIAL_UGCBASE_IMPL_SOCIAL_UTILS_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: legacy_cloud_ug_cpath_mapping  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_UGCBASE_IMPL_SOCIAL_UTILS_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.SocialUtilsImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "legacyCloudUGCPathMapping", legacy_cloud_ug_cpath_mapping));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_UGCBASE_IMPL_SOCIAL_UTILS_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_UGCBASE_IMPL_SOCIAL_UTILS_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_ugcbase_moderation_impl_auto_moderation_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; automoderation_sequence: detachable LIST [STRING_32]; automoderation_onfailurestop: BOOLEAN): detachable COM_ADOBE_CQ_SOCIAL_UGCBASE_MODERATION_IMPL_AUTO_MODERATION_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: automoderation_sequence  (optional)
			-- 
			-- argument: automoderation_onfailurestop  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_UGCBASE_MODERATION_IMPL_AUTO_MODERATION_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.ugcbase.moderation.impl.AutoModerationImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "automoderation.sequence", automoderation_sequence));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "automoderation.onfailurestop", automoderation_onfailurestop));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_UGCBASE_MODERATION_IMPL_AUTO_MODERATION_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_UGCBASE_MODERATION_IMPL_AUTO_MODERATION_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_ugcbase_moderation_impl_sentiment_process (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; watchwords_positive: detachable LIST [STRING_32]; watchwords_negative: detachable LIST [STRING_32]; watchwords_path: STRING_32; sentiment_path: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_UGCBASE_MODERATION_IMPL_SENTIMENT_PROCESS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: watchwords_positive  (optional)
			-- 
			-- argument: watchwords_negative  (optional)
			-- 
			-- argument: watchwords_path  (optional)
			-- 
			-- argument: sentiment_path  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_UGCBASE_MODERATION_IMPL_SENTIMENT_PROCESS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.ugcbase.moderation.impl.SentimentProcess"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "watchwords.positive", watchwords_positive));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "watchwords.negative", watchwords_negative));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "watchwords.path", watchwords_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sentiment.path", sentiment_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_UGCBASE_MODERATION_IMPL_SENTIMENT_PROCESS_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_UGCBASE_MODERATION_IMPL_SENTIMENT_PROCESS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_ugcbase_security_impl_default_attachment_type_blackli (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; default_attachment_type_blacklist: detachable LIST [STRING_32]; baseline_attachment_type_blacklist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_UGCBASE_SECURITY_IMPL_DEFAULT_ATTACHMENT_TYPE_BLACKLI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: default_attachment_type_blacklist  (optional)
			-- 
			-- argument: baseline_attachment_type_blacklist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_UGCBASE_SECURITY_IMPL_DEFAULT_ATTACHMENT_TYPE_BLACKLI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.ugcbase.security.impl.DefaultAttachmentTypeBlacklistService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "default.attachment.type.blacklist", default_attachment_type_blacklist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "baseline.attachment.type.blacklist", baseline_attachment_type_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_UGCBASE_SECURITY_IMPL_DEFAULT_ATTACHMENT_TYPE_BLACKLI_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_UGCBASE_SECURITY_IMPL_DEFAULT_ATTACHMENT_TYPE_BLACKLI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_ugcbase_security_impl_safer_sling_post_validator_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; parameter_whitelist: detachable LIST [STRING_32]; parameter_whitelist_prefixes: detachable LIST [STRING_32]; binary_parameter_whitelist: detachable LIST [STRING_32]; modifier_whitelist: detachable LIST [STRING_32]; operation_whitelist: detachable LIST [STRING_32]; operation_whitelist_prefixes: detachable LIST [STRING_32]; typehint_whitelist: detachable LIST [STRING_32]; resourcetype_whitelist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_UGCBASE_SECURITY_IMPL_SAFER_SLING_POST_VALIDATOR_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: parameter_whitelist  (optional)
			-- 
			-- argument: parameter_whitelist_prefixes  (optional)
			-- 
			-- argument: binary_parameter_whitelist  (optional)
			-- 
			-- argument: modifier_whitelist  (optional)
			-- 
			-- argument: operation_whitelist  (optional)
			-- 
			-- argument: operation_whitelist_prefixes  (optional)
			-- 
			-- argument: typehint_whitelist  (optional)
			-- 
			-- argument: resourcetype_whitelist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_UGCBASE_SECURITY_IMPL_SAFER_SLING_POST_VALIDATOR_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.ugcbase.security.impl.SaferSlingPostValidatorImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "parameter.whitelist", parameter_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "parameter.whitelist.prefixes", parameter_whitelist_prefixes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "binary.parameter.whitelist", binary_parameter_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "modifier.whitelist", modifier_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "operation.whitelist", operation_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "operation.whitelist.prefixes", operation_whitelist_prefixes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "typehint.whitelist", typehint_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resourcetype.whitelist", resourcetype_whitelist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_UGCBASE_SECURITY_IMPL_SAFER_SLING_POST_VALIDATOR_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_UGCBASE_SECURITY_IMPL_SAFER_SLING_POST_VALIDATOR_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_user_endpoints_impl_users_group_from_publish_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_extensions: STRING_32; sling_servlet_paths: STRING_32; sling_servlet_methods: STRING_32): detachable COM_ADOBE_CQ_SOCIAL_USER_ENDPOINTS_IMPL_USERS_GROUP_FROM_PUBLISH_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_extensions  (optional)
			-- 
			-- argument: sling_servlet_paths  (optional)
			-- 
			-- argument: sling_servlet_methods  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_USER_ENDPOINTS_IMPL_USERS_GROUP_FROM_PUBLISH_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.user.endpoints.impl.UsersGroupFromPublishServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.extensions", sling_servlet_extensions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.paths", sling_servlet_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.methods", sling_servlet_methods));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_USER_ENDPOINTS_IMPL_USERS_GROUP_FROM_PUBLISH_SERVLET_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_USER_ENDPOINTS_IMPL_USERS_GROUP_FROM_PUBLISH_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_social_user_impl_transport_http_to_publisher (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enable: BOOLEAN; agent_configuration: detachable LIST [STRING_32]; context_path: STRING_32; disabled_cipher_suites: detachable LIST [STRING_32]; enabled_cipher_suites: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_SOCIAL_USER_IMPL_TRANSPORT_HTTP_TO_PUBLISHER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enable  (optional)
			-- 
			-- argument: agent_configuration  (optional)
			-- 
			-- argument: context_path  (optional)
			-- 
			-- argument: disabled_cipher_suites  (optional)
			-- 
			-- argument: enabled_cipher_suites  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_SOCIAL_USER_IMPL_TRANSPORT_HTTP_TO_PUBLISHER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.social.user.impl.transport.HttpToPublisher"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable", enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "agent.configuration", agent_configuration));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "context.path", context_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "disabled.cipher.suites", disabled_cipher_suites));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "enabled.cipher.suites", enabled_cipher_suites));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_SOCIAL_USER_IMPL_TRANSPORT_HTTP_TO_PUBLISHER_INFO } l_response.data ({ COM_ADOBE_CQ_SOCIAL_USER_IMPL_TRANSPORT_HTTP_TO_PUBLISHER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_ui_wcm_commons_internal_servlets_rte_rt_efilter_servlet_fact (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; resource_types: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_UI_WCM_COMMONS_INTERNAL_SERVLETS_RTE_RTE_FILTER_SERVLET_FACT_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: resource_types  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_UI_WCM_COMMONS_INTERNAL_SERVLETS_RTE_RTE_FILTER_SERVLET_FACT_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.ui.wcm.commons.internal.servlets.rte.RTEFilterServletFactory.amended"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resource.types", resource_types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_UI_WCM_COMMONS_INTERNAL_SERVLETS_RTE_RTE_FILTER_SERVLET_FACT_INFO } l_response.data ({ COM_ADOBE_CQ_UI_WCM_COMMONS_INTERNAL_SERVLETS_RTE_RTE_FILTER_SERVLET_FACT_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_upgrades_cleanup_impl_upgrade_content_cleanup (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; delete_path_regexps: detachable LIST [STRING_32]; delete_sql2_query: STRING_32): detachable COM_ADOBE_CQ_UPGRADES_CLEANUP_IMPL_UPGRADE_CONTENT_CLEANUP_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: delete_path_regexps  (optional)
			-- 
			-- argument: delete_sql2_query  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_UPGRADES_CLEANUP_IMPL_UPGRADE_CONTENT_CLEANUP_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.upgrades.cleanup.impl.UpgradeContentCleanup"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "delete.path.regexps", delete_path_regexps));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete.sql2.query", delete_sql2_query));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_UPGRADES_CLEANUP_IMPL_UPGRADE_CONTENT_CLEANUP_INFO } l_response.data ({ COM_ADOBE_CQ_UPGRADES_CLEANUP_IMPL_UPGRADE_CONTENT_CLEANUP_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_upgrades_cleanup_impl_upgrade_install_folder_cleanup (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; delete_name_regexps: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_UPGRADES_CLEANUP_IMPL_UPGRADE_INSTALL_FOLDER_CLEANUP_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: delete_name_regexps  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_UPGRADES_CLEANUP_IMPL_UPGRADE_INSTALL_FOLDER_CLEANUP_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.upgrades.cleanup.impl.UpgradeInstallFolderCleanup"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "delete.name.regexps", delete_name_regexps));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_UPGRADES_CLEANUP_IMPL_UPGRADE_INSTALL_FOLDER_CLEANUP_INFO } l_response.data ({ COM_ADOBE_CQ_UPGRADES_CLEANUP_IMPL_UPGRADE_INSTALL_FOLDER_CLEANUP_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_wcm_jobs_async_impl_async_delete_config_provider_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; threshold: INTEGER_32; job_topic_name: STRING_32; email_enabled: BOOLEAN): detachable COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_DELETE_CONFIG_PROVIDER_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: threshold  (optional)
			-- 
			-- argument: job_topic_name  (optional)
			-- 
			-- argument: email_enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_DELETE_CONFIG_PROVIDER_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncDeleteConfigProviderService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "threshold", threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jobTopicName", job_topic_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "emailEnabled", email_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_DELETE_CONFIG_PROVIDER_SERVICE_INFO } l_response.data ({ COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_DELETE_CONFIG_PROVIDER_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_wcm_jobs_async_impl_async_job_clean_up_task (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_expression: STRING_32; job_purge_threshold: INTEGER_32; job_purge_max_jobs: INTEGER_32): detachable COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_JOB_CLEAN_UP_TASK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- argument: job_purge_threshold  (optional)
			-- 
			-- argument: job_purge_max_jobs  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_JOB_CLEAN_UP_TASK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncJobCleanUpTask"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "job.purge.threshold", job_purge_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "job.purge.max.jobs", job_purge_max_jobs));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_JOB_CLEAN_UP_TASK_INFO } l_response.data ({ COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_JOB_CLEAN_UP_TASK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_wcm_jobs_async_impl_async_move_config_provider_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; threshold: INTEGER_32; job_topic_name: STRING_32; email_enabled: BOOLEAN): detachable COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_MOVE_CONFIG_PROVIDER_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: threshold  (optional)
			-- 
			-- argument: job_topic_name  (optional)
			-- 
			-- argument: email_enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_MOVE_CONFIG_PROVIDER_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncMoveConfigProviderService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "threshold", threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jobTopicName", job_topic_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "emailEnabled", email_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_MOVE_CONFIG_PROVIDER_SERVICE_INFO } l_response.data ({ COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_MOVE_CONFIG_PROVIDER_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_wcm_jobs_async_impl_async_page_move_config_provider_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; threshold: INTEGER_32; job_topic_name: STRING_32; email_enabled: BOOLEAN): detachable COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_PAGE_MOVE_CONFIG_PROVIDER_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: threshold  (optional)
			-- 
			-- argument: job_topic_name  (optional)
			-- 
			-- argument: email_enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_PAGE_MOVE_CONFIG_PROVIDER_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncPageMoveConfigProviderService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "threshold", threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jobTopicName", job_topic_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "emailEnabled", email_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_PAGE_MOVE_CONFIG_PROVIDER_SERVICE_INFO } l_response.data ({ COM_ADOBE_CQ_WCM_JOBS_ASYNC_IMPL_ASYNC_PAGE_MOVE_CONFIG_PROVIDER_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_wcm_launches_impl_launches_event_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_filter: STRING_32; launches_eventhandler_threadpool_maxsize: INTEGER_32; launches_eventhandler_threadpool_priority: STRING_32; launches_eventhandler_updatelastmodification: BOOLEAN): detachable COM_ADOBE_CQ_WCM_LAUNCHES_IMPL_LAUNCHES_EVENT_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- argument: launches_eventhandler_threadpool_maxsize  (optional)
			-- 
			-- argument: launches_eventhandler_threadpool_priority  (optional)
			-- 
			-- argument: launches_eventhandler_updatelastmodification  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_WCM_LAUNCHES_IMPL_LAUNCHES_EVENT_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.wcm.launches.impl.LaunchesEventHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "launches.eventhandler.threadpool.maxsize", launches_eventhandler_threadpool_maxsize));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "launches.eventhandler.threadpool.priority", launches_eventhandler_threadpool_priority));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "launches.eventhandler.updatelastmodification", launches_eventhandler_updatelastmodification));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_WCM_LAUNCHES_IMPL_LAUNCHES_EVENT_HANDLER_INFO } l_response.data ({ COM_ADOBE_CQ_WCM_LAUNCHES_IMPL_LAUNCHES_EVENT_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_wcm_mobile_qrcode_servlet_qr_code_image_generator (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_wcm_qrcode_servlet_whitelist: detachable LIST [STRING_32]): detachable COM_ADOBE_CQ_WCM_MOBILE_QRCODE_SERVLET_QR_CODE_IMAGE_GENERATOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_wcm_qrcode_servlet_whitelist  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_WCM_MOBILE_QRCODE_SERVLET_QR_CODE_IMAGE_GENERATOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.wcm.mobile.qrcode.servlet.QRCodeImageGenerator"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.qrcode.servlet.whitelist", cq_wcm_qrcode_servlet_whitelist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_WCM_MOBILE_QRCODE_SERVLET_QR_CODE_IMAGE_GENERATOR_INFO } l_response.data ({ COM_ADOBE_CQ_WCM_MOBILE_QRCODE_SERVLET_QR_CODE_IMAGE_GENERATOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_wcm_style_internal_component_style_info_cache_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; size: INTEGER_32): detachable COM_ADOBE_CQ_WCM_STYLE_INTERNAL_COMPONENT_STYLE_INFO_CACHE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: size  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_WCM_STYLE_INTERNAL_COMPONENT_STYLE_INFO_CACHE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.wcm.style.internal.ComponentStyleInfoCacheImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "size", size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_WCM_STYLE_INTERNAL_COMPONENT_STYLE_INFO_CACHE_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_WCM_STYLE_INTERNAL_COMPONENT_STYLE_INFO_CACHE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_cq_wcm_translation_impl_translation_platform_configuration_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sync_translation_state_scheduling_format: STRING_32; scheduling_repeat_translation_scheduling_format: STRING_32; sync_translation_state_lock_timeout_in_minutes: STRING_32; export_format: STRING_32): detachable COM_ADOBE_CQ_WCM_TRANSLATION_IMPL_TRANSLATION_PLATFORM_CONFIGURATION_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sync_translation_state_scheduling_format  (optional)
			-- 
			-- argument: scheduling_repeat_translation_scheduling_format  (optional)
			-- 
			-- argument: sync_translation_state_lock_timeout_in_minutes  (optional)
			-- 
			-- argument: export_format  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_CQ_WCM_TRANSLATION_IMPL_TRANSLATION_PLATFORM_CONFIGURATION_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.cq.wcm.translation.impl.TranslationPlatformConfigurationImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "syncTranslationState.schedulingFormat", sync_translation_state_scheduling_format));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "schedulingRepeatTranslation.schedulingFormat", scheduling_repeat_translation_scheduling_format));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "syncTranslationState.lockTimeoutInMinutes", sync_translation_state_lock_timeout_in_minutes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "export.format", export_format));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_CQ_WCM_TRANSLATION_IMPL_TRANSLATION_PLATFORM_CONFIGURATION_IMPL_INFO } l_response.data ({ COM_ADOBE_CQ_WCM_TRANSLATION_IMPL_TRANSLATION_PLATFORM_CONFIGURATION_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_fd_fp_config_forms_portal_draftsand_submission_config_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; portal_outboxes: detachable LIST [STRING_32]; draft_data_service: STRING_32; draft_metadata_service: STRING_32; submit_data_service: STRING_32; submit_metadata_service: STRING_32; pending_sign_data_service: STRING_32; pending_sign_metadata_service: STRING_32): detachable COM_ADOBE_FD_FP_CONFIG_FORMS_PORTAL_DRAFTSAND_SUBMISSION_CONFIG_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: portal_outboxes  (optional)
			-- 
			-- argument: draft_data_service  (optional)
			-- 
			-- argument: draft_metadata_service  (optional)
			-- 
			-- argument: submit_data_service  (optional)
			-- 
			-- argument: submit_metadata_service  (optional)
			-- 
			-- argument: pending_sign_data_service  (optional)
			-- 
			-- argument: pending_sign_metadata_service  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_FD_FP_CONFIG_FORMS_PORTAL_DRAFTSAND_SUBMISSION_CONFIG_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.fd.fp.config.FormsPortalDraftsandSubmissionConfigService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "portal.outboxes", portal_outboxes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "draft.data.service", draft_data_service));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "draft.metadata.service", draft_metadata_service));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "submit.data.service", submit_data_service));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "submit.metadata.service", submit_metadata_service));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pendingSign.data.service", pending_sign_data_service));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pendingSign.metadata.service", pending_sign_metadata_service));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_FD_FP_CONFIG_FORMS_PORTAL_DRAFTSAND_SUBMISSION_CONFIG_SERVICE_INFO } l_response.data ({ COM_ADOBE_FD_FP_CONFIG_FORMS_PORTAL_DRAFTSAND_SUBMISSION_CONFIG_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_fd_fp_config_forms_portal_scheduler_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; formportal_interval: STRING_32): detachable COM_ADOBE_FD_FP_CONFIG_FORMS_PORTAL_SCHEDULER_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: formportal_interval  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_FD_FP_CONFIG_FORMS_PORTAL_SCHEDULER_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.fd.fp.config.FormsPortalSchedulerService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "formportal.interval", formportal_interval));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_FD_FP_CONFIG_FORMS_PORTAL_SCHEDULER_SERVICE_INFO } l_response.data ({ COM_ADOBE_FD_FP_CONFIG_FORMS_PORTAL_SCHEDULER_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_forms_common_service_impl_default_data_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; alloweddata_file_locations: detachable LIST [STRING_32]): detachable COM_ADOBE_FORMS_COMMON_SERVICE_IMPL_DEFAULT_DATA_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: alloweddata_file_locations  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_FORMS_COMMON_SERVICE_IMPL_DEFAULT_DATA_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.forms.common.service.impl.DefaultDataProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "alloweddataFileLocations", alloweddata_file_locations));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_FORMS_COMMON_SERVICE_IMPL_DEFAULT_DATA_PROVIDER_INFO } l_response.data ({ COM_ADOBE_FORMS_COMMON_SERVICE_IMPL_DEFAULT_DATA_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_forms_common_service_impl_forms_common_configuration_service_imp (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; temp_storage_config: STRING_32): detachable COM_ADOBE_FORMS_COMMON_SERVICE_IMPL_FORMS_COMMON_CONFIGURATION_SERVICE_IMP_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: temp_storage_config  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_FORMS_COMMON_SERVICE_IMPL_FORMS_COMMON_CONFIGURATION_SERVICE_IMP_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.forms.common.service.impl.FormsCommonConfigurationServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tempStorageConfig", temp_storage_config));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_FORMS_COMMON_SERVICE_IMPL_FORMS_COMMON_CONFIGURATION_SERVICE_IMP_INFO } l_response.data ({ COM_ADOBE_FORMS_COMMON_SERVICE_IMPL_FORMS_COMMON_CONFIGURATION_SERVICE_IMP_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_forms_common_servlet_temp_clean_up_task (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_expression: STRING_32; duration_for__temporary__storage: STRING_32; duration_for__anonymous__storage: STRING_32): detachable COM_ADOBE_FORMS_COMMON_SERVLET_TEMP_CLEAN_UP_TASK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- argument: duration_for__temporary__storage  (optional)
			-- 
			-- argument: duration_for__anonymous__storage  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_FORMS_COMMON_SERVLET_TEMP_CLEAN_UP_TASK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.forms.common.servlet.TempCleanUpTask"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "Duration for Temporary Storage", duration_for__temporary__storage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "Duration for Anonymous Storage", duration_for__anonymous__storage));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_FORMS_COMMON_SERVLET_TEMP_CLEAN_UP_TASK_INFO } l_response.data ({ COM_ADOBE_FORMS_COMMON_SERVLET_TEMP_CLEAN_UP_TASK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_acp_platform_platform_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; query_limit: INTEGER_32; file_type_extension_map: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_ACP_PLATFORM_PLATFORM_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: query_limit  (optional)
			-- 
			-- argument: file_type_extension_map  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_ACP_PLATFORM_PLATFORM_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.acp.platform.PlatformServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "query.limit", query_limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "file.type.extension.map", file_type_extension_map));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_ACP_PLATFORM_PLATFORM_SERVLET_INFO } l_response.data ({ COM_ADOBE_GRANITE_ACP_PLATFORM_PLATFORM_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_activitystreams_impl_activity_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; aggregate_relationships: detachable LIST [STRING_32]; aggregate_descend_virtual: BOOLEAN): detachable COM_ADOBE_GRANITE_ACTIVITYSTREAMS_IMPL_ACTIVITY_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: aggregate_relationships  (optional)
			-- 
			-- argument: aggregate_descend_virtual  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_ACTIVITYSTREAMS_IMPL_ACTIVITY_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.activitystreams.impl.ActivityManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "aggregate.relationships", aggregate_relationships));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "aggregate.descend.virtual", aggregate_descend_virtual));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_ACTIVITYSTREAMS_IMPL_ACTIVITY_MANAGER_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_ACTIVITYSTREAMS_IMPL_ACTIVITY_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_analyzer_base_system_status_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; disabled: BOOLEAN): detachable COM_ADOBE_GRANITE_ANALYZER_BASE_SYSTEM_STATUS_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: disabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_ANALYZER_BASE_SYSTEM_STATUS_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.analyzer.base.SystemStatusServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "disabled", disabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_ANALYZER_BASE_SYSTEM_STATUS_SERVLET_INFO } l_response.data ({ COM_ADOBE_GRANITE_ANALYZER_BASE_SYSTEM_STATUS_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_analyzer_scripts_compile_all_scripts_compiler_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; disabled: BOOLEAN): detachable COM_ADOBE_GRANITE_ANALYZER_SCRIPTS_COMPILE_ALL_SCRIPTS_COMPILER_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: disabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_ANALYZER_SCRIPTS_COMPILE_ALL_SCRIPTS_COMPILER_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.analyzer.scripts.compile.AllScriptsCompilerServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "disabled", disabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_ANALYZER_SCRIPTS_COMPILE_ALL_SCRIPTS_COMPILER_SERVLET_INFO } l_response.data ({ COM_ADOBE_GRANITE_ANALYZER_SCRIPTS_COMPILE_ALL_SCRIPTS_COMPILER_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_apicontroller_filter_resolver_hook_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_adobe_cq_cdn_cdn_rewriter: STRING_32; com_adobe_cq_cloud_config_components: STRING_32; com_adobe_cq_cloud_config_core: STRING_32; com_adobe_cq_cloud_config_ui: STRING_32; com_adobe_cq_com_adobe_cq_editor: STRING_32; com_adobe_cq_com_adobe_cq_projects_core: STRING_32; com_adobe_cq_com_adobe_cq_projects_wcm_core: STRING_32; com_adobe_cq_com_adobe_cq_ui_commons: STRING_32; com_adobe_cq_com_adobe_cq_wcm_style: STRING_32; com_adobe_cq_cq_activitymap_integration: STRING_32; com_adobe_cq_cq_contexthub_commons: STRING_32; com_adobe_cq_cq_dtm: STRING_32; com_adobe_cq_cq_healthcheck: STRING_32; com_adobe_cq_cq_multisite_targeting: STRING_32; com_adobe_cq_cq_pre_upgrade_cleanup: STRING_32; com_adobe_cq_cq_product_info_provider: STRING_32; com_adobe_cq_cq_rest_sites: STRING_32; com_adobe_cq_cq_security_hc: STRING_32; com_adobe_cq_dam_cq_dam_svg_handler: STRING_32; com_adobe_cq_dam_cq_scene7_imaging: STRING_32; com_adobe_cq_dtm_reactor_core: STRING_32; com_adobe_cq_dtm_reactor_ui: STRING_32; com_adobe_cq_exp_jspel_resolver: STRING_32; com_adobe_cq_inbox_cq_inbox: STRING_32; com_adobe_cq_json_schema_parser: STRING_32; com_adobe_cq_media_cq_media_publishing_dps_fp_core: STRING_32; com_adobe_cq_mobile_cq_mobile_caas: STRING_32; com_adobe_cq_mobile_cq_mobile_index_builder: STRING_32; com_adobe_cq_mobile_cq_mobile_phonegap_build: STRING_32; com_adobe_cq_myspell: STRING_32; com_adobe_cq_sample_we_retail_core: STRING_32; com_adobe_cq_screens_com_adobe_cq_screens_dcc: STRING_32; com_adobe_cq_screens_com_adobe_cq_screens_mq_core: STRING_32; com_adobe_cq_social_cq_social_as_provider: STRING_32; com_adobe_cq_social_cq_social_badging_basic_impl: STRING_32; com_adobe_cq_social_cq_social_badging_impl: STRING_32; com_adobe_cq_social_cq_social_calendar_impl: STRING_32; com_adobe_cq_social_cq_social_content_fragments_impl: STRING_32; com_adobe_cq_social_cq_social_enablement_impl: STRING_32; com_adobe_cq_social_cq_social_graph_impl: STRING_32; com_adobe_cq_social_cq_social_ideation_impl: STRING_32; com_adobe_cq_social_cq_social_jcr_provider: STRING_32; com_adobe_cq_social_cq_social_members_impl: STRING_32; com_adobe_cq_social_cq_social_ms_provider: STRING_32; com_adobe_cq_social_cq_social_notifications_channels_web: STRING_32; com_adobe_cq_social_cq_social_notifications_impl: STRING_32; com_adobe_cq_social_cq_social_rdb_provider: STRING_32; com_adobe_cq_social_cq_social_scf_impl: STRING_32; com_adobe_cq_social_cq_social_scoring_basic_impl: STRING_32; com_adobe_cq_social_cq_social_scoring_impl: STRING_32; com_adobe_cq_social_cq_social_serviceusers_impl: STRING_32; com_adobe_cq_social_cq_social_srp_impl: STRING_32; com_adobe_cq_social_cq_social_ugcbase_impl: STRING_32; com_adobe_dam_cq_dam_cfm_impl: STRING_32; com_adobe_forms_foundation_forms_foundation_base: STRING_32; com_adobe_granite_apicontroller: STRING_32; com_adobe_granite_asset_core: STRING_32; com_adobe_granite_auth_sso: STRING_32; com_adobe_granite_bundles_hc_impl: STRING_32; com_adobe_granite_compat_router: STRING_32; com_adobe_granite_conf: STRING_32; com_adobe_granite_conf_ui_core: STRING_32; com_adobe_granite_cors: STRING_32; com_adobe_granite_crx_explorer: STRING_32; com_adobe_granite_crxde_lite: STRING_32; com_adobe_granite_crypto_config: STRING_32; com_adobe_granite_crypto_extension: STRING_32; com_adobe_granite_crypto_file: STRING_32; com_adobe_granite_crypto_jcr: STRING_32; com_adobe_granite_csrf: STRING_32; com_adobe_granite_distribution_core: STRING_32; com_adobe_granite_dropwizard_metrics: STRING_32; com_adobe_granite_frags_impl: STRING_32; com_adobe_granite_gibson: STRING_32; com_adobe_granite_infocollector: STRING_32; com_adobe_granite_installer_factory_packages: STRING_32; com_adobe_granite_jetty_ssl: STRING_32; com_adobe_granite_jobs_async: STRING_32; com_adobe_granite_maintenance_oak: STRING_32; com_adobe_granite_monitoring_core: STRING_32; com_adobe_granite_queries: STRING_32; com_adobe_granite_replication_hc_impl: STRING_32; com_adobe_granite_repository_checker: STRING_32; com_adobe_granite_repository_hc_impl: STRING_32; com_adobe_granite_rest_assets: STRING_32; com_adobe_granite_security_ui: STRING_32; com_adobe_granite_startup: STRING_32; com_adobe_granite_tagsoup: STRING_32; com_adobe_granite_taskmanagement_core: STRING_32; com_adobe_granite_taskmanagement_workflow: STRING_32; com_adobe_granite_ui_clientlibs_compiler_less: STRING_32; com_adobe_granite_ui_clientlibs_processor_gcc: STRING_32; com_adobe_granite_webconsole_plugins: STRING_32; com_adobe_granite_workflow_console: STRING_32; com_adobe_xmp_worker_files_native_fragment_linux: STRING_32; com_adobe_xmp_worker_files_native_fragment_macosx: STRING_32; com_adobe_xmp_worker_files_native_fragment_win: STRING_32; com_day_commons_osgi_wrapper_simple_jndi: STRING_32; com_day_cq_cq_authhandler: STRING_32; com_day_cq_cq_compat_configupdate: STRING_32; com_day_cq_cq_licensebranding: STRING_32; com_day_cq_cq_notifcation_impl: STRING_32; com_day_cq_cq_replication_audit: STRING_32; com_day_cq_cq_search_ext: STRING_32; com_day_cq_dam_cq_dam_annotation_print: STRING_32; com_day_cq_dam_cq_dam_asset_usage: STRING_32; com_day_cq_dam_cq_dam_s7dam: STRING_32; com_day_cq_dam_cq_dam_similaritysearch: STRING_32; com_day_cq_dam_dam_webdav_support: STRING_32; com_day_cq_pre_upgrade_tasks: STRING_32; com_day_cq_replication_extensions: STRING_32; com_day_cq_wcm_cq_msm_core: STRING_32; com_day_cq_wcm_cq_wcm_translation: STRING_32; day_commons_jrawio: STRING_32; org_apache_aries_jmx_whiteboard: STRING_32; org_apache_felix_http_sslfilter: STRING_32; org_apache_felix_org_apache_felix_threaddump: STRING_32; org_apache_felix_webconsole_plugins_ds: STRING_32; org_apache_felix_webconsole_plugins_event: STRING_32; org_apache_felix_webconsole_plugins_memoryusage: STRING_32; org_apache_felix_webconsole_plugins_packageadmin: STRING_32; org_apache_jackrabbit_oak_auth_ldap: STRING_32; org_apache_jackrabbit_oak_segment_tar: STRING_32; org_apache_jackrabbit_oak_solr_osgi: STRING_32; org_apache_sling_bundleresource_impl: STRING_32; org_apache_sling_commons_fsclassloader: STRING_32; org_apache_sling_commons_log_webconsole: STRING_32; org_apache_sling_datasource: STRING_32; org_apache_sling_discovery_base: STRING_32; org_apache_sling_discovery_oak: STRING_32; org_apache_sling_discovery_support: STRING_32; org_apache_sling_distribution_api: STRING_32; org_apache_sling_distribution_core: STRING_32; org_apache_sling_extensions_webconsolesecurityprovider: STRING_32; org_apache_sling_hc_webconsole: STRING_32; org_apache_sling_installer_console: STRING_32; org_apache_sling_installer_provider_file: STRING_32; org_apache_sling_installer_provider_jcr: STRING_32; org_apache_sling_jcr_davex: STRING_32; org_apache_sling_jcr_resourcesecurity: STRING_32; org_apache_sling_jmx_provider: STRING_32; org_apache_sling_launchpad_installer: STRING_32; org_apache_sling_models_impl: STRING_32; org_apache_sling_repoinit_parser: STRING_32; org_apache_sling_resource_inventory: STRING_32; org_apache_sling_resourceresolver: STRING_32; org_apache_sling_scripting_javascript: STRING_32; org_apache_sling_scripting_jst: STRING_32; org_apache_sling_scripting_sightly_js_provider: STRING_32; org_apache_sling_scripting_sightly_models_provider: STRING_32; org_apache_sling_security: STRING_32; org_apache_sling_servlets_compat: STRING_32; org_apache_sling_servlets_get: STRING_32; org_apache_sling_startupfilter_disabler: STRING_32; org_apache_sling_tracer: STRING_32; we_retail_client_app_core: STRING_32): detachable COM_ADOBE_GRANITE_APICONTROLLER_FILTER_RESOLVER_HOOK_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_adobe_cq_cdn_cdn_rewriter  (optional)
			-- 
			-- argument: com_adobe_cq_cloud_config_components  (optional)
			-- 
			-- argument: com_adobe_cq_cloud_config_core  (optional)
			-- 
			-- argument: com_adobe_cq_cloud_config_ui  (optional)
			-- 
			-- argument: com_adobe_cq_com_adobe_cq_editor  (optional)
			-- 
			-- argument: com_adobe_cq_com_adobe_cq_projects_core  (optional)
			-- 
			-- argument: com_adobe_cq_com_adobe_cq_projects_wcm_core  (optional)
			-- 
			-- argument: com_adobe_cq_com_adobe_cq_ui_commons  (optional)
			-- 
			-- argument: com_adobe_cq_com_adobe_cq_wcm_style  (optional)
			-- 
			-- argument: com_adobe_cq_cq_activitymap_integration  (optional)
			-- 
			-- argument: com_adobe_cq_cq_contexthub_commons  (optional)
			-- 
			-- argument: com_adobe_cq_cq_dtm  (optional)
			-- 
			-- argument: com_adobe_cq_cq_healthcheck  (optional)
			-- 
			-- argument: com_adobe_cq_cq_multisite_targeting  (optional)
			-- 
			-- argument: com_adobe_cq_cq_pre_upgrade_cleanup  (optional)
			-- 
			-- argument: com_adobe_cq_cq_product_info_provider  (optional)
			-- 
			-- argument: com_adobe_cq_cq_rest_sites  (optional)
			-- 
			-- argument: com_adobe_cq_cq_security_hc  (optional)
			-- 
			-- argument: com_adobe_cq_dam_cq_dam_svg_handler  (optional)
			-- 
			-- argument: com_adobe_cq_dam_cq_scene7_imaging  (optional)
			-- 
			-- argument: com_adobe_cq_dtm_reactor_core  (optional)
			-- 
			-- argument: com_adobe_cq_dtm_reactor_ui  (optional)
			-- 
			-- argument: com_adobe_cq_exp_jspel_resolver  (optional)
			-- 
			-- argument: com_adobe_cq_inbox_cq_inbox  (optional)
			-- 
			-- argument: com_adobe_cq_json_schema_parser  (optional)
			-- 
			-- argument: com_adobe_cq_media_cq_media_publishing_dps_fp_core  (optional)
			-- 
			-- argument: com_adobe_cq_mobile_cq_mobile_caas  (optional)
			-- 
			-- argument: com_adobe_cq_mobile_cq_mobile_index_builder  (optional)
			-- 
			-- argument: com_adobe_cq_mobile_cq_mobile_phonegap_build  (optional)
			-- 
			-- argument: com_adobe_cq_myspell  (optional)
			-- 
			-- argument: com_adobe_cq_sample_we_retail_core  (optional)
			-- 
			-- argument: com_adobe_cq_screens_com_adobe_cq_screens_dcc  (optional)
			-- 
			-- argument: com_adobe_cq_screens_com_adobe_cq_screens_mq_core  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_as_provider  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_badging_basic_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_badging_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_calendar_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_content_fragments_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_enablement_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_graph_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_ideation_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_jcr_provider  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_members_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_ms_provider  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_notifications_channels_web  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_notifications_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_rdb_provider  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_scf_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_scoring_basic_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_scoring_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_serviceusers_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_srp_impl  (optional)
			-- 
			-- argument: com_adobe_cq_social_cq_social_ugcbase_impl  (optional)
			-- 
			-- argument: com_adobe_dam_cq_dam_cfm_impl  (optional)
			-- 
			-- argument: com_adobe_forms_foundation_forms_foundation_base  (optional)
			-- 
			-- argument: com_adobe_granite_apicontroller  (optional)
			-- 
			-- argument: com_adobe_granite_asset_core  (optional)
			-- 
			-- argument: com_adobe_granite_auth_sso  (optional)
			-- 
			-- argument: com_adobe_granite_bundles_hc_impl  (optional)
			-- 
			-- argument: com_adobe_granite_compat_router  (optional)
			-- 
			-- argument: com_adobe_granite_conf  (optional)
			-- 
			-- argument: com_adobe_granite_conf_ui_core  (optional)
			-- 
			-- argument: com_adobe_granite_cors  (optional)
			-- 
			-- argument: com_adobe_granite_crx_explorer  (optional)
			-- 
			-- argument: com_adobe_granite_crxde_lite  (optional)
			-- 
			-- argument: com_adobe_granite_crypto_config  (optional)
			-- 
			-- argument: com_adobe_granite_crypto_extension  (optional)
			-- 
			-- argument: com_adobe_granite_crypto_file  (optional)
			-- 
			-- argument: com_adobe_granite_crypto_jcr  (optional)
			-- 
			-- argument: com_adobe_granite_csrf  (optional)
			-- 
			-- argument: com_adobe_granite_distribution_core  (optional)
			-- 
			-- argument: com_adobe_granite_dropwizard_metrics  (optional)
			-- 
			-- argument: com_adobe_granite_frags_impl  (optional)
			-- 
			-- argument: com_adobe_granite_gibson  (optional)
			-- 
			-- argument: com_adobe_granite_infocollector  (optional)
			-- 
			-- argument: com_adobe_granite_installer_factory_packages  (optional)
			-- 
			-- argument: com_adobe_granite_jetty_ssl  (optional)
			-- 
			-- argument: com_adobe_granite_jobs_async  (optional)
			-- 
			-- argument: com_adobe_granite_maintenance_oak  (optional)
			-- 
			-- argument: com_adobe_granite_monitoring_core  (optional)
			-- 
			-- argument: com_adobe_granite_queries  (optional)
			-- 
			-- argument: com_adobe_granite_replication_hc_impl  (optional)
			-- 
			-- argument: com_adobe_granite_repository_checker  (optional)
			-- 
			-- argument: com_adobe_granite_repository_hc_impl  (optional)
			-- 
			-- argument: com_adobe_granite_rest_assets  (optional)
			-- 
			-- argument: com_adobe_granite_security_ui  (optional)
			-- 
			-- argument: com_adobe_granite_startup  (optional)
			-- 
			-- argument: com_adobe_granite_tagsoup  (optional)
			-- 
			-- argument: com_adobe_granite_taskmanagement_core  (optional)
			-- 
			-- argument: com_adobe_granite_taskmanagement_workflow  (optional)
			-- 
			-- argument: com_adobe_granite_ui_clientlibs_compiler_less  (optional)
			-- 
			-- argument: com_adobe_granite_ui_clientlibs_processor_gcc  (optional)
			-- 
			-- argument: com_adobe_granite_webconsole_plugins  (optional)
			-- 
			-- argument: com_adobe_granite_workflow_console  (optional)
			-- 
			-- argument: com_adobe_xmp_worker_files_native_fragment_linux  (optional)
			-- 
			-- argument: com_adobe_xmp_worker_files_native_fragment_macosx  (optional)
			-- 
			-- argument: com_adobe_xmp_worker_files_native_fragment_win  (optional)
			-- 
			-- argument: com_day_commons_osgi_wrapper_simple_jndi  (optional)
			-- 
			-- argument: com_day_cq_cq_authhandler  (optional)
			-- 
			-- argument: com_day_cq_cq_compat_configupdate  (optional)
			-- 
			-- argument: com_day_cq_cq_licensebranding  (optional)
			-- 
			-- argument: com_day_cq_cq_notifcation_impl  (optional)
			-- 
			-- argument: com_day_cq_cq_replication_audit  (optional)
			-- 
			-- argument: com_day_cq_cq_search_ext  (optional)
			-- 
			-- argument: com_day_cq_dam_cq_dam_annotation_print  (optional)
			-- 
			-- argument: com_day_cq_dam_cq_dam_asset_usage  (optional)
			-- 
			-- argument: com_day_cq_dam_cq_dam_s7dam  (optional)
			-- 
			-- argument: com_day_cq_dam_cq_dam_similaritysearch  (optional)
			-- 
			-- argument: com_day_cq_dam_dam_webdav_support  (optional)
			-- 
			-- argument: com_day_cq_pre_upgrade_tasks  (optional)
			-- 
			-- argument: com_day_cq_replication_extensions  (optional)
			-- 
			-- argument: com_day_cq_wcm_cq_msm_core  (optional)
			-- 
			-- argument: com_day_cq_wcm_cq_wcm_translation  (optional)
			-- 
			-- argument: day_commons_jrawio  (optional)
			-- 
			-- argument: org_apache_aries_jmx_whiteboard  (optional)
			-- 
			-- argument: org_apache_felix_http_sslfilter  (optional)
			-- 
			-- argument: org_apache_felix_org_apache_felix_threaddump  (optional)
			-- 
			-- argument: org_apache_felix_webconsole_plugins_ds  (optional)
			-- 
			-- argument: org_apache_felix_webconsole_plugins_event  (optional)
			-- 
			-- argument: org_apache_felix_webconsole_plugins_memoryusage  (optional)
			-- 
			-- argument: org_apache_felix_webconsole_plugins_packageadmin  (optional)
			-- 
			-- argument: org_apache_jackrabbit_oak_auth_ldap  (optional)
			-- 
			-- argument: org_apache_jackrabbit_oak_segment_tar  (optional)
			-- 
			-- argument: org_apache_jackrabbit_oak_solr_osgi  (optional)
			-- 
			-- argument: org_apache_sling_bundleresource_impl  (optional)
			-- 
			-- argument: org_apache_sling_commons_fsclassloader  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_webconsole  (optional)
			-- 
			-- argument: org_apache_sling_datasource  (optional)
			-- 
			-- argument: org_apache_sling_discovery_base  (optional)
			-- 
			-- argument: org_apache_sling_discovery_oak  (optional)
			-- 
			-- argument: org_apache_sling_discovery_support  (optional)
			-- 
			-- argument: org_apache_sling_distribution_api  (optional)
			-- 
			-- argument: org_apache_sling_distribution_core  (optional)
			-- 
			-- argument: org_apache_sling_extensions_webconsolesecurityprovider  (optional)
			-- 
			-- argument: org_apache_sling_hc_webconsole  (optional)
			-- 
			-- argument: org_apache_sling_installer_console  (optional)
			-- 
			-- argument: org_apache_sling_installer_provider_file  (optional)
			-- 
			-- argument: org_apache_sling_installer_provider_jcr  (optional)
			-- 
			-- argument: org_apache_sling_jcr_davex  (optional)
			-- 
			-- argument: org_apache_sling_jcr_resourcesecurity  (optional)
			-- 
			-- argument: org_apache_sling_jmx_provider  (optional)
			-- 
			-- argument: org_apache_sling_launchpad_installer  (optional)
			-- 
			-- argument: org_apache_sling_models_impl  (optional)
			-- 
			-- argument: org_apache_sling_repoinit_parser  (optional)
			-- 
			-- argument: org_apache_sling_resource_inventory  (optional)
			-- 
			-- argument: org_apache_sling_resourceresolver  (optional)
			-- 
			-- argument: org_apache_sling_scripting_javascript  (optional)
			-- 
			-- argument: org_apache_sling_scripting_jst  (optional)
			-- 
			-- argument: org_apache_sling_scripting_sightly_js_provider  (optional)
			-- 
			-- argument: org_apache_sling_scripting_sightly_models_provider  (optional)
			-- 
			-- argument: org_apache_sling_security  (optional)
			-- 
			-- argument: org_apache_sling_servlets_compat  (optional)
			-- 
			-- argument: org_apache_sling_servlets_get  (optional)
			-- 
			-- argument: org_apache_sling_startupfilter_disabler  (optional)
			-- 
			-- argument: org_apache_sling_tracer  (optional)
			-- 
			-- argument: we_retail_client_app_core  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_APICONTROLLER_FILTER_RESOLVER_HOOK_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.apicontroller.FilterResolverHookFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cdn.cdn-rewriter", com_adobe_cq_cdn_cdn_rewriter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cloud-config.components", com_adobe_cq_cloud_config_components));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cloud-config.core", com_adobe_cq_cloud_config_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cloud-config.ui", com_adobe_cq_cloud_config_ui));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.com.adobe.cq.editor", com_adobe_cq_com_adobe_cq_editor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.com.adobe.cq.projects.core", com_adobe_cq_com_adobe_cq_projects_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.com.adobe.cq.projects.wcm.core", com_adobe_cq_com_adobe_cq_projects_wcm_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.com.adobe.cq.ui.commons", com_adobe_cq_com_adobe_cq_ui_commons));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.com.adobe.cq.wcm.style", com_adobe_cq_com_adobe_cq_wcm_style));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cq-activitymap-integration", com_adobe_cq_cq_activitymap_integration));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cq-contexthub-commons", com_adobe_cq_cq_contexthub_commons));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cq-dtm", com_adobe_cq_cq_dtm));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cq-healthcheck", com_adobe_cq_cq_healthcheck));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cq-multisite-targeting", com_adobe_cq_cq_multisite_targeting));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cq-pre-upgrade-cleanup", com_adobe_cq_cq_pre_upgrade_cleanup));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cq-product-info-provider", com_adobe_cq_cq_product_info_provider));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cq-rest-sites", com_adobe_cq_cq_rest_sites));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.cq-security-hc", com_adobe_cq_cq_security_hc));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.dam.cq-dam-svg-handler", com_adobe_cq_dam_cq_dam_svg_handler));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.dam.cq-scene7-imaging", com_adobe_cq_dam_cq_scene7_imaging));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.dtm-reactor.core", com_adobe_cq_dtm_reactor_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.dtm-reactor.ui", com_adobe_cq_dtm_reactor_ui));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.exp-jspel-resolver", com_adobe_cq_exp_jspel_resolver));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.inbox.cq-inbox", com_adobe_cq_inbox_cq_inbox));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.json-schema-parser", com_adobe_cq_json_schema_parser));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.media.cq-media-publishing-dps-fp-core", com_adobe_cq_media_cq_media_publishing_dps_fp_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.mobile.cq-mobile-caas", com_adobe_cq_mobile_cq_mobile_caas));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.mobile.cq-mobile-index-builder", com_adobe_cq_mobile_cq_mobile_index_builder));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.mobile.cq-mobile-phonegap-build", com_adobe_cq_mobile_cq_mobile_phonegap_build));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.myspell", com_adobe_cq_myspell));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.sample.we.retail.core", com_adobe_cq_sample_we_retail_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.com.adobe.cq.screens.dcc", com_adobe_cq_screens_com_adobe_cq_screens_dcc));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.screens.com.adobe.cq.screens.mq.core", com_adobe_cq_screens_com_adobe_cq_screens_mq_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-as-provider", com_adobe_cq_social_cq_social_as_provider));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-badging-basic-impl", com_adobe_cq_social_cq_social_badging_basic_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-badging-impl", com_adobe_cq_social_cq_social_badging_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-calendar-impl", com_adobe_cq_social_cq_social_calendar_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-content-fragments-impl", com_adobe_cq_social_cq_social_content_fragments_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-enablement-impl", com_adobe_cq_social_cq_social_enablement_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-graph-impl", com_adobe_cq_social_cq_social_graph_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-ideation-impl", com_adobe_cq_social_cq_social_ideation_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-jcr-provider", com_adobe_cq_social_cq_social_jcr_provider));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-members-impl", com_adobe_cq_social_cq_social_members_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-ms-provider", com_adobe_cq_social_cq_social_ms_provider));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-notifications-channels-web", com_adobe_cq_social_cq_social_notifications_channels_web));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-notifications-impl", com_adobe_cq_social_cq_social_notifications_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-rdb-provider", com_adobe_cq_social_cq_social_rdb_provider));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-scf-impl", com_adobe_cq_social_cq_social_scf_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-scoring-basic-impl", com_adobe_cq_social_cq_social_scoring_basic_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-scoring-impl", com_adobe_cq_social_cq_social_scoring_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-serviceusers-impl", com_adobe_cq_social_cq_social_serviceusers_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-srp-impl", com_adobe_cq_social_cq_social_srp_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.cq.social.cq-social-ugcbase-impl", com_adobe_cq_social_cq_social_ugcbase_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.dam.cq-dam-cfm-impl", com_adobe_dam_cq_dam_cfm_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.forms.foundation-forms-foundation-base", com_adobe_forms_foundation_forms_foundation_base));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.apicontroller", com_adobe_granite_apicontroller));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.asset.core", com_adobe_granite_asset_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.auth.sso", com_adobe_granite_auth_sso));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.bundles.hc.impl", com_adobe_granite_bundles_hc_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.compat-router", com_adobe_granite_compat_router));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.conf", com_adobe_granite_conf));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.conf.ui.core", com_adobe_granite_conf_ui_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.cors", com_adobe_granite_cors));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.crx-explorer", com_adobe_granite_crx_explorer));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.crxde-lite", com_adobe_granite_crxde_lite));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.crypto.config", com_adobe_granite_crypto_config));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.crypto.extension", com_adobe_granite_crypto_extension));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.crypto.file", com_adobe_granite_crypto_file));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.crypto.jcr", com_adobe_granite_crypto_jcr));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.csrf", com_adobe_granite_csrf));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.distribution.core", com_adobe_granite_distribution_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.dropwizard.metrics", com_adobe_granite_dropwizard_metrics));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.frags.impl", com_adobe_granite_frags_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.gibson", com_adobe_granite_gibson));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.infocollector", com_adobe_granite_infocollector));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.installer.factory.packages", com_adobe_granite_installer_factory_packages));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.jetty.ssl", com_adobe_granite_jetty_ssl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.jobs.async", com_adobe_granite_jobs_async));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.maintenance.oak", com_adobe_granite_maintenance_oak));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.monitoring.core", com_adobe_granite_monitoring_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.queries", com_adobe_granite_queries));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.replication.hc.impl", com_adobe_granite_replication_hc_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.repository.checker", com_adobe_granite_repository_checker));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.repository.hc.impl", com_adobe_granite_repository_hc_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.rest.assets", com_adobe_granite_rest_assets));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.security.ui", com_adobe_granite_security_ui));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.startup", com_adobe_granite_startup));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.tagsoup", com_adobe_granite_tagsoup));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.taskmanagement.core", com_adobe_granite_taskmanagement_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.taskmanagement.workflow", com_adobe_granite_taskmanagement_workflow));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.ui.clientlibs.compiler.less", com_adobe_granite_ui_clientlibs_compiler_less));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.ui.clientlibs.processor.gcc", com_adobe_granite_ui_clientlibs_processor_gcc));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.webconsole.plugins", com_adobe_granite_webconsole_plugins));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.workflow.console", com_adobe_granite_workflow_console));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.xmp.worker.files.native.fragment.linux", com_adobe_xmp_worker_files_native_fragment_linux));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.xmp.worker.files.native.fragment.macosx", com_adobe_xmp_worker_files_native_fragment_macosx));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.xmp.worker.files.native.fragment.win", com_adobe_xmp_worker_files_native_fragment_win));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.commons.osgi.wrapper.simple-jndi", com_day_commons_osgi_wrapper_simple_jndi));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.cq-authhandler", com_day_cq_cq_authhandler));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.cq-compat-configupdate", com_day_cq_cq_compat_configupdate));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.cq-licensebranding", com_day_cq_cq_licensebranding));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.cq-notifcation-impl", com_day_cq_cq_notifcation_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.cq-replication-audit", com_day_cq_cq_replication_audit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.cq-search-ext", com_day_cq_cq_search_ext));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.dam.cq-dam-annotation-print", com_day_cq_dam_cq_dam_annotation_print));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.dam.cq-dam-asset-usage", com_day_cq_dam_cq_dam_asset_usage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.dam.cq-dam-s7dam", com_day_cq_dam_cq_dam_s7dam));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.dam.cq-dam-similaritysearch", com_day_cq_dam_cq_dam_similaritysearch));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.dam.dam-webdav-support", com_day_cq_dam_dam_webdav_support));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.pre-upgrade-tasks", com_day_cq_pre_upgrade_tasks));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.replication.extensions", com_day_cq_replication_extensions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.wcm.cq-msm-core", com_day_cq_wcm_cq_msm_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.day.cq.wcm.cq-wcm-translation", com_day_cq_wcm_cq_wcm_translation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "day-commons-jrawio", day_commons_jrawio));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.aries.jmx.whiteboard", org_apache_aries_jmx_whiteboard));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.sslfilter", org_apache_felix_http_sslfilter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.org.apache.felix.threaddump", org_apache_felix_org_apache_felix_threaddump));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.webconsole.plugins.ds", org_apache_felix_webconsole_plugins_ds));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.webconsole.plugins.event", org_apache_felix_webconsole_plugins_event));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.webconsole.plugins.memoryusage", org_apache_felix_webconsole_plugins_memoryusage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.webconsole.plugins.packageadmin", org_apache_felix_webconsole_plugins_packageadmin));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.jackrabbit.oak-auth-ldap", org_apache_jackrabbit_oak_auth_ldap));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.jackrabbit.oak-segment-tar", org_apache_jackrabbit_oak_segment_tar));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.jackrabbit.oak-solr-osgi", org_apache_jackrabbit_oak_solr_osgi));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.bundleresource.impl", org_apache_sling_bundleresource_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.fsclassloader", org_apache_sling_commons_fsclassloader));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.webconsole", org_apache_sling_commons_log_webconsole));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.datasource", org_apache_sling_datasource));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.discovery.base", org_apache_sling_discovery_base));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.discovery.oak", org_apache_sling_discovery_oak));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.discovery.support", org_apache_sling_discovery_support));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.distribution.api", org_apache_sling_distribution_api));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.distribution.core", org_apache_sling_distribution_core));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.extensions.webconsolesecurityprovider", org_apache_sling_extensions_webconsolesecurityprovider));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.hc.webconsole", org_apache_sling_hc_webconsole));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.installer.console", org_apache_sling_installer_console));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.installer.provider.file", org_apache_sling_installer_provider_file));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.installer.provider.jcr", org_apache_sling_installer_provider_jcr));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.jcr.davex", org_apache_sling_jcr_davex));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.jcr.resourcesecurity", org_apache_sling_jcr_resourcesecurity));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.jmx.provider", org_apache_sling_jmx_provider));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.launchpad.installer", org_apache_sling_launchpad_installer));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.models.impl", org_apache_sling_models_impl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.repoinit.parser", org_apache_sling_repoinit_parser));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.resource.inventory", org_apache_sling_resource_inventory));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.resourceresolver", org_apache_sling_resourceresolver));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.scripting.javascript", org_apache_sling_scripting_javascript));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.scripting.jst", org_apache_sling_scripting_jst));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.scripting.sightly.js.provider", org_apache_sling_scripting_sightly_js_provider));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.scripting.sightly.models.provider", org_apache_sling_scripting_sightly_models_provider));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.security", org_apache_sling_security));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.servlets.compat", org_apache_sling_servlets_compat));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.servlets.get", org_apache_sling_servlets_get));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.startupfilter.disabler", org_apache_sling_startupfilter_disabler));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.tracer", org_apache_sling_tracer));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "we.retail.client.app.core", we_retail_client_app_core));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_APICONTROLLER_FILTER_RESOLVER_HOOK_FACTORY_INFO } l_response.data ({ COM_ADOBE_GRANITE_APICONTROLLER_FILTER_RESOLVER_HOOK_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_cert_impl_client_cert_auth_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path: STRING_32; service_ranking: INTEGER_32): detachable COM_ADOBE_GRANITE_AUTH_CERT_IMPL_CLIENT_CERT_AUTH_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_CERT_IMPL_CLIENT_CERT_AUTH_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.cert.impl.ClientCertAuthHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_CERT_IMPL_CLIENT_CERT_AUTH_HANDLER_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_CERT_IMPL_CLIENT_CERT_AUTH_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_ims (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; configid: STRING_32; scope: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_IMS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: configid  (optional)
			-- 
			-- argument: scope  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_IMS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.ims"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "configid", configid));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scope", scope));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_IMS_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_IMS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_ims_impl_external_user_id_mapping_provider_extension (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_provider_id: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_IMS_IMPL_EXTERNAL_USER_ID_MAPPING_PROVIDER_EXTENSION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_provider_id  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_IMS_IMPL_EXTERNAL_USER_ID_MAPPING_PROVIDER_EXTENSION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.ims.impl.ExternalUserIdMappingProviderExtension"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.id", oauth_provider_id));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_IMS_IMPL_EXTERNAL_USER_ID_MAPPING_PROVIDER_EXTENSION_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_IMS_IMPL_EXTERNAL_USER_ID_MAPPING_PROVIDER_EXTENSION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_ims_impl_im_saccess_token_request_customizer_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; auth_ims_client_secret: STRING_32; customizer_type: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_ACCESS_TOKEN_REQUEST_CUSTOMIZER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: auth_ims_client_secret  (optional)
			-- 
			-- argument: customizer_type  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_ACCESS_TOKEN_REQUEST_CUSTOMIZER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSAccessTokenRequestCustomizerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.ims.client.secret", auth_ims_client_secret));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "customizer.type", customizer_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_ACCESS_TOKEN_REQUEST_CUSTOMIZER_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_ACCESS_TOKEN_REQUEST_CUSTOMIZER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_ims_impl_im_sinstance_credentials_validator (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_provider_id: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_INSTANCE_CREDENTIALS_VALIDATOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_provider_id  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_INSTANCE_CREDENTIALS_VALIDATOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSInstanceCredentialsValidator"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.id", oauth_provider_id));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_INSTANCE_CREDENTIALS_VALIDATOR_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_INSTANCE_CREDENTIALS_VALIDATOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_ims_impl_im_sprovider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_provider_id: STRING_32; oauth_provider_ims_authorization_url: STRING_32; oauth_provider_ims_token_url: STRING_32; oauth_provider_ims_profile_url: STRING_32; oauth_provider_ims_extended_details_urls: detachable LIST [STRING_32]; oauth_provider_ims_validate_token_url: STRING_32; oauth_provider_ims_session_property: STRING_32; oauth_provider_ims_service_token_client_id: STRING_32; oauth_provider_ims_service_token_client_secret: STRING_32; oauth_provider_ims_service_token: STRING_32; ims_org_ref: STRING_32; ims_group_mapping: detachable LIST [STRING_32]; oauth_provider_ims_only_license_group: BOOLEAN): detachable COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_provider_id  (optional)
			-- 
			-- argument: oauth_provider_ims_authorization_url  (optional)
			-- 
			-- argument: oauth_provider_ims_token_url  (optional)
			-- 
			-- argument: oauth_provider_ims_profile_url  (optional)
			-- 
			-- argument: oauth_provider_ims_extended_details_urls  (optional)
			-- 
			-- argument: oauth_provider_ims_validate_token_url  (optional)
			-- 
			-- argument: oauth_provider_ims_session_property  (optional)
			-- 
			-- argument: oauth_provider_ims_service_token_client_id  (optional)
			-- 
			-- argument: oauth_provider_ims_service_token_client_secret  (optional)
			-- 
			-- argument: oauth_provider_ims_service_token  (optional)
			-- 
			-- argument: ims_org_ref  (optional)
			-- 
			-- argument: ims_group_mapping  (optional)
			-- 
			-- argument: oauth_provider_ims_only_license_group  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.id", oauth_provider_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.ims.authorization.url", oauth_provider_ims_authorization_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.ims.token.url", oauth_provider_ims_token_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.ims.profile.url", oauth_provider_ims_profile_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "oauth.provider.ims.extended.details.urls", oauth_provider_ims_extended_details_urls));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.ims.validate.token.url", oauth_provider_ims_validate_token_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.ims.session.property", oauth_provider_ims_session_property));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.ims.service.token.client.id", oauth_provider_ims_service_token_client_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.ims.service.token.client.secret", oauth_provider_ims_service_token_client_secret));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.ims.service.token", oauth_provider_ims_service_token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ims.org.ref", ims_org_ref));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "ims.group.mapping", ims_group_mapping));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.ims.only.license.group", oauth_provider_ims_only_license_group));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_PROVIDER_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_ims_impl_ims_config_provider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_configmanager_ims_configid: STRING_32; ims_owning_entity: STRING_32; aem_instance_id: STRING_32; ims_service_code: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_CONFIG_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_configmanager_ims_configid  (optional)
			-- 
			-- argument: ims_owning_entity  (optional)
			-- 
			-- argument: aem_instance_id  (optional)
			-- 
			-- argument: ims_service_code  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_CONFIG_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.ims.impl.ImsConfigProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.configmanager.ims.configid", oauth_configmanager_ims_configid));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ims.owningEntity", ims_owning_entity));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "aem.instanceId", aem_instance_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ims.serviceCode", ims_service_code));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_CONFIG_PROVIDER_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_IMS_IMPL_IMS_CONFIG_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_oauth_accesstoken_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; auth_token_provider_title: STRING_32; auth_token_provider_default_claims: detachable LIST [STRING_32]; auth_token_provider_endpoint: STRING_32; auth_access_token_request: STRING_32; auth_token_provider_keypair_alias: STRING_32; auth_token_provider_conn_timeout: INTEGER_32; auth_token_provider_so_timeout: INTEGER_32; auth_token_provider_client_id: STRING_32; auth_token_provider_scope: STRING_32; auth_token_provider_reuse_access_token: BOOLEAN; auth_token_provider_relaxed_ssl: BOOLEAN; token_request_customizer_type: STRING_32; auth_token_validator_type: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_OAUTH_ACCESSTOKEN_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: auth_token_provider_title  (optional)
			-- 
			-- argument: auth_token_provider_default_claims  (optional)
			-- 
			-- argument: auth_token_provider_endpoint  (optional)
			-- 
			-- argument: auth_access_token_request  (optional)
			-- 
			-- argument: auth_token_provider_keypair_alias  (optional)
			-- 
			-- argument: auth_token_provider_conn_timeout  (optional)
			-- 
			-- argument: auth_token_provider_so_timeout  (optional)
			-- 
			-- argument: auth_token_provider_client_id  (optional)
			-- 
			-- argument: auth_token_provider_scope  (optional)
			-- 
			-- argument: auth_token_provider_reuse_access_token  (optional)
			-- 
			-- argument: auth_token_provider_relaxed_ssl  (optional)
			-- 
			-- argument: token_request_customizer_type  (optional)
			-- 
			-- argument: auth_token_validator_type  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_OAUTH_ACCESSTOKEN_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.oauth.accesstoken.provider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.token.provider.title", auth_token_provider_title));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "auth.token.provider.default.claims", auth_token_provider_default_claims));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.token.provider.endpoint", auth_token_provider_endpoint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.access.token.request", auth_access_token_request));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.token.provider.keypair.alias", auth_token_provider_keypair_alias));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.token.provider.conn.timeout", auth_token_provider_conn_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.token.provider.so.timeout", auth_token_provider_so_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.token.provider.client.id", auth_token_provider_client_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.token.provider.scope", auth_token_provider_scope));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.token.provider.reuse.access.token", auth_token_provider_reuse_access_token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.token.provider.relaxed.ssl", auth_token_provider_relaxed_ssl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token.request.customizer.type", token_request_customizer_type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.token.validator.type", auth_token_validator_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_OAUTH_ACCESSTOKEN_PROVIDER_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_OAUTH_ACCESSTOKEN_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_oauth_impl_bearer_authentication_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path: STRING_32; oauth_client_ids_allowed: detachable LIST [STRING_32]; auth_bearer_sync_ims: BOOLEAN; auth_token_request_parameter: STRING_32; oauth_bearer_configid: STRING_32; oauth_jwt_support: BOOLEAN): detachable COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_BEARER_AUTHENTICATION_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: oauth_client_ids_allowed  (optional)
			-- 
			-- argument: auth_bearer_sync_ims  (optional)
			-- 
			-- argument: auth_token_request_parameter  (optional)
			-- 
			-- argument: oauth_bearer_configid  (optional)
			-- 
			-- argument: oauth_jwt_support  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_BEARER_AUTHENTICATION_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.BearerAuthenticationHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "oauth.clientIds.allowed", oauth_client_ids_allowed));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.bearer.sync.ims", auth_bearer_sync_ims));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.tokenRequestParameter", auth_token_request_parameter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.bearer.configid", oauth_bearer_configid));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.jwt.support", oauth_jwt_support));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_BEARER_AUTHENTICATION_HANDLER_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_BEARER_AUTHENTICATION_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_oauth_impl_default_token_validator_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; auth_token_validator_type: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_DEFAULT_TOKEN_VALIDATOR_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: auth_token_validator_type  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_DEFAULT_TOKEN_VALIDATOR_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.DefaultTokenValidatorImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.token.validator.type", auth_token_validator_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_DEFAULT_TOKEN_VALIDATOR_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_DEFAULT_TOKEN_VALIDATOR_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_oauth_impl_facebook_provider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_provider_id: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_FACEBOOK_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_provider_id  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_FACEBOOK_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.FacebookProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.id", oauth_provider_id));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_FACEBOOK_PROVIDER_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_FACEBOOK_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_oauth_impl_github_provider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_provider_id: STRING_32; oauth_provider_github_authorization_url: STRING_32; oauth_provider_github_token_url: STRING_32; oauth_provider_github_profile_url: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_GITHUB_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_provider_id  (optional)
			-- 
			-- argument: oauth_provider_github_authorization_url  (optional)
			-- 
			-- argument: oauth_provider_github_token_url  (optional)
			-- 
			-- argument: oauth_provider_github_profile_url  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_GITHUB_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.GithubProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.id", oauth_provider_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.github.authorization.url", oauth_provider_github_authorization_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.github.token.url", oauth_provider_github_token_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.github.profile.url", oauth_provider_github_profile_url));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_GITHUB_PROVIDER_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_GITHUB_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_oauth_impl_granite_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_provider_id: STRING_32; oauth_provider_granite_authorization_url: STRING_32; oauth_provider_granite_token_url: STRING_32; oauth_provider_granite_profile_url: STRING_32; oauth_provider_granite_extended_details_urls: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_GRANITE_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_provider_id  (optional)
			-- 
			-- argument: oauth_provider_granite_authorization_url  (optional)
			-- 
			-- argument: oauth_provider_granite_token_url  (optional)
			-- 
			-- argument: oauth_provider_granite_profile_url  (optional)
			-- 
			-- argument: oauth_provider_granite_extended_details_urls  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_GRANITE_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.GraniteProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.id", oauth_provider_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.granite.authorization.url", oauth_provider_granite_authorization_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.granite.token.url", oauth_provider_granite_token_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.granite.profile.url", oauth_provider_granite_profile_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.granite.extended.details.urls", oauth_provider_granite_extended_details_urls));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_GRANITE_PROVIDER_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_GRANITE_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_oauth_impl_helper_provider_config_manager (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_cookie_login_timeout: STRING_32; oauth_cookie_max_age: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_HELPER_PROVIDER_CONFIG_MANAGER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_cookie_login_timeout  (optional)
			-- 
			-- argument: oauth_cookie_max_age  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_HELPER_PROVIDER_CONFIG_MANAGER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.helper.ProviderConfigManager"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.cookie.login.timeout", oauth_cookie_login_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.cookie.max.age", oauth_cookie_max_age));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_HELPER_PROVIDER_CONFIG_MANAGER_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_HELPER_PROVIDER_CONFIG_MANAGER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_oauth_impl_helper_provider_config_manager_internal (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_cookie_login_timeout: STRING_32; oauth_cookie_max_age: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_HELPER_PROVIDER_CONFIG_MANAGER_INTERNAL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_cookie_login_timeout  (optional)
			-- 
			-- argument: oauth_cookie_max_age  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_HELPER_PROVIDER_CONFIG_MANAGER_INTERNAL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.helper.ProviderConfigManagerInternal"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.cookie.login.timeout", oauth_cookie_login_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.cookie.max.age", oauth_cookie_max_age));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_HELPER_PROVIDER_CONFIG_MANAGER_INTERNAL_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_HELPER_PROVIDER_CONFIG_MANAGER_INTERNAL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_oauth_impl_oauth_authentication_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_O_AUTH_AUTHENTICATION_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_O_AUTH_AUTHENTICATION_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.OAuthAuthenticationHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_O_AUTH_AUTHENTICATION_HANDLER_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_O_AUTH_AUTHENTICATION_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_oauth_impl_twitter_provider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_provider_id: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_TWITTER_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_provider_id  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_TWITTER_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.TwitterProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.provider.id", oauth_provider_id));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_TWITTER_PROVIDER_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_OAUTH_IMPL_TWITTER_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_oauth_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_config_id: STRING_32; oauth_client_id: STRING_32; oauth_client_secret: STRING_32; oauth_scope: detachable LIST [STRING_32]; oauth_config_provider_id: STRING_32; oauth_create_users: BOOLEAN; oauth_userid_property: STRING_32; force_strict_username_matching: BOOLEAN; oauth_encode_userids: BOOLEAN; oauth_hash_userids: BOOLEAN; oauth_call_back_url: STRING_32; oauth_access_token_persist: BOOLEAN; oauth_access_token_persist_cookie: BOOLEAN; oauth_csrf_state_protection: BOOLEAN; oauth_redirect_request_params: BOOLEAN; oauth_config_siblings_allow: BOOLEAN): detachable COM_ADOBE_GRANITE_AUTH_OAUTH_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_config_id  (optional)
			-- 
			-- argument: oauth_client_id  (optional)
			-- 
			-- argument: oauth_client_secret  (optional)
			-- 
			-- argument: oauth_scope  (optional)
			-- 
			-- argument: oauth_config_provider_id  (optional)
			-- 
			-- argument: oauth_create_users  (optional)
			-- 
			-- argument: oauth_userid_property  (optional)
			-- 
			-- argument: force_strict_username_matching  (optional)
			-- 
			-- argument: oauth_encode_userids  (optional)
			-- 
			-- argument: oauth_hash_userids  (optional)
			-- 
			-- argument: oauth_call_back_url  (optional)
			-- 
			-- argument: oauth_access_token_persist  (optional)
			-- 
			-- argument: oauth_access_token_persist_cookie  (optional)
			-- 
			-- argument: oauth_csrf_state_protection  (optional)
			-- 
			-- argument: oauth_redirect_request_params  (optional)
			-- 
			-- argument: oauth_config_siblings_allow  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_OAUTH_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.oauth.provider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.config.id", oauth_config_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.client.id", oauth_client_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.client.secret", oauth_client_secret));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "oauth.scope", oauth_scope));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.config.provider.id", oauth_config_provider_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.create.users", oauth_create_users));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.userid.property", oauth_userid_property));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "force.strict.username.matching", force_strict_username_matching));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.encode.userids", oauth_encode_userids));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.hash.userids", oauth_hash_userids));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.callBackUrl", oauth_call_back_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.access.token.persist", oauth_access_token_persist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.access.token.persist.cookie", oauth_access_token_persist_cookie));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.csrf.state.protection", oauth_csrf_state_protection));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.redirect.request.params", oauth_redirect_request_params));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.config.siblings.allow", oauth_config_siblings_allow));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_OAUTH_PROVIDER_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_OAUTH_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_requirement_impl_default_requirement_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; supported_paths: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_AUTH_REQUIREMENT_IMPL_DEFAULT_REQUIREMENT_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: supported_paths  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_REQUIREMENT_IMPL_DEFAULT_REQUIREMENT_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.requirement.impl.DefaultRequirementHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "supportedPaths", supported_paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_REQUIREMENT_IMPL_DEFAULT_REQUIREMENT_HANDLER_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_REQUIREMENT_IMPL_DEFAULT_REQUIREMENT_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_saml_saml_authentication_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path: detachable LIST [STRING_32]; service_ranking: INTEGER_32; idp_url: STRING_32; idp_cert_alias: STRING_32; idp_http_redirect: BOOLEAN; service_provider_entity_id: STRING_32; assertion_consumer_service_ur_l: STRING_32; sp_private_key_alias: STRING_32; key_store_password: STRING_32; default_redirect_url: STRING_32; user_id_attribute: STRING_32; use_encryption: BOOLEAN; create_user: BOOLEAN; user_intermediate_path: STRING_32; add_group_memberships: BOOLEAN; group_membership_attribute: STRING_32; default_groups: detachable LIST [STRING_32]; name_id_format: STRING_32; synchronize_attributes: detachable LIST [STRING_32]; handle_logout: BOOLEAN; logout_url: STRING_32; clock_tolerance: INTEGER_32; digest_method: STRING_32; signature_method: STRING_32; identity_sync_type: STRING_32; idp_identifier: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_SAML_SAML_AUTHENTICATION_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: idp_url  (optional)
			-- 
			-- argument: idp_cert_alias  (optional)
			-- 
			-- argument: idp_http_redirect  (optional)
			-- 
			-- argument: service_provider_entity_id  (optional)
			-- 
			-- argument: assertion_consumer_service_ur_l  (optional)
			-- 
			-- argument: sp_private_key_alias  (optional)
			-- 
			-- argument: key_store_password  (optional)
			-- 
			-- argument: default_redirect_url  (optional)
			-- 
			-- argument: user_id_attribute  (optional)
			-- 
			-- argument: use_encryption  (optional)
			-- 
			-- argument: create_user  (optional)
			-- 
			-- argument: user_intermediate_path  (optional)
			-- 
			-- argument: add_group_memberships  (optional)
			-- 
			-- argument: group_membership_attribute  (optional)
			-- 
			-- argument: default_groups  (optional)
			-- 
			-- argument: name_id_format  (optional)
			-- 
			-- argument: synchronize_attributes  (optional)
			-- 
			-- argument: handle_logout  (optional)
			-- 
			-- argument: logout_url  (optional)
			-- 
			-- argument: clock_tolerance  (optional)
			-- 
			-- argument: digest_method  (optional)
			-- 
			-- argument: signature_method  (optional)
			-- 
			-- argument: identity_sync_type  (optional)
			-- 
			-- argument: idp_identifier  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_SAML_SAML_AUTHENTICATION_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "idpUrl", idp_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "idpCertAlias", idp_cert_alias));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "idpHttpRedirect", idp_http_redirect));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceProviderEntityId", service_provider_entity_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "assertionConsumerServiceURL", assertion_consumer_service_ur_l));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "spPrivateKeyAlias", sp_private_key_alias));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "keyStorePassword", key_store_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultRedirectUrl", default_redirect_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "userIDAttribute", user_id_attribute));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "useEncryption", use_encryption));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "createUser", create_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "userIntermediatePath", user_intermediate_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "addGroupMemberships", add_group_memberships));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "groupMembershipAttribute", group_membership_attribute));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "defaultGroups", default_groups));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "nameIdFormat", name_id_format));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "synchronizeAttributes", synchronize_attributes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "handleLogout", handle_logout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "logoutUrl", logout_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "clockTolerance", clock_tolerance));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "digestMethod", digest_method));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "signatureMethod", signature_method));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "identitySyncType", identity_sync_type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "idpIdentifier", idp_identifier));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_SAML_SAML_AUTHENTICATION_HANDLER_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_SAML_SAML_AUTHENTICATION_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_auth_sso_impl_sso_authentication_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path: STRING_32; service_ranking: INTEGER_32; jaas_control_flag: STRING_32; jaas_realm_name: STRING_32; jaas_ranking: INTEGER_32; headers: detachable LIST [STRING_32]; cookies: detachable LIST [STRING_32]; parameters: detachable LIST [STRING_32]; usermap: detachable LIST [STRING_32]; format: STRING_32; trusted_credentials_attribute: STRING_32): detachable COM_ADOBE_GRANITE_AUTH_SSO_IMPL_SSO_AUTHENTICATION_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: jaas_control_flag  (optional)
			-- 
			-- argument: jaas_realm_name  (optional)
			-- 
			-- argument: jaas_ranking  (optional)
			-- 
			-- argument: headers  (optional)
			-- 
			-- argument: cookies  (optional)
			-- 
			-- argument: parameters  (optional)
			-- 
			-- argument: usermap  (optional)
			-- 
			-- argument: format  (optional)
			-- 
			-- argument: trusted_credentials_attribute  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_AUTH_SSO_IMPL_SSO_AUTHENTICATION_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.auth.sso.impl.SsoAuthenticationHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.controlFlag", jaas_control_flag));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.realmName", jaas_realm_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.ranking", jaas_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "headers", headers));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cookies", cookies));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "parameters", parameters));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "usermap", usermap));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "format", format));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "trustedCredentialsAttribute", trusted_credentials_attribute));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_AUTH_SSO_IMPL_SSO_AUTHENTICATION_HANDLER_INFO } l_response.data ({ COM_ADOBE_GRANITE_AUTH_SSO_IMPL_SSO_AUTHENTICATION_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_bundles_hc_impl_code_cache_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]; minimum_code_cache_size: INTEGER_32): detachable COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_CODE_CACHE_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: minimum_code_cache_size  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_CODE_CACHE_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.CodeCacheHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "minimum.code.cache.size", minimum_code_cache_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_CODE_CACHE_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_CODE_CACHE_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_bundles_hc_impl_crxde_support_bundle_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_CRXDE_SUPPORT_BUNDLE_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_CRXDE_SUPPORT_BUNDLE_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.CrxdeSupportBundleHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_CRXDE_SUPPORT_BUNDLE_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_CRXDE_SUPPORT_BUNDLE_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_bundles_hc_impl_dav_ex_bundle_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_DAV_EX_BUNDLE_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_DAV_EX_BUNDLE_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.DavExBundleHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_DAV_EX_BUNDLE_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_DAV_EX_BUNDLE_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_bundles_hc_impl_inactive_bundles_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]; ignored_bundles: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_INACTIVE_BUNDLES_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: ignored_bundles  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_INACTIVE_BUNDLES_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.InactiveBundlesHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "ignored.bundles", ignored_bundles));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_INACTIVE_BUNDLES_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_INACTIVE_BUNDLES_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_bundles_hc_impl_jobs_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]; max_queued_jobs: INTEGER_32): detachable COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_JOBS_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: max_queued_jobs  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_JOBS_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.JobsHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "max.queued.jobs", max_queued_jobs));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_JOBS_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_JOBS_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_bundles_hc_impl_sling_get_servlet_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_GET_SERVLET_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_GET_SERVLET_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingGetServletHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_GET_SERVLET_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_GET_SERVLET_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_bundles_hc_impl_sling_java_script_handler_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_JAVA_SCRIPT_HANDLER_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_JAVA_SCRIPT_HANDLER_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingJavaScriptHandlerHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_JAVA_SCRIPT_HANDLER_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_JAVA_SCRIPT_HANDLER_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_bundles_hc_impl_sling_jsp_script_handler_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_JSP_SCRIPT_HANDLER_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_JSP_SCRIPT_HANDLER_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingJspScriptHandlerHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_JSP_SCRIPT_HANDLER_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_JSP_SCRIPT_HANDLER_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_bundles_hc_impl_sling_referrer_filter_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_REFERRER_FILTER_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_REFERRER_FILTER_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingReferrerFilterHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_REFERRER_FILTER_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_SLING_REFERRER_FILTER_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_bundles_hc_impl_web_dav_bundle_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_WEB_DAV_BUNDLE_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_WEB_DAV_BUNDLE_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.WebDavBundleHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_WEB_DAV_BUNDLE_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_BUNDLES_HC_IMPL_WEB_DAV_BUNDLE_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_comments_internal_comment_replication_content_filter_fac (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; replicate_comment_resource_types: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_COMMENTS_INTERNAL_COMMENT_REPLICATION_CONTENT_FILTER_FAC_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: replicate_comment_resource_types  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_COMMENTS_INTERNAL_COMMENT_REPLICATION_CONTENT_FILTER_FAC_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.comments.internal.CommentReplicationContentFilterFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "replicate.comment.resourceTypes", replicate_comment_resource_types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_COMMENTS_INTERNAL_COMMENT_REPLICATION_CONTENT_FILTER_FAC_INFO } l_response.data ({ COM_ADOBE_GRANITE_COMMENTS_INTERNAL_COMMENT_REPLICATION_CONTENT_FILTER_FAC_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_compatrouter_impl_compat_switching_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; compatgroups: detachable LIST [STRING_32]; enabled: BOOLEAN): detachable COM_ADOBE_GRANITE_COMPATROUTER_IMPL_COMPAT_SWITCHING_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: compatgroups  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_COMPATROUTER_IMPL_COMPAT_SWITCHING_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.compatrouter.impl.CompatSwitchingServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "compatgroups", compatgroups));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_COMPATROUTER_IMPL_COMPAT_SWITCHING_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_COMPATROUTER_IMPL_COMPAT_SWITCHING_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_compatrouter_impl_routing_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; id: STRING_32; compat_path: STRING_32; new_path: STRING_32): detachable COM_ADOBE_GRANITE_COMPATROUTER_IMPL_ROUTING_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: id  (optional)
			-- 
			-- argument: compat_path  (optional)
			-- 
			-- argument: new_path  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_COMPATROUTER_IMPL_ROUTING_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.compatrouter.impl.RoutingConfig"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compatPath", compat_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "newPath", new_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_COMPATROUTER_IMPL_ROUTING_CONFIG_INFO } l_response.data ({ COM_ADOBE_GRANITE_COMPATROUTER_IMPL_ROUTING_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_compatrouter_impl_switch_mapping_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; group: STRING_32; ids: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_COMPATROUTER_IMPL_SWITCH_MAPPING_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: group  (optional)
			-- 
			-- argument: ids  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_COMPATROUTER_IMPL_SWITCH_MAPPING_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.compatrouter.impl.SwitchMappingConfig"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "group", group));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "ids", ids));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_COMPATROUTER_IMPL_SWITCH_MAPPING_CONFIG_INFO } l_response.data ({ COM_ADOBE_GRANITE_COMPATROUTER_IMPL_SWITCH_MAPPING_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_conf_impl_runtime_aware_configuration_resource_resolving (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN; fallback_paths: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_CONF_IMPL_RUNTIME_AWARE_CONFIGURATION_RESOURCE_RESOLVING_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: fallback_paths  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_CONF_IMPL_RUNTIME_AWARE_CONFIGURATION_RESOURCE_RESOLVING_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.conf.impl.RuntimeAwareConfigurationResourceResolvingStrategy"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fallbackPaths", fallback_paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_CONF_IMPL_RUNTIME_AWARE_CONFIGURATION_RESOURCE_RESOLVING_INFO } l_response.data ({ COM_ADOBE_GRANITE_CONF_IMPL_RUNTIME_AWARE_CONFIGURATION_RESOURCE_RESOLVING_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_contexthub_impl_context_hub_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_adobe_granite_contexthub_silent_mode: BOOLEAN; com_adobe_granite_contexthub_show_ui: BOOLEAN): detachable COM_ADOBE_GRANITE_CONTEXTHUB_IMPL_CONTEXT_HUB_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_adobe_granite_contexthub_silent_mode  (optional)
			-- 
			-- argument: com_adobe_granite_contexthub_show_ui  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_CONTEXTHUB_IMPL_CONTEXT_HUB_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.contexthub.impl.ContextHubImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.contexthub.silent_mode", com_adobe_granite_contexthub_silent_mode));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.contexthub.show_ui", com_adobe_granite_contexthub_show_ui));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_CONTEXTHUB_IMPL_CONTEXT_HUB_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_CONTEXTHUB_IMPL_CONTEXT_HUB_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_cors_impl_co_rs_policy_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; alloworigin: detachable LIST [STRING_32]; alloworiginregexp: detachable LIST [STRING_32]; allowedpaths: detachable LIST [STRING_32]; exposedheaders: detachable LIST [STRING_32]; maxage: INTEGER_32; supportedheaders: detachable LIST [STRING_32]; supportedmethods: detachable LIST [STRING_32]; supportscredentials: BOOLEAN): detachable COM_ADOBE_GRANITE_CORS_IMPL_CORS_POLICY_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: alloworigin  (optional)
			-- 
			-- argument: alloworiginregexp  (optional)
			-- 
			-- argument: allowedpaths  (optional)
			-- 
			-- argument: exposedheaders  (optional)
			-- 
			-- argument: maxage  (optional)
			-- 
			-- argument: supportedheaders  (optional)
			-- 
			-- argument: supportedmethods  (optional)
			-- 
			-- argument: supportscredentials  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_CORS_IMPL_CORS_POLICY_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.cors.impl.CORSPolicyImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "alloworigin", alloworigin));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "alloworiginregexp", alloworiginregexp));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "allowedpaths", allowedpaths));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "exposedheaders", exposedheaders));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxage", maxage));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "supportedheaders", supportedheaders));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "supportedmethods", supportedmethods));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "supportscredentials", supportscredentials));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_CORS_IMPL_CORS_POLICY_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_CORS_IMPL_CORS_POLICY_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_csrf_impl_cs_rf_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; filter_methods: detachable LIST [STRING_32]; filter_enable_safe_user_agents: BOOLEAN; filter_safe_user_agents: detachable LIST [STRING_32]; filter_excluded_paths: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_CSRF_IMPL_CSRF_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: filter_methods  (optional)
			-- 
			-- argument: filter_enable_safe_user_agents  (optional)
			-- 
			-- argument: filter_safe_user_agents  (optional)
			-- 
			-- argument: filter_excluded_paths  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_CSRF_IMPL_CSRF_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.csrf.impl.CSRFFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "filter.methods", filter_methods));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter.enable.safe.user.agents", filter_enable_safe_user_agents));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "filter.safe.user.agents", filter_safe_user_agents));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "filter.excluded.paths", filter_excluded_paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_CSRF_IMPL_CSRF_FILTER_INFO } l_response.data ({ COM_ADOBE_GRANITE_CSRF_IMPL_CSRF_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_csrf_impl_cs_rf_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; csrf_token_expires_in: INTEGER_32; sling_auth_requirements: STRING_32): detachable COM_ADOBE_GRANITE_CSRF_IMPL_CSRF_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: csrf_token_expires_in  (optional)
			-- 
			-- argument: sling_auth_requirements  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_CSRF_IMPL_CSRF_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.csrf.impl.CSRFServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "csrf.token.expires.in", csrf_token_expires_in));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.auth.requirements", sling_auth_requirements));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_CSRF_IMPL_CSRF_SERVLET_INFO } l_response.data ({ COM_ADOBE_GRANITE_CSRF_IMPL_CSRF_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_distribution_core_impl_crypto_distribution_transport_se (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; username: STRING_32; encrypted_password: STRING_32): detachable COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_CRYPTO_DISTRIBUTION_TRANSPORT_SE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: username  (optional)
			-- 
			-- argument: encrypted_password  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_CRYPTO_DISTRIBUTION_TRANSPORT_SE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.distribution.core.impl.CryptoDistributionTransportSecretProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "username", username));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "encryptedPassword", encrypted_password));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_CRYPTO_DISTRIBUTION_TRANSPORT_SE_INFO } l_response.data ({ COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_CRYPTO_DISTRIBUTION_TRANSPORT_SE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_distribution_core_impl_diff_diff_changes_observer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN; agent_name: STRING_32; diff_path: STRING_32; observed_path: STRING_32; service_name: STRING_32; property_names: STRING_32; distribution_delay: INTEGER_32; service_user_target: STRING_32): detachable COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_DIFF_DIFF_CHANGES_OBSERVER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: agent_name  (optional)
			-- 
			-- argument: diff_path  (optional)
			-- 
			-- argument: observed_path  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- argument: property_names  (optional)
			-- 
			-- argument: distribution_delay  (optional)
			-- 
			-- argument: service_user_target  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_DIFF_DIFF_CHANGES_OBSERVER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.distribution.core.impl.diff.DiffChangesObserver"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "agentName", agent_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "diffPath", diff_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "observedPath", observed_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceName", service_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "propertyNames", property_names));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "distributionDelay", distribution_delay));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceUser.target", service_user_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_DIFF_DIFF_CHANGES_OBSERVER_INFO } l_response.data ({ COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_DIFF_DIFF_CHANGES_OBSERVER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_distribution_core_impl_diff_diff_event_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; diff_path: STRING_32; service_name: STRING_32; service_user_target: STRING_32): detachable COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_DIFF_DIFF_EVENT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: diff_path  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- argument: service_user_target  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_DIFF_DIFF_EVENT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.distribution.core.impl.diff.DiffEventListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "diffPath", diff_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceName", service_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceUser.target", service_user_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_DIFF_DIFF_EVENT_LISTENER_INFO } l_response.data ({ COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_DIFF_DIFF_EVENT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_distribution_core_impl_distribution_to_replication_even (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; importer_name: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_DISTRIBUTION_TO_REPLICATION_EVEN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: importer_name  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_DISTRIBUTION_TO_REPLICATION_EVEN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.distribution.core.impl.DistributionToReplicationEventTransformer"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "importer.name", importer_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_DISTRIBUTION_TO_REPLICATION_EVEN_INFO } l_response.data ({ COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_DISTRIBUTION_TO_REPLICATION_EVEN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_distribution_core_impl_replication_adapters_replicat (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; provider_name: STRING_32; forward_requests: BOOLEAN): detachable COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_REPLICATION_ADAPTERS_REPLICAT_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: provider_name  (optional)
			-- 
			-- argument: forward_requests  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_REPLICATION_ADAPTERS_REPLICAT_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.distribution.core.impl.replication.adapters.ReplicationAgentProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "providerName", provider_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "forward.requests", forward_requests));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_REPLICATION_ADAPTERS_REPLICAT_INFO } l_response.data ({ COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_REPLICATION_ADAPTERS_REPLICAT_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_distribution_core_impl_replication_distribution_trans (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; forward_requests: BOOLEAN): detachable COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_REPLICATION_DISTRIBUTION_TRANS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: forward_requests  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_REPLICATION_DISTRIBUTION_TRANS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.distribution.core.impl.replication.DistributionTransportHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "forward.requests", forward_requests));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_REPLICATION_DISTRIBUTION_TRANS_INFO } l_response.data ({ COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_REPLICATION_DISTRIBUTION_TRANS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_distribution_core_impl_transport_access_token_distribu (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; service_name: STRING_32; user_id: STRING_32; access_token_provider_target: STRING_32): detachable COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_TRANSPORT_ACCESS_TOKEN_DISTRIBU_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- argument: user_id  (optional)
			-- 
			-- argument: access_token_provider_target  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_TRANSPORT_ACCESS_TOKEN_DISTRIBU_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.distribution.core.impl.transport.AccessTokenDistributionTransportSecretProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceName", service_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "userId", user_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "accessTokenProvider.target", access_token_provider_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_TRANSPORT_ACCESS_TOKEN_DISTRIBU_INFO } l_response.data ({ COM_ADOBE_GRANITE_DISTRIBUTION_CORE_IMPL_TRANSPORT_ACCESS_TOKEN_DISTRIBU_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_frags_impl_check_http_header_flag (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; feature_name: STRING_32; feature_description: STRING_32; http_header_name: STRING_32; http_header_valuepattern: STRING_32): detachable COM_ADOBE_GRANITE_FRAGS_IMPL_CHECK_HTTP_HEADER_FLAG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: feature_name  (optional)
			-- 
			-- argument: feature_description  (optional)
			-- 
			-- argument: http_header_name  (optional)
			-- 
			-- argument: http_header_valuepattern  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_FRAGS_IMPL_CHECK_HTTP_HEADER_FLAG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.frags.impl.CheckHttpHeaderFlag"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "feature.name", feature_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "feature.description", feature_description));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "http.header.name", http_header_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "http.header.valuepattern", http_header_valuepattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_FRAGS_IMPL_CHECK_HTTP_HEADER_FLAG_INFO } l_response.data ({ COM_ADOBE_GRANITE_FRAGS_IMPL_CHECK_HTTP_HEADER_FLAG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_frags_impl_random_feature (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; feature_name: STRING_32; feature_description: STRING_32; active_percentage: STRING_32; cookie_name: STRING_32; cookie_max_age: INTEGER_32): detachable COM_ADOBE_GRANITE_FRAGS_IMPL_RANDOM_FEATURE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: feature_name  (optional)
			-- 
			-- argument: feature_description  (optional)
			-- 
			-- argument: active_percentage  (optional)
			-- 
			-- argument: cookie_name  (optional)
			-- 
			-- argument: cookie_max_age  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_FRAGS_IMPL_RANDOM_FEATURE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.frags.impl.RandomFeature"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "feature.name", feature_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "feature.description", feature_description));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "active.percentage", active_percentage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cookie.name", cookie_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cookie.maxAge", cookie_max_age));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_FRAGS_IMPL_RANDOM_FEATURE_INFO } l_response.data ({ COM_ADOBE_GRANITE_FRAGS_IMPL_RANDOM_FEATURE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_httpcache_file_file_cache_store (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_adobe_granite_httpcache_file_document_root: STRING_32; com_adobe_granite_httpcache_file_include_host: STRING_32): detachable COM_ADOBE_GRANITE_HTTPCACHE_FILE_FILE_CACHE_STORE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_adobe_granite_httpcache_file_document_root  (optional)
			-- 
			-- argument: com_adobe_granite_httpcache_file_include_host  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_HTTPCACHE_FILE_FILE_CACHE_STORE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.httpcache.file.FileCacheStore"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.httpcache.file.documentRoot", com_adobe_granite_httpcache_file_document_root));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.httpcache.file.includeHost", com_adobe_granite_httpcache_file_include_host));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_HTTPCACHE_FILE_FILE_CACHE_STORE_INFO } l_response.data ({ COM_ADOBE_GRANITE_HTTPCACHE_FILE_FILE_CACHE_STORE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_httpcache_impl_outer_cache_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_adobe_granite_httpcache_url_paths: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_HTTPCACHE_IMPL_OUTER_CACHE_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_adobe_granite_httpcache_url_paths  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_HTTPCACHE_IMPL_OUTER_CACHE_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.httpcache.impl.OuterCacheFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "com.adobe.granite.httpcache.url.paths", com_adobe_granite_httpcache_url_paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_HTTPCACHE_IMPL_OUTER_CACHE_FILTER_INFO } l_response.data ({ COM_ADOBE_GRANITE_HTTPCACHE_IMPL_OUTER_CACHE_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_i18n_impl_bundle_pseudo_translations (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; pseudo_patterns: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_I18N_IMPL_BUNDLE_PSEUDO_TRANSLATIONS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: pseudo_patterns  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_I18N_IMPL_BUNDLE_PSEUDO_TRANSLATIONS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.i18n.impl.bundle.PseudoTranslations"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "pseudo.patterns", pseudo_patterns));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_I18N_IMPL_BUNDLE_PSEUDO_TRANSLATIONS_INFO } l_response.data ({ COM_ADOBE_GRANITE_I18N_IMPL_BUNDLE_PSEUDO_TRANSLATIONS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_i18n_impl_preferences_locale_resolver_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; security_preferences_name: STRING_32): detachable COM_ADOBE_GRANITE_I18N_IMPL_PREFERENCES_LOCALE_RESOLVER_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: security_preferences_name  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_I18N_IMPL_PREFERENCES_LOCALE_RESOLVER_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.i18n.impl.PreferencesLocaleResolverService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "security.preferences.name", security_preferences_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_I18N_IMPL_PREFERENCES_LOCALE_RESOLVER_SERVICE_INFO } l_response.data ({ COM_ADOBE_GRANITE_I18N_IMPL_PREFERENCES_LOCALE_RESOLVER_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_infocollector_info_collector (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; granite_infocollector_include_thread_dumps: BOOLEAN; granite_infocollector_include_heap_dump: BOOLEAN): detachable COM_ADOBE_GRANITE_INFOCOLLECTOR_INFO_COLLECTOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: granite_infocollector_include_thread_dumps  (optional)
			-- 
			-- argument: granite_infocollector_include_heap_dump  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_INFOCOLLECTOR_INFO_COLLECTOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.infocollector.InfoCollector"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.infocollector.includeThreadDumps", granite_infocollector_include_thread_dumps));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.infocollector.includeHeapDump", granite_infocollector_include_heap_dump));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_INFOCOLLECTOR_INFO_COLLECTOR_INFO } l_response.data ({ COM_ADOBE_GRANITE_INFOCOLLECTOR_INFO_COLLECTOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_jetty_ssl_internal_granite_ssl_connector_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_adobe_granite_jetty_ssl_port: INTEGER_32; com_adobe_granite_jetty_ssl_keystore_user: STRING_32; com_adobe_granite_jetty_ssl_keystore_password: STRING_32; com_adobe_granite_jetty_ssl_ciphersuites_excluded: detachable LIST [STRING_32]; com_adobe_granite_jetty_ssl_ciphersuites_included: detachable LIST [STRING_32]; com_adobe_granite_jetty_ssl_client_certificate: STRING_32): detachable COM_ADOBE_GRANITE_JETTY_SSL_INTERNAL_GRANITE_SSL_CONNECTOR_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_adobe_granite_jetty_ssl_port  (optional)
			-- 
			-- argument: com_adobe_granite_jetty_ssl_keystore_user  (optional)
			-- 
			-- argument: com_adobe_granite_jetty_ssl_keystore_password  (optional)
			-- 
			-- argument: com_adobe_granite_jetty_ssl_ciphersuites_excluded  (optional)
			-- 
			-- argument: com_adobe_granite_jetty_ssl_ciphersuites_included  (optional)
			-- 
			-- argument: com_adobe_granite_jetty_ssl_client_certificate  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_JETTY_SSL_INTERNAL_GRANITE_SSL_CONNECTOR_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.jetty.ssl.internal.GraniteSslConnectorFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.jetty.ssl.port", com_adobe_granite_jetty_ssl_port));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.jetty.ssl.keystore.user", com_adobe_granite_jetty_ssl_keystore_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.jetty.ssl.keystore.password", com_adobe_granite_jetty_ssl_keystore_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "com.adobe.granite.jetty.ssl.ciphersuites.excluded", com_adobe_granite_jetty_ssl_ciphersuites_excluded));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "com.adobe.granite.jetty.ssl.ciphersuites.included", com_adobe_granite_jetty_ssl_ciphersuites_included));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "com.adobe.granite.jetty.ssl.client.certificate", com_adobe_granite_jetty_ssl_client_certificate));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_JETTY_SSL_INTERNAL_GRANITE_SSL_CONNECTOR_FACTORY_INFO } l_response.data ({ COM_ADOBE_GRANITE_JETTY_SSL_INTERNAL_GRANITE_SSL_CONNECTOR_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_license_impl_license_check_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; check_internval: INTEGER_32; exclude_ids: detachable LIST [STRING_32]; encrypt_ping: BOOLEAN): detachable COM_ADOBE_GRANITE_LICENSE_IMPL_LICENSE_CHECK_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: check_internval  (optional)
			-- 
			-- argument: exclude_ids  (optional)
			-- 
			-- argument: encrypt_ping  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_LICENSE_IMPL_LICENSE_CHECK_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.license.impl.LicenseCheckFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "checkInternval", check_internval));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "excludeIds", exclude_ids));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "encryptPing", encrypt_ping));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_LICENSE_IMPL_LICENSE_CHECK_FILTER_INFO } l_response.data ({ COM_ADOBE_GRANITE_LICENSE_IMPL_LICENSE_CHECK_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_logging_impl_log_analyser_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; messages_queue_size: INTEGER_32; logger_config: detachable LIST [STRING_32]; messages_size: INTEGER_32): detachable COM_ADOBE_GRANITE_LOGGING_IMPL_LOG_ANALYSER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: messages_queue_size  (optional)
			-- 
			-- argument: logger_config  (optional)
			-- 
			-- argument: messages_size  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_LOGGING_IMPL_LOG_ANALYSER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.logging.impl.LogAnalyserImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "messages.queue.size", messages_queue_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "logger.config", logger_config));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "messages.size", messages_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_LOGGING_IMPL_LOG_ANALYSER_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_LOGGING_IMPL_LOG_ANALYSER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_logging_impl_log_error_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_LOGGING_IMPL_LOG_ERROR_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_LOGGING_IMPL_LOG_ERROR_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.logging.impl.LogErrorHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_LOGGING_IMPL_LOG_ERROR_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_LOGGING_IMPL_LOG_ERROR_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_maintenance_crx_impl_data_store_garbage_collection_task (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; granite_maintenance_mandatory: BOOLEAN; job_topics: STRING_32): detachable COM_ADOBE_GRANITE_MAINTENANCE_CRX_IMPL_DATA_STORE_GARBAGE_COLLECTION_TASK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: granite_maintenance_mandatory  (optional)
			-- 
			-- argument: job_topics  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_MAINTENANCE_CRX_IMPL_DATA_STORE_GARBAGE_COLLECTION_TASK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.DataStoreGarbageCollectionTask"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.maintenance.mandatory", granite_maintenance_mandatory));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "job.topics", job_topics));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_MAINTENANCE_CRX_IMPL_DATA_STORE_GARBAGE_COLLECTION_TASK_INFO } l_response.data ({ COM_ADOBE_GRANITE_MAINTENANCE_CRX_IMPL_DATA_STORE_GARBAGE_COLLECTION_TASK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_maintenance_crx_impl_lucene_binaries_cleanup_task (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; job_topics: STRING_32): detachable COM_ADOBE_GRANITE_MAINTENANCE_CRX_IMPL_LUCENE_BINARIES_CLEANUP_TASK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: job_topics  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_MAINTENANCE_CRX_IMPL_LUCENE_BINARIES_CLEANUP_TASK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.LuceneBinariesCleanupTask"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "job.topics", job_topics));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_MAINTENANCE_CRX_IMPL_LUCENE_BINARIES_CLEANUP_TASK_INFO } l_response.data ({ COM_ADOBE_GRANITE_MAINTENANCE_CRX_IMPL_LUCENE_BINARIES_CLEANUP_TASK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_maintenance_crx_impl_revision_cleanup_task (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; full_gc_days: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_MAINTENANCE_CRX_IMPL_REVISION_CLEANUP_TASK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: full_gc_days  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_MAINTENANCE_CRX_IMPL_REVISION_CLEANUP_TASK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.RevisionCleanupTask"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "full.gc.days", full_gc_days));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_MAINTENANCE_CRX_IMPL_REVISION_CLEANUP_TASK_INFO } l_response.data ({ COM_ADOBE_GRANITE_MAINTENANCE_CRX_IMPL_REVISION_CLEANUP_TASK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_monitoring_impl_script_config_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; script_filename: STRING_32; script_display: STRING_32; script_path: STRING_32; script_platform: detachable LIST [STRING_32]; interval: INTEGER_32; jmxdomain: STRING_32): detachable COM_ADOBE_GRANITE_MONITORING_IMPL_SCRIPT_CONFIG_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: script_filename  (optional)
			-- 
			-- argument: script_display  (optional)
			-- 
			-- argument: script_path  (optional)
			-- 
			-- argument: script_platform  (optional)
			-- 
			-- argument: interval  (optional)
			-- 
			-- argument: jmxdomain  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_MONITORING_IMPL_SCRIPT_CONFIG_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.monitoring.impl.ScriptConfigImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "script.filename", script_filename));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "script.display", script_display));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "script.path", script_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "script.platform", script_platform));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "interval", interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jmxdomain", jmxdomain));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_MONITORING_IMPL_SCRIPT_CONFIG_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_MONITORING_IMPL_SCRIPT_CONFIG_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_oauth_server_auth_impl_oauth2_server_authentication_han (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path: STRING_32; jaas_control_flag: STRING_32; jaas_realm_name: STRING_32; jaas_ranking: INTEGER_32; oauth_offline_validation: BOOLEAN): detachable COM_ADOBE_GRANITE_OAUTH_SERVER_AUTH_IMPL_O_AUTH2_SERVER_AUTHENTICATION_HAN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: jaas_control_flag  (optional)
			-- 
			-- argument: jaas_realm_name  (optional)
			-- 
			-- argument: jaas_ranking  (optional)
			-- 
			-- argument: oauth_offline_validation  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OAUTH_SERVER_AUTH_IMPL_O_AUTH2_SERVER_AUTHENTICATION_HAN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.oauth.server.auth.impl.OAuth2ServerAuthenticationHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.controlFlag", jaas_control_flag));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.realmName", jaas_realm_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.ranking", jaas_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.offline.validation", oauth_offline_validation));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OAUTH_SERVER_AUTH_IMPL_O_AUTH2_SERVER_AUTHENTICATION_HAN_INFO } l_response.data ({ COM_ADOBE_GRANITE_OAUTH_SERVER_AUTH_IMPL_O_AUTH2_SERVER_AUTHENTICATION_HAN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_oauth_server_impl_access_token_cleanup_task (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_expression: STRING_32): detachable COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_ACCESS_TOKEN_CLEANUP_TASK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_ACCESS_TOKEN_CLEANUP_TASK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.oauth.server.impl.AccessTokenCleanupTask"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_ACCESS_TOKEN_CLEANUP_TASK_INFO } l_response.data ({ COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_ACCESS_TOKEN_CLEANUP_TASK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_oauth_server_impl_oauth2_client_revocation_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_client_revocation_active: BOOLEAN): detachable COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_CLIENT_REVOCATION_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_client_revocation_active  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_CLIENT_REVOCATION_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2ClientRevocationServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.client.revocation.active", oauth_client_revocation_active));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_CLIENT_REVOCATION_SERVLET_INFO } l_response.data ({ COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_CLIENT_REVOCATION_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_oauth_server_impl_oauth2_revocation_endpoint_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_paths: STRING_32; oauth_revocation_active: BOOLEAN): detachable COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_REVOCATION_ENDPOINT_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_paths  (optional)
			-- 
			-- argument: oauth_revocation_active  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_REVOCATION_ENDPOINT_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2RevocationEndpointServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.paths", sling_servlet_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.revocation.active", oauth_revocation_active));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_REVOCATION_ENDPOINT_SERVLET_INFO } l_response.data ({ COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_REVOCATION_ENDPOINT_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_oauth_server_impl_oauth2_token_endpoint_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_issuer: STRING_32; oauth_access_token_expires_in: STRING_32; osgi_http_whiteboard_servlet_pattern: STRING_32; osgi_http_whiteboard_context_select: STRING_32): detachable COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_TOKEN_ENDPOINT_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_issuer  (optional)
			-- 
			-- argument: oauth_access_token_expires_in  (optional)
			-- 
			-- argument: osgi_http_whiteboard_servlet_pattern  (optional)
			-- 
			-- argument: osgi_http_whiteboard_context_select  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_TOKEN_ENDPOINT_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2TokenEndpointServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.issuer", oauth_issuer));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.access.token.expires.in", oauth_access_token_expires_in));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "osgi.http.whiteboard.servlet.pattern", osgi_http_whiteboard_servlet_pattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "osgi.http.whiteboard.context.select", osgi_http_whiteboard_context_select));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_TOKEN_ENDPOINT_SERVLET_INFO } l_response.data ({ COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_TOKEN_ENDPOINT_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_oauth_server_impl_oauth2_token_revocation_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; oauth_token_revocation_active: BOOLEAN): detachable COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_TOKEN_REVOCATION_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: oauth_token_revocation_active  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_TOKEN_REVOCATION_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2TokenRevocationServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oauth.token.revocation.active", oauth_token_revocation_active));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_TOKEN_REVOCATION_SERVLET_INFO } l_response.data ({ COM_ADOBE_GRANITE_OAUTH_SERVER_IMPL_O_AUTH2_TOKEN_REVOCATION_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_offloading_impl_offloading_configurator (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; offloading_transporter: STRING_32; offloading_cleanup_payload: BOOLEAN): detachable COM_ADOBE_GRANITE_OFFLOADING_IMPL_OFFLOADING_CONFIGURATOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: offloading_transporter  (optional)
			-- 
			-- argument: offloading_cleanup_payload  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OFFLOADING_IMPL_OFFLOADING_CONFIGURATOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingConfigurator"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "offloading.transporter", offloading_transporter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "offloading.cleanup.payload", offloading_cleanup_payload));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OFFLOADING_IMPL_OFFLOADING_CONFIGURATOR_INFO } l_response.data ({ COM_ADOBE_GRANITE_OFFLOADING_IMPL_OFFLOADING_CONFIGURATOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_offloading_impl_offloading_job_cloner (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; offloading_jobcloner_enabled: BOOLEAN): detachable COM_ADOBE_GRANITE_OFFLOADING_IMPL_OFFLOADING_JOB_CLONER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: offloading_jobcloner_enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OFFLOADING_IMPL_OFFLOADING_JOB_CLONER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingJobCloner"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "offloading.jobcloner.enabled", offloading_jobcloner_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OFFLOADING_IMPL_OFFLOADING_JOB_CLONER_INFO } l_response.data ({ COM_ADOBE_GRANITE_OFFLOADING_IMPL_OFFLOADING_JOB_CLONER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_offloading_impl_offloading_job_offloader (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; offloading_offloader_enabled: BOOLEAN): detachable COM_ADOBE_GRANITE_OFFLOADING_IMPL_OFFLOADING_JOB_OFFLOADER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: offloading_offloader_enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OFFLOADING_IMPL_OFFLOADING_JOB_OFFLOADER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingJobOffloader"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "offloading.offloader.enabled", offloading_offloader_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OFFLOADING_IMPL_OFFLOADING_JOB_OFFLOADER_INFO } l_response.data ({ COM_ADOBE_GRANITE_OFFLOADING_IMPL_OFFLOADING_JOB_OFFLOADER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_offloading_impl_transporter_offloading_agent_manager (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; offloading_agentmanager_enabled: BOOLEAN): detachable COM_ADOBE_GRANITE_OFFLOADING_IMPL_TRANSPORTER_OFFLOADING_AGENT_MANAGER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: offloading_agentmanager_enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OFFLOADING_IMPL_TRANSPORTER_OFFLOADING_AGENT_MANAGER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.offloading.impl.transporter.OffloadingAgentManager"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "offloading.agentmanager.enabled", offloading_agentmanager_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OFFLOADING_IMPL_TRANSPORTER_OFFLOADING_AGENT_MANAGER_INFO } l_response.data ({ COM_ADOBE_GRANITE_OFFLOADING_IMPL_TRANSPORTER_OFFLOADING_AGENT_MANAGER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_offloading_impl_transporter_offloading_default_transpo (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; default_transport_agent_to_worker_prefix: STRING_32; default_transport_agent_to_master_prefix: STRING_32; default_transport_input_package: STRING_32; default_transport_output_package: STRING_32; default_transport_replication_synchronous: BOOLEAN; default_transport_contentpackage: BOOLEAN; offloading_transporter_default_enabled: BOOLEAN): detachable COM_ADOBE_GRANITE_OFFLOADING_IMPL_TRANSPORTER_OFFLOADING_DEFAULT_TRANSPO_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: default_transport_agent_to_worker_prefix  (optional)
			-- 
			-- argument: default_transport_agent_to_master_prefix  (optional)
			-- 
			-- argument: default_transport_input_package  (optional)
			-- 
			-- argument: default_transport_output_package  (optional)
			-- 
			-- argument: default_transport_replication_synchronous  (optional)
			-- 
			-- argument: default_transport_contentpackage  (optional)
			-- 
			-- argument: offloading_transporter_default_enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OFFLOADING_IMPL_TRANSPORTER_OFFLOADING_DEFAULT_TRANSPO_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.offloading.impl.transporter.OffloadingDefaultTransporter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.transport.agent-to-worker.prefix", default_transport_agent_to_worker_prefix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.transport.agent-to-master.prefix", default_transport_agent_to_master_prefix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.transport.input.package", default_transport_input_package));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.transport.output.package", default_transport_output_package));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.transport.replication.synchronous", default_transport_replication_synchronous));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.transport.contentpackage", default_transport_contentpackage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "offloading.transporter.default.enabled", offloading_transporter_default_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OFFLOADING_IMPL_TRANSPORTER_OFFLOADING_DEFAULT_TRANSPO_INFO } l_response.data ({ COM_ADOBE_GRANITE_OFFLOADING_IMPL_TRANSPORTER_OFFLOADING_DEFAULT_TRANSPO_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_omnisearch_impl_core_omni_search_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; omnisearch_suggestion_requiretext_min: INTEGER_32; omnisearch_suggestion_spellcheck_require: BOOLEAN): detachable COM_ADOBE_GRANITE_OMNISEARCH_IMPL_CORE_OMNI_SEARCH_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: omnisearch_suggestion_requiretext_min  (optional)
			-- 
			-- argument: omnisearch_suggestion_spellcheck_require  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OMNISEARCH_IMPL_CORE_OMNI_SEARCH_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.omnisearch.impl.core.OmniSearchServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "omnisearch.suggestion.requiretext.min", omnisearch_suggestion_requiretext_min));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "omnisearch.suggestion.spellcheck.require", omnisearch_suggestion_spellcheck_require));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OMNISEARCH_IMPL_CORE_OMNI_SEARCH_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_OMNISEARCH_IMPL_CORE_OMNI_SEARCH_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_optout_impl_opt_out_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; optout_cookies: detachable LIST [STRING_32]; optout_headers: detachable LIST [STRING_32]; optout_whitelist_cookies: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_OPTOUT_IMPL_OPT_OUT_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: optout_cookies  (optional)
			-- 
			-- argument: optout_headers  (optional)
			-- 
			-- argument: optout_whitelist_cookies  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_OPTOUT_IMPL_OPT_OUT_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.optout.impl.OptOutServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "optout.cookies", optout_cookies));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "optout.headers", optout_headers));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "optout.whitelist.cookies", optout_whitelist_cookies));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_OPTOUT_IMPL_OPT_OUT_SERVICE_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_OPTOUT_IMPL_OPT_OUT_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_queries_impl_hc_async_index_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; indexing_critical_threshold: INTEGER_32; indexing_warn_threshold: INTEGER_32; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_QUERIES_IMPL_HC_ASYNC_INDEX_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: indexing_critical_threshold  (optional)
			-- 
			-- argument: indexing_warn_threshold  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_QUERIES_IMPL_HC_ASYNC_INDEX_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.queries.impl.hc.AsyncIndexHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "indexing.critical.threshold", indexing_critical_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "indexing.warn.threshold", indexing_warn_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_QUERIES_IMPL_HC_ASYNC_INDEX_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_QUERIES_IMPL_HC_ASYNC_INDEX_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_queries_impl_hc_large_index_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; large_index_critical_threshold: INTEGER_32; large_index_warn_threshold: INTEGER_32; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_QUERIES_IMPL_HC_LARGE_INDEX_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: large_index_critical_threshold  (optional)
			-- 
			-- argument: large_index_warn_threshold  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_QUERIES_IMPL_HC_LARGE_INDEX_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.queries.impl.hc.LargeIndexHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "large.index.critical.threshold", large_index_critical_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "large.index.warn.threshold", large_index_warn_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_QUERIES_IMPL_HC_LARGE_INDEX_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_QUERIES_IMPL_HC_LARGE_INDEX_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_queries_impl_hc_queries_status_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_QUERIES_IMPL_HC_QUERIES_STATUS_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_QUERIES_IMPL_HC_QUERIES_STATUS_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueriesStatusHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_QUERIES_IMPL_HC_QUERIES_STATUS_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_QUERIES_IMPL_HC_QUERIES_STATUS_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_queries_impl_hc_query_health_check_metrics (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; get_period: INTEGER_32): detachable COM_ADOBE_GRANITE_QUERIES_IMPL_HC_QUERY_HEALTH_CHECK_METRICS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: get_period  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_QUERIES_IMPL_HC_QUERY_HEALTH_CHECK_METRICS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueryHealthCheckMetrics"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "getPeriod", get_period));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_QUERIES_IMPL_HC_QUERY_HEALTH_CHECK_METRICS_INFO } l_response.data ({ COM_ADOBE_GRANITE_QUERIES_IMPL_HC_QUERY_HEALTH_CHECK_METRICS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_queries_impl_hc_query_limits_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_QUERIES_IMPL_HC_QUERY_LIMITS_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_QUERIES_IMPL_HC_QUERY_LIMITS_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueryLimitsHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_QUERIES_IMPL_HC_QUERY_LIMITS_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_QUERIES_IMPL_HC_QUERY_LIMITS_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_replication_hc_impl_replication_queue_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; number_of_retries_allowed: INTEGER_32; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_REPLICATION_HC_IMPL_REPLICATION_QUEUE_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: number_of_retries_allowed  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REPLICATION_HC_IMPL_REPLICATION_QUEUE_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.replication.hc.impl.ReplicationQueueHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "number.of.retries.allowed", number_of_retries_allowed));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REPLICATION_HC_IMPL_REPLICATION_QUEUE_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_REPLICATION_HC_IMPL_REPLICATION_QUEUE_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_replication_hc_impl_replication_transport_users_health_c (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_REPLICATION_HC_IMPL_REPLICATION_TRANSPORT_USERS_HEALTH_C_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REPLICATION_HC_IMPL_REPLICATION_TRANSPORT_USERS_HEALTH_C_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.replication.hc.impl.ReplicationTransportUsersHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REPLICATION_HC_IMPL_REPLICATION_TRANSPORT_USERS_HEALTH_C_INFO } l_response.data ({ COM_ADOBE_GRANITE_REPLICATION_HC_IMPL_REPLICATION_TRANSPORT_USERS_HEALTH_C_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_repository_hc_impl_authorizable_node_name_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_AUTHORIZABLE_NODE_NAME_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_AUTHORIZABLE_NODE_NAME_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.repository.hc.impl.AuthorizableNodeNameHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_AUTHORIZABLE_NODE_NAME_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_AUTHORIZABLE_NODE_NAME_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_repository_hc_impl_content_sling_sling_content_health_c (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]; exclude_search_path: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_CONTENT_SLING_SLING_CONTENT_HEALTH_C_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: exclude_search_path  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_CONTENT_SLING_SLING_CONTENT_HEALTH_C_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.repository.hc.impl.content.sling.SlingContentHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "exclude.search.path", exclude_search_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_CONTENT_SLING_SLING_CONTENT_HEALTH_C_INFO } l_response.data ({ COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_CONTENT_SLING_SLING_CONTENT_HEALTH_C_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_repository_hc_impl_continuous_rg_chealth_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_CONTINUOUS_RGC_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_CONTINUOUS_RGC_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.repository.hc.impl.ContinuousRGCHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_CONTINUOUS_RGC_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_CONTINUOUS_RGC_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_repository_hc_impl_default_access_user_profile_health_che (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_DEFAULT_ACCESS_USER_PROFILE_HEALTH_CHE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_DEFAULT_ACCESS_USER_PROFILE_HEALTH_CHE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.repository.hc.impl.DefaultAccessUserProfileHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_DEFAULT_ACCESS_USER_PROFILE_HEALTH_CHE_INFO } l_response.data ({ COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_DEFAULT_ACCESS_USER_PROFILE_HEALTH_CHE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_repository_hc_impl_default_logins_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]; account_logins: detachable LIST [STRING_32]; console_logins: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_DEFAULT_LOGINS_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: account_logins  (optional)
			-- 
			-- argument: console_logins  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_DEFAULT_LOGINS_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.repository.hc.impl.DefaultLoginsHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "account.logins", account_logins));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "console.logins", console_logins));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_DEFAULT_LOGINS_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_DEFAULT_LOGINS_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_repository_hc_impl_disk_space_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]; disk_space_warn_threshold: INTEGER_32; disk_space_error_threshold: INTEGER_32): detachable COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_DISK_SPACE_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: disk_space_warn_threshold  (optional)
			-- 
			-- argument: disk_space_error_threshold  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_DISK_SPACE_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.repository.hc.impl.DiskSpaceHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "disk.space.warn.threshold", disk_space_warn_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "disk.space.error.threshold", disk_space_error_threshold));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_DISK_SPACE_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_DISK_SPACE_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_repository_hc_impl_observation_queue_length_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_OBSERVATION_QUEUE_LENGTH_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_OBSERVATION_QUEUE_LENGTH_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.repository.hc.impl.ObservationQueueLengthHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_OBSERVATION_QUEUE_LENGTH_HEALTH_CHECK_INFO } l_response.data ({ COM_ADOBE_GRANITE_REPOSITORY_HC_IMPL_OBSERVATION_QUEUE_LENGTH_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_repository_impl_commit_stats_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN; interval_seconds: INTEGER_32; commits_per_interval_threshold: INTEGER_32; max_location_length: INTEGER_32; max_details_shown: INTEGER_32; min_details_percentage: INTEGER_32; thread_matchers: detachable LIST [STRING_32]; max_greedy_depth: INTEGER_32; greedy_stack_matchers: STRING_32; stack_filters: detachable LIST [STRING_32]; stack_matchers: detachable LIST [STRING_32]; stack_categorizers: detachable LIST [STRING_32]; stack_shorteners: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_REPOSITORY_IMPL_COMMIT_STATS_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: interval_seconds  (optional)
			-- 
			-- argument: commits_per_interval_threshold  (optional)
			-- 
			-- argument: max_location_length  (optional)
			-- 
			-- argument: max_details_shown  (optional)
			-- 
			-- argument: min_details_percentage  (optional)
			-- 
			-- argument: thread_matchers  (optional)
			-- 
			-- argument: max_greedy_depth  (optional)
			-- 
			-- argument: greedy_stack_matchers  (optional)
			-- 
			-- argument: stack_filters  (optional)
			-- 
			-- argument: stack_matchers  (optional)
			-- 
			-- argument: stack_categorizers  (optional)
			-- 
			-- argument: stack_shorteners  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REPOSITORY_IMPL_COMMIT_STATS_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.repository.impl.CommitStatsConfig"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "intervalSeconds", interval_seconds));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "commitsPerIntervalThreshold", commits_per_interval_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxLocationLength", max_location_length));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxDetailsShown", max_details_shown));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "minDetailsPercentage", min_details_percentage));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "threadMatchers", thread_matchers));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxGreedyDepth", max_greedy_depth));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "greedyStackMatchers", greedy_stack_matchers));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "stackFilters", stack_filters));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "stackMatchers", stack_matchers));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "stackCategorizers", stack_categorizers));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "stackShorteners", stack_shorteners));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REPOSITORY_IMPL_COMMIT_STATS_CONFIG_INFO } l_response.data ({ COM_ADOBE_GRANITE_REPOSITORY_IMPL_COMMIT_STATS_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_repository_service_user_configuration (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; serviceusers_simple_subject_population: BOOLEAN; serviceusers_list: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_REPOSITORY_SERVICE_USER_CONFIGURATION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: serviceusers_simple_subject_population  (optional)
			-- 
			-- argument: serviceusers_list  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REPOSITORY_SERVICE_USER_CONFIGURATION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.repository.ServiceUserConfiguration"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceusers.simpleSubjectPopulation", serviceusers_simple_subject_population));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "serviceusers.list", serviceusers_list));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REPOSITORY_SERVICE_USER_CONFIGURATION_INFO } l_response.data ({ COM_ADOBE_GRANITE_REPOSITORY_SERVICE_USER_CONFIGURATION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_requests_logging_impl_hc_requests_status_health_check_im (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_REQUESTS_LOGGING_IMPL_HC_REQUESTS_STATUS_HEALTH_CHECK_IM_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REQUESTS_LOGGING_IMPL_HC_REQUESTS_STATUS_HEALTH_CHECK_IM_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.requests.logging.impl.hc.RequestsStatusHealthCheckImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REQUESTS_LOGGING_IMPL_HC_REQUESTS_STATUS_HEALTH_CHECK_IM_INFO } l_response.data ({ COM_ADOBE_GRANITE_REQUESTS_LOGGING_IMPL_HC_REQUESTS_STATUS_HEALTH_CHECK_IM_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_resourcestatus_impl_composite_status_type (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; types: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_RESOURCESTATUS_IMPL_COMPOSITE_STATUS_TYPE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: types  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_RESOURCESTATUS_IMPL_COMPOSITE_STATUS_TYPE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.resourcestatus.impl.CompositeStatusType"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "types", types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_RESOURCESTATUS_IMPL_COMPOSITE_STATUS_TYPE_INFO } l_response.data ({ COM_ADOBE_GRANITE_RESOURCESTATUS_IMPL_COMPOSITE_STATUS_TYPE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_resourcestatus_impl_status_resource_provider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; provider_root: STRING_32): detachable COM_ADOBE_GRANITE_RESOURCESTATUS_IMPL_STATUS_RESOURCE_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: provider_root  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_RESOURCESTATUS_IMPL_STATUS_RESOURCE_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.resourcestatus.impl.StatusResourceProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.root", provider_root));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_RESOURCESTATUS_IMPL_STATUS_RESOURCE_PROVIDER_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_RESOURCESTATUS_IMPL_STATUS_RESOURCE_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_rest_assets_impl_asset_content_disposition_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; mime_allow_empty: BOOLEAN; mime_allowed: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_REST_ASSETS_IMPL_ASSET_CONTENT_DISPOSITION_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: mime_allow_empty  (optional)
			-- 
			-- argument: mime_allowed  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REST_ASSETS_IMPL_ASSET_CONTENT_DISPOSITION_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.rest.assets.impl.AssetContentDispositionFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "mime.allowEmpty", mime_allow_empty));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "mime.allowed", mime_allowed));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REST_ASSETS_IMPL_ASSET_CONTENT_DISPOSITION_FILTER_INFO } l_response.data ({ COM_ADOBE_GRANITE_REST_ASSETS_IMPL_ASSET_CONTENT_DISPOSITION_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_rest_impl_api_endpoint_resource_provider_factory_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; provider_roots: STRING_32): detachable COM_ADOBE_GRANITE_REST_IMPL_API_ENDPOINT_RESOURCE_PROVIDER_FACTORY_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: provider_roots  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REST_IMPL_API_ENDPOINT_RESOURCE_PROVIDER_FACTORY_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.rest.impl.ApiEndpointResourceProviderFactoryImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.roots", provider_roots));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REST_IMPL_API_ENDPOINT_RESOURCE_PROVIDER_FACTORY_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_REST_IMPL_API_ENDPOINT_RESOURCE_PROVIDER_FACTORY_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_rest_impl_servlet_default_ge_tservlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; default_limit: INTEGER_32; use_absolute_uri: BOOLEAN): detachable COM_ADOBE_GRANITE_REST_IMPL_SERVLET_DEFAULT_GET_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: default_limit  (optional)
			-- 
			-- argument: use_absolute_uri  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_REST_IMPL_SERVLET_DEFAULT_GET_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.rest.impl.servlet.DefaultGETServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.limit", default_limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "use.absolute.uri", use_absolute_uri));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_REST_IMPL_SERVLET_DEFAULT_GET_SERVLET_INFO } l_response.data ({ COM_ADOBE_GRANITE_REST_IMPL_SERVLET_DEFAULT_GET_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_security_user_ui_internal_servlets_ss_lconfiguration_s (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_tags: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_SECURITY_USER_UI_INTERNAL_SERVLETS_SSL_CONFIGURATION_S_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_SECURITY_USER_UI_INTERNAL_SERVLETS_SSL_CONFIGURATION_S_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.security.user.ui.internal.servlets.SSLConfigurationServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_SECURITY_USER_UI_INTERNAL_SERVLETS_SSL_CONFIGURATION_S_INFO } l_response.data ({ COM_ADOBE_GRANITE_SECURITY_USER_UI_INTERNAL_SERVLETS_SSL_CONFIGURATION_S_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_security_user_user_properties_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; adapter_condition: STRING_32; granite_userproperties_nodetypes: detachable LIST [STRING_32]; granite_userproperties_resourcetypes: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_SECURITY_USER_USER_PROPERTIES_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: adapter_condition  (optional)
			-- 
			-- argument: granite_userproperties_nodetypes  (optional)
			-- 
			-- argument: granite_userproperties_resourcetypes  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_SECURITY_USER_USER_PROPERTIES_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.security.user.UserPropertiesService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "adapter.condition", adapter_condition));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "granite.userproperties.nodetypes", granite_userproperties_nodetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "granite.userproperties.resourcetypes", granite_userproperties_resourcetypes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_SECURITY_USER_USER_PROPERTIES_SERVICE_INFO } l_response.data ({ COM_ADOBE_GRANITE_SECURITY_USER_USER_PROPERTIES_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_socialgraph_impl_social_graph_factory_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; group2member_relationship_outgoing: STRING_32; group2member_excluded_outgoing: detachable LIST [STRING_32]; group2member_relationship_incoming: STRING_32; group2member_excluded_incoming: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_SOCIALGRAPH_IMPL_SOCIAL_GRAPH_FACTORY_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: group2member_relationship_outgoing  (optional)
			-- 
			-- argument: group2member_excluded_outgoing  (optional)
			-- 
			-- argument: group2member_relationship_incoming  (optional)
			-- 
			-- argument: group2member_excluded_incoming  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_SOCIALGRAPH_IMPL_SOCIAL_GRAPH_FACTORY_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.socialgraph.impl.SocialGraphFactoryImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "group2member.relationship.outgoing", group2member_relationship_outgoing));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "group2member.excluded.outgoing", group2member_excluded_outgoing));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "group2member.relationship.incoming", group2member_relationship_incoming));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "group2member.excluded.incoming", group2member_excluded_incoming));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_SOCIALGRAPH_IMPL_SOCIAL_GRAPH_FACTORY_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_SOCIALGRAPH_IMPL_SOCIAL_GRAPH_FACTORY_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_system_monitoring_impl_system_stats_mbean_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_expression: STRING_32; jmx_objectname: STRING_32): detachable COM_ADOBE_GRANITE_SYSTEM_MONITORING_IMPL_SYSTEM_STATS_M_BEAN_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- argument: jmx_objectname  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_SYSTEM_MONITORING_IMPL_SYSTEM_STATS_M_BEAN_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.system.monitoring.impl.SystemStatsMBeanImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jmx.objectname", jmx_objectname));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_SYSTEM_MONITORING_IMPL_SYSTEM_STATS_M_BEAN_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_SYSTEM_MONITORING_IMPL_SYSTEM_STATS_M_BEAN_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_taskmanagement_impl_jcr_task_adapter_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; adapter_condition: STRING_32): detachable COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_JCR_TASK_ADAPTER_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: adapter_condition  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_JCR_TASK_ADAPTER_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.taskmanagement.impl.jcr.TaskAdapterFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "adapter.condition", adapter_condition));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_JCR_TASK_ADAPTER_FACTORY_INFO } l_response.data ({ COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_JCR_TASK_ADAPTER_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_taskmanagement_impl_jcr_task_archive_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; archiving_enabled: BOOLEAN; scheduler_expression: STRING_32; archive_since_days_completed: INTEGER_32): detachable COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_JCR_TASK_ARCHIVE_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: archiving_enabled  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- argument: archive_since_days_completed  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_JCR_TASK_ARCHIVE_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.taskmanagement.impl.jcr.TaskArchiveService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "archiving.enabled", archiving_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "archive.since.days.completed", archive_since_days_completed));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_JCR_TASK_ARCHIVE_SERVICE_INFO } l_response.data ({ COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_JCR_TASK_ARCHIVE_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_taskmanagement_impl_purge_task_purge_maintenance_task (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; purge_completed: BOOLEAN; completed_age: INTEGER_32; purge_active: BOOLEAN; active_age: INTEGER_32; save_threshold: INTEGER_32): detachable COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_PURGE_TASK_PURGE_MAINTENANCE_TASK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: purge_completed  (optional)
			-- 
			-- argument: completed_age  (optional)
			-- 
			-- argument: purge_active  (optional)
			-- 
			-- argument: active_age  (optional)
			-- 
			-- argument: save_threshold  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_PURGE_TASK_PURGE_MAINTENANCE_TASK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.taskmanagement.impl.purge.TaskPurgeMaintenanceTask"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "purgeCompleted", purge_completed));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "completedAge", completed_age));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "purgeActive", purge_active));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "activeAge", active_age));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "saveThreshold", save_threshold));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_PURGE_TASK_PURGE_MAINTENANCE_TASK_INFO } l_response.data ({ COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_PURGE_TASK_PURGE_MAINTENANCE_TASK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_taskmanagement_impl_service_task_manager_adapter_factor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; adapter_condition: STRING_32; taskmanager_admingroups: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_SERVICE_TASK_MANAGER_ADAPTER_FACTOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: adapter_condition  (optional)
			-- 
			-- argument: taskmanager_admingroups  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_SERVICE_TASK_MANAGER_ADAPTER_FACTOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.taskmanagement.impl.service.TaskManagerAdapterFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "adapter.condition", adapter_condition));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "taskmanager.admingroups", taskmanager_admingroups));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_SERVICE_TASK_MANAGER_ADAPTER_FACTOR_INFO } l_response.data ({ COM_ADOBE_GRANITE_TASKMANAGEMENT_IMPL_SERVICE_TASK_MANAGER_ADAPTER_FACTOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_threaddump_thread_dump_collector (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_period: INTEGER_32; scheduler_run_on: STRING_32; granite_threaddump_enabled: BOOLEAN; granite_threaddump_dumps_per_file: INTEGER_32; granite_threaddump_enable_gzip_compression: BOOLEAN; granite_threaddump_enable_directories_compression: BOOLEAN; granite_threaddump_enable_jstack: BOOLEAN; granite_threaddump_max_backup_days: INTEGER_32; granite_threaddump_backup_clean_trigger: STRING_32): detachable COM_ADOBE_GRANITE_THREADDUMP_THREAD_DUMP_COLLECTOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_period  (optional)
			-- 
			-- argument: scheduler_run_on  (optional)
			-- 
			-- argument: granite_threaddump_enabled  (optional)
			-- 
			-- argument: granite_threaddump_dumps_per_file  (optional)
			-- 
			-- argument: granite_threaddump_enable_gzip_compression  (optional)
			-- 
			-- argument: granite_threaddump_enable_directories_compression  (optional)
			-- 
			-- argument: granite_threaddump_enable_jstack  (optional)
			-- 
			-- argument: granite_threaddump_max_backup_days  (optional)
			-- 
			-- argument: granite_threaddump_backup_clean_trigger  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_THREADDUMP_THREAD_DUMP_COLLECTOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.threaddump.ThreadDumpCollector"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.period", scheduler_period));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.runOn", scheduler_run_on));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.threaddump.enabled", granite_threaddump_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.threaddump.dumpsPerFile", granite_threaddump_dumps_per_file));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.threaddump.enableGzipCompression", granite_threaddump_enable_gzip_compression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.threaddump.enableDirectoriesCompression", granite_threaddump_enable_directories_compression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.threaddump.enableJStack", granite_threaddump_enable_jstack));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.threaddump.maxBackupDays", granite_threaddump_max_backup_days));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.threaddump.backupCleanTrigger", granite_threaddump_backup_clean_trigger));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_THREADDUMP_THREAD_DUMP_COLLECTOR_INFO } l_response.data ({ COM_ADOBE_GRANITE_THREADDUMP_THREAD_DUMP_COLLECTOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_translation_connector_msft_core_impl_microsoft_transl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; translation_factory: STRING_32; default_connector_label: STRING_32; default_connector_attribution: STRING_32; default_connector_workspace_id: STRING_32; default_connector_subscription_key: STRING_32; language_map_location: STRING_32; category_map_location: STRING_32; retry_attempts: INTEGER_32; timeout_count: INTEGER_32): detachable COM_ADOBE_GRANITE_TRANSLATION_CONNECTOR_MSFT_CORE_IMPL_MICROSOFT_TRANSL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: translation_factory  (optional)
			-- 
			-- argument: default_connector_label  (optional)
			-- 
			-- argument: default_connector_attribution  (optional)
			-- 
			-- argument: default_connector_workspace_id  (optional)
			-- 
			-- argument: default_connector_subscription_key  (optional)
			-- 
			-- argument: language_map_location  (optional)
			-- 
			-- argument: category_map_location  (optional)
			-- 
			-- argument: retry_attempts  (optional)
			-- 
			-- argument: timeout_count  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_TRANSLATION_CONNECTOR_MSFT_CORE_IMPL_MICROSOFT_TRANSL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.translation.connector.msft.core.impl.MicrosoftTranslationServiceFactoryImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "translationFactory", translation_factory));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultConnectorLabel", default_connector_label));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultConnectorAttribution", default_connector_attribution));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultConnectorWorkspaceId", default_connector_workspace_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultConnectorSubscriptionKey", default_connector_subscription_key));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "languageMapLocation", language_map_location));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "categoryMapLocation", category_map_location));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "retryAttempts", retry_attempts));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "timeoutCount", timeout_count));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_TRANSLATION_CONNECTOR_MSFT_CORE_IMPL_MICROSOFT_TRANSL_INFO } l_response.data ({ COM_ADOBE_GRANITE_TRANSLATION_CONNECTOR_MSFT_CORE_IMPL_MICROSOFT_TRANSL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_translation_core_impl_translation_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; default_connector_name: STRING_32; default_category: STRING_32): detachable COM_ADOBE_GRANITE_TRANSLATION_CORE_IMPL_TRANSLATION_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: default_connector_name  (optional)
			-- 
			-- argument: default_category  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_TRANSLATION_CORE_IMPL_TRANSLATION_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.translation.core.impl.TranslationManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultConnectorName", default_connector_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultCategory", default_category));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_TRANSLATION_CORE_IMPL_TRANSLATION_MANAGER_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_TRANSLATION_CORE_IMPL_TRANSLATION_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_ui_clientlibs_impl_html_library_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; htmllibmanager_timing: BOOLEAN; htmllibmanager_debug_init_js: STRING_32; htmllibmanager_minify: BOOLEAN; htmllibmanager_debug: BOOLEAN; htmllibmanager_gzip: BOOLEAN; htmllibmanager_max_data_uri_size: INTEGER_32; htmllibmanager_maxage: INTEGER_32; htmllibmanager_force_cq_url_info: BOOLEAN; htmllibmanager_defaultthemename: STRING_32; htmllibmanager_defaultuserthemename: STRING_32; htmllibmanager_clientmanager: STRING_32; htmllibmanager_path_list: detachable LIST [STRING_32]; htmllibmanager_excluded_path_list: detachable LIST [STRING_32]; htmllibmanager_processor_js: detachable LIST [STRING_32]; htmllibmanager_processor_css: detachable LIST [STRING_32]; htmllibmanager_longcache_patterns: detachable LIST [STRING_32]; htmllibmanager_longcache_format: STRING_32; htmllibmanager_use_file_system_output_cache: BOOLEAN; htmllibmanager_file_system_output_cache_location: STRING_32; htmllibmanager_disable_replacement: detachable LIST [STRING_32]): detachable COM_ADOBE_GRANITE_UI_CLIENTLIBS_IMPL_HTML_LIBRARY_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: htmllibmanager_timing  (optional)
			-- 
			-- argument: htmllibmanager_debug_init_js  (optional)
			-- 
			-- argument: htmllibmanager_minify  (optional)
			-- 
			-- argument: htmllibmanager_debug  (optional)
			-- 
			-- argument: htmllibmanager_gzip  (optional)
			-- 
			-- argument: htmllibmanager_max_data_uri_size  (optional)
			-- 
			-- argument: htmllibmanager_maxage  (optional)
			-- 
			-- argument: htmllibmanager_force_cq_url_info  (optional)
			-- 
			-- argument: htmllibmanager_defaultthemename  (optional)
			-- 
			-- argument: htmllibmanager_defaultuserthemename  (optional)
			-- 
			-- argument: htmllibmanager_clientmanager  (optional)
			-- 
			-- argument: htmllibmanager_path_list  (optional)
			-- 
			-- argument: htmllibmanager_excluded_path_list  (optional)
			-- 
			-- argument: htmllibmanager_processor_js  (optional)
			-- 
			-- argument: htmllibmanager_processor_css  (optional)
			-- 
			-- argument: htmllibmanager_longcache_patterns  (optional)
			-- 
			-- argument: htmllibmanager_longcache_format  (optional)
			-- 
			-- argument: htmllibmanager_use_file_system_output_cache  (optional)
			-- 
			-- argument: htmllibmanager_file_system_output_cache_location  (optional)
			-- 
			-- argument: htmllibmanager_disable_replacement  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_UI_CLIENTLIBS_IMPL_HTML_LIBRARY_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.ui.clientlibs.impl.HtmlLibraryManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.timing", htmllibmanager_timing));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.debug.init.js", htmllibmanager_debug_init_js));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.minify", htmllibmanager_minify));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.debug", htmllibmanager_debug));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.gzip", htmllibmanager_gzip));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.maxDataUriSize", htmllibmanager_max_data_uri_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.maxage", htmllibmanager_maxage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.forceCQUrlInfo", htmllibmanager_force_cq_url_info));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.defaultthemename", htmllibmanager_defaultthemename));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.defaultuserthemename", htmllibmanager_defaultuserthemename));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.clientmanager", htmllibmanager_clientmanager));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "htmllibmanager.path.list", htmllibmanager_path_list));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "htmllibmanager.excluded.path.list", htmllibmanager_excluded_path_list));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "htmllibmanager.processor.js", htmllibmanager_processor_js));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "htmllibmanager.processor.css", htmllibmanager_processor_css));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "htmllibmanager.longcache.patterns", htmllibmanager_longcache_patterns));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.longcache.format", htmllibmanager_longcache_format));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.useFileSystemOutputCache", htmllibmanager_use_file_system_output_cache));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.fileSystemOutputCacheLocation", htmllibmanager_file_system_output_cache_location));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "htmllibmanager.disable.replacement", htmllibmanager_disable_replacement));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_UI_CLIENTLIBS_IMPL_HTML_LIBRARY_MANAGER_IMPL_INFO } l_response.data ({ COM_ADOBE_GRANITE_UI_CLIENTLIBS_IMPL_HTML_LIBRARY_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_workflow_console_frags_workflow_withdraw_feature (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN): detachable COM_ADOBE_GRANITE_WORKFLOW_CONSOLE_FRAGS_WORKFLOW_WITHDRAW_FEATURE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_WORKFLOW_CONSOLE_FRAGS_WORKFLOW_WITHDRAW_FEATURE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.workflow.console.frags.WorkflowWithdrawFeature"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_WORKFLOW_CONSOLE_FRAGS_WORKFLOW_WITHDRAW_FEATURE_INFO } l_response.data ({ COM_ADOBE_GRANITE_WORKFLOW_CONSOLE_FRAGS_WORKFLOW_WITHDRAW_FEATURE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_workflow_console_publish_workflow_publish_event_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; granite_workflow__workflow_publish_event_service_enabled: BOOLEAN): detachable COM_ADOBE_GRANITE_WORKFLOW_CONSOLE_PUBLISH_WORKFLOW_PUBLISH_EVENT_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: granite_workflow__workflow_publish_event_service_enabled  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_WORKFLOW_CONSOLE_PUBLISH_WORKFLOW_PUBLISH_EVENT_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.workflow.console.publish.WorkflowPublishEventService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.workflow.WorkflowPublishEventService.enabled", granite_workflow__workflow_publish_event_service_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_WORKFLOW_CONSOLE_PUBLISH_WORKFLOW_PUBLISH_EVENT_SERVICE_INFO } l_response.data ({ COM_ADOBE_GRANITE_WORKFLOW_CONSOLE_PUBLISH_WORKFLOW_PUBLISH_EVENT_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_workflow_core_jcr_workflow_bucket_manager (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; bucket_size: INTEGER_32): detachable COM_ADOBE_GRANITE_WORKFLOW_CORE_JCR_WORKFLOW_BUCKET_MANAGER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: bucket_size  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_WORKFLOW_CORE_JCR_WORKFLOW_BUCKET_MANAGER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.workflow.core.jcr.WorkflowBucketManager"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "bucketSize", bucket_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_WORKFLOW_CORE_JCR_WORKFLOW_BUCKET_MANAGER_INFO } l_response.data ({ COM_ADOBE_GRANITE_WORKFLOW_CORE_JCR_WORKFLOW_BUCKET_MANAGER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_workflow_core_job_external_process_job_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; default_timeout: INTEGER_32; max_timeout: INTEGER_32; default_period: INTEGER_32): detachable COM_ADOBE_GRANITE_WORKFLOW_CORE_JOB_EXTERNAL_PROCESS_JOB_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: default_timeout  (optional)
			-- 
			-- argument: max_timeout  (optional)
			-- 
			-- argument: default_period  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_WORKFLOW_CORE_JOB_EXTERNAL_PROCESS_JOB_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.workflow.core.job.ExternalProcessJobHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.timeout", default_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "max.timeout", max_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.period", default_period));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_WORKFLOW_CORE_JOB_EXTERNAL_PROCESS_JOB_HANDLER_INFO } l_response.data ({ COM_ADOBE_GRANITE_WORKFLOW_CORE_JOB_EXTERNAL_PROCESS_JOB_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_workflow_core_job_job_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; job_topics: detachable LIST [STRING_32]; allow_self_process_termination: BOOLEAN): detachable COM_ADOBE_GRANITE_WORKFLOW_CORE_JOB_JOB_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: job_topics  (optional)
			-- 
			-- argument: allow_self_process_termination  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_WORKFLOW_CORE_JOB_JOB_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.workflow.core.job.JobHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "job.topics", job_topics));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "allow.self.process.termination", allow_self_process_termination));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_WORKFLOW_CORE_JOB_JOB_HANDLER_INFO } l_response.data ({ COM_ADOBE_GRANITE_WORKFLOW_CORE_JOB_JOB_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_workflow_core_offloading_workflow_offloading_job_consum (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; job_topics: STRING_32): detachable COM_ADOBE_GRANITE_WORKFLOW_CORE_OFFLOADING_WORKFLOW_OFFLOADING_JOB_CONSUM_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: job_topics  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_WORKFLOW_CORE_OFFLOADING_WORKFLOW_OFFLOADING_JOB_CONSUM_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.workflow.core.offloading.WorkflowOffloadingJobConsumer"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "job.topics", job_topics));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_WORKFLOW_CORE_OFFLOADING_WORKFLOW_OFFLOADING_JOB_CONSUM_INFO } l_response.data ({ COM_ADOBE_GRANITE_WORKFLOW_CORE_OFFLOADING_WORKFLOW_OFFLOADING_JOB_CONSUM_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_workflow_core_payload_map_cache (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; get_system_workflow_models: detachable LIST [STRING_32]; get_package_root_path: STRING_32): detachable COM_ADOBE_GRANITE_WORKFLOW_CORE_PAYLOAD_MAP_CACHE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: get_system_workflow_models  (optional)
			-- 
			-- argument: get_package_root_path  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_WORKFLOW_CORE_PAYLOAD_MAP_CACHE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.workflow.core.PayloadMapCache"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "getSystemWorkflowModels", get_system_workflow_models));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "getPackageRootPath", get_package_root_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_WORKFLOW_CORE_PAYLOAD_MAP_CACHE_INFO } l_response.data ({ COM_ADOBE_GRANITE_WORKFLOW_CORE_PAYLOAD_MAP_CACHE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_workflow_core_payloadmap_payload_move_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; payload_move_white_list: detachable LIST [STRING_32]; payload_move_handle_from_workflow_process: BOOLEAN): detachable COM_ADOBE_GRANITE_WORKFLOW_CORE_PAYLOADMAP_PAYLOAD_MOVE_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: payload_move_white_list  (optional)
			-- 
			-- argument: payload_move_handle_from_workflow_process  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_WORKFLOW_CORE_PAYLOADMAP_PAYLOAD_MOVE_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.workflow.core.payloadmap.PayloadMoveListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "payload.move.white.list", payload_move_white_list));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "payload.move.handle.from.workflow.process", payload_move_handle_from_workflow_process));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_WORKFLOW_CORE_PAYLOADMAP_PAYLOAD_MOVE_LISTENER_INFO } l_response.data ({ COM_ADOBE_GRANITE_WORKFLOW_CORE_PAYLOADMAP_PAYLOAD_MOVE_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_workflow_core_workflow_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_workflow_config_workflow_packages_root_path: detachable LIST [STRING_32]; cq_workflow_config_workflow_process_legacy_mode: BOOLEAN; cq_workflow_config_allow_locking: BOOLEAN): detachable COM_ADOBE_GRANITE_WORKFLOW_CORE_WORKFLOW_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_workflow_config_workflow_packages_root_path  (optional)
			-- 
			-- argument: cq_workflow_config_workflow_process_legacy_mode  (optional)
			-- 
			-- argument: cq_workflow_config_allow_locking  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_WORKFLOW_CORE_WORKFLOW_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.workflow.core.WorkflowConfig"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.workflow.config.workflow.packages.root.path", cq_workflow_config_workflow_packages_root_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.workflow.config.workflow.process.legacy.mode", cq_workflow_config_workflow_process_legacy_mode));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.workflow.config.allow.locking", cq_workflow_config_allow_locking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_WORKFLOW_CORE_WORKFLOW_CONFIG_INFO } l_response.data ({ COM_ADOBE_GRANITE_WORKFLOW_CORE_WORKFLOW_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_workflow_core_workflow_session_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; granite_workflowinbox_sort_property_name: STRING_32; granite_workflowinbox_sort_order: STRING_32; cq_workflow_job_retry: INTEGER_32; cq_workflow_superuser: detachable LIST [STRING_32]; granite_workflow_inbox_query_size: INTEGER_32; granite_workflow_admin_user_group_filter: BOOLEAN; granite_workflow_enforce_workitem_assignee_permissions: BOOLEAN; granite_workflow_enforce_workflow_initiator_permissions: BOOLEAN; granite_workflow_inject_tenant_id_in_job_topics: BOOLEAN; granite_workflow_max_purge_save_threshold: INTEGER_32; granite_workflow_max_purge_query_count: INTEGER_32): detachable COM_ADOBE_GRANITE_WORKFLOW_CORE_WORKFLOW_SESSION_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: granite_workflowinbox_sort_property_name  (optional)
			-- 
			-- argument: granite_workflowinbox_sort_order  (optional)
			-- 
			-- argument: cq_workflow_job_retry  (optional)
			-- 
			-- argument: cq_workflow_superuser  (optional)
			-- 
			-- argument: granite_workflow_inbox_query_size  (optional)
			-- 
			-- argument: granite_workflow_admin_user_group_filter  (optional)
			-- 
			-- argument: granite_workflow_enforce_workitem_assignee_permissions  (optional)
			-- 
			-- argument: granite_workflow_enforce_workflow_initiator_permissions  (optional)
			-- 
			-- argument: granite_workflow_inject_tenant_id_in_job_topics  (optional)
			-- 
			-- argument: granite_workflow_max_purge_save_threshold  (optional)
			-- 
			-- argument: granite_workflow_max_purge_query_count  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_WORKFLOW_CORE_WORKFLOW_SESSION_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.workflow.core.WorkflowSessionFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.workflowinbox.sort.propertyName", granite_workflowinbox_sort_property_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.workflowinbox.sort.order", granite_workflowinbox_sort_order));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.workflow.job.retry", cq_workflow_job_retry));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.workflow.superuser", cq_workflow_superuser));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.workflow.inboxQuerySize", granite_workflow_inbox_query_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.workflow.adminUserGroupFilter", granite_workflow_admin_user_group_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.workflow.enforceWorkitemAssigneePermissions", granite_workflow_enforce_workitem_assignee_permissions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.workflow.enforceWorkflowInitiatorPermissions", granite_workflow_enforce_workflow_initiator_permissions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.workflow.injectTenantIdInJobTopics", granite_workflow_inject_tenant_id_in_job_topics));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.workflow.maxPurgeSaveThreshold", granite_workflow_max_purge_save_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "granite.workflow.maxPurgeQueryCount", granite_workflow_max_purge_query_count));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_WORKFLOW_CORE_WORKFLOW_SESSION_FACTORY_INFO } l_response.data ({ COM_ADOBE_GRANITE_WORKFLOW_CORE_WORKFLOW_SESSION_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_granite_workflow_purge_scheduler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduledpurge_name: STRING_32; scheduledpurge_workflow_status: STRING_32; scheduledpurge_model_ids: detachable LIST [STRING_32]; scheduledpurge_daysold: INTEGER_32): detachable COM_ADOBE_GRANITE_WORKFLOW_PURGE_SCHEDULER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduledpurge_name  (optional)
			-- 
			-- argument: scheduledpurge_workflow_status  (optional)
			-- 
			-- argument: scheduledpurge_model_ids  (optional)
			-- 
			-- argument: scheduledpurge_daysold  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_GRANITE_WORKFLOW_PURGE_SCHEDULER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.granite.workflow.purge.Scheduler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduledpurge.name", scheduledpurge_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduledpurge.workflowStatus", scheduledpurge_workflow_status));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "scheduledpurge.modelIds", scheduledpurge_model_ids));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduledpurge.daysold", scheduledpurge_daysold));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_GRANITE_WORKFLOW_PURGE_SCHEDULER_INFO } l_response.data ({ COM_ADOBE_GRANITE_WORKFLOW_PURGE_SCHEDULER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_octopus_ncomm_bootstrap (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_connections: INTEGER_32; max_requests: INTEGER_32; request_timeout: INTEGER_32; request_retries: INTEGER_32; launch_timeout: INTEGER_32): detachable COM_ADOBE_OCTOPUS_NCOMM_BOOTSTRAP_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_connections  (optional)
			-- 
			-- argument: max_requests  (optional)
			-- 
			-- argument: request_timeout  (optional)
			-- 
			-- argument: request_retries  (optional)
			-- 
			-- argument: launch_timeout  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_OCTOPUS_NCOMM_BOOTSTRAP_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.octopus.ncomm.bootstrap"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxConnections", max_connections));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxRequests", max_requests));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "requestTimeout", request_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "requestRetries", request_retries));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "launchTimeout", launch_timeout));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_OCTOPUS_NCOMM_BOOTSTRAP_INFO } l_response.data ({ COM_ADOBE_OCTOPUS_NCOMM_BOOTSTRAP_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_social_integrations_livefyre_user_pingforpull_impl_ping_pull_s (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; communities_integration_livefyre_sling_event_filter: STRING_32): detachable COM_ADOBE_SOCIAL_INTEGRATIONS_LIVEFYRE_USER_PINGFORPULL_IMPL_PING_PULL_S_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: communities_integration_livefyre_sling_event_filter  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_SOCIAL_INTEGRATIONS_LIVEFYRE_USER_PINGFORPULL_IMPL_PING_PULL_S_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.social.integrations.livefyre.user.pingforpull.impl.PingPullServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "communities.integration.livefyre.sling.event.filter", communities_integration_livefyre_sling_event_filter));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_SOCIAL_INTEGRATIONS_LIVEFYRE_USER_PINGFORPULL_IMPL_PING_PULL_S_INFO } l_response.data ({ COM_ADOBE_SOCIAL_INTEGRATIONS_LIVEFYRE_USER_PINGFORPULL_IMPL_PING_PULL_S_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_adobe_xmp_worker_files_ncomm_xm_pfiles_ncomm (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_connections: STRING_32; max_requests: STRING_32; request_timeout: STRING_32; log_dir: STRING_32): detachable COM_ADOBE_XMP_WORKER_FILES_NCOMM_XMP_FILES_N_COMM_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_connections  (optional)
			-- 
			-- argument: max_requests  (optional)
			-- 
			-- argument: request_timeout  (optional)
			-- 
			-- argument: log_dir  (optional)
			-- 
			-- 
			-- Result COM_ADOBE_XMP_WORKER_FILES_NCOMM_XMP_FILES_N_COMM_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.adobe.xmp.worker.files.ncomm.XMPFilesNComm"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxConnections", max_connections));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxRequests", max_requests));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "requestTimeout", request_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "logDir", log_dir));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_ADOBE_XMP_WORKER_FILES_NCOMM_XMP_FILES_N_COMM_INFO } l_response.data ({ COM_ADOBE_XMP_WORKER_FILES_NCOMM_XMP_FILES_N_COMM_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_commons_datasource_jdbcpool_jdbc_pool_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; jdbc_driver_class: STRING_32; jdbc_connection_uri: STRING_32; jdbc_username: STRING_32; jdbc_password: STRING_32; jdbc_validation_query: STRING_32; default_readonly: BOOLEAN; default_autocommit: BOOLEAN; pool_size: INTEGER_32; pool_max_wait_msec: INTEGER_32; datasource_name: STRING_32; datasource_svc_properties: detachable LIST [STRING_32]): detachable COM_DAY_COMMONS_DATASOURCE_JDBCPOOL_JDBC_POOL_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: jdbc_driver_class  (optional)
			-- 
			-- argument: jdbc_connection_uri  (optional)
			-- 
			-- argument: jdbc_username  (optional)
			-- 
			-- argument: jdbc_password  (optional)
			-- 
			-- argument: jdbc_validation_query  (optional)
			-- 
			-- argument: default_readonly  (optional)
			-- 
			-- argument: default_autocommit  (optional)
			-- 
			-- argument: pool_size  (optional)
			-- 
			-- argument: pool_max_wait_msec  (optional)
			-- 
			-- argument: datasource_name  (optional)
			-- 
			-- argument: datasource_svc_properties  (optional)
			-- 
			-- 
			-- Result COM_DAY_COMMONS_DATASOURCE_JDBCPOOL_JDBC_POOL_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.commons.datasource.jdbcpool.JdbcPoolService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jdbc.driver.class", jdbc_driver_class));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jdbc.connection.uri", jdbc_connection_uri));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jdbc.username", jdbc_username));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jdbc.password", jdbc_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jdbc.validation.query", jdbc_validation_query));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.readonly", default_readonly));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.autocommit", default_autocommit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool.size", pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool.max.wait.msec", pool_max_wait_msec));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "datasource.name", datasource_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "datasource.svc.properties", datasource_svc_properties));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_COMMONS_DATASOURCE_JDBCPOOL_JDBC_POOL_SERVICE_INFO } l_response.data ({ COM_DAY_COMMONS_DATASOURCE_JDBCPOOL_JDBC_POOL_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_commons_httpclient (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; proxy_enabled: BOOLEAN; proxy_host: STRING_32; proxy_user: STRING_32; proxy_password: STRING_32; proxy_ntlm_host: STRING_32; proxy_ntlm_domain: STRING_32; proxy_exceptions: detachable LIST [STRING_32]): detachable COM_DAY_COMMONS_HTTPCLIENT_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: proxy_enabled  (optional)
			-- 
			-- argument: proxy_host  (optional)
			-- 
			-- argument: proxy_user  (optional)
			-- 
			-- argument: proxy_password  (optional)
			-- 
			-- argument: proxy_ntlm_host  (optional)
			-- 
			-- argument: proxy_ntlm_domain  (optional)
			-- 
			-- argument: proxy_exceptions  (optional)
			-- 
			-- 
			-- Result COM_DAY_COMMONS_HTTPCLIENT_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.commons.httpclient"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.enabled", proxy_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.host", proxy_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.user", proxy_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.password", proxy_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.ntlm.host", proxy_ntlm_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.ntlm.domain", proxy_ntlm_domain));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "proxy.exceptions", proxy_exceptions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_COMMONS_HTTPCLIENT_INFO } l_response.data ({ COM_DAY_COMMONS_HTTPCLIENT_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_analytics_impl_store_properties_change_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_store_listener_additional_store_paths: detachable LIST [STRING_32]): detachable COM_DAY_CQ_ANALYTICS_IMPL_STORE_PROPERTIES_CHANGE_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_store_listener_additional_store_paths  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_ANALYTICS_IMPL_STORE_PROPERTIES_CHANGE_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.analytics.impl.StorePropertiesChangeListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.store.listener.additionalStorePaths", cq_store_listener_additional_store_paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_ANALYTICS_IMPL_STORE_PROPERTIES_CHANGE_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_ANALYTICS_IMPL_STORE_PROPERTIES_CHANGE_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_analytics_sitecatalyst_impl_exporter_classifications_exporte (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; allowed_paths: detachable LIST [STRING_32]; cq_analytics_saint_exporter_pagesize: INTEGER_32): detachable COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_EXPORTER_CLASSIFICATIONS_EXPORTE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: allowed_paths  (optional)
			-- 
			-- argument: cq_analytics_saint_exporter_pagesize  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_EXPORTER_CLASSIFICATIONS_EXPORTE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.exporter.ClassificationsExporter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "allowed.paths", allowed_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.analytics.saint.exporter.pagesize", cq_analytics_saint_exporter_pagesize));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_EXPORTER_CLASSIFICATIONS_EXPORTE_INFO } l_response.data ({ COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_EXPORTER_CLASSIFICATIONS_EXPORTE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_analytics_sitecatalyst_impl_importer_report_importer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; report_fetch_attempts: INTEGER_32; report_fetch_delay: INTEGER_32): detachable COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_IMPORTER_REPORT_IMPORTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: report_fetch_attempts  (optional)
			-- 
			-- argument: report_fetch_delay  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_IMPORTER_REPORT_IMPORTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.importer.ReportImporter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "report.fetch.attempts", report_fetch_attempts));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "report.fetch.delay", report_fetch_delay));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_IMPORTER_REPORT_IMPORTER_INFO } l_response.data ({ COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_IMPORTER_REPORT_IMPORTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_analytics_sitecatalyst_impl_sitecatalyst_adapter_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_analytics_adapterfactory_contextstores: detachable LIST [STRING_32]): detachable COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_SITECATALYST_ADAPTER_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_analytics_adapterfactory_contextstores  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_SITECATALYST_ADAPTER_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.SitecatalystAdapterFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.analytics.adapterfactory.contextstores", cq_analytics_adapterfactory_contextstores));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_SITECATALYST_ADAPTER_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_SITECATALYST_ADAPTER_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_analytics_sitecatalyst_impl_sitecatalyst_http_client_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_analytics_sitecatalyst_service_datacenter_url: detachable LIST [STRING_32]; devhostnamepatterns: detachable LIST [STRING_32]; connection_timeout: INTEGER_32; socket_timeout: INTEGER_32): detachable COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_SITECATALYST_HTTP_CLIENT_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_analytics_sitecatalyst_service_datacenter_url  (optional)
			-- 
			-- argument: devhostnamepatterns  (optional)
			-- 
			-- argument: connection_timeout  (optional)
			-- 
			-- argument: socket_timeout  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_SITECATALYST_HTTP_CLIENT_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.SitecatalystHttpClientImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.analytics.sitecatalyst.service.datacenter.url", cq_analytics_sitecatalyst_service_datacenter_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "devhostnamepatterns", devhostnamepatterns));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connection.timeout", connection_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "socket.timeout", socket_timeout));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_SITECATALYST_HTTP_CLIENT_IMPL_INFO } l_response.data ({ COM_DAY_CQ_ANALYTICS_SITECATALYST_IMPL_SITECATALYST_HTTP_CLIENT_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_analytics_testandtarget_impl_account_options_updater (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_analytics_testandtarget_accountoptionsupdater_enabled: BOOLEAN): detachable COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_ACCOUNT_OPTIONS_UPDATER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_analytics_testandtarget_accountoptionsupdater_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_ACCOUNT_OPTIONS_UPDATER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.AccountOptionsUpdater"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.analytics.testandtarget.accountoptionsupdater.enabled", cq_analytics_testandtarget_accountoptionsupdater_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_ACCOUNT_OPTIONS_UPDATER_INFO } l_response.data ({ COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_ACCOUNT_OPTIONS_UPDATER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_analytics_testandtarget_impl_delete_author_activity_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_analytics_testandtarget_deleteauthoractivitylistener_enabled: BOOLEAN): detachable COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_DELETE_AUTHOR_ACTIVITY_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_analytics_testandtarget_deleteauthoractivitylistener_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_DELETE_AUTHOR_ACTIVITY_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.DeleteAuthorActivityListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.analytics.testandtarget.deleteauthoractivitylistener.enabled", cq_analytics_testandtarget_deleteauthoractivitylistener_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_DELETE_AUTHOR_ACTIVITY_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_DELETE_AUTHOR_ACTIVITY_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_analytics_testandtarget_impl_push_author_campaign_page_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_analytics_testandtarget_pushauthorcampaignpagelistener_enabled: BOOLEAN): detachable COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_PUSH_AUTHOR_CAMPAIGN_PAGE_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_analytics_testandtarget_pushauthorcampaignpagelistener_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_PUSH_AUTHOR_CAMPAIGN_PAGE_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.PushAuthorCampaignPageListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.analytics.testandtarget.pushauthorcampaignpagelistener.enabled", cq_analytics_testandtarget_pushauthorcampaignpagelistener_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_PUSH_AUTHOR_CAMPAIGN_PAGE_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_PUSH_AUTHOR_CAMPAIGN_PAGE_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_analytics_testandtarget_impl_segment_importer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_analytics_testandtarget_segmentimporter_enabled: BOOLEAN): detachable COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_SEGMENT_IMPORTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_analytics_testandtarget_segmentimporter_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_SEGMENT_IMPORTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.SegmentImporter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.analytics.testandtarget.segmentimporter.enabled", cq_analytics_testandtarget_segmentimporter_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_SEGMENT_IMPORTER_INFO } l_response.data ({ COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_SEGMENT_IMPORTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_analytics_testandtarget_impl_service_web_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; endpoint_uri: STRING_32; connection_timeout: INTEGER_32; socket_timeout: INTEGER_32): detachable COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_SERVICE_WEB_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: endpoint_uri  (optional)
			-- 
			-- argument: connection_timeout  (optional)
			-- 
			-- argument: socket_timeout  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_SERVICE_WEB_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.service.WebServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endpointUri", endpoint_uri));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connectionTimeout", connection_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "socketTimeout", socket_timeout));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_SERVICE_WEB_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_SERVICE_WEB_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_analytics_testandtarget_impl_servlets_admin_server_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; testandtarget_endpoint_url: STRING_32): detachable COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_SERVLETS_ADMIN_SERVER_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: testandtarget_endpoint_url  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_SERVLETS_ADMIN_SERVER_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.servlets.AdminServerServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "testandtarget.endpoint.url", testandtarget_endpoint_url));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_SERVLETS_ADMIN_SERVER_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_SERVLETS_ADMIN_SERVER_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_analytics_testandtarget_impl_testandtarget_http_client_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_analytics_testandtarget_api_url: STRING_32; cq_analytics_testandtarget_timeout: INTEGER_32; cq_analytics_testandtarget_sockettimeout: INTEGER_32; cq_analytics_testandtarget_recommendations_url_replace: STRING_32; cq_analytics_testandtarget_recommendations_url_replacewith: STRING_32): detachable COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_TESTANDTARGET_HTTP_CLIENT_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_analytics_testandtarget_api_url  (optional)
			-- 
			-- argument: cq_analytics_testandtarget_timeout  (optional)
			-- 
			-- argument: cq_analytics_testandtarget_sockettimeout  (optional)
			-- 
			-- argument: cq_analytics_testandtarget_recommendations_url_replace  (optional)
			-- 
			-- argument: cq_analytics_testandtarget_recommendations_url_replacewith  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_TESTANDTARGET_HTTP_CLIENT_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.TestandtargetHttpClientImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.analytics.testandtarget.api.url", cq_analytics_testandtarget_api_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.analytics.testandtarget.timeout", cq_analytics_testandtarget_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.analytics.testandtarget.sockettimeout", cq_analytics_testandtarget_sockettimeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.analytics.testandtarget.recommendations.url.replace", cq_analytics_testandtarget_recommendations_url_replace));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.analytics.testandtarget.recommendations.url.replacewith", cq_analytics_testandtarget_recommendations_url_replacewith));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_TESTANDTARGET_HTTP_CLIENT_IMPL_INFO } l_response.data ({ COM_DAY_CQ_ANALYTICS_TESTANDTARGET_IMPL_TESTANDTARGET_HTTP_CLIENT_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_auth_impl_cug_cug_support_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cug_exempted_principals: detachable LIST [STRING_32]; cug_enabled: BOOLEAN; cug_principals_regex: STRING_32; cug_principals_replacement: STRING_32): detachable COM_DAY_CQ_AUTH_IMPL_CUG_CUG_SUPPORT_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cug_exempted_principals  (optional)
			-- 
			-- argument: cug_enabled  (optional)
			-- 
			-- argument: cug_principals_regex  (optional)
			-- 
			-- argument: cug_principals_replacement  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_AUTH_IMPL_CUG_CUG_SUPPORT_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.auth.impl.cug.CugSupportImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cug.exempted.principals", cug_exempted_principals));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cug.enabled", cug_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cug.principals.regex", cug_principals_regex));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cug.principals.replacement", cug_principals_replacement));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_AUTH_IMPL_CUG_CUG_SUPPORT_IMPL_INFO } l_response.data ({ COM_DAY_CQ_AUTH_IMPL_CUG_CUG_SUPPORT_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_auth_impl_login_selector_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path: STRING_32; service_ranking: INTEGER_32; auth_loginselector_mappings: detachable LIST [STRING_32]; auth_loginselector_changepw_mappings: detachable LIST [STRING_32]; auth_loginselector_defaultloginpage: STRING_32; auth_loginselector_defaultchangepwpage: STRING_32; auth_loginselector_handle: detachable LIST [STRING_32]; auth_loginselector_handle_all_extensions: BOOLEAN): detachable COM_DAY_CQ_AUTH_IMPL_LOGIN_SELECTOR_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: auth_loginselector_mappings  (optional)
			-- 
			-- argument: auth_loginselector_changepw_mappings  (optional)
			-- 
			-- argument: auth_loginselector_defaultloginpage  (optional)
			-- 
			-- argument: auth_loginselector_defaultchangepwpage  (optional)
			-- 
			-- argument: auth_loginselector_handle  (optional)
			-- 
			-- argument: auth_loginselector_handle_all_extensions  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_AUTH_IMPL_LOGIN_SELECTOR_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.auth.impl.LoginSelectorHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "auth.loginselector.mappings", auth_loginselector_mappings));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "auth.loginselector.changepw.mappings", auth_loginselector_changepw_mappings));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.loginselector.defaultloginpage", auth_loginselector_defaultloginpage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.loginselector.defaultchangepwpage", auth_loginselector_defaultchangepwpage));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "auth.loginselector.handle", auth_loginselector_handle));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.loginselector.handle.all.extensions", auth_loginselector_handle_all_extensions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_AUTH_IMPL_LOGIN_SELECTOR_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_AUTH_IMPL_LOGIN_SELECTOR_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_commons_impl_externalizer_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; externalizer_domains: detachable LIST [STRING_32]; externalizer_host: STRING_32; externalizer_contextpath: STRING_32; externalizer_encodedpath: BOOLEAN): detachable COM_DAY_CQ_COMMONS_IMPL_EXTERNALIZER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: externalizer_domains  (optional)
			-- 
			-- argument: externalizer_host  (optional)
			-- 
			-- argument: externalizer_contextpath  (optional)
			-- 
			-- argument: externalizer_encodedpath  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_COMMONS_IMPL_EXTERNALIZER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.commons.impl.ExternalizerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "externalizer.domains", externalizer_domains));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "externalizer.host", externalizer_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "externalizer.contextpath", externalizer_contextpath));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "externalizer.encodedpath", externalizer_encodedpath));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_COMMONS_IMPL_EXTERNALIZER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_COMMONS_IMPL_EXTERNALIZER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_commons_servlets_root_mapping_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; rootmapping_target: STRING_32): detachable COM_DAY_CQ_COMMONS_SERVLETS_ROOT_MAPPING_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: rootmapping_target  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_COMMONS_SERVLETS_ROOT_MAPPING_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.commons.servlets.RootMappingServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "rootmapping.target", rootmapping_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_COMMONS_SERVLETS_ROOT_MAPPING_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_COMMONS_SERVLETS_ROOT_MAPPING_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_compat_codeupgrade_impl_code_upgrade_execution_condition_checke (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; codeupgradetasks: detachable LIST [STRING_32]; codeupgradetaskfilters: detachable LIST [STRING_32]): detachable COM_DAY_CQ_COMPAT_CODEUPGRADE_IMPL_CODE_UPGRADE_EXECUTION_CONDITION_CHECKE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: codeupgradetasks  (optional)
			-- 
			-- argument: codeupgradetaskfilters  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_COMPAT_CODEUPGRADE_IMPL_CODE_UPGRADE_EXECUTION_CONDITION_CHECKE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.CodeUpgradeExecutionConditionChecker"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "codeupgradetasks", codeupgradetasks));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "codeupgradetaskfilters", codeupgradetaskfilters));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_COMPAT_CODEUPGRADE_IMPL_CODE_UPGRADE_EXECUTION_CONDITION_CHECKE_INFO } l_response.data ({ COM_DAY_CQ_COMPAT_CODEUPGRADE_IMPL_CODE_UPGRADE_EXECUTION_CONDITION_CHECKE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_compat_codeupgrade_impl_upgrade_task_ignore_list (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; upgrade_task_ignore_list: detachable LIST [STRING_32]): detachable COM_DAY_CQ_COMPAT_CODEUPGRADE_IMPL_UPGRADE_TASK_IGNORE_LIST_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: upgrade_task_ignore_list  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_COMPAT_CODEUPGRADE_IMPL_UPGRADE_TASK_IGNORE_LIST_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.UpgradeTaskIgnoreList"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "upgradeTaskIgnoreList", upgrade_task_ignore_list));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_COMPAT_CODEUPGRADE_IMPL_UPGRADE_TASK_IGNORE_LIST_INFO } l_response.data ({ COM_DAY_CQ_COMPAT_CODEUPGRADE_IMPL_UPGRADE_TASK_IGNORE_LIST_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_compat_codeupgrade_impl_version_range_task_ignorelist (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; effective_bundle_list_path: STRING_32): detachable COM_DAY_CQ_COMPAT_CODEUPGRADE_IMPL_VERSION_RANGE_TASK_IGNORELIST_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: effective_bundle_list_path  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_COMPAT_CODEUPGRADE_IMPL_VERSION_RANGE_TASK_IGNORELIST_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.VersionRangeTaskIgnorelist"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "effectiveBundleListPath", effective_bundle_list_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_COMPAT_CODEUPGRADE_IMPL_VERSION_RANGE_TASK_IGNORELIST_INFO } l_response.data ({ COM_DAY_CQ_COMPAT_CODEUPGRADE_IMPL_VERSION_RANGE_TASK_IGNORELIST_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_contentsync_impl_content_sync_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; contentsync_fallback_authorizable: STRING_32; contentsync_fallback_updateuser: STRING_32): detachable COM_DAY_CQ_CONTENTSYNC_IMPL_CONTENT_SYNC_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: contentsync_fallback_authorizable  (optional)
			-- 
			-- argument: contentsync_fallback_updateuser  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_CONTENTSYNC_IMPL_CONTENT_SYNC_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.contentsync.impl.ContentSyncManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "contentsync.fallback.authorizable", contentsync_fallback_authorizable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "contentsync.fallback.updateuser", contentsync_fallback_updateuser));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_CONTENTSYNC_IMPL_CONTENT_SYNC_MANAGER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_CONTENTSYNC_IMPL_CONTENT_SYNC_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_commons_handler_standard_image_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; large_file_threshold: INTEGER_32; large_comment_threshold: INTEGER_32; cq_dam_enable_ext_meta_extraction: BOOLEAN): detachable COM_DAY_CQ_DAM_COMMONS_HANDLER_STANDARD_IMAGE_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: large_file_threshold  (optional)
			-- 
			-- argument: large_comment_threshold  (optional)
			-- 
			-- argument: cq_dam_enable_ext_meta_extraction  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_COMMONS_HANDLER_STANDARD_IMAGE_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.commons.handler.StandardImageHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "large_file_threshold", large_file_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "large_comment_threshold", large_comment_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.enable.ext.meta.extraction", cq_dam_enable_ext_meta_extraction));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_COMMONS_HANDLER_STANDARD_IMAGE_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_DAM_COMMONS_HANDLER_STANDARD_IMAGE_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_commons_metadata_xmp_filter_black_white (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; xmp_filter_apply_whitelist: BOOLEAN; xmp_filter_whitelist: detachable LIST [STRING_32]; xmp_filter_apply_blacklist: BOOLEAN; xmp_filter_blacklist: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_COMMONS_METADATA_XMP_FILTER_BLACK_WHITE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: xmp_filter_apply_whitelist  (optional)
			-- 
			-- argument: xmp_filter_whitelist  (optional)
			-- 
			-- argument: xmp_filter_apply_blacklist  (optional)
			-- 
			-- argument: xmp_filter_blacklist  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_COMMONS_METADATA_XMP_FILTER_BLACK_WHITE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.commons.metadata.XmpFilterBlackWhite"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "xmp.filter.apply_whitelist", xmp_filter_apply_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "xmp.filter.whitelist", xmp_filter_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "xmp.filter.apply_blacklist", xmp_filter_apply_blacklist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "xmp.filter.blacklist", xmp_filter_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_COMMONS_METADATA_XMP_FILTER_BLACK_WHITE_INFO } l_response.data ({ COM_DAY_CQ_DAM_COMMONS_METADATA_XMP_FILTER_BLACK_WHITE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_commons_util_impl_asset_cache_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; large_file_min: INTEGER_32; cache_apply: BOOLEAN; mime_types: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_COMMONS_UTIL_IMPL_ASSET_CACHE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: large_file_min  (optional)
			-- 
			-- argument: cache_apply  (optional)
			-- 
			-- argument: mime_types  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_COMMONS_UTIL_IMPL_ASSET_CACHE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.commons.util.impl.AssetCacheImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "large.file.min", large_file_min));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.apply", cache_apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "mime.types", mime_types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_COMMONS_UTIL_IMPL_ASSET_CACHE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_COMMONS_UTIL_IMPL_ASSET_CACHE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_annotation_pdf_annotation_pdf_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_config_annotation_pdf_document_width: INTEGER_32; cq_dam_config_annotation_pdf_document_height: INTEGER_32; cq_dam_config_annotation_pdf_document_padding_horizontal: INTEGER_32; cq_dam_config_annotation_pdf_document_padding_vertical: INTEGER_32; cq_dam_config_annotation_pdf_font_size: INTEGER_32; cq_dam_config_annotation_pdf_font_color: STRING_32; cq_dam_config_annotation_pdf_font_family: STRING_32; cq_dam_config_annotation_pdf_font_light: STRING_32; cq_dam_config_annotation_pdf_margin_text_image: INTEGER_32; cq_dam_config_annotation_pdf_min_image_height: INTEGER_32; cq_dam_config_annotation_pdf_review_status_width: INTEGER_32; cq_dam_config_annotation_pdf_review_status_color_approved: STRING_32; cq_dam_config_annotation_pdf_review_status_color_rejected: STRING_32; cq_dam_config_annotation_pdf_review_status_color_changes_requested: STRING_32; cq_dam_config_annotation_pdf_annotation_marker_width: INTEGER_32; cq_dam_config_annotation_pdf_asset_minheight: INTEGER_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_ANNOTATION_PDF_ANNOTATION_PDF_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_document_width  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_document_height  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_document_padding_horizontal  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_document_padding_vertical  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_font_size  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_font_color  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_font_family  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_font_light  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_margin_text_image  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_min_image_height  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_review_status_width  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_review_status_color_approved  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_review_status_color_rejected  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_review_status_color_changes_requested  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_annotation_marker_width  (optional)
			-- 
			-- argument: cq_dam_config_annotation_pdf_asset_minheight  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_ANNOTATION_PDF_ANNOTATION_PDF_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.annotation.pdf.AnnotationPdfConfig"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.document.width", cq_dam_config_annotation_pdf_document_width));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.document.height", cq_dam_config_annotation_pdf_document_height));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.document.padding.horizontal", cq_dam_config_annotation_pdf_document_padding_horizontal));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.document.padding.vertical", cq_dam_config_annotation_pdf_document_padding_vertical));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.font.size", cq_dam_config_annotation_pdf_font_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.font.color", cq_dam_config_annotation_pdf_font_color));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.font.family", cq_dam_config_annotation_pdf_font_family));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.font.light", cq_dam_config_annotation_pdf_font_light));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.marginTextImage", cq_dam_config_annotation_pdf_margin_text_image));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.minImageHeight", cq_dam_config_annotation_pdf_min_image_height));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.reviewStatus.width", cq_dam_config_annotation_pdf_review_status_width));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.reviewStatus.color.approved", cq_dam_config_annotation_pdf_review_status_color_approved));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.reviewStatus.color.rejected", cq_dam_config_annotation_pdf_review_status_color_rejected));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.reviewStatus.color.changesRequested", cq_dam_config_annotation_pdf_review_status_color_changes_requested));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.annotationMarker.width", cq_dam_config_annotation_pdf_annotation_marker_width));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.annotation.pdf.asset.minheight", cq_dam_config_annotation_pdf_asset_minheight));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_ANNOTATION_PDF_ANNOTATION_PDF_CONFIG_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_ANNOTATION_PDF_ANNOTATION_PDF_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_asset_move_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_ASSET_MOVE_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_ASSET_MOVE_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.AssetMoveListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_ASSET_MOVE_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_ASSET_MOVE_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_assethome_asset_home_page_configuration (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; is_enabled: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_ASSETHOME_ASSET_HOME_PAGE_CONFIGURATION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: is_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_ASSETHOME_ASSET_HOME_PAGE_CONFIGURATION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.assethome.AssetHomePageConfiguration"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "isEnabled", is_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_ASSETHOME_ASSET_HOME_PAGE_CONFIGURATION_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_ASSETHOME_ASSET_HOME_PAGE_CONFIGURATION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_assetlinkshare_adhoc_asset_share_proxy_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_adhoc_asset_share_prezip_maxcontentsize: INTEGER_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_ASSETLINKSHARE_ADHOC_ASSET_SHARE_PROXY_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_adhoc_asset_share_prezip_maxcontentsize  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_ASSETLINKSHARE_ADHOC_ASSET_SHARE_PROXY_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.assetlinkshare.AdhocAssetShareProxyServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.adhoc.asset.share.prezip.maxcontentsize", cq_dam_adhoc_asset_share_prezip_maxcontentsize));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_ASSETLINKSHARE_ADHOC_ASSET_SHARE_PROXY_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_ASSETLINKSHARE_ADHOC_ASSET_SHARE_PROXY_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_cache_cq_buffered_image_cache (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_image_cache_max_memory: INTEGER_32; cq_dam_image_cache_max_age: INTEGER_32; cq_dam_image_cache_max_dimension: STRING_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_CACHE_CQ_BUFFERED_IMAGE_CACHE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_image_cache_max_memory  (optional)
			-- 
			-- argument: cq_dam_image_cache_max_age  (optional)
			-- 
			-- argument: cq_dam_image_cache_max_dimension  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_CACHE_CQ_BUFFERED_IMAGE_CACHE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.cache.CQBufferedImageCache"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.image.cache.max.memory", cq_dam_image_cache_max_memory));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.image.cache.max.age", cq_dam_image_cache_max_age));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.image.cache.max.dimension", cq_dam_image_cache_max_dimension));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_CACHE_CQ_BUFFERED_IMAGE_CACHE_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_CACHE_CQ_BUFFERED_IMAGE_CACHE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_dam_change_event_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; changeeventlistener_observed_paths: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_CORE_IMPL_DAM_CHANGE_EVENT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: changeeventlistener_observed_paths  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_DAM_CHANGE_EVENT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.DamChangeEventListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "changeeventlistener.observed.paths", changeeventlistener_observed_paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_DAM_CHANGE_EVENT_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_DAM_CHANGE_EVENT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_dam_event_purge_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_expression: STRING_32; max_saved_activities: INTEGER_32; save_interval: INTEGER_32; enable_activity_purge: BOOLEAN; event_types: STRING_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_DAM_EVENT_PURGE_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- argument: max_saved_activities  (optional)
			-- 
			-- argument: save_interval  (optional)
			-- 
			-- argument: enable_activity_purge  (optional)
			-- 
			-- argument: event_types  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_DAM_EVENT_PURGE_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.DamEventPurgeService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxSavedActivities", max_saved_activities));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "saveInterval", save_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableActivityPurge", enable_activity_purge));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "eventTypes", event_types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_DAM_EVENT_PURGE_SERVICE_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_DAM_EVENT_PURGE_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_dam_event_recorder_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_filter: STRING_32; event_queue_length: INTEGER_32; eventrecorder_enabled: BOOLEAN; eventrecorder_blacklist: detachable LIST [STRING_32]; eventrecorder_eventtypes: STRING_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_DAM_EVENT_RECORDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- argument: event_queue_length  (optional)
			-- 
			-- argument: eventrecorder_enabled  (optional)
			-- 
			-- argument: eventrecorder_blacklist  (optional)
			-- 
			-- argument: eventrecorder_eventtypes  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_DAM_EVENT_RECORDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.DamEventRecorderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.queue.length", event_queue_length));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "eventrecorder.enabled", eventrecorder_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "eventrecorder.blacklist", eventrecorder_blacklist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "eventrecorder.eventtypes", eventrecorder_eventtypes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_DAM_EVENT_RECORDER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_DAM_EVENT_RECORDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_event_dam_event_audit_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_filter: STRING_32; enabled: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_EVENT_DAM_EVENT_AUDIT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_EVENT_DAM_EVENT_AUDIT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.event.DamEventAuditListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_EVENT_DAM_EVENT_AUDIT_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_EVENT_DAM_EVENT_AUDIT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_expiry_notification_job_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_expiry_notification_scheduler_istimebased: BOOLEAN; cq_dam_expiry_notification_scheduler_timebased_rule: STRING_32; cq_dam_expiry_notification_scheduler_period_rule: INTEGER_32; send_email: BOOLEAN; asset_expired_limit: INTEGER_32; prior_notification_seconds: INTEGER_32; cq_dam_expiry_notification_url_protocol: STRING_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_EXPIRY_NOTIFICATION_JOB_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_expiry_notification_scheduler_istimebased  (optional)
			-- 
			-- argument: cq_dam_expiry_notification_scheduler_timebased_rule  (optional)
			-- 
			-- argument: cq_dam_expiry_notification_scheduler_period_rule  (optional)
			-- 
			-- argument: send_email  (optional)
			-- 
			-- argument: asset_expired_limit  (optional)
			-- 
			-- argument: prior_notification_seconds  (optional)
			-- 
			-- argument: cq_dam_expiry_notification_url_protocol  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_EXPIRY_NOTIFICATION_JOB_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.ExpiryNotificationJobImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.expiry.notification.scheduler.istimebased", cq_dam_expiry_notification_scheduler_istimebased));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.expiry.notification.scheduler.timebased.rule", cq_dam_expiry_notification_scheduler_timebased_rule));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.expiry.notification.scheduler.period.rule", cq_dam_expiry_notification_scheduler_period_rule));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "send_email", send_email));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "asset_expired_limit", asset_expired_limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "prior_notification_seconds", prior_notification_seconds));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.expiry.notification.url.protocol", cq_dam_expiry_notification_url_protocol));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_EXPIRY_NOTIFICATION_JOB_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_EXPIRY_NOTIFICATION_JOB_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_foldermetadataschema_folder_metadata_schema_feat (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; is_enabled: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_FOLDERMETADATASCHEMA_FOLDER_METADATA_SCHEMA_FEAT_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: is_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_FOLDERMETADATASCHEMA_FOLDER_METADATA_SCHEMA_FEAT_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.foldermetadataschema.FolderMetadataSchemaFeatureFlag"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "isEnabled", is_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_FOLDERMETADATASCHEMA_FOLDER_METADATA_SCHEMA_FEAT_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_FOLDERMETADATASCHEMA_FOLDER_METADATA_SCHEMA_FEAT_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_gfx_commons_gfx_renderer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; skip_bufferedcache: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_GFX_COMMONS_GFX_RENDERER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: skip_bufferedcache  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_GFX_COMMONS_GFX_RENDERER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.gfx.CommonsGfxRenderer"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "skip.bufferedcache", skip_bufferedcache));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_GFX_COMMONS_GFX_RENDERER_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_GFX_COMMONS_GFX_RENDERER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_handler_ep_sformat_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; mimetype: STRING_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_EPS_FORMAT_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: mimetype  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_EPS_FORMAT_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.handler.EPSFormatHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "mimetype", mimetype));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_EPS_FORMAT_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_EPS_FORMAT_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_handler_indesign_format_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; mimetype: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_INDESIGN_FORMAT_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: mimetype  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_INDESIGN_FORMAT_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.handler.IndesignFormatHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "mimetype", mimetype));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_INDESIGN_FORMAT_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_INDESIGN_FORMAT_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_handler_jpeg_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_enable_ext_meta_extraction: BOOLEAN; large_file_threshold: INTEGER_32; large_comment_threshold: INTEGER_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_JPEG_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_enable_ext_meta_extraction  (optional)
			-- 
			-- argument: large_file_threshold  (optional)
			-- 
			-- argument: large_comment_threshold  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_JPEG_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.handler.JpegHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.enable.ext.meta.extraction", cq_dam_enable_ext_meta_extraction));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "large_file_threshold", large_file_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "large_comment_threshold", large_comment_threshold));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_JPEG_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_JPEG_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_handler_xmp_ncomm_xm_phandler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; xmphandler_cq_formats: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_XMP_N_COMM_XMP_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: xmphandler_cq_formats  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_XMP_N_COMM_XMP_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.handler.xmp.NCommXMPHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "xmphandler.cq.formats", xmphandler_cq_formats));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_XMP_N_COMM_XMP_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_HANDLER_XMP_N_COMM_XMP_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_jmx_asset_index_update_monitor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; jmx_objectname: STRING_32; property_measure_enabled: BOOLEAN; property_name: STRING_32; property_max_wait_ms: INTEGER_32; property_max_rate: REAL_32; fulltext_measure_enabled: BOOLEAN; fulltext_name: STRING_32; fulltext_max_wait_ms: INTEGER_32; fulltext_max_rate: REAL_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_JMX_ASSET_INDEX_UPDATE_MONITOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: jmx_objectname  (optional)
			-- 
			-- argument: property_measure_enabled  (optional)
			-- 
			-- argument: property_name  (optional)
			-- 
			-- argument: property_max_wait_ms  (optional)
			-- 
			-- argument: property_max_rate  (optional)
			-- 
			-- argument: fulltext_measure_enabled  (optional)
			-- 
			-- argument: fulltext_name  (optional)
			-- 
			-- argument: fulltext_max_wait_ms  (optional)
			-- 
			-- argument: fulltext_max_rate  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_JMX_ASSET_INDEX_UPDATE_MONITOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetIndexUpdateMonitor"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jmx.objectname", jmx_objectname));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "property.measure.enabled", property_measure_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "property.name", property_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "property.max.wait.ms", property_max_wait_ms));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "property.max.rate", property_max_rate));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "fulltext.measure.enabled", fulltext_measure_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "fulltext.name", fulltext_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "fulltext.max.wait.ms", fulltext_max_wait_ms));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "fulltext.max.rate", fulltext_max_rate));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_JMX_ASSET_INDEX_UPDATE_MONITOR_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_JMX_ASSET_INDEX_UPDATE_MONITOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_jmx_asset_migration_mbean_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; jmx_objectname: STRING_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_JMX_ASSET_MIGRATION_M_BEAN_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: jmx_objectname  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_JMX_ASSET_MIGRATION_M_BEAN_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetMigrationMBeanImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jmx.objectname", jmx_objectname));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_JMX_ASSET_MIGRATION_M_BEAN_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_JMX_ASSET_MIGRATION_M_BEAN_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_jmx_asset_update_monitor_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; jmx_objectname: STRING_32; active: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_JMX_ASSET_UPDATE_MONITOR_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: jmx_objectname  (optional)
			-- 
			-- argument: active  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_JMX_ASSET_UPDATE_MONITOR_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetUpdateMonitorImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jmx.objectname", jmx_objectname));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "active", active));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_JMX_ASSET_UPDATE_MONITOR_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_JMX_ASSET_UPDATE_MONITOR_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_jobs_metadataexport_async_metadata_export_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; operation: STRING_32; email_enabled: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_JOBS_METADATAEXPORT_ASYNC_METADATA_EXPORT_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: operation  (optional)
			-- 
			-- argument: email_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_JOBS_METADATAEXPORT_ASYNC_METADATA_EXPORT_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.jobs.metadataexport.AsyncMetadataExportConfigProviderService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "operation", operation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "emailEnabled", email_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_JOBS_METADATAEXPORT_ASYNC_METADATA_EXPORT_CONFIG_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_JOBS_METADATAEXPORT_ASYNC_METADATA_EXPORT_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_jobs_metadataimport_async_metadata_import_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; operation: STRING_32; operation_icon: STRING_32; topic_name: STRING_32; email_enabled: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_JOBS_METADATAIMPORT_ASYNC_METADATA_IMPORT_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: operation  (optional)
			-- 
			-- argument: operation_icon  (optional)
			-- 
			-- argument: topic_name  (optional)
			-- 
			-- argument: email_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_JOBS_METADATAIMPORT_ASYNC_METADATA_IMPORT_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.jobs.metadataimport.AsyncMetadataImportConfigProviderService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "operation", operation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "operationIcon", operation_icon));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "topicName", topic_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "emailEnabled", email_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_JOBS_METADATAIMPORT_ASYNC_METADATA_IMPORT_CONFIG_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_JOBS_METADATAIMPORT_ASYNC_METADATA_IMPORT_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_lightbox_lightbox_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_paths: STRING_32; sling_servlet_methods: detachable LIST [STRING_32]; cq_dam_enable_anonymous: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_LIGHTBOX_LIGHTBOX_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_paths  (optional)
			-- 
			-- argument: sling_servlet_methods  (optional)
			-- 
			-- argument: cq_dam_enable_anonymous  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_LIGHTBOX_LIGHTBOX_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.lightbox.LightboxServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.paths", sling_servlet_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.servlet.methods", sling_servlet_methods));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.enable.anonymous", cq_dam_enable_anonymous));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_LIGHTBOX_LIGHTBOX_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_LIGHTBOX_LIGHTBOX_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_metadata_editor_select_component_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; granitedata: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_CORE_IMPL_METADATA_EDITOR_SELECT_COMPONENT_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: granitedata  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_METADATA_EDITOR_SELECT_COMPONENT_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.metadata.editor.SelectComponentHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "granite:data", granitedata));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_METADATA_EDITOR_SELECT_COMPONENT_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_METADATA_EDITOR_SELECT_COMPONENT_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_mime_type_asset_upload_restriction_helper (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_allow_all_mime: BOOLEAN; cq_dam_allowed_asset_mimes: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_CORE_IMPL_MIME_TYPE_ASSET_UPLOAD_RESTRICTION_HELPER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_allow_all_mime  (optional)
			-- 
			-- argument: cq_dam_allowed_asset_mimes  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_MIME_TYPE_ASSET_UPLOAD_RESTRICTION_HELPER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.mimeType.AssetUploadRestrictionHelper"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.allow.all.mime", cq_dam_allow_all_mime));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.dam.allowed.asset.mimes", cq_dam_allowed_asset_mimes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_MIME_TYPE_ASSET_UPLOAD_RESTRICTION_HELPER_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_MIME_TYPE_ASSET_UPLOAD_RESTRICTION_HELPER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_mime_type_dam_mime_type_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_detect_asset_mime_from_content: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_MIME_TYPE_DAM_MIME_TYPE_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_detect_asset_mime_from_content  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_MIME_TYPE_DAM_MIME_TYPE_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.mimeType.DamMimeTypeServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.detect.asset.mime.from.content", cq_dam_detect_asset_mime_from_content));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_MIME_TYPE_DAM_MIME_TYPE_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_MIME_TYPE_DAM_MIME_TYPE_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_missing_metadata_notification_job (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_missingmetadata_notification_scheduler_istimebased: BOOLEAN; cq_dam_missingmetadata_notification_scheduler_timebased_rule: STRING_32; cq_dam_missingmetadata_notification_scheduler_period_rule: INTEGER_32; cq_dam_missingmetadata_notification_recipient: STRING_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_MISSING_METADATA_NOTIFICATION_JOB_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_missingmetadata_notification_scheduler_istimebased  (optional)
			-- 
			-- argument: cq_dam_missingmetadata_notification_scheduler_timebased_rule  (optional)
			-- 
			-- argument: cq_dam_missingmetadata_notification_scheduler_period_rule  (optional)
			-- 
			-- argument: cq_dam_missingmetadata_notification_recipient  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_MISSING_METADATA_NOTIFICATION_JOB_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.MissingMetadataNotificationJob"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.missingmetadata.notification.scheduler.istimebased", cq_dam_missingmetadata_notification_scheduler_istimebased));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.missingmetadata.notification.scheduler.timebased.rule", cq_dam_missingmetadata_notification_scheduler_timebased_rule));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.missingmetadata.notification.scheduler.period.rule", cq_dam_missingmetadata_notification_scheduler_period_rule));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.missingmetadata.notification.recipient", cq_dam_missingmetadata_notification_recipient));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_MISSING_METADATA_NOTIFICATION_JOB_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_MISSING_METADATA_NOTIFICATION_JOB_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_process_send_transient_workflow_completed_email_pr (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; process_label: STRING_32; notify_on__complete: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_PROCESS_SEND_TRANSIENT_WORKFLOW_COMPLETED_EMAIL_PR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: process_label  (optional)
			-- 
			-- argument: notify_on__complete  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_PROCESS_SEND_TRANSIENT_WORKFLOW_COMPLETED_EMAIL_PR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.process.SendTransientWorkflowCompletedEmailProcess"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "process.label", process_label));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "Notify on Complete", notify_on__complete));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_PROCESS_SEND_TRANSIENT_WORKFLOW_COMPLETED_EMAIL_PR_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_PROCESS_SEND_TRANSIENT_WORKFLOW_COMPLETED_EMAIL_PR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_process_text_extraction_process (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; mime_types: detachable LIST [STRING_32]; max_extract: INTEGER_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_PROCESS_TEXT_EXTRACTION_PROCESS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: mime_types  (optional)
			-- 
			-- argument: max_extract  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_PROCESS_TEXT_EXTRACTION_PROCESS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.process.TextExtractionProcess"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "mimeTypes", mime_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxExtract", max_extract));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_PROCESS_TEXT_EXTRACTION_PROCESS_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_PROCESS_TEXT_EXTRACTION_PROCESS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_rendition_maker_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; xmp_propagate: BOOLEAN; xmp_excludes: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_CORE_IMPL_RENDITION_MAKER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: xmp_propagate  (optional)
			-- 
			-- argument: xmp_excludes  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_RENDITION_MAKER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.RenditionMakerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "xmp.propagate", xmp_propagate));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "xmp.excludes", xmp_excludes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_RENDITION_MAKER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_RENDITION_MAKER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_reports_report_export_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; query_batch_size: INTEGER_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_REPORTS_REPORT_EXPORT_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: query_batch_size  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_REPORTS_REPORT_EXPORT_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.reports.ReportExportService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queryBatchSize", query_batch_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_REPORTS_REPORT_EXPORT_SERVICE_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_REPORTS_REPORT_EXPORT_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_reports_report_purge_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_expression: STRING_32; max_saved_reports: INTEGER_32; time_duration: INTEGER_32; enable_report_purge: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_REPORTS_REPORT_PURGE_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- argument: max_saved_reports  (optional)
			-- 
			-- argument: time_duration  (optional)
			-- 
			-- argument: enable_report_purge  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_REPORTS_REPORT_PURGE_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.reports.ReportPurgeService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxSavedReports", max_saved_reports));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "timeDuration", time_duration));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableReportPurge", enable_report_purge));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_REPORTS_REPORT_PURGE_SERVICE_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_REPORTS_REPORT_PURGE_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_asset_download_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_ASSET_DOWNLOAD_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_ASSET_DOWNLOAD_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetDownloadServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_ASSET_DOWNLOAD_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_ASSET_DOWNLOAD_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_asset_status_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_batch_status_maxassets: INTEGER_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_ASSET_STATUS_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_batch_status_maxassets  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_ASSET_STATUS_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetStatusServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.batch.status.maxassets", cq_dam_batch_status_maxassets));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_ASSET_STATUS_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_ASSET_STATUS_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_asset_xm_psearch_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_batch_indesign_maxassets: INTEGER_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_ASSET_XMP_SEARCH_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_batch_indesign_maxassets  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_ASSET_XMP_SEARCH_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetXMPSearchServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.batch.indesign.maxassets", cq_dam_batch_indesign_maxassets));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_ASSET_XMP_SEARCH_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_ASSET_XMP_SEARCH_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_batch_metadata_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_batch_metadata_asset_default: detachable LIST [STRING_32]; cq_dam_batch_metadata_collection_default: detachable LIST [STRING_32]; cq_dam_batch_metadata_maxresources: INTEGER_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_BATCH_METADATA_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_batch_metadata_asset_default  (optional)
			-- 
			-- argument: cq_dam_batch_metadata_collection_default  (optional)
			-- 
			-- argument: cq_dam_batch_metadata_maxresources  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_BATCH_METADATA_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.BatchMetadataServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.dam.batch.metadata.asset.default", cq_dam_batch_metadata_asset_default));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.dam.batch.metadata.collection.default", cq_dam_batch_metadata_collection_default));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.batch.metadata.maxresources", cq_dam_batch_metadata_maxresources));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_BATCH_METADATA_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_BATCH_METADATA_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_binary_provider_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_resource_types: detachable LIST [STRING_32]; sling_servlet_methods: detachable LIST [STRING_32]; cq_dam_drm_enable: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_BINARY_PROVIDER_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_resource_types  (optional)
			-- 
			-- argument: sling_servlet_methods  (optional)
			-- 
			-- argument: cq_dam_drm_enable  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_BINARY_PROVIDER_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.BinaryProviderServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.servlet.resourceTypes", sling_servlet_resource_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.servlet.methods", sling_servlet_methods));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.drm.enable", cq_dam_drm_enable));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_BINARY_PROVIDER_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_BINARY_PROVIDER_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_collection_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_batch_collection_properties: detachable LIST [STRING_32]; cq_dam_batch_collection_maxcollections: INTEGER_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_COLLECTION_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_batch_collection_properties  (optional)
			-- 
			-- argument: cq_dam_batch_collection_maxcollections  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_COLLECTION_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CollectionServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.dam.batch.collection.properties", cq_dam_batch_collection_properties));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.batch.collection.maxcollections", cq_dam_batch_collection_maxcollections));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_COLLECTION_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_COLLECTION_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_collections_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_batch_collections_properties: detachable LIST [STRING_32]; cq_dam_batch_collections_limit: INTEGER_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_COLLECTIONS_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_batch_collections_properties  (optional)
			-- 
			-- argument: cq_dam_batch_collections_limit  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_COLLECTIONS_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CollectionsServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.dam.batch.collections.properties", cq_dam_batch_collections_properties));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.batch.collections.limit", cq_dam_batch_collections_limit));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_COLLECTIONS_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_COLLECTIONS_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_companion_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; more__info: STRING_32; mntoverlaydamguicontentassetsmoreinfo_htmlpath: STRING_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_COMPANION_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: more__info  (optional)
			-- 
			-- argument: mntoverlaydamguicontentassetsmoreinfo_htmlpath  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_COMPANION_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CompanionServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "More Info", more__info));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "/mnt/overlay/dam/gui/content/assets/moreinfo.html/${path}", mntoverlaydamguicontentassetsmoreinfo_htmlpath));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_COMPANION_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_COMPANION_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_create_asset_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; detect_duplicate: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_CREATE_ASSET_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: detect_duplicate  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_CREATE_ASSET_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CreateAssetServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "detect_duplicate", detect_duplicate));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_CREATE_ASSET_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_CREATE_ASSET_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_dam_content_disposition_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_mime_type_blacklist: detachable LIST [STRING_32]; cq_dam_empty_mime: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_DAM_CONTENT_DISPOSITION_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_mime_type_blacklist  (optional)
			-- 
			-- argument: cq_dam_empty_mime  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_DAM_CONTENT_DISPOSITION_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.DamContentDispositionFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.mime.type.blacklist", cq_mime_type_blacklist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.empty.mime", cq_dam_empty_mime));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_DAM_CONTENT_DISPOSITION_FILTER_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_DAM_CONTENT_DISPOSITION_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_guid_lookup_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_core_guidlookupfilter_enabled: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_GUID_LOOKUP_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_core_guidlookupfilter_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_GUID_LOOKUP_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.GuidLookupFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.core.guidlookupfilter.enabled", cq_dam_core_guidlookupfilter_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_GUID_LOOKUP_FILTER_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_GUID_LOOKUP_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_health_check_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_sync_workflow_id: STRING_32; cq_dam_sync_folder_types: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_HEALTH_CHECK_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_sync_workflow_id  (optional)
			-- 
			-- argument: cq_dam_sync_folder_types  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_HEALTH_CHECK_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.HealthCheckServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.sync.workflow.id", cq_dam_sync_workflow_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.dam.sync.folder.types", cq_dam_sync_folder_types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_HEALTH_CHECK_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_HEALTH_CHECK_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_metadata_get_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_resource_types: STRING_32; sling_servlet_methods: STRING_32; sling_servlet_extensions: STRING_32; sling_servlet_selectors: STRING_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_METADATA_GET_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_resource_types  (optional)
			-- 
			-- argument: sling_servlet_methods  (optional)
			-- 
			-- argument: sling_servlet_extensions  (optional)
			-- 
			-- argument: sling_servlet_selectors  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_METADATA_GET_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.MetadataGetServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.resourceTypes", sling_servlet_resource_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.methods", sling_servlet_methods));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.extensions", sling_servlet_extensions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.selectors", sling_servlet_selectors));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_METADATA_GET_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_METADATA_GET_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_multiple_license_accept_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_drm_enable: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_MULTIPLE_LICENSE_ACCEPT_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_drm_enable  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_MULTIPLE_LICENSE_ACCEPT_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.MultipleLicenseAcceptServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.drm.enable", cq_dam_drm_enable));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_MULTIPLE_LICENSE_ACCEPT_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_MULTIPLE_LICENSE_ACCEPT_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_servlet_resource_collection_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_resource_types: detachable LIST [STRING_32]; sling_servlet_methods: STRING_32; sling_servlet_selectors: STRING_32; download_config: STRING_32; view_selector: STRING_32; send_email: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_RESOURCE_COLLECTION_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_resource_types  (optional)
			-- 
			-- argument: sling_servlet_methods  (optional)
			-- 
			-- argument: sling_servlet_selectors  (optional)
			-- 
			-- argument: download_config  (optional)
			-- 
			-- argument: view_selector  (optional)
			-- 
			-- argument: send_email  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_RESOURCE_COLLECTION_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.ResourceCollectionServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.servlet.resourceTypes", sling_servlet_resource_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.methods", sling_servlet_methods));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.selectors", sling_servlet_selectors));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "download.config", download_config));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "view.selector", view_selector));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "send_email", send_email));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_RESOURCE_COLLECTION_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_SERVLET_RESOURCE_COLLECTION_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_ui_preview_folder_preview_updater_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; create_preview_enabled: BOOLEAN; update_preview_enabled: BOOLEAN; queue_size: INTEGER_32; folder_preview_rendition_regex: STRING_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_UI_PREVIEW_FOLDER_PREVIEW_UPDATER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: create_preview_enabled  (optional)
			-- 
			-- argument: update_preview_enabled  (optional)
			-- 
			-- argument: queue_size  (optional)
			-- 
			-- argument: folder_preview_rendition_regex  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_UI_PREVIEW_FOLDER_PREVIEW_UPDATER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.ui.preview.FolderPreviewUpdaterImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "createPreviewEnabled", create_preview_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "updatePreviewEnabled", update_preview_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queueSize", queue_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "folderPreviewRenditionRegex", folder_preview_rendition_regex));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_UI_PREVIEW_FOLDER_PREVIEW_UPDATER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_UI_PREVIEW_FOLDER_PREVIEW_UPDATER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_impl_unzip_unzip_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_config_unzip_maxuncompressedsize: INTEGER_32; cq_dam_config_unzip_encoding: STRING_32): detachable COM_DAY_CQ_DAM_CORE_IMPL_UNZIP_UNZIP_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_config_unzip_maxuncompressedsize  (optional)
			-- 
			-- argument: cq_dam_config_unzip_encoding  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_IMPL_UNZIP_UNZIP_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.impl.unzip.UnzipConfig"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.unzip.maxuncompressedsize", cq_dam_config_unzip_maxuncompressedsize));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.config.unzip.encoding", cq_dam_config_unzip_encoding));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_IMPL_UNZIP_UNZIP_CONFIG_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_IMPL_UNZIP_UNZIP_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_process_exif_tool_extract_metadata_process (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; process_label: STRING_32; cq_dam_enable_sha1: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_PROCESS_EXIF_TOOL_EXTRACT_METADATA_PROCESS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: process_label  (optional)
			-- 
			-- argument: cq_dam_enable_sha1  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_PROCESS_EXIF_TOOL_EXTRACT_METADATA_PROCESS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.process.ExifToolExtractMetadataProcess"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "process.label", process_label));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.enable.sha1", cq_dam_enable_sha1));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_PROCESS_EXIF_TOOL_EXTRACT_METADATA_PROCESS_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_PROCESS_EXIF_TOOL_EXTRACT_METADATA_PROCESS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_process_extract_metadata_process (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; process_label: STRING_32; cq_dam_enable_sha1: BOOLEAN): detachable COM_DAY_CQ_DAM_CORE_PROCESS_EXTRACT_METADATA_PROCESS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: process_label  (optional)
			-- 
			-- argument: cq_dam_enable_sha1  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_PROCESS_EXTRACT_METADATA_PROCESS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.process.ExtractMetadataProcess"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "process.label", process_label));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.enable.sha1", cq_dam_enable_sha1));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_PROCESS_EXTRACT_METADATA_PROCESS_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_PROCESS_EXTRACT_METADATA_PROCESS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_core_process_metadata_processor_process (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; process_label: STRING_32; cq_dam_enable_sha1: BOOLEAN; cq_dam_metadata_xssprotected_properties: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_CORE_PROCESS_METADATA_PROCESSOR_PROCESS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: process_label  (optional)
			-- 
			-- argument: cq_dam_enable_sha1  (optional)
			-- 
			-- argument: cq_dam_metadata_xssprotected_properties  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_CORE_PROCESS_METADATA_PROCESSOR_PROCESS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.core.process.MetadataProcessorProcess"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "process.label", process_label));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.enable.sha1", cq_dam_enable_sha1));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.dam.metadata.xssprotected.properties", cq_dam_metadata_xssprotected_properties));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_CORE_PROCESS_METADATA_PROCESSOR_PROCESS_INFO } l_response.data ({ COM_DAY_CQ_DAM_CORE_PROCESS_METADATA_PROCESSOR_PROCESS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_handler_ffmpeg_locator_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; executable_searchpath: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_HANDLER_FFMPEG_LOCATOR_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: executable_searchpath  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_HANDLER_FFMPEG_LOCATOR_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.handler.ffmpeg.LocatorImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "executable.searchpath", executable_searchpath));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_HANDLER_FFMPEG_LOCATOR_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_HANDLER_FFMPEG_LOCATOR_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_handler_gibson_fontmanager_impl_font_manager_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_filter: STRING_32; fontmgr_system_font_dir: detachable LIST [STRING_32]; fontmgr_adobe_font_dir: STRING_32; fontmgr_customer_font_dir: STRING_32): detachable COM_DAY_CQ_DAM_HANDLER_GIBSON_FONTMANAGER_IMPL_FONT_MANAGER_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- argument: fontmgr_system_font_dir  (optional)
			-- 
			-- argument: fontmgr_adobe_font_dir  (optional)
			-- 
			-- argument: fontmgr_customer_font_dir  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_HANDLER_GIBSON_FONTMANAGER_IMPL_FONT_MANAGER_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.handler.gibson.fontmanager.impl.FontManagerServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fontmgr.system.font.dir", fontmgr_system_font_dir));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "fontmgr.adobe.font.dir", fontmgr_adobe_font_dir));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "fontmgr.customer.font.dir", fontmgr_customer_font_dir));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_HANDLER_GIBSON_FONTMANAGER_IMPL_FONT_MANAGER_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_HANDLER_GIBSON_FONTMANAGER_IMPL_FONT_MANAGER_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_handler_standard_pdf_pdf_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; raster_annotation: BOOLEAN): detachable COM_DAY_CQ_DAM_HANDLER_STANDARD_PDF_PDF_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: raster_annotation  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_HANDLER_STANDARD_PDF_PDF_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.handler.standard.pdf.PdfHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "raster.annotation", raster_annotation));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_HANDLER_STANDARD_PDF_PDF_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_DAM_HANDLER_STANDARD_PDF_PDF_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_handler_standard_ps_post_script_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; raster_annotation: BOOLEAN): detachable COM_DAY_CQ_DAM_HANDLER_STANDARD_PS_POST_SCRIPT_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: raster_annotation  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_HANDLER_STANDARD_PS_POST_SCRIPT_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.handler.standard.ps.PostScriptHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "raster.annotation", raster_annotation));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_HANDLER_STANDARD_PS_POST_SCRIPT_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_DAM_HANDLER_STANDARD_PS_POST_SCRIPT_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_handler_standard_psd_psd_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; large_file_threshold: INTEGER_32): detachable COM_DAY_CQ_DAM_HANDLER_STANDARD_PSD_PSD_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: large_file_threshold  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_HANDLER_STANDARD_PSD_PSD_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.handler.standard.psd.PsdHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "large_file_threshold", large_file_threshold));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_HANDLER_STANDARD_PSD_PSD_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_DAM_HANDLER_STANDARD_PSD_PSD_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_ids_impl_id_sjob_processor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enable_multisession: BOOLEAN; ids_cc_enable: BOOLEAN; enable_retry: BOOLEAN; enable_retry_scripterror: BOOLEAN; externalizer_domain_cqhost: STRING_32; externalizer_domain_http: STRING_32): detachable COM_DAY_CQ_DAM_IDS_IMPL_IDS_JOB_PROCESSOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enable_multisession  (optional)
			-- 
			-- argument: ids_cc_enable  (optional)
			-- 
			-- argument: enable_retry  (optional)
			-- 
			-- argument: enable_retry_scripterror  (optional)
			-- 
			-- argument: externalizer_domain_cqhost  (optional)
			-- 
			-- argument: externalizer_domain_http  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_IDS_IMPL_IDS_JOB_PROCESSOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.ids.impl.IDSJobProcessor"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.multisession", enable_multisession));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ids.cc.enable", ids_cc_enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.retry", enable_retry));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.retry.scripterror", enable_retry_scripterror));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "externalizer.domain.cqhost", externalizer_domain_cqhost));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "externalizer.domain.http", externalizer_domain_http));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_IDS_IMPL_IDS_JOB_PROCESSOR_INFO } l_response.data ({ COM_DAY_CQ_DAM_IDS_IMPL_IDS_JOB_PROCESSOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_ids_impl_id_spool_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_errors_to_blacklist: INTEGER_32; retry_interval_to_whitelist: INTEGER_32; connect_timeout: INTEGER_32; socket_timeout: INTEGER_32; process_label: STRING_32; connection_use_max: INTEGER_32): detachable COM_DAY_CQ_DAM_IDS_IMPL_IDS_POOL_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_errors_to_blacklist  (optional)
			-- 
			-- argument: retry_interval_to_whitelist  (optional)
			-- 
			-- argument: connect_timeout  (optional)
			-- 
			-- argument: socket_timeout  (optional)
			-- 
			-- argument: process_label  (optional)
			-- 
			-- argument: connection_use_max  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_IDS_IMPL_IDS_POOL_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.ids.impl.IDSPoolManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "max.errors.to.blacklist", max_errors_to_blacklist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "retry.interval.to.whitelist", retry_interval_to_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connect.timeout", connect_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "socket.timeout", socket_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "process.label", process_label));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connection.use.max", connection_use_max));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_IDS_IMPL_IDS_POOL_MANAGER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_IDS_IMPL_IDS_POOL_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_indd_impl_handler_indesign_xm_phandler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; process_label: STRING_32; extract_pages: BOOLEAN): detachable COM_DAY_CQ_DAM_INDD_IMPL_HANDLER_INDESIGN_XMP_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: process_label  (optional)
			-- 
			-- argument: extract_pages  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_INDD_IMPL_HANDLER_INDESIGN_XMP_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.indd.impl.handler.IndesignXMPHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "process.label", process_label));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "extract.pages", extract_pages));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_INDD_IMPL_HANDLER_INDESIGN_XMP_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_DAM_INDD_IMPL_HANDLER_INDESIGN_XMP_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_indd_impl_servlet_snippet_creation_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; snippetcreation_maxcollections: INTEGER_32): detachable COM_DAY_CQ_DAM_INDD_IMPL_SERVLET_SNIPPET_CREATION_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: snippetcreation_maxcollections  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_INDD_IMPL_SERVLET_SNIPPET_CREATION_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.indd.impl.servlet.SnippetCreationServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "snippetcreation.maxcollections", snippetcreation_maxcollections));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_INDD_IMPL_SERVLET_SNIPPET_CREATION_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_INDD_IMPL_SERVLET_SNIPPET_CREATION_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_indd_process_in_dd_media_extract_process (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; process_label: STRING_32; cq_dam_indd_pages_regex: STRING_32; ids_job_decoupled: BOOLEAN; ids_job_workflow_model: STRING_32): detachable COM_DAY_CQ_DAM_INDD_PROCESS_INDD_MEDIA_EXTRACT_PROCESS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: process_label  (optional)
			-- 
			-- argument: cq_dam_indd_pages_regex  (optional)
			-- 
			-- argument: ids_job_decoupled  (optional)
			-- 
			-- argument: ids_job_workflow_model  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_INDD_PROCESS_INDD_MEDIA_EXTRACT_PROCESS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.indd.process.INDDMediaExtractProcess"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "process.label", process_label));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.indd.pages.regex", cq_dam_indd_pages_regex));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ids.job.decoupled", ids_job_decoupled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ids.job.workflow.model", ids_job_workflow_model));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_INDD_PROCESS_INDD_MEDIA_EXTRACT_PROCESS_INFO } l_response.data ({ COM_DAY_CQ_DAM_INDD_PROCESS_INDD_MEDIA_EXTRACT_PROCESS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_performance_internal_asset_performance_data_handler_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; batch_commit_size: INTEGER_32): detachable COM_DAY_CQ_DAM_PERFORMANCE_INTERNAL_ASSET_PERFORMANCE_DATA_HANDLER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: batch_commit_size  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_PERFORMANCE_INTERNAL_ASSET_PERFORMANCE_DATA_HANDLER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.performance.internal.AssetPerformanceDataHandlerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "batch.commit.size", batch_commit_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_PERFORMANCE_INTERNAL_ASSET_PERFORMANCE_DATA_HANDLER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_PERFORMANCE_INTERNAL_ASSET_PERFORMANCE_DATA_HANDLER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_performance_internal_asset_performance_report_sync_job (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_expression: STRING_32): detachable COM_DAY_CQ_DAM_PERFORMANCE_INTERNAL_ASSET_PERFORMANCE_REPORT_SYNC_JOB_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_PERFORMANCE_INTERNAL_ASSET_PERFORMANCE_REPORT_SYNC_JOB_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.performance.internal.AssetPerformanceReportSyncJob"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_PERFORMANCE_INTERNAL_ASSET_PERFORMANCE_REPORT_SYNC_JOB_INFO } l_response.data ({ COM_DAY_CQ_DAM_PERFORMANCE_INTERNAL_ASSET_PERFORMANCE_REPORT_SYNC_JOB_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_pim_impl_sourcing_upload_process_product_assets_upload_pro (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; delete_zip_file: BOOLEAN): detachable COM_DAY_CQ_DAM_PIM_IMPL_SOURCING_UPLOAD_PROCESS_PRODUCT_ASSETS_UPLOAD_PRO_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: delete_zip_file  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_PIM_IMPL_SOURCING_UPLOAD_PROCESS_PRODUCT_ASSETS_UPLOAD_PRO_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.pim.impl.sourcing.upload.process.ProductAssetsUploadProcess"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete.zip.file", delete_zip_file));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_PIM_IMPL_SOURCING_UPLOAD_PROCESS_PRODUCT_ASSETS_UPLOAD_PRO_INFO } l_response.data ({ COM_DAY_CQ_DAM_PIM_IMPL_SOURCING_UPLOAD_PROCESS_PRODUCT_ASSETS_UPLOAD_PRO_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_s7dam_common_analytics_impl_s7dam_dynamic_media_config_even (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_s7dam_dynamicmediaconfigeventlistener_enabled: BOOLEAN): detachable COM_DAY_CQ_DAM_S7DAM_COMMON_ANALYTICS_IMPL_S7DAM_DYNAMIC_MEDIA_CONFIG_EVEN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_s7dam_dynamicmediaconfigeventlistener_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_S7DAM_COMMON_ANALYTICS_IMPL_S7DAM_DYNAMIC_MEDIA_CONFIG_EVEN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.s7dam.common.analytics.impl.S7damDynamicMediaConfigEventListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.s7dam.dynamicmediaconfigeventlistener.enabled", cq_dam_s7dam_dynamicmediaconfigeventlistener_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_S7DAM_COMMON_ANALYTICS_IMPL_S7DAM_DYNAMIC_MEDIA_CONFIG_EVEN_INFO } l_response.data ({ COM_DAY_CQ_DAM_S7DAM_COMMON_ANALYTICS_IMPL_S7DAM_DYNAMIC_MEDIA_CONFIG_EVEN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_s7dam_common_analytics_impl_site_catalyst_report_runner (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_expression: STRING_32; scheduler_concurrent: BOOLEAN): detachable COM_DAY_CQ_DAM_S7DAM_COMMON_ANALYTICS_IMPL_SITE_CATALYST_REPORT_RUNNER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- argument: scheduler_concurrent  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_S7DAM_COMMON_ANALYTICS_IMPL_SITE_CATALYST_REPORT_RUNNER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.s7dam.common.analytics.impl.SiteCatalystReportRunner"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.concurrent", scheduler_concurrent));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_S7DAM_COMMON_ANALYTICS_IMPL_SITE_CATALYST_REPORT_RUNNER_INFO } l_response.data ({ COM_DAY_CQ_DAM_S7DAM_COMMON_ANALYTICS_IMPL_SITE_CATALYST_REPORT_RUNNER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_s7dam_common_post_servlets_set_create_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_post_operation: STRING_32; sling_servlet_methods: STRING_32): detachable COM_DAY_CQ_DAM_S7DAM_COMMON_POST_SERVLETS_SET_CREATE_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_post_operation  (optional)
			-- 
			-- argument: sling_servlet_methods  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_S7DAM_COMMON_POST_SERVLETS_SET_CREATE_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.s7dam.common.post.servlets.SetCreateHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.post.operation", sling_post_operation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.methods", sling_servlet_methods));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_S7DAM_COMMON_POST_SERVLETS_SET_CREATE_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_DAM_S7DAM_COMMON_POST_SERVLETS_SET_CREATE_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_s7dam_common_post_servlets_set_modify_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_post_operation: STRING_32; sling_servlet_methods: STRING_32): detachable COM_DAY_CQ_DAM_S7DAM_COMMON_POST_SERVLETS_SET_MODIFY_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_post_operation  (optional)
			-- 
			-- argument: sling_servlet_methods  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_S7DAM_COMMON_POST_SERVLETS_SET_MODIFY_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.s7dam.common.post.servlets.SetModifyHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.post.operation", sling_post_operation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.methods", sling_servlet_methods));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_S7DAM_COMMON_POST_SERVLETS_SET_MODIFY_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_DAM_S7DAM_COMMON_POST_SERVLETS_SET_MODIFY_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_s7dam_common_process_video_thumbnail_download_process (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; process_label: STRING_32): detachable COM_DAY_CQ_DAM_S7DAM_COMMON_PROCESS_VIDEO_THUMBNAIL_DOWNLOAD_PROCESS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: process_label  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_S7DAM_COMMON_PROCESS_VIDEO_THUMBNAIL_DOWNLOAD_PROCESS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.s7dam.common.process.VideoThumbnailDownloadProcess"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "process.label", process_label));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_S7DAM_COMMON_PROCESS_VIDEO_THUMBNAIL_DOWNLOAD_PROCESS_INFO } l_response.data ({ COM_DAY_CQ_DAM_S7DAM_COMMON_PROCESS_VIDEO_THUMBNAIL_DOWNLOAD_PROCESS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_s7dam_common_s7dam_dam_change_event_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_s7dam_damchangeeventlistener_enabled: BOOLEAN): detachable COM_DAY_CQ_DAM_S7DAM_COMMON_S7DAM_DAM_CHANGE_EVENT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_s7dam_damchangeeventlistener_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_S7DAM_COMMON_S7DAM_DAM_CHANGE_EVENT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.s7dam.common.S7damDamChangeEventListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.s7dam.damchangeeventlistener.enabled", cq_dam_s7dam_damchangeeventlistener_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_S7DAM_COMMON_S7DAM_DAM_CHANGE_EVENT_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_DAM_S7DAM_COMMON_S7DAM_DAM_CHANGE_EVENT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_s7dam_common_servlets_s7dam_product_info_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_paths: STRING_32; sling_servlet_methods: STRING_32): detachable COM_DAY_CQ_DAM_S7DAM_COMMON_SERVLETS_S7DAM_PRODUCT_INFO_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_paths  (optional)
			-- 
			-- argument: sling_servlet_methods  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_S7DAM_COMMON_SERVLETS_S7DAM_PRODUCT_INFO_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.s7dam.common.servlets.S7damProductInfoServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.paths", sling_servlet_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.methods", sling_servlet_methods));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_S7DAM_COMMON_SERVLETS_S7DAM_PRODUCT_INFO_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_S7DAM_COMMON_SERVLETS_S7DAM_PRODUCT_INFO_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_s7dam_common_video_impl_video_proxy_client_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_s7dam_videoproxyclientservice_multipartupload_minsize_name: INTEGER_32; cq_dam_s7dam_videoproxyclientservice_multipartupload_partsize_name: INTEGER_32; cq_dam_s7dam_videoproxyclientservice_multipartupload_numthread_name: INTEGER_32; cq_dam_s7dam_videoproxyclientservice_http_readtimeout_name: INTEGER_32; cq_dam_s7dam_videoproxyclientservice_http_connectiontimeout_name: INTEGER_32; cq_dam_s7dam_videoproxyclientservice_http_maxretrycount_name: INTEGER_32; cq_dam_s7dam_videoproxyclientservice_uploadprogress_interval_name: INTEGER_32): detachable COM_DAY_CQ_DAM_S7DAM_COMMON_VIDEO_IMPL_VIDEO_PROXY_CLIENT_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_s7dam_videoproxyclientservice_multipartupload_minsize_name  (optional)
			-- 
			-- argument: cq_dam_s7dam_videoproxyclientservice_multipartupload_partsize_name  (optional)
			-- 
			-- argument: cq_dam_s7dam_videoproxyclientservice_multipartupload_numthread_name  (optional)
			-- 
			-- argument: cq_dam_s7dam_videoproxyclientservice_http_readtimeout_name  (optional)
			-- 
			-- argument: cq_dam_s7dam_videoproxyclientservice_http_connectiontimeout_name  (optional)
			-- 
			-- argument: cq_dam_s7dam_videoproxyclientservice_http_maxretrycount_name  (optional)
			-- 
			-- argument: cq_dam_s7dam_videoproxyclientservice_uploadprogress_interval_name  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_S7DAM_COMMON_VIDEO_IMPL_VIDEO_PROXY_CLIENT_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.s7dam.common.video.impl.VideoProxyClientServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.s7dam.videoproxyclientservice.multipartupload.minsize.name", cq_dam_s7dam_videoproxyclientservice_multipartupload_minsize_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.s7dam.videoproxyclientservice.multipartupload.partsize.name", cq_dam_s7dam_videoproxyclientservice_multipartupload_partsize_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.s7dam.videoproxyclientservice.multipartupload.numthread.name", cq_dam_s7dam_videoproxyclientservice_multipartupload_numthread_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.s7dam.videoproxyclientservice.http.readtimeout.name", cq_dam_s7dam_videoproxyclientservice_http_readtimeout_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.s7dam.videoproxyclientservice.http.connectiontimeout.name", cq_dam_s7dam_videoproxyclientservice_http_connectiontimeout_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.s7dam.videoproxyclientservice.http.maxretrycount.name", cq_dam_s7dam_videoproxyclientservice_http_maxretrycount_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.s7dam.videoproxyclientservice.uploadprogress.interval.name", cq_dam_s7dam_videoproxyclientservice_uploadprogress_interval_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_S7DAM_COMMON_VIDEO_IMPL_VIDEO_PROXY_CLIENT_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_S7DAM_COMMON_VIDEO_IMPL_VIDEO_PROXY_CLIENT_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_scene7_impl_scene7_ap_iclient_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_scene7_apiclient_recordsperpage_nofilter_name: INTEGER_32; cq_dam_scene7_apiclient_recordsperpage_withfilter_name: INTEGER_32): detachable COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_API_CLIENT_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_scene7_apiclient_recordsperpage_nofilter_name  (optional)
			-- 
			-- argument: cq_dam_scene7_apiclient_recordsperpage_withfilter_name  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_API_CLIENT_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7APIClientImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.scene7.apiclient.recordsperpage.nofilter.name", cq_dam_scene7_apiclient_recordsperpage_nofilter_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.scene7.apiclient.recordsperpage.withfilter.name", cq_dam_scene7_apiclient_recordsperpage_withfilter_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_API_CLIENT_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_API_CLIENT_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_scene7_impl_scene7_asset_mime_type_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_scene7_assetmimetypeservice_mapping: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_ASSET_MIME_TYPE_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_scene7_assetmimetypeservice_mapping  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_ASSET_MIME_TYPE_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7AssetMimeTypeServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.dam.scene7.assetmimetypeservice.mapping", cq_dam_scene7_assetmimetypeservice_mapping));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_ASSET_MIME_TYPE_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_ASSET_MIME_TYPE_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_scene7_impl_scene7_configuration_event_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_scene7_configurationeventlistener_enabled: BOOLEAN): detachable COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_CONFIGURATION_EVENT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_scene7_configurationeventlistener_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_CONFIGURATION_EVENT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7ConfigurationEventListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.scene7.configurationeventlistener.enabled", cq_dam_scene7_configurationeventlistener_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_CONFIGURATION_EVENT_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_CONFIGURATION_EVENT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_scene7_impl_scene7_dam_change_event_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_scene7_damchangeeventlistener_enabled: BOOLEAN; cq_dam_scene7_damchangeeventlistener_observed_paths: detachable LIST [STRING_32]): detachable COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_DAM_CHANGE_EVENT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_scene7_damchangeeventlistener_enabled  (optional)
			-- 
			-- argument: cq_dam_scene7_damchangeeventlistener_observed_paths  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_DAM_CHANGE_EVENT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7DamChangeEventListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.scene7.damchangeeventlistener.enabled", cq_dam_scene7_damchangeeventlistener_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.dam.scene7.damchangeeventlistener.observed.paths", cq_dam_scene7_damchangeeventlistener_observed_paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_DAM_CHANGE_EVENT_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_DAM_CHANGE_EVENT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_scene7_impl_scene7_flash_templates_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scene7_flash_templates_rti: STRING_32; scene7_flash_templates_rsi: STRING_32; scene7_flash_templates_rb: STRING_32; scene7_flash_templates_rurl: STRING_32; scene7_flash_template_url_format_parameter: STRING_32): detachable COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_FLASH_TEMPLATES_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scene7_flash_templates_rti  (optional)
			-- 
			-- argument: scene7_flash_templates_rsi  (optional)
			-- 
			-- argument: scene7_flash_templates_rb  (optional)
			-- 
			-- argument: scene7_flash_templates_rurl  (optional)
			-- 
			-- argument: scene7_flash_template_url_format_parameter  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_FLASH_TEMPLATES_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7FlashTemplatesServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scene7FlashTemplates.rti", scene7_flash_templates_rti));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scene7FlashTemplates.rsi", scene7_flash_templates_rsi));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scene7FlashTemplates.rb", scene7_flash_templates_rb));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scene7FlashTemplates.rurl", scene7_flash_templates_rurl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scene7FlashTemplate.urlFormatParameter", scene7_flash_template_url_format_parameter));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_FLASH_TEMPLATES_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_FLASH_TEMPLATES_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_scene7_impl_scene7_upload_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_dam_scene7_uploadservice_activejobtimeout_label: INTEGER_32; cq_dam_scene7_uploadservice_connectionmaxperroute_label: INTEGER_32): detachable COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_UPLOAD_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_dam_scene7_uploadservice_activejobtimeout_label  (optional)
			-- 
			-- argument: cq_dam_scene7_uploadservice_connectionmaxperroute_label  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_UPLOAD_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7UploadServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.scene7.uploadservice.activejobtimeout.label", cq_dam_scene7_uploadservice_activejobtimeout_label));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.dam.scene7.uploadservice.connectionmaxperroute.label", cq_dam_scene7_uploadservice_connectionmaxperroute_label));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_UPLOAD_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_DAM_SCENE7_IMPL_SCENE7_UPLOAD_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_stock_integration_impl_cache_stock_cache_configuration_ser (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; get_cache_expiration_unit: STRING_32; get_cache_expiration_value: INTEGER_32): detachable COM_DAY_CQ_DAM_STOCK_INTEGRATION_IMPL_CACHE_STOCK_CACHE_CONFIGURATION_SER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: get_cache_expiration_unit  (optional)
			-- 
			-- argument: get_cache_expiration_value  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_STOCK_INTEGRATION_IMPL_CACHE_STOCK_CACHE_CONFIGURATION_SER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.stock.integration.impl.cache.StockCacheConfigurationServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "getCacheExpirationUnit", get_cache_expiration_unit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "getCacheExpirationValue", get_cache_expiration_value));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_STOCK_INTEGRATION_IMPL_CACHE_STOCK_CACHE_CONFIGURATION_SER_INFO } l_response.data ({ COM_DAY_CQ_DAM_STOCK_INTEGRATION_IMPL_CACHE_STOCK_CACHE_CONFIGURATION_SER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_stock_integration_impl_configuration_stock_configuration (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; locale: STRING_32; ims_config: STRING_32): detachable COM_DAY_CQ_DAM_STOCK_INTEGRATION_IMPL_CONFIGURATION_STOCK_CONFIGURATION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: locale  (optional)
			-- 
			-- argument: ims_config  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_STOCK_INTEGRATION_IMPL_CONFIGURATION_STOCK_CONFIGURATION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.stock.integration.impl.configuration.StockConfigurationImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "locale", locale));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "imsConfig", ims_config));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_STOCK_INTEGRATION_IMPL_CONFIGURATION_STOCK_CONFIGURATION_INFO } l_response.data ({ COM_DAY_CQ_DAM_STOCK_INTEGRATION_IMPL_CONFIGURATION_STOCK_CONFIGURATION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_dam_video_impl_servlet_video_test_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN): detachable COM_DAY_CQ_DAM_VIDEO_IMPL_SERVLET_VIDEO_TEST_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_DAM_VIDEO_IMPL_SERVLET_VIDEO_TEST_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.dam.video.impl.servlet.VideoTestServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_DAM_VIDEO_IMPL_SERVLET_VIDEO_TEST_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_DAM_VIDEO_IMPL_SERVLET_VIDEO_TEST_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_extwidget_servlets_image_sprite_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_width: INTEGER_32; max_height: INTEGER_32): detachable COM_DAY_CQ_EXTWIDGET_SERVLETS_IMAGE_SPRITE_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_width  (optional)
			-- 
			-- argument: max_height  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_EXTWIDGET_SERVLETS_IMAGE_SPRITE_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.extwidget.servlets.ImageSpriteServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxWidth", max_width));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxHeight", max_height));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_EXTWIDGET_SERVLETS_IMAGE_SPRITE_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_EXTWIDGET_SERVLETS_IMAGE_SPRITE_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_image_internal_font_font_helper (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; fontpath: detachable LIST [STRING_32]; oversampling_factor: INTEGER_32): detachable COM_DAY_CQ_IMAGE_INTERNAL_FONT_FONT_HELPER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: fontpath  (optional)
			-- 
			-- argument: oversampling_factor  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_IMAGE_INTERNAL_FONT_FONT_HELPER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.image.internal.font.FontHelper"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fontpath", fontpath));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oversamplingFactor", oversampling_factor));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_IMAGE_INTERNAL_FONT_FONT_HELPER_INFO } l_response.data ({ COM_DAY_CQ_IMAGE_INTERNAL_FONT_FONT_HELPER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_jcrclustersupport_cluster_start_level_controller (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cluster_level_enable: BOOLEAN; cluster_master_level: INTEGER_32; cluster_slave_level: INTEGER_32): detachable COM_DAY_CQ_JCRCLUSTERSUPPORT_CLUSTER_START_LEVEL_CONTROLLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cluster_level_enable  (optional)
			-- 
			-- argument: cluster_master_level  (optional)
			-- 
			-- argument: cluster_slave_level  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_JCRCLUSTERSUPPORT_CLUSTER_START_LEVEL_CONTROLLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.jcrclustersupport.ClusterStartLevelController"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.level.enable", cluster_level_enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.master.level", cluster_master_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cluster.slave.level", cluster_slave_level));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_JCRCLUSTERSUPPORT_CLUSTER_START_LEVEL_CONTROLLER_INFO } l_response.data ({ COM_DAY_CQ_JCRCLUSTERSUPPORT_CLUSTER_START_LEVEL_CONTROLLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mailer_default_mail_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; smtp_host: STRING_32; smtp_port: INTEGER_32; smtp_user: STRING_32; smtp_password: STRING_32; from_address: STRING_32; smtp_ssl: BOOLEAN; smtp_starttls: BOOLEAN; debug_email: BOOLEAN): detachable COM_DAY_CQ_MAILER_DEFAULT_MAIL_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: smtp_host  (optional)
			-- 
			-- argument: smtp_port  (optional)
			-- 
			-- argument: smtp_user  (optional)
			-- 
			-- argument: smtp_password  (optional)
			-- 
			-- argument: from_address  (optional)
			-- 
			-- argument: smtp_ssl  (optional)
			-- 
			-- argument: smtp_starttls  (optional)
			-- 
			-- argument: debug_email  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MAILER_DEFAULT_MAIL_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mailer.DefaultMailService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "smtp.host", smtp_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "smtp.port", smtp_port));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "smtp.user", smtp_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "smtp.password", smtp_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "from.address", from_address));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "smtp.ssl", smtp_ssl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "smtp.starttls", smtp_starttls));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "debug.email", debug_email));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MAILER_DEFAULT_MAIL_SERVICE_INFO } l_response.data ({ COM_DAY_CQ_MAILER_DEFAULT_MAIL_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mailer_impl_cq_mailing_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_recipient_count: STRING_32): detachable COM_DAY_CQ_MAILER_IMPL_CQ_MAILING_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_recipient_count  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MAILER_IMPL_CQ_MAILING_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mailer.impl.CqMailingService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "max.recipient.count", max_recipient_count));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MAILER_IMPL_CQ_MAILING_SERVICE_INFO } l_response.data ({ COM_DAY_CQ_MAILER_IMPL_CQ_MAILING_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mailer_impl_email_cq_email_template_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; mailer_email_charset: STRING_32): detachable COM_DAY_CQ_MAILER_IMPL_EMAIL_CQ_EMAIL_TEMPLATE_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: mailer_email_charset  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MAILER_IMPL_EMAIL_CQ_EMAIL_TEMPLATE_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mailer.impl.email.CqEmailTemplateFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "mailer.email.charset", mailer_email_charset));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MAILER_IMPL_EMAIL_CQ_EMAIL_TEMPLATE_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_MAILER_IMPL_EMAIL_CQ_EMAIL_TEMPLATE_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mailer_impl_email_cq_retriever_template_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; mailer_email_embed: BOOLEAN; mailer_email_charset: STRING_32; mailer_email_retriever_user_id: STRING_32; mailer_email_retriever_user_pw_d: STRING_32): detachable COM_DAY_CQ_MAILER_IMPL_EMAIL_CQ_RETRIEVER_TEMPLATE_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: mailer_email_embed  (optional)
			-- 
			-- argument: mailer_email_charset  (optional)
			-- 
			-- argument: mailer_email_retriever_user_id  (optional)
			-- 
			-- argument: mailer_email_retriever_user_pw_d  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MAILER_IMPL_EMAIL_CQ_RETRIEVER_TEMPLATE_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mailer.impl.email.CqRetrieverTemplateFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "mailer.email.embed", mailer_email_embed));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "mailer.email.charset", mailer_email_charset));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "mailer.email.retrieverUserID", mailer_email_retriever_user_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "mailer.email.retrieverUserPWD", mailer_email_retriever_user_pw_d));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MAILER_IMPL_EMAIL_CQ_RETRIEVER_TEMPLATE_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_MAILER_IMPL_EMAIL_CQ_RETRIEVER_TEMPLATE_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mcm_campaign_impl_integration_config_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; aem_mcm_campaign_form_constraints: detachable LIST [STRING_32]; aem_mcm_campaign_public_url: STRING_32; aem_mcm_campaign_relaxed_ss_l: BOOLEAN): detachable COM_DAY_CQ_MCM_CAMPAIGN_IMPL_INTEGRATION_CONFIG_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: aem_mcm_campaign_form_constraints  (optional)
			-- 
			-- argument: aem_mcm_campaign_public_url  (optional)
			-- 
			-- argument: aem_mcm_campaign_relaxed_ss_l  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MCM_CAMPAIGN_IMPL_INTEGRATION_CONFIG_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mcm.campaign.impl.IntegrationConfigImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "aem.mcm.campaign.formConstraints", aem_mcm_campaign_form_constraints));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "aem.mcm.campaign.publicUrl", aem_mcm_campaign_public_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "aem.mcm.campaign.relaxedSSL", aem_mcm_campaign_relaxed_ss_l));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MCM_CAMPAIGN_IMPL_INTEGRATION_CONFIG_IMPL_INFO } l_response.data ({ COM_DAY_CQ_MCM_CAMPAIGN_IMPL_INTEGRATION_CONFIG_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mcm_campaign_importer_personalized_text_handler_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_MCM_CAMPAIGN_IMPORTER_PERSONALIZED_TEXT_HANDLER_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MCM_CAMPAIGN_IMPORTER_PERSONALIZED_TEXT_HANDLER_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mcm.campaign.importer.PersonalizedTextHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MCM_CAMPAIGN_IMPORTER_PERSONALIZED_TEXT_HANDLER_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_MCM_CAMPAIGN_IMPORTER_PERSONALIZED_TEXT_HANDLER_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mcm_core_newsletter_newsletter_email_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; from_address: STRING_32; sender_host: STRING_32; max_bounce_count: STRING_32): detachable COM_DAY_CQ_MCM_CORE_NEWSLETTER_NEWSLETTER_EMAIL_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: from_address  (optional)
			-- 
			-- argument: sender_host  (optional)
			-- 
			-- argument: max_bounce_count  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MCM_CORE_NEWSLETTER_NEWSLETTER_EMAIL_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mcm.core.newsletter.NewsletterEmailServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "from.address", from_address));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sender.host", sender_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "max.bounce.count", max_bounce_count));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MCM_CORE_NEWSLETTER_NEWSLETTER_EMAIL_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_MCM_CORE_NEWSLETTER_NEWSLETTER_EMAIL_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mcm_impl_mc_mconfiguration (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; experience_indirection: detachable LIST [STRING_32]; touchpoint_indirection: detachable LIST [STRING_32]): detachable COM_DAY_CQ_MCM_IMPL_MCM_CONFIGURATION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: experience_indirection  (optional)
			-- 
			-- argument: touchpoint_indirection  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MCM_IMPL_MCM_CONFIGURATION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mcm.impl.MCMConfiguration"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "experience.indirection", experience_indirection));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "touchpoint.indirection", touchpoint_indirection));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MCM_IMPL_MCM_CONFIGURATION_INFO } l_response.data ({ COM_DAY_CQ_MCM_IMPL_MCM_CONFIGURATION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mcm_landingpage_parser_taghandlers_cta_click_through_componen (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32; component_resource_type: STRING_32): detachable COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_CTA_CLICK_THROUGH_COMPONEN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- argument: component_resource_type  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_CTA_CLICK_THROUGH_COMPONEN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.ClickThroughComponentTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "component.resourceType", component_resource_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_CTA_CLICK_THROUGH_COMPONEN_INFO } l_response.data ({ COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_CTA_CLICK_THROUGH_COMPONEN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mcm_landingpage_parser_taghandlers_cta_graphical_click_throug (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32; component_resource_type: STRING_32): detachable COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_CTA_GRAPHICAL_CLICK_THROUG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- argument: component_resource_type  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_CTA_GRAPHICAL_CLICK_THROUG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.GraphicalClickThroughComponentTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "component.resourceType", component_resource_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_CTA_GRAPHICAL_CLICK_THROUG_INFO } l_response.data ({ COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_CTA_GRAPHICAL_CLICK_THROUG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mcm_landingpage_parser_taghandlers_cta_lead_form_ct_acomponent (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_CTA_LEAD_FORM_CTA_COMPONENT_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_CTA_LEAD_FORM_CTA_COMPONENT_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.LeadFormCTAComponentTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_CTA_LEAD_FORM_CTA_COMPONENT_INFO } l_response.data ({ COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_CTA_LEAD_FORM_CTA_COMPONENT_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mcm_landingpage_parser_taghandlers_mbox_mbox_experience_tag_ha (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_MBOX_M_BOX_EXPERIENCE_TAG_HA_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_MBOX_M_BOX_EXPERIENCE_TAG_HA_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.mbox.MBoxExperienceTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_MBOX_M_BOX_EXPERIENCE_TAG_HA_INFO } l_response.data ({ COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_MBOX_M_BOX_EXPERIENCE_TAG_HA_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_mcm_landingpage_parser_taghandlers_mbox_target_component_tag_h (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32; component_resource_type: STRING_32): detachable COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_MBOX_TARGET_COMPONENT_TAG_H_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- argument: component_resource_type  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_MBOX_TARGET_COMPONENT_TAG_H_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.mbox.TargetComponentTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "component.resourceType", component_resource_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_MBOX_TARGET_COMPONENT_TAG_H_INFO } l_response.data ({ COM_DAY_CQ_MCM_LANDINGPAGE_PARSER_TAGHANDLERS_MBOX_TARGET_COMPONENT_TAG_H_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_notification_impl_notification_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_filter: STRING_32): detachable COM_DAY_CQ_NOTIFICATION_IMPL_NOTIFICATION_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_NOTIFICATION_IMPL_NOTIFICATION_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.notification.impl.NotificationServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_NOTIFICATION_IMPL_NOTIFICATION_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_NOTIFICATION_IMPL_NOTIFICATION_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_personalization_impl_servlets_targeting_configuration_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; forcelocation: BOOLEAN): detachable COM_DAY_CQ_PERSONALIZATION_IMPL_SERVLETS_TARGETING_CONFIGURATION_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: forcelocation  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_PERSONALIZATION_IMPL_SERVLETS_TARGETING_CONFIGURATION_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.personalization.impl.servlets.TargetingConfigurationServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "forcelocation", forcelocation));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_PERSONALIZATION_IMPL_SERVLETS_TARGETING_CONFIGURATION_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_PERSONALIZATION_IMPL_SERVLETS_TARGETING_CONFIGURATION_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_polling_importer_impl_managed_poll_config_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; id: STRING_32; enabled: BOOLEAN; reference: BOOLEAN; interval: INTEGER_32; expression: STRING_32; source: STRING_32; target: STRING_32; login: STRING_32; password: STRING_32): detachable COM_DAY_CQ_POLLING_IMPORTER_IMPL_MANAGED_POLL_CONFIG_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: id  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: reference  (optional)
			-- 
			-- argument: interval  (optional)
			-- 
			-- argument: expression  (optional)
			-- 
			-- argument: source  (optional)
			-- 
			-- argument: target  (optional)
			-- 
			-- argument: login  (optional)
			-- 
			-- argument: password  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_POLLING_IMPORTER_IMPL_MANAGED_POLL_CONFIG_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.polling.importer.impl.ManagedPollConfigImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "reference", reference));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "interval", interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "expression", expression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "source", source));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "target", target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "login", login));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "password", password));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_POLLING_IMPORTER_IMPL_MANAGED_POLL_CONFIG_IMPL_INFO } l_response.data ({ COM_DAY_CQ_POLLING_IMPORTER_IMPL_MANAGED_POLL_CONFIG_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_polling_importer_impl_managed_polling_importer_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; importer_user: STRING_32): detachable COM_DAY_CQ_POLLING_IMPORTER_IMPL_MANAGED_POLLING_IMPORTER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: importer_user  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_POLLING_IMPORTER_IMPL_MANAGED_POLLING_IMPORTER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.polling.importer.impl.ManagedPollingImporterImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "importer.user", importer_user));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_POLLING_IMPORTER_IMPL_MANAGED_POLLING_IMPORTER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_POLLING_IMPORTER_IMPL_MANAGED_POLLING_IMPORTER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_polling_importer_impl_polling_importer_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; importer_min_interval: INTEGER_32; importer_user: STRING_32; exclude_paths: detachable LIST [STRING_32]; include_paths: detachable LIST [STRING_32]): detachable COM_DAY_CQ_POLLING_IMPORTER_IMPL_POLLING_IMPORTER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: importer_min_interval  (optional)
			-- 
			-- argument: importer_user  (optional)
			-- 
			-- argument: exclude_paths  (optional)
			-- 
			-- argument: include_paths  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_POLLING_IMPORTER_IMPL_POLLING_IMPORTER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.polling.importer.impl.PollingImporterImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "importer.min.interval", importer_min_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "importer.user", importer_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "exclude.paths", exclude_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "include.paths", include_paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_POLLING_IMPORTER_IMPL_POLLING_IMPORTER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_POLLING_IMPORTER_IMPL_POLLING_IMPORTER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_replication_audit_replication_event_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32): detachable COM_DAY_CQ_REPLICATION_AUDIT_REPLICATION_EVENT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPLICATION_AUDIT_REPLICATION_EVENT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.replication.audit.ReplicationEventListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPLICATION_AUDIT_REPLICATION_EVENT_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_REPLICATION_AUDIT_REPLICATION_EVENT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_replication_content_static_content_builder (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; host: STRING_32; port: INTEGER_32): detachable COM_DAY_CQ_REPLICATION_CONTENT_STATIC_CONTENT_BUILDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: host  (optional)
			-- 
			-- argument: port  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPLICATION_CONTENT_STATIC_CONTENT_BUILDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.replication.content.StaticContentBuilder"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "host", host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "port", port));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPLICATION_CONTENT_STATIC_CONTENT_BUILDER_INFO } l_response.data ({ COM_DAY_CQ_REPLICATION_CONTENT_STATIC_CONTENT_BUILDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_replication_impl_agent_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; job_topics: STRING_32; service_user_target: STRING_32; agent_provider_target: STRING_32): detachable COM_DAY_CQ_REPLICATION_IMPL_AGENT_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: job_topics  (optional)
			-- 
			-- argument: service_user_target  (optional)
			-- 
			-- argument: agent_provider_target  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPLICATION_IMPL_AGENT_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.replication.impl.AgentManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "job.topics", job_topics));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceUser.target", service_user_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "agentProvider.target", agent_provider_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPLICATION_IMPL_AGENT_MANAGER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_REPLICATION_IMPL_AGENT_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_replication_impl_content_durbo_binary_less_content_builder (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; binary_threshold: INTEGER_32): detachable COM_DAY_CQ_REPLICATION_IMPL_CONTENT_DURBO_BINARY_LESS_CONTENT_BUILDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: binary_threshold  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPLICATION_IMPL_CONTENT_DURBO_BINARY_LESS_CONTENT_BUILDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.replication.impl.content.durbo.BinaryLessContentBuilder"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "binary.threshold", binary_threshold));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPLICATION_IMPL_CONTENT_DURBO_BINARY_LESS_CONTENT_BUILDER_INFO } l_response.data ({ COM_DAY_CQ_REPLICATION_IMPL_CONTENT_DURBO_BINARY_LESS_CONTENT_BUILDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_replication_impl_content_durbo_durbo_import_configuration_prov (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; preserve_hierarchy_nodes: BOOLEAN; ignore_versioning: BOOLEAN; import_acl: BOOLEAN; save_threshold: INTEGER_32; preserve_user_paths: BOOLEAN; preserve_uuid: BOOLEAN; preserve_uuid_nodetypes: detachable LIST [STRING_32]; preserve_uuid_subtrees: detachable LIST [STRING_32]; auto_commit: BOOLEAN): detachable COM_DAY_CQ_REPLICATION_IMPL_CONTENT_DURBO_DURBO_IMPORT_CONFIGURATION_PROV_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: preserve_hierarchy_nodes  (optional)
			-- 
			-- argument: ignore_versioning  (optional)
			-- 
			-- argument: import_acl  (optional)
			-- 
			-- argument: save_threshold  (optional)
			-- 
			-- argument: preserve_user_paths  (optional)
			-- 
			-- argument: preserve_uuid  (optional)
			-- 
			-- argument: preserve_uuid_nodetypes  (optional)
			-- 
			-- argument: preserve_uuid_subtrees  (optional)
			-- 
			-- argument: auto_commit  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPLICATION_IMPL_CONTENT_DURBO_DURBO_IMPORT_CONFIGURATION_PROV_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.replication.impl.content.durbo.DurboImportConfigurationProviderService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "preserve.hierarchy.nodes", preserve_hierarchy_nodes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ignore.versioning", ignore_versioning));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "import.acl", import_acl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "save.threshold", save_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "preserve.user.paths", preserve_user_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "preserve.uuid", preserve_uuid));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "preserve.uuid.nodetypes", preserve_uuid_nodetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "preserve.uuid.subtrees", preserve_uuid_subtrees));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auto.commit", auto_commit));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPLICATION_IMPL_CONTENT_DURBO_DURBO_IMPORT_CONFIGURATION_PROV_INFO } l_response.data ({ COM_DAY_CQ_REPLICATION_IMPL_CONTENT_DURBO_DURBO_IMPORT_CONFIGURATION_PROV_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_replication_impl_replication_content_factory_provider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; replication_content_use_file_storage: BOOLEAN; replication_content_max_commit_attempts: INTEGER_32): detachable COM_DAY_CQ_REPLICATION_IMPL_REPLICATION_CONTENT_FACTORY_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: replication_content_use_file_storage  (optional)
			-- 
			-- argument: replication_content_max_commit_attempts  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPLICATION_IMPL_REPLICATION_CONTENT_FACTORY_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.replication.impl.ReplicationContentFactoryProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "replication.content.useFileStorage", replication_content_use_file_storage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "replication.content.maxCommitAttempts", replication_content_max_commit_attempts));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPLICATION_IMPL_REPLICATION_CONTENT_FACTORY_PROVIDER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_REPLICATION_IMPL_REPLICATION_CONTENT_FACTORY_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_replication_impl_replication_receiver_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; receiver_tmpfile_threshold: INTEGER_32; receiver_packages_use_install: BOOLEAN): detachable COM_DAY_CQ_REPLICATION_IMPL_REPLICATION_RECEIVER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: receiver_tmpfile_threshold  (optional)
			-- 
			-- argument: receiver_packages_use_install  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPLICATION_IMPL_REPLICATION_RECEIVER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.replication.impl.ReplicationReceiverImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "receiver.tmpfile.threshold", receiver_tmpfile_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "receiver.packages.use.install", receiver_packages_use_install));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPLICATION_IMPL_REPLICATION_RECEIVER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_REPLICATION_IMPL_REPLICATION_RECEIVER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_replication_impl_replicator_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; distribute_events: BOOLEAN): detachable COM_DAY_CQ_REPLICATION_IMPL_REPLICATOR_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: distribute_events  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPLICATION_IMPL_REPLICATOR_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.replication.impl.ReplicatorImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "distribute_events", distribute_events));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPLICATION_IMPL_REPLICATOR_IMPL_INFO } l_response.data ({ COM_DAY_CQ_REPLICATION_IMPL_REPLICATOR_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_replication_impl_reverse_replicator (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_period: INTEGER_32): detachable COM_DAY_CQ_REPLICATION_IMPL_REVERSE_REPLICATOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_period  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPLICATION_IMPL_REVERSE_REPLICATOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.replication.impl.ReverseReplicator"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.period", scheduler_period));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPLICATION_IMPL_REVERSE_REPLICATOR_INFO } l_response.data ({ COM_DAY_CQ_REPLICATION_IMPL_REVERSE_REPLICATOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_replication_impl_transport_binary_less_transport_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; disabled_cipher_suites: detachable LIST [STRING_32]; enabled_cipher_suites: detachable LIST [STRING_32]): detachable COM_DAY_CQ_REPLICATION_IMPL_TRANSPORT_BINARY_LESS_TRANSPORT_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: disabled_cipher_suites  (optional)
			-- 
			-- argument: enabled_cipher_suites  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPLICATION_IMPL_TRANSPORT_BINARY_LESS_TRANSPORT_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.replication.impl.transport.BinaryLessTransportHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "disabled.cipher.suites", disabled_cipher_suites));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "enabled.cipher.suites", enabled_cipher_suites));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPLICATION_IMPL_TRANSPORT_BINARY_LESS_TRANSPORT_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_REPLICATION_IMPL_TRANSPORT_BINARY_LESS_TRANSPORT_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_replication_impl_transport_http (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; disabled_cipher_suites: detachable LIST [STRING_32]; enabled_cipher_suites: detachable LIST [STRING_32]): detachable COM_DAY_CQ_REPLICATION_IMPL_TRANSPORT_HTTP_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: disabled_cipher_suites  (optional)
			-- 
			-- argument: enabled_cipher_suites  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPLICATION_IMPL_TRANSPORT_HTTP_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.replication.impl.transport.Http"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "disabled.cipher.suites", disabled_cipher_suites));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "enabled.cipher.suites", enabled_cipher_suites));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPLICATION_IMPL_TRANSPORT_HTTP_INFO } l_response.data ({ COM_DAY_CQ_REPLICATION_IMPL_TRANSPORT_HTTP_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_reporting_impl_cache_cache_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; repcache_enable: BOOLEAN; repcache_ttl: INTEGER_32; repcache_max: INTEGER_32): detachable COM_DAY_CQ_REPORTING_IMPL_CACHE_CACHE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: repcache_enable  (optional)
			-- 
			-- argument: repcache_ttl  (optional)
			-- 
			-- argument: repcache_max  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPORTING_IMPL_CACHE_CACHE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.reporting.impl.cache.CacheImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repcache.enable", repcache_enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repcache.ttl", repcache_ttl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repcache.max", repcache_max));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPORTING_IMPL_CACHE_CACHE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_REPORTING_IMPL_CACHE_CACHE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_reporting_impl_config_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; repconf_timezone: STRING_32; repconf_locale: STRING_32; repconf_snapshots: STRING_32; repconf_repdir: STRING_32; repconf_hourofday: INTEGER_32; repconf_minofhour: INTEGER_32; repconf_maxrows: INTEGER_32; repconf_fakedata: BOOLEAN; repconf_snapshotuser: STRING_32; repconf_enforcesnapshotuser: BOOLEAN): detachable COM_DAY_CQ_REPORTING_IMPL_CONFIG_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: repconf_timezone  (optional)
			-- 
			-- argument: repconf_locale  (optional)
			-- 
			-- argument: repconf_snapshots  (optional)
			-- 
			-- argument: repconf_repdir  (optional)
			-- 
			-- argument: repconf_hourofday  (optional)
			-- 
			-- argument: repconf_minofhour  (optional)
			-- 
			-- argument: repconf_maxrows  (optional)
			-- 
			-- argument: repconf_fakedata  (optional)
			-- 
			-- argument: repconf_snapshotuser  (optional)
			-- 
			-- argument: repconf_enforcesnapshotuser  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPORTING_IMPL_CONFIG_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.reporting.impl.ConfigServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repconf.timezone", repconf_timezone));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repconf.locale", repconf_locale));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repconf.snapshots", repconf_snapshots));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repconf.repdir", repconf_repdir));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repconf.hourofday", repconf_hourofday));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repconf.minofhour", repconf_minofhour));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repconf.maxrows", repconf_maxrows));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repconf.fakedata", repconf_fakedata));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repconf.snapshotuser", repconf_snapshotuser));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repconf.enforcesnapshotuser", repconf_enforcesnapshotuser));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPORTING_IMPL_CONFIG_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_REPORTING_IMPL_CONFIG_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_reporting_impl_rlog_analyzer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; request_log_output: STRING_32): detachable COM_DAY_CQ_REPORTING_IMPL_R_LOG_ANALYZER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: request_log_output  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REPORTING_IMPL_R_LOG_ANALYZER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.reporting.impl.RLogAnalyzer"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "request.log.output", request_log_output));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REPORTING_IMPL_R_LOG_ANALYZER_INFO } l_response.data ({ COM_DAY_CQ_REPORTING_IMPL_R_LOG_ANALYZER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_rewriter_linkchecker_impl_link_checker_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_period: INTEGER_32; scheduler_concurrent: BOOLEAN; service_bad_link_tolerance_interval: INTEGER_32; service_check_override_patterns: detachable LIST [STRING_32]; service_cache_broken_internal_links: BOOLEAN; service_special_link_prefix: detachable LIST [STRING_32]; service_special_link_patterns: detachable LIST [STRING_32]): detachable COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_CHECKER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_period  (optional)
			-- 
			-- argument: scheduler_concurrent  (optional)
			-- 
			-- argument: service_bad_link_tolerance_interval  (optional)
			-- 
			-- argument: service_check_override_patterns  (optional)
			-- 
			-- argument: service_cache_broken_internal_links  (optional)
			-- 
			-- argument: service_special_link_prefix  (optional)
			-- 
			-- argument: service_special_link_patterns  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_CHECKER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.period", scheduler_period));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.concurrent", scheduler_concurrent));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.bad_link_tolerance_interval", service_bad_link_tolerance_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "service.check_override_patterns", service_check_override_patterns));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.cache_broken_internal_links", service_cache_broken_internal_links));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "service.special_link_prefix", service_special_link_prefix));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "service.special_link_patterns", service_special_link_patterns));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_CHECKER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_CHECKER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_rewriter_linkchecker_impl_link_checker_task (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_period: INTEGER_32; scheduler_concurrent: BOOLEAN; good_link_test_interval: INTEGER_32; bad_link_test_interval: INTEGER_32; link_unused_interval: INTEGER_32; connection_timeout: INTEGER_32): detachable COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_CHECKER_TASK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_period  (optional)
			-- 
			-- argument: scheduler_concurrent  (optional)
			-- 
			-- argument: good_link_test_interval  (optional)
			-- 
			-- argument: bad_link_test_interval  (optional)
			-- 
			-- argument: link_unused_interval  (optional)
			-- 
			-- argument: connection_timeout  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_CHECKER_TASK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerTask"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.period", scheduler_period));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.concurrent", scheduler_concurrent));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "good_link_test_interval", good_link_test_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "bad_link_test_interval", bad_link_test_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "link_unused_interval", link_unused_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connection.timeout", connection_timeout));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_CHECKER_TASK_INFO } l_response.data ({ COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_CHECKER_TASK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_rewriter_linkchecker_impl_link_checker_transformer_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; linkcheckertransformer_disable_rewriting: BOOLEAN; linkcheckertransformer_disable_checking: BOOLEAN; linkcheckertransformer_map_cache_size: INTEGER_32; linkcheckertransformer_strict_extension_check: BOOLEAN; linkcheckertransformer_strip_htmlt_extension: BOOLEAN; linkcheckertransformer_rewrite_elements: detachable LIST [STRING_32]; linkcheckertransformer_strip_extension_path_blacklist: detachable LIST [STRING_32]): detachable COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_CHECKER_TRANSFORMER_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: linkcheckertransformer_disable_rewriting  (optional)
			-- 
			-- argument: linkcheckertransformer_disable_checking  (optional)
			-- 
			-- argument: linkcheckertransformer_map_cache_size  (optional)
			-- 
			-- argument: linkcheckertransformer_strict_extension_check  (optional)
			-- 
			-- argument: linkcheckertransformer_strip_htmlt_extension  (optional)
			-- 
			-- argument: linkcheckertransformer_rewrite_elements  (optional)
			-- 
			-- argument: linkcheckertransformer_strip_extension_path_blacklist  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_CHECKER_TRANSFORMER_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerTransformerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "linkcheckertransformer.disableRewriting", linkcheckertransformer_disable_rewriting));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "linkcheckertransformer.disableChecking", linkcheckertransformer_disable_checking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "linkcheckertransformer.mapCacheSize", linkcheckertransformer_map_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "linkcheckertransformer.strictExtensionCheck", linkcheckertransformer_strict_extension_check));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "linkcheckertransformer.stripHtmltExtension", linkcheckertransformer_strip_htmlt_extension));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "linkcheckertransformer.rewriteElements", linkcheckertransformer_rewrite_elements));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "linkcheckertransformer.stripExtensionPathBlacklist", linkcheckertransformer_strip_extension_path_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_CHECKER_TRANSFORMER_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_CHECKER_TRANSFORMER_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_rewriter_linkchecker_impl_link_info_storage_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_max_links_per_host: INTEGER_32; service_save_external_link_references: BOOLEAN): detachable COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_INFO_STORAGE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_max_links_per_host  (optional)
			-- 
			-- argument: service_save_external_link_references  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_INFO_STORAGE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkInfoStorageImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.max_links_per_host", service_max_links_per_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.save_external_link_references", service_save_external_link_references));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_INFO_STORAGE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_REWRITER_LINKCHECKER_IMPL_LINK_INFO_STORAGE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_rewriter_processor_impl_html_parser_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; htmlparser_process_tags: detachable LIST [STRING_32]; htmlparser_preserve_camel_case: BOOLEAN): detachable COM_DAY_CQ_REWRITER_PROCESSOR_IMPL_HTML_PARSER_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: htmlparser_process_tags  (optional)
			-- 
			-- argument: htmlparser_preserve_camel_case  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_REWRITER_PROCESSOR_IMPL_HTML_PARSER_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.rewriter.processor.impl.HtmlParserFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "htmlparser.processTags", htmlparser_process_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmlparser.preserveCamelCase", htmlparser_preserve_camel_case));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_REWRITER_PROCESSOR_IMPL_HTML_PARSER_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_REWRITER_PROCESSOR_IMPL_HTML_PARSER_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_search_impl_builder_query_builder_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; excerpt_properties: detachable LIST [STRING_32]; cache_max_entries: INTEGER_32; cache_entry_lifetime: INTEGER_32; xpath_union: BOOLEAN): detachable COM_DAY_CQ_SEARCH_IMPL_BUILDER_QUERY_BUILDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: excerpt_properties  (optional)
			-- 
			-- argument: cache_max_entries  (optional)
			-- 
			-- argument: cache_entry_lifetime  (optional)
			-- 
			-- argument: xpath_union  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_SEARCH_IMPL_BUILDER_QUERY_BUILDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.search.impl.builder.QueryBuilderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "excerpt.properties", excerpt_properties));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.max.entries", cache_max_entries));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache.entry.lifetime", cache_entry_lifetime));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "xpath.union", xpath_union));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_SEARCH_IMPL_BUILDER_QUERY_BUILDER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_SEARCH_IMPL_BUILDER_QUERY_BUILDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_search_suggest_impl_suggestion_index_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path_builder_target: STRING_32; suggest_basepath: STRING_32): detachable COM_DAY_CQ_SEARCH_SUGGEST_IMPL_SUGGESTION_INDEX_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path_builder_target  (optional)
			-- 
			-- argument: suggest_basepath  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_SEARCH_SUGGEST_IMPL_SUGGESTION_INDEX_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.search.suggest.impl.SuggestionIndexManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pathBuilder.target", path_builder_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "suggest.basepath", suggest_basepath));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_SEARCH_SUGGEST_IMPL_SUGGESTION_INDEX_MANAGER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_SEARCH_SUGGEST_IMPL_SUGGESTION_INDEX_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_searchpromote_impl_publish_search_promote_config_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_searchpromote_confighandler_enabled: BOOLEAN): detachable COM_DAY_CQ_SEARCHPROMOTE_IMPL_PUBLISH_SEARCH_PROMOTE_CONFIG_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_searchpromote_confighandler_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_SEARCHPROMOTE_IMPL_PUBLISH_SEARCH_PROMOTE_CONFIG_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.searchpromote.impl.PublishSearchPromoteConfigHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.searchpromote.confighandler.enabled", cq_searchpromote_confighandler_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_SEARCHPROMOTE_IMPL_PUBLISH_SEARCH_PROMOTE_CONFIG_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_SEARCHPROMOTE_IMPL_PUBLISH_SEARCH_PROMOTE_CONFIG_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_searchpromote_impl_search_promote_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_searchpromote_configuration_server_uri: STRING_32; cq_searchpromote_configuration_environment: STRING_32; connection_timeout: INTEGER_32; socket_timeout: INTEGER_32): detachable COM_DAY_CQ_SEARCHPROMOTE_IMPL_SEARCH_PROMOTE_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_searchpromote_configuration_server_uri  (optional)
			-- 
			-- argument: cq_searchpromote_configuration_environment  (optional)
			-- 
			-- argument: connection_timeout  (optional)
			-- 
			-- argument: socket_timeout  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_SEARCHPROMOTE_IMPL_SEARCH_PROMOTE_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.searchpromote.impl.SearchPromoteServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.searchpromote.configuration.server.uri", cq_searchpromote_configuration_server_uri));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.searchpromote.configuration.environment", cq_searchpromote_configuration_environment));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connection.timeout", connection_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "socket.timeout", socket_timeout));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_SEARCHPROMOTE_IMPL_SEARCH_PROMOTE_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_SEARCHPROMOTE_IMPL_SEARCH_PROMOTE_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_security_ac_lsetup (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_aclsetup_rules: detachable LIST [STRING_32]): detachable COM_DAY_CQ_SECURITY_ACL_SETUP_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_aclsetup_rules  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_SECURITY_ACL_SETUP_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.security.ACLSetup"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.aclsetup.rules", cq_aclsetup_rules));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_SECURITY_ACL_SETUP_INFO } l_response.data ({ COM_DAY_CQ_SECURITY_ACL_SETUP_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_statistics_impl_statistics_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_period: INTEGER_32; scheduler_concurrent: BOOLEAN; path: STRING_32; workspace: STRING_32; keywords_path: STRING_32; async_entries: BOOLEAN): detachable COM_DAY_CQ_STATISTICS_IMPL_STATISTICS_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_period  (optional)
			-- 
			-- argument: scheduler_concurrent  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: workspace  (optional)
			-- 
			-- argument: keywords_path  (optional)
			-- 
			-- argument: async_entries  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_STATISTICS_IMPL_STATISTICS_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.statistics.impl.StatisticsServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.period", scheduler_period));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.concurrent", scheduler_concurrent));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "workspace", workspace));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "keywordsPath", keywords_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "asyncEntries", async_entries));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_STATISTICS_IMPL_STATISTICS_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_STATISTICS_IMPL_STATISTICS_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_tagging_impl_jcr_tag_manager_factory_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; validation_enabled: BOOLEAN): detachable COM_DAY_CQ_TAGGING_IMPL_JCR_TAG_MANAGER_FACTORY_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: validation_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_TAGGING_IMPL_JCR_TAG_MANAGER_FACTORY_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.tagging.impl.JcrTagManagerFactoryImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "validation.enabled", validation_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_TAGGING_IMPL_JCR_TAG_MANAGER_FACTORY_IMPL_INFO } l_response.data ({ COM_DAY_CQ_TAGGING_IMPL_JCR_TAG_MANAGER_FACTORY_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_tagging_impl_search_tag_predicate_evaluator (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; ignore_path: BOOLEAN): detachable COM_DAY_CQ_TAGGING_IMPL_SEARCH_TAG_PREDICATE_EVALUATOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: ignore_path  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_TAGGING_IMPL_SEARCH_TAG_PREDICATE_EVALUATOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.tagging.impl.search.TagPredicateEvaluator"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ignore_path", ignore_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_TAGGING_IMPL_SEARCH_TAG_PREDICATE_EVALUATOR_INFO } l_response.data ({ COM_DAY_CQ_TAGGING_IMPL_SEARCH_TAG_PREDICATE_EVALUATOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_tagging_impl_tag_garbage_collector (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_expression: STRING_32): detachable COM_DAY_CQ_TAGGING_IMPL_TAG_GARBAGE_COLLECTOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_TAGGING_IMPL_TAG_GARBAGE_COLLECTOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.tagging.impl.TagGarbageCollector"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_TAGGING_IMPL_TAG_GARBAGE_COLLECTOR_INFO } l_response.data ({ COM_DAY_CQ_TAGGING_IMPL_TAG_GARBAGE_COLLECTOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_contentsync_impl_handler_pages_update_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_pagesupdatehandler_imageresourcetypes: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_CONTENTSYNC_IMPL_HANDLER_PAGES_UPDATE_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_pagesupdatehandler_imageresourcetypes  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CONTENTSYNC_IMPL_HANDLER_PAGES_UPDATE_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.contentsync.impl.handler.PagesUpdateHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.pagesupdatehandler.imageresourcetypes", cq_pagesupdatehandler_imageresourcetypes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CONTENTSYNC_IMPL_HANDLER_PAGES_UPDATE_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_WCM_CONTENTSYNC_IMPL_HANDLER_PAGES_UPDATE_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_contentsync_impl_rewriter_path_rewriter_transformer_factor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_contentsync_pathrewritertransformer_mapping_links: detachable LIST [STRING_32]; cq_contentsync_pathrewritertransformer_mapping_clientlibs: detachable LIST [STRING_32]; cq_contentsync_pathrewritertransformer_mapping_images: detachable LIST [STRING_32]; cq_contentsync_pathrewritertransformer_attribute_pattern: STRING_32; cq_contentsync_pathrewritertransformer_clientlibrary_pattern: STRING_32; cq_contentsync_pathrewritertransformer_clientlibrary_replace: STRING_32): detachable COM_DAY_CQ_WCM_CONTENTSYNC_IMPL_REWRITER_PATH_REWRITER_TRANSFORMER_FACTOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_contentsync_pathrewritertransformer_mapping_links  (optional)
			-- 
			-- argument: cq_contentsync_pathrewritertransformer_mapping_clientlibs  (optional)
			-- 
			-- argument: cq_contentsync_pathrewritertransformer_mapping_images  (optional)
			-- 
			-- argument: cq_contentsync_pathrewritertransformer_attribute_pattern  (optional)
			-- 
			-- argument: cq_contentsync_pathrewritertransformer_clientlibrary_pattern  (optional)
			-- 
			-- argument: cq_contentsync_pathrewritertransformer_clientlibrary_replace  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CONTENTSYNC_IMPL_REWRITER_PATH_REWRITER_TRANSFORMER_FACTOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.contentsync.impl.rewriter.PathRewriterTransformerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.contentsync.pathrewritertransformer.mapping.links", cq_contentsync_pathrewritertransformer_mapping_links));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.contentsync.pathrewritertransformer.mapping.clientlibs", cq_contentsync_pathrewritertransformer_mapping_clientlibs));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.contentsync.pathrewritertransformer.mapping.images", cq_contentsync_pathrewritertransformer_mapping_images));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.contentsync.pathrewritertransformer.attribute.pattern", cq_contentsync_pathrewritertransformer_attribute_pattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.contentsync.pathrewritertransformer.clientlibrary.pattern", cq_contentsync_pathrewritertransformer_clientlibrary_pattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.contentsync.pathrewritertransformer.clientlibrary.replace", cq_contentsync_pathrewritertransformer_clientlibrary_replace));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CONTENTSYNC_IMPL_REWRITER_PATH_REWRITER_TRANSFORMER_FACTOR_INFO } l_response.data ({ COM_DAY_CQ_WCM_CONTENTSYNC_IMPL_REWRITER_PATH_REWRITER_TRANSFORMER_FACTOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_authoring_ui_mode_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; authoring_ui_mode_service_default: STRING_32): detachable COM_DAY_CQ_WCM_CORE_IMPL_AUTHORING_UI_MODE_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: authoring_ui_mode_service_default  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_AUTHORING_UI_MODE_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.AuthoringUIModeServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "authoringUIModeService.default", authoring_ui_mode_service_default));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_AUTHORING_UI_MODE_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_AUTHORING_UI_MODE_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_commands_wc_mcommand_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; wcmcommandservlet_delete_whitelist: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_CORE_IMPL_COMMANDS_WCM_COMMAND_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: wcmcommandservlet_delete_whitelist  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_COMMANDS_WCM_COMMAND_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.commands.WCMCommandServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "wcmcommandservlet.delete_whitelist", wcmcommandservlet_delete_whitelist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_COMMANDS_WCM_COMMAND_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_COMMANDS_WCM_COMMAND_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_devicedetection_device_identification_mode_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; dim_default_mode: STRING_32; dim_appcache_enabled: BOOLEAN): detachable COM_DAY_CQ_WCM_CORE_IMPL_DEVICEDETECTION_DEVICE_IDENTIFICATION_MODE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: dim_default_mode  (optional)
			-- 
			-- argument: dim_appcache_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_DEVICEDETECTION_DEVICE_IDENTIFICATION_MODE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.devicedetection.DeviceIdentificationModeImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dim.default.mode", dim_default_mode));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dim.appcache.enabled", dim_appcache_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_DEVICEDETECTION_DEVICE_IDENTIFICATION_MODE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_DEVICEDETECTION_DEVICE_IDENTIFICATION_MODE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_event_page_event_audit_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; configured: STRING_32): detachable COM_DAY_CQ_WCM_CORE_IMPL_EVENT_PAGE_EVENT_AUDIT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: configured  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_EVENT_PAGE_EVENT_AUDIT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.event.PageEventAuditListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "configured", configured));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_EVENT_PAGE_EVENT_AUDIT_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_EVENT_PAGE_EVENT_AUDIT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_event_page_post_processor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; paths: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_CORE_IMPL_EVENT_PAGE_POST_PROCESSOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: paths  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_EVENT_PAGE_POST_PROCESSOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.event.PagePostProcessor"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "paths", paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_EVENT_PAGE_POST_PROCESSOR_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_EVENT_PAGE_POST_PROCESSOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_event_repository_change_event_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; paths: detachable LIST [STRING_32]; excluded_paths: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_CORE_IMPL_EVENT_REPOSITORY_CHANGE_EVENT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: paths  (optional)
			-- 
			-- argument: excluded_paths  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_EVENT_REPOSITORY_CHANGE_EVENT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.event.RepositoryChangeEventListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "paths", paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "excludedPaths", excluded_paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_EVENT_REPOSITORY_CHANGE_EVENT_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_EVENT_REPOSITORY_CHANGE_EVENT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_event_template_post_processor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; paths: STRING_32): detachable COM_DAY_CQ_WCM_CORE_IMPL_EVENT_TEMPLATE_POST_PROCESSOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: paths  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_EVENT_TEMPLATE_POST_PROCESSOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.event.TemplatePostProcessor"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "paths", paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_EVENT_TEMPLATE_POST_PROCESSOR_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_EVENT_TEMPLATE_POST_PROCESSOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_language_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; langmgr_list_path: STRING_32; langmgr_country_default: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_CORE_IMPL_LANGUAGE_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: langmgr_list_path  (optional)
			-- 
			-- argument: langmgr_country_default  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_LANGUAGE_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.LanguageManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "langmgr.list.path", langmgr_list_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "langmgr.country.default", langmgr_country_default));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_LANGUAGE_MANAGER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_LANGUAGE_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_link_checker_configuration_factory_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; link_expired_prefix: STRING_32; link_expired_remove: BOOLEAN; link_expired_suffix: STRING_32; link_invalid_prefix: STRING_32; link_invalid_remove: BOOLEAN; link_invalid_suffix: STRING_32; link_predated_prefix: STRING_32; link_predated_remove: BOOLEAN; link_predated_suffix: STRING_32; link_wcmmodes: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_CORE_IMPL_LINK_CHECKER_CONFIGURATION_FACTORY_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: link_expired_prefix  (optional)
			-- 
			-- argument: link_expired_remove  (optional)
			-- 
			-- argument: link_expired_suffix  (optional)
			-- 
			-- argument: link_invalid_prefix  (optional)
			-- 
			-- argument: link_invalid_remove  (optional)
			-- 
			-- argument: link_invalid_suffix  (optional)
			-- 
			-- argument: link_predated_prefix  (optional)
			-- 
			-- argument: link_predated_remove  (optional)
			-- 
			-- argument: link_predated_suffix  (optional)
			-- 
			-- argument: link_wcmmodes  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_LINK_CHECKER_CONFIGURATION_FACTORY_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.LinkCheckerConfigurationFactoryImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "link.expired.prefix", link_expired_prefix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "link.expired.remove", link_expired_remove));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "link.expired.suffix", link_expired_suffix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "link.invalid.prefix", link_invalid_prefix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "link.invalid.remove", link_invalid_remove));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "link.invalid.suffix", link_invalid_suffix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "link.predated.prefix", link_predated_prefix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "link.predated.remove", link_predated_remove));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "link.predated.suffix", link_predated_suffix));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "link.wcmmodes", link_wcmmodes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_LINK_CHECKER_CONFIGURATION_FACTORY_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_LINK_CHECKER_CONFIGURATION_FACTORY_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_page_page_info_aggregator_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; page_info_provider_property_regex_default: STRING_32; page_info_provider_property_name: STRING_32): detachable COM_DAY_CQ_WCM_CORE_IMPL_PAGE_PAGE_INFO_AGGREGATOR_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: page_info_provider_property_regex_default  (optional)
			-- 
			-- argument: page_info_provider_property_name  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_PAGE_PAGE_INFO_AGGREGATOR_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.page.PageInfoAggregatorImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "page.info.provider.property.regex.default", page_info_provider_property_regex_default));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "page.info.provider.property.name", page_info_provider_property_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_PAGE_PAGE_INFO_AGGREGATOR_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_PAGE_PAGE_INFO_AGGREGATOR_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_page_page_manager_factory_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; illegal_char_mapping: STRING_32; page_sub_tree_activation_check: BOOLEAN): detachable COM_DAY_CQ_WCM_CORE_IMPL_PAGE_PAGE_MANAGER_FACTORY_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: illegal_char_mapping  (optional)
			-- 
			-- argument: page_sub_tree_activation_check  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_PAGE_PAGE_MANAGER_FACTORY_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.page.PageManagerFactoryImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "illegalCharMapping", illegal_char_mapping));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pageSubTreeActivationCheck", page_sub_tree_activation_check));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_PAGE_PAGE_MANAGER_FACTORY_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_PAGE_PAGE_MANAGER_FACTORY_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_references_content_content_reference_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; content_reference_config_resource_types: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_CORE_IMPL_REFERENCES_CONTENT_CONTENT_REFERENCE_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: content_reference_config_resource_types  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_REFERENCES_CONTENT_CONTENT_REFERENCE_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.references.content.ContentReferenceConfig"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "contentReferenceConfig.resourceTypes", content_reference_config_resource_types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_REFERENCES_CONTENT_CONTENT_REFERENCE_CONFIG_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_REFERENCES_CONTENT_CONTENT_REFERENCE_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_servlets_contentfinder_asset_view_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; dam_showexpired: BOOLEAN; dam_showhidden: BOOLEAN; tag_title_search: BOOLEAN; guess_total: STRING_32; dam_expiry_property: STRING_32): detachable COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_CONTENTFINDER_ASSET_VIEW_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: dam_showexpired  (optional)
			-- 
			-- argument: dam_showhidden  (optional)
			-- 
			-- argument: tag_title_search  (optional)
			-- 
			-- argument: guess_total  (optional)
			-- 
			-- argument: dam_expiry_property  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_CONTENTFINDER_ASSET_VIEW_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.AssetViewHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dam.showexpired", dam_showexpired));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dam.showhidden", dam_showhidden));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagTitleSearch", tag_title_search));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "guessTotal", guess_total));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dam.expiryProperty", dam_expiry_property));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_CONTENTFINDER_ASSET_VIEW_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_CONTENTFINDER_ASSET_VIEW_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_servlets_contentfinder_connector_connector_vie (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; item_resource_types: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_CONTENTFINDER_CONNECTOR_CONNECTOR_VIE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: item_resource_types  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_CONTENTFINDER_CONNECTOR_CONNECTOR_VIE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.connector.ConnectorViewHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "item.resource.types", item_resource_types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_CONTENTFINDER_CONNECTOR_CONNECTOR_VIE_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_CONTENTFINDER_CONNECTOR_CONNECTOR_VIE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_servlets_contentfinder_page_view_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; guess_total: STRING_32; tag_title_search: BOOLEAN): detachable COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_CONTENTFINDER_PAGE_VIEW_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: guess_total  (optional)
			-- 
			-- argument: tag_title_search  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_CONTENTFINDER_PAGE_VIEW_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.PageViewHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "guessTotal", guess_total));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagTitleSearch", tag_title_search));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_CONTENTFINDER_PAGE_VIEW_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_CONTENTFINDER_PAGE_VIEW_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_servlets_find_replace_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scope: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_FIND_REPLACE_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scope  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_FIND_REPLACE_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.FindReplaceServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "scope", scope));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_FIND_REPLACE_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_FIND_REPLACE_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_servlets_reference_search_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; referencesearchservlet_max_references_per_page: INTEGER_32; referencesearchservlet_max_pages: INTEGER_32): detachable COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_REFERENCE_SEARCH_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: referencesearchservlet_max_references_per_page  (optional)
			-- 
			-- argument: referencesearchservlet_max_pages  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_REFERENCE_SEARCH_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.ReferenceSearchServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "referencesearchservlet.maxReferencesPerPage", referencesearchservlet_max_references_per_page));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "referencesearchservlet.maxPages", referencesearchservlet_max_pages));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_REFERENCE_SEARCH_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_REFERENCE_SEARCH_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_servlets_thumbnail_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; workspace: STRING_32; dimensions: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_THUMBNAIL_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: workspace  (optional)
			-- 
			-- argument: dimensions  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_THUMBNAIL_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.ThumbnailServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "workspace", workspace));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "dimensions", dimensions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_THUMBNAIL_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_SERVLETS_THUMBNAIL_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_utils_default_page_name_validator (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; non_valid_chars: STRING_32): detachable COM_DAY_CQ_WCM_CORE_IMPL_UTILS_DEFAULT_PAGE_NAME_VALIDATOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: non_valid_chars  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_UTILS_DEFAULT_PAGE_NAME_VALIDATOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.utils.DefaultPageNameValidator"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "nonValidChars", non_valid_chars));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_UTILS_DEFAULT_PAGE_NAME_VALIDATOR_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_UTILS_DEFAULT_PAGE_NAME_VALIDATOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_variants_page_variants_provider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; default_externalizer_domain: STRING_32): detachable COM_DAY_CQ_WCM_CORE_IMPL_VARIANTS_PAGE_VARIANTS_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: default_externalizer_domain  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_VARIANTS_PAGE_VARIANTS_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.variants.PageVariantsProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.externalizer.domain", default_externalizer_domain));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_VARIANTS_PAGE_VARIANTS_PROVIDER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_VARIANTS_PAGE_VARIANTS_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_version_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; versionmanager_create_version_on_activation: BOOLEAN; versionmanager_purging_enabled: BOOLEAN; versionmanager_purge_paths: detachable LIST [STRING_32]; versionmanager_iv_paths: detachable LIST [STRING_32]; versionmanager_max_age_days: INTEGER_32; versionmanager_max_number_versions: INTEGER_32; versionmanager_min_number_versions: INTEGER_32): detachable COM_DAY_CQ_WCM_CORE_IMPL_VERSION_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: versionmanager_create_version_on_activation  (optional)
			-- 
			-- argument: versionmanager_purging_enabled  (optional)
			-- 
			-- argument: versionmanager_purge_paths  (optional)
			-- 
			-- argument: versionmanager_iv_paths  (optional)
			-- 
			-- argument: versionmanager_max_age_days  (optional)
			-- 
			-- argument: versionmanager_max_number_versions  (optional)
			-- 
			-- argument: versionmanager_min_number_versions  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_VERSION_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.VersionManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "versionmanager.createVersionOnActivation", versionmanager_create_version_on_activation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "versionmanager.purgingEnabled", versionmanager_purging_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "versionmanager.purgePaths", versionmanager_purge_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "versionmanager.ivPaths", versionmanager_iv_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "versionmanager.maxAgeDays", versionmanager_max_age_days));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "versionmanager.maxNumberVersions", versionmanager_max_number_versions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "versionmanager.minNumberVersions", versionmanager_min_number_versions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_VERSION_MANAGER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_VERSION_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_version_purge_task (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; versionpurge_paths: detachable LIST [STRING_32]; versionpurge_recursive: BOOLEAN; versionpurge_max_versions: INTEGER_32; versionpurge_min_versions: INTEGER_32; versionpurge_max_age_days: INTEGER_32): detachable COM_DAY_CQ_WCM_CORE_IMPL_VERSION_PURGE_TASK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: versionpurge_paths  (optional)
			-- 
			-- argument: versionpurge_recursive  (optional)
			-- 
			-- argument: versionpurge_max_versions  (optional)
			-- 
			-- argument: versionpurge_min_versions  (optional)
			-- 
			-- argument: versionpurge_max_age_days  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_VERSION_PURGE_TASK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.VersionPurgeTask"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "versionpurge.paths", versionpurge_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "versionpurge.recursive", versionpurge_recursive));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "versionpurge.maxVersions", versionpurge_max_versions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "versionpurge.minVersions", versionpurge_min_versions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "versionpurge.maxAgeDays", versionpurge_max_age_days));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_VERSION_PURGE_TASK_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_VERSION_PURGE_TASK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_warp_time_warp_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; filter_order: STRING_32; filter_scope: STRING_32): detachable COM_DAY_CQ_WCM_CORE_IMPL_WARP_TIME_WARP_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: filter_order  (optional)
			-- 
			-- argument: filter_scope  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_WARP_TIME_WARP_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.warp.TimeWarpFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter.order", filter_order));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter.scope", filter_scope));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_WARP_TIME_WARP_FILTER_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_WARP_TIME_WARP_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_wc_mdebug_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; wcmdbgfilter_enabled: BOOLEAN; wcmdbgfilter_jsp_debug: BOOLEAN): detachable COM_DAY_CQ_WCM_CORE_IMPL_WCM_DEBUG_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: wcmdbgfilter_enabled  (optional)
			-- 
			-- argument: wcmdbgfilter_jsp_debug  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_WCM_DEBUG_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.WCMDebugFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "wcmdbgfilter.enabled", wcmdbgfilter_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "wcmdbgfilter.jspDebug", wcmdbgfilter_jsp_debug));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_WCM_DEBUG_FILTER_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_WCM_DEBUG_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_impl_wc_mdeveloper_mode_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; wcmdevmodefilter_enabled: BOOLEAN): detachable COM_DAY_CQ_WCM_CORE_IMPL_WCM_DEVELOPER_MODE_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: wcmdevmodefilter_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_IMPL_WCM_DEVELOPER_MODE_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.impl.WCMDeveloperModeFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "wcmdevmodefilter.enabled", wcmdevmodefilter_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_IMPL_WCM_DEVELOPER_MODE_FILTER_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_IMPL_WCM_DEVELOPER_MODE_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_mvt_mv_tstatistics_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; mvtstatistics_trackingurl: STRING_32): detachable COM_DAY_CQ_WCM_CORE_MVT_MVT_STATISTICS_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: mvtstatistics_trackingurl  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_MVT_MVT_STATISTICS_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.mvt.MVTStatisticsImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "mvtstatistics.trackingurl", mvtstatistics_trackingurl));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_MVT_MVT_STATISTICS_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_MVT_MVT_STATISTICS_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_stats_page_view_statistics_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; pageviewstatistics_trackingurl: STRING_32; pageviewstatistics_trackingscript_enabled: STRING_32): detachable COM_DAY_CQ_WCM_CORE_STATS_PAGE_VIEW_STATISTICS_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: pageviewstatistics_trackingurl  (optional)
			-- 
			-- argument: pageviewstatistics_trackingscript_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_STATS_PAGE_VIEW_STATISTICS_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.stats.PageViewStatisticsImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pageviewstatistics.trackingurl", pageviewstatistics_trackingurl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pageviewstatistics.trackingscript.enabled", pageviewstatistics_trackingscript_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_STATS_PAGE_VIEW_STATISTICS_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_STATS_PAGE_VIEW_STATISTICS_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_core_wc_mrequest_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; wcmfilter_mode: STRING_32): detachable COM_DAY_CQ_WCM_CORE_WCM_REQUEST_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: wcmfilter_mode  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_CORE_WCM_REQUEST_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.core.WCMRequestFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "wcmfilter.mode", wcmfilter_mode));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_CORE_WCM_REQUEST_FILTER_INFO } l_response.data ({ COM_DAY_CQ_WCM_CORE_WCM_REQUEST_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_design_package_importer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; extract_filter: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_DESIGN_PACKAGE_IMPORTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: extract_filter  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_DESIGN_PACKAGE_IMPORTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.DesignPackageImporter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "extract.filter", extract_filter));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_DESIGN_PACKAGE_IMPORTER_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_DESIGN_PACKAGE_IMPORTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_impl_canvas_builder_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; filepattern: STRING_32; build_page_nodes: BOOLEAN; build_client_libs: BOOLEAN; build_canvas_component: BOOLEAN): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_CANVAS_BUILDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: filepattern  (optional)
			-- 
			-- argument: build_page_nodes  (optional)
			-- 
			-- argument: build_client_libs  (optional)
			-- 
			-- argument: build_canvas_component  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_CANVAS_BUILDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.impl.CanvasBuilderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filepattern", filepattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "build.page.nodes", build_page_nodes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "build.client.libs", build_client_libs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "build.canvas.component", build_canvas_component));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_CANVAS_BUILDER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_CANVAS_BUILDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_impl_canvas_page_delete_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; min_thread_pool_size: INTEGER_32; max_thread_pool_size: INTEGER_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_CANVAS_PAGE_DELETE_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: min_thread_pool_size  (optional)
			-- 
			-- argument: max_thread_pool_size  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_CANVAS_PAGE_DELETE_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.impl.CanvasPageDeleteHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "minThreadPoolSize", min_thread_pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxThreadPoolSize", max_thread_pool_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_CANVAS_PAGE_DELETE_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_CANVAS_PAGE_DELETE_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_impl_entry_preprocessor_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; search_pattern: STRING_32; replace_pattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_ENTRY_PREPROCESSOR_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: search_pattern  (optional)
			-- 
			-- argument: replace_pattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_ENTRY_PREPROCESSOR_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.impl.EntryPreprocessorImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "search.pattern", search_pattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "replace.pattern", replace_pattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_ENTRY_PREPROCESSOR_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_ENTRY_PREPROCESSOR_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_impl_mobile_canvas_builder_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; filepattern: STRING_32; device_groups: detachable LIST [STRING_32]; build_page_nodes: BOOLEAN; build_client_libs: BOOLEAN; build_canvas_component: BOOLEAN): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_MOBILE_CANVAS_BUILDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: filepattern  (optional)
			-- 
			-- argument: device_groups  (optional)
			-- 
			-- argument: build_page_nodes  (optional)
			-- 
			-- argument: build_client_libs  (optional)
			-- 
			-- argument: build_canvas_component  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_MOBILE_CANVAS_BUILDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.impl.MobileCanvasBuilderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filepattern", filepattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "device.groups", device_groups));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "build.page.nodes", build_page_nodes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "build.client.libs", build_client_libs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "build.canvas.component", build_canvas_component));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_MOBILE_CANVAS_BUILDER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_IMPL_MOBILE_CANVAS_BUILDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_canvas_compone (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_CANVAS_COMPONE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_CANVAS_COMPONE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.CanvasComponentTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_CANVAS_COMPONE_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_CANVAS_COMPONE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_default_compon (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_DEFAULT_COMPON_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_DEFAULT_COMPON_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.DefaultComponentTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_DEFAULT_COMPON_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_DEFAULT_COMPON_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_default_tag_han (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_DEFAULT_TAG_HAN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_DEFAULT_TAG_HAN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.DefaultTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_DEFAULT_TAG_HAN_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_DEFAULT_TAG_HAN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_head_tag_handle (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_HEAD_TAG_HANDLE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_HEAD_TAG_HANDLE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.HeadTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_HEAD_TAG_HANDLE_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_HEAD_TAG_HANDLE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_iframe_tag_hand (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_I_FRAME_TAG_HAND_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_I_FRAME_TAG_HAND_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.IFrameTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_I_FRAME_TAG_HAND_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_I_FRAME_TAG_HAND_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_image_componen (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32; component_resource_type: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_IMAGE_COMPONEN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- argument: component_resource_type  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_IMAGE_COMPONEN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ImageComponentTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "component.resourceType", component_resource_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_IMAGE_COMPONEN_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_IMAGE_COMPONEN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_img_tag_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_IMG_TAG_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_IMG_TAG_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ImgTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_IMG_TAG_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_IMG_TAG_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_inline_script_t (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_INLINE_SCRIPT_T_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_INLINE_SCRIPT_T_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.InlineScriptTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_INLINE_SCRIPT_T_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_INLINE_SCRIPT_T_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_link_tag_handle (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_LINK_TAG_HANDLE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_LINK_TAG_HANDLE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.LinkTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_LINK_TAG_HANDLE_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_LINK_TAG_HANDLE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_meta_tag_handle (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_META_TAG_HANDLE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_META_TAG_HANDLE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.MetaTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_META_TAG_HANDLE_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_META_TAG_HANDLE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_non_script_tag_h (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_NON_SCRIPT_TAG_H_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_NON_SCRIPT_TAG_H_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.NonScriptTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_NON_SCRIPT_TAG_H_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_NON_SCRIPT_TAG_H_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_parsys_compone (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32; component_resource_type: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_PARSYS_COMPONE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- argument: component_resource_type  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_PARSYS_COMPONE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ParsysComponentTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "component.resourceType", component_resource_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_PARSYS_COMPONE_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_PARSYS_COMPONE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_script_tag_hand (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_SCRIPT_TAG_HAND_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_SCRIPT_TAG_HAND_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ScriptTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_SCRIPT_TAG_HAND_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_SCRIPT_TAG_HAND_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_style_tag_handl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_STYLE_TAG_HANDL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_STYLE_TAG_HANDL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.StyleTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_STYLE_TAG_HANDL_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_STYLE_TAG_HANDL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_text_component (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32; component_resource_type: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_TEXT_COMPONENT_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- argument: component_resource_type  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_TEXT_COMPONENT_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TextComponentTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "component.resourceType", component_resource_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_TEXT_COMPONENT_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_TEXT_COMPONENT_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_title_componen (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32; component_resource_type: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_TITLE_COMPONEN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- argument: component_resource_type  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_TITLE_COMPONEN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TitleComponentTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "component.resourceType", component_resource_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_TITLE_COMPONEN_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_TITLE_COMPONEN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_designimporter_parser_taghandlers_factory_title_tag_handl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; tagpattern: STRING_32): detachable COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_TITLE_TAG_HANDL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: tagpattern  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_TITLE_TAG_HANDL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TitleTagHandlerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tagpattern", tagpattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_TITLE_TAG_HANDL_INFO } l_response.data ({ COM_DAY_CQ_WCM_DESIGNIMPORTER_PARSER_TAGHANDLERS_FACTORY_TITLE_TAG_HANDL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_foundation_forms_impl_form_chooser_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_name: STRING_32; sling_servlet_resource_types: STRING_32; sling_servlet_selectors: STRING_32; sling_servlet_methods: detachable LIST [STRING_32]; forms_formchooserservlet_advansesearch_require: BOOLEAN): detachable COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_FORM_CHOOSER_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- argument: sling_servlet_resource_types  (optional)
			-- 
			-- argument: sling_servlet_selectors  (optional)
			-- 
			-- argument: sling_servlet_methods  (optional)
			-- 
			-- argument: forms_formchooserservlet_advansesearch_require  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_FORM_CHOOSER_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormChooserServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.name", service_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.resourceTypes", sling_servlet_resource_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.selectors", sling_servlet_selectors));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.servlet.methods", sling_servlet_methods));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "forms.formchooserservlet.advansesearch.require", forms_formchooserservlet_advansesearch_require));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_FORM_CHOOSER_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_FORM_CHOOSER_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_foundation_forms_impl_form_paragraph_post_processor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; forms_formparagraphpostprocessor_enabled: BOOLEAN; forms_formparagraphpostprocessor_formresourcetypes: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_FORM_PARAGRAPH_POST_PROCESSOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: forms_formparagraphpostprocessor_enabled  (optional)
			-- 
			-- argument: forms_formparagraphpostprocessor_formresourcetypes  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_FORM_PARAGRAPH_POST_PROCESSOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormParagraphPostProcessor"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "forms.formparagraphpostprocessor.enabled", forms_formparagraphpostprocessor_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "forms.formparagraphpostprocessor.formresourcetypes", forms_formparagraphpostprocessor_formresourcetypes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_FORM_PARAGRAPH_POST_PROCESSOR_INFO } l_response.data ({ COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_FORM_PARAGRAPH_POST_PROCESSOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_foundation_forms_impl_forms_handling_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name_whitelist: STRING_32; allow_expressions: BOOLEAN): detachable COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_FORMS_HANDLING_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name_whitelist  (optional)
			-- 
			-- argument: allow_expressions  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_FORMS_HANDLING_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormsHandlingServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name.whitelist", name_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "allow.expressions", allow_expressions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_FORMS_HANDLING_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_FORMS_HANDLING_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_foundation_forms_impl_mail_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_resource_types: STRING_32; sling_servlet_selectors: STRING_32; resource_whitelist: detachable LIST [STRING_32]; resource_blacklist: STRING_32): detachable COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_MAIL_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_resource_types  (optional)
			-- 
			-- argument: sling_servlet_selectors  (optional)
			-- 
			-- argument: resource_whitelist  (optional)
			-- 
			-- argument: resource_blacklist  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_MAIL_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.MailServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.resourceTypes", sling_servlet_resource_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.selectors", sling_servlet_selectors));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resource.whitelist", resource_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.blacklist", resource_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_MAIL_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_WCM_FOUNDATION_FORMS_IMPL_MAIL_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_foundation_impl_adaptive_image_component_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; adapt_supported_widths: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_FOUNDATION_IMPL_ADAPTIVE_IMAGE_COMPONENT_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: adapt_supported_widths  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_FOUNDATION_IMPL_ADAPTIVE_IMAGE_COMPONENT_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.foundation.impl.AdaptiveImageComponentServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "adapt.supported.widths", adapt_supported_widths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_FOUNDATION_IMPL_ADAPTIVE_IMAGE_COMPONENT_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_WCM_FOUNDATION_IMPL_ADAPTIVE_IMAGE_COMPONENT_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_foundation_impl_ht_tp_auth_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path: STRING_32; auth_http_nologin: BOOLEAN; auth_http_realm: STRING_32; auth_default_loginpage: STRING_32; auth_cred_form: detachable LIST [STRING_32]; auth_cred_utf8: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_FOUNDATION_IMPL_HTTP_AUTH_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: auth_http_nologin  (optional)
			-- 
			-- argument: auth_http_realm  (optional)
			-- 
			-- argument: auth_default_loginpage  (optional)
			-- 
			-- argument: auth_cred_form  (optional)
			-- 
			-- argument: auth_cred_utf8  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_FOUNDATION_IMPL_HTTP_AUTH_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.foundation.impl.HTTPAuthHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.http.nologin", auth_http_nologin));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.http.realm", auth_http_realm));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.default.loginpage", auth_default_loginpage));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "auth.cred.form", auth_cred_form));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "auth.cred.utf8", auth_cred_utf8));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_FOUNDATION_IMPL_HTTP_AUTH_HANDLER_INFO } l_response.data ({ COM_DAY_CQ_WCM_FOUNDATION_IMPL_HTTP_AUTH_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_foundation_impl_page_impressions_tracker (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_auth_requirements: STRING_32): detachable COM_DAY_CQ_WCM_FOUNDATION_IMPL_PAGE_IMPRESSIONS_TRACKER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_auth_requirements  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_FOUNDATION_IMPL_PAGE_IMPRESSIONS_TRACKER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.foundation.impl.PageImpressionsTracker"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.auth.requirements", sling_auth_requirements));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_FOUNDATION_IMPL_PAGE_IMPRESSIONS_TRACKER_INFO } l_response.data ({ COM_DAY_CQ_WCM_FOUNDATION_IMPL_PAGE_IMPRESSIONS_TRACKER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_foundation_impl_page_redirect_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; excluded_resource_types: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_FOUNDATION_IMPL_PAGE_REDIRECT_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: excluded_resource_types  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_FOUNDATION_IMPL_PAGE_REDIRECT_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.foundation.impl.PageRedirectServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "excluded.resource.types", excluded_resource_types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_FOUNDATION_IMPL_PAGE_REDIRECT_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_WCM_FOUNDATION_IMPL_PAGE_REDIRECT_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_foundation_security_impl_default_attachment_type_blacklist (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; default_attachment_type_blacklist: detachable LIST [STRING_32]; baseline_attachment_type_blacklist: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_FOUNDATION_SECURITY_IMPL_DEFAULT_ATTACHMENT_TYPE_BLACKLIST_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: default_attachment_type_blacklist  (optional)
			-- 
			-- argument: baseline_attachment_type_blacklist  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_FOUNDATION_SECURITY_IMPL_DEFAULT_ATTACHMENT_TYPE_BLACKLIST_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.foundation.security.impl.DefaultAttachmentTypeBlacklistService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "default.attachment.type.blacklist", default_attachment_type_blacklist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "baseline.attachment.type.blacklist", baseline_attachment_type_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_FOUNDATION_SECURITY_IMPL_DEFAULT_ATTACHMENT_TYPE_BLACKLIST_INFO } l_response.data ({ COM_DAY_CQ_WCM_FOUNDATION_SECURITY_IMPL_DEFAULT_ATTACHMENT_TYPE_BLACKLIST_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_foundation_security_impl_safer_sling_post_validator_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; parameter_whitelist: detachable LIST [STRING_32]; parameter_whitelist_prefixes: detachable LIST [STRING_32]; binary_parameter_whitelist: detachable LIST [STRING_32]; modifier_whitelist: detachable LIST [STRING_32]; operation_whitelist: detachable LIST [STRING_32]; operation_whitelist_prefixes: detachable LIST [STRING_32]; typehint_whitelist: detachable LIST [STRING_32]; resourcetype_whitelist: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_FOUNDATION_SECURITY_IMPL_SAFER_SLING_POST_VALIDATOR_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: parameter_whitelist  (optional)
			-- 
			-- argument: parameter_whitelist_prefixes  (optional)
			-- 
			-- argument: binary_parameter_whitelist  (optional)
			-- 
			-- argument: modifier_whitelist  (optional)
			-- 
			-- argument: operation_whitelist  (optional)
			-- 
			-- argument: operation_whitelist_prefixes  (optional)
			-- 
			-- argument: typehint_whitelist  (optional)
			-- 
			-- argument: resourcetype_whitelist  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_FOUNDATION_SECURITY_IMPL_SAFER_SLING_POST_VALIDATOR_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.foundation.security.impl.SaferSlingPostValidatorImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "parameter.whitelist", parameter_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "parameter.whitelist.prefixes", parameter_whitelist_prefixes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "binary.parameter.whitelist", binary_parameter_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "modifier.whitelist", modifier_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "operation.whitelist", operation_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "operation.whitelist.prefixes", operation_whitelist_prefixes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "typehint.whitelist", typehint_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resourcetype.whitelist", resourcetype_whitelist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_FOUNDATION_SECURITY_IMPL_SAFER_SLING_POST_VALIDATOR_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_FOUNDATION_SECURITY_IMPL_SAFER_SLING_POST_VALIDATOR_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_mobile_core_impl_device_device_info_transformer_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; device_info_transformer_enabled: BOOLEAN; device_info_transformer_css_style: STRING_32): detachable COM_DAY_CQ_WCM_MOBILE_CORE_IMPL_DEVICE_DEVICE_INFO_TRANSFORMER_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: device_info_transformer_enabled  (optional)
			-- 
			-- argument: device_info_transformer_css_style  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_MOBILE_CORE_IMPL_DEVICE_DEVICE_INFO_TRANSFORMER_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.mobile.core.impl.device.DeviceInfoTransformerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "device.info.transformer.enabled", device_info_transformer_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "device.info.transformer.css.style", device_info_transformer_css_style));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_MOBILE_CORE_IMPL_DEVICE_DEVICE_INFO_TRANSFORMER_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_WCM_MOBILE_CORE_IMPL_DEVICE_DEVICE_INFO_TRANSFORMER_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_mobile_core_impl_redirect_redirect_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; redirect_enabled: BOOLEAN; redirect_stats_enabled: BOOLEAN; redirect_extensions: detachable LIST [STRING_32]; redirect_paths: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_MOBILE_CORE_IMPL_REDIRECT_REDIRECT_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: redirect_enabled  (optional)
			-- 
			-- argument: redirect_stats_enabled  (optional)
			-- 
			-- argument: redirect_extensions  (optional)
			-- 
			-- argument: redirect_paths  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_MOBILE_CORE_IMPL_REDIRECT_REDIRECT_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.mobile.core.impl.redirect.RedirectFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "redirect.enabled", redirect_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "redirect.stats.enabled", redirect_stats_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "redirect.extensions", redirect_extensions));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "redirect.paths", redirect_paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_MOBILE_CORE_IMPL_REDIRECT_REDIRECT_FILTER_INFO } l_response.data ({ COM_DAY_CQ_WCM_MOBILE_CORE_IMPL_REDIRECT_REDIRECT_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_msm_impl_actions_content_copy_action_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_wcm_msm_action_excludednodetypes: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedparagraphitems: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedprops: detachable LIST [STRING_32]; contentcopyaction_order_style: STRING_32): detachable COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_CONTENT_COPY_ACTION_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludednodetypes  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedparagraphitems  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedprops  (optional)
			-- 
			-- argument: contentcopyaction_order_style  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_CONTENT_COPY_ACTION_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentCopyActionFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludednodetypes", cq_wcm_msm_action_excludednodetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedparagraphitems", cq_wcm_msm_action_excludedparagraphitems));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedprops", cq_wcm_msm_action_excludedprops));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "contentcopyaction.order.style", contentcopyaction_order_style));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_CONTENT_COPY_ACTION_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_CONTENT_COPY_ACTION_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_msm_impl_actions_content_delete_action_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_wcm_msm_action_excludednodetypes: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedparagraphitems: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedprops: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_CONTENT_DELETE_ACTION_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludednodetypes  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedparagraphitems  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedprops  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_CONTENT_DELETE_ACTION_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentDeleteActionFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludednodetypes", cq_wcm_msm_action_excludednodetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedparagraphitems", cq_wcm_msm_action_excludedparagraphitems));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedprops", cq_wcm_msm_action_excludedprops));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_CONTENT_DELETE_ACTION_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_CONTENT_DELETE_ACTION_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_msm_impl_actions_content_update_action_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_wcm_msm_action_excludednodetypes: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedparagraphitems: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedprops: detachable LIST [STRING_32]; cq_wcm_msm_action_ignored_mixin: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_CONTENT_UPDATE_ACTION_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludednodetypes  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedparagraphitems  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedprops  (optional)
			-- 
			-- argument: cq_wcm_msm_action_ignored_mixin  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_CONTENT_UPDATE_ACTION_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentUpdateActionFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludednodetypes", cq_wcm_msm_action_excludednodetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedparagraphitems", cq_wcm_msm_action_excludedparagraphitems));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedprops", cq_wcm_msm_action_excludedprops));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.ignoredMixin", cq_wcm_msm_action_ignored_mixin));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_CONTENT_UPDATE_ACTION_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_CONTENT_UPDATE_ACTION_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_msm_impl_actions_order_children_action_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_wcm_msm_action_excludednodetypes: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedparagraphitems: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedprops: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_ORDER_CHILDREN_ACTION_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludednodetypes  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedparagraphitems  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedprops  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_ORDER_CHILDREN_ACTION_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.OrderChildrenActionFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludednodetypes", cq_wcm_msm_action_excludednodetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedparagraphitems", cq_wcm_msm_action_excludedparagraphitems));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedprops", cq_wcm_msm_action_excludedprops));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_ORDER_CHILDREN_ACTION_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_ORDER_CHILDREN_ACTION_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_msm_impl_actions_page_move_action_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_wcm_msm_action_excludednodetypes: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedparagraphitems: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedprops: detachable LIST [STRING_32]; cq_wcm_msm_impl_actions_pagemove_prop_reference_update: BOOLEAN): detachable COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_PAGE_MOVE_ACTION_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludednodetypes  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedparagraphitems  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedprops  (optional)
			-- 
			-- argument: cq_wcm_msm_impl_actions_pagemove_prop_reference_update  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_PAGE_MOVE_ACTION_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.PageMoveActionFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludednodetypes", cq_wcm_msm_action_excludednodetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedparagraphitems", cq_wcm_msm_action_excludedparagraphitems));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedprops", cq_wcm_msm_action_excludedprops));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.wcm.msm.impl.actions.pagemove.prop_referenceUpdate", cq_wcm_msm_impl_actions_pagemove_prop_reference_update));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_PAGE_MOVE_ACTION_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_PAGE_MOVE_ACTION_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_msm_impl_actions_references_update_action_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_wcm_msm_action_excludednodetypes: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedparagraphitems: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedprops: detachable LIST [STRING_32]; cq_wcm_msm_impl_action_referencesupdate_prop_update_nested: BOOLEAN): detachable COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_REFERENCES_UPDATE_ACTION_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludednodetypes  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedparagraphitems  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedprops  (optional)
			-- 
			-- argument: cq_wcm_msm_impl_action_referencesupdate_prop_update_nested  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_REFERENCES_UPDATE_ACTION_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ReferencesUpdateActionFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludednodetypes", cq_wcm_msm_action_excludednodetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedparagraphitems", cq_wcm_msm_action_excludedparagraphitems));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedprops", cq_wcm_msm_action_excludedprops));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.wcm.msm.impl.action.referencesupdate.prop_updateNested", cq_wcm_msm_impl_action_referencesupdate_prop_update_nested));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_REFERENCES_UPDATE_ACTION_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_REFERENCES_UPDATE_ACTION_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_msm_impl_actions_version_copy_action_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_wcm_msm_action_excludednodetypes: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedparagraphitems: detachable LIST [STRING_32]; cq_wcm_msm_action_excludedprops: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_VERSION_COPY_ACTION_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludednodetypes  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedparagraphitems  (optional)
			-- 
			-- argument: cq_wcm_msm_action_excludedprops  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_VERSION_COPY_ACTION_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.VersionCopyActionFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludednodetypes", cq_wcm_msm_action_excludednodetypes));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedparagraphitems", cq_wcm_msm_action_excludedparagraphitems));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.msm.action.excludedprops", cq_wcm_msm_action_excludedprops));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_VERSION_COPY_ACTION_FACTORY_INFO } l_response.data ({ COM_DAY_CQ_WCM_MSM_IMPL_ACTIONS_VERSION_COPY_ACTION_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_msm_impl_live_relationship_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; liverelationshipmgr_relationsconfig_default: STRING_32): detachable COM_DAY_CQ_WCM_MSM_IMPL_LIVE_RELATIONSHIP_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: liverelationshipmgr_relationsconfig_default  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_MSM_IMPL_LIVE_RELATIONSHIP_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.msm.impl.LiveRelationshipManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "liverelationshipmgr.relationsconfig.default", liverelationshipmgr_relationsconfig_default));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_MSM_IMPL_LIVE_RELATIONSHIP_MANAGER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_MSM_IMPL_LIVE_RELATIONSHIP_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_msm_impl_rollout_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_filter: STRING_32; rolloutmgr_excludedprops_default: detachable LIST [STRING_32]; rolloutmgr_excludedparagraphprops_default: detachable LIST [STRING_32]; rolloutmgr_excludednodetypes_default: detachable LIST [STRING_32]; rolloutmgr_threadpool_maxsize: INTEGER_32; rolloutmgr_threadpool_maxshutdowntime: INTEGER_32; rolloutmgr_threadpool_priority: STRING_32; rolloutmgr_commit_size: INTEGER_32; rolloutmgr_conflicthandling_enabled: BOOLEAN): detachable COM_DAY_CQ_WCM_MSM_IMPL_ROLLOUT_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- argument: rolloutmgr_excludedprops_default  (optional)
			-- 
			-- argument: rolloutmgr_excludedparagraphprops_default  (optional)
			-- 
			-- argument: rolloutmgr_excludednodetypes_default  (optional)
			-- 
			-- argument: rolloutmgr_threadpool_maxsize  (optional)
			-- 
			-- argument: rolloutmgr_threadpool_maxshutdowntime  (optional)
			-- 
			-- argument: rolloutmgr_threadpool_priority  (optional)
			-- 
			-- argument: rolloutmgr_commit_size  (optional)
			-- 
			-- argument: rolloutmgr_conflicthandling_enabled  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_MSM_IMPL_ROLLOUT_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.msm.impl.RolloutManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "rolloutmgr.excludedprops.default", rolloutmgr_excludedprops_default));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "rolloutmgr.excludedparagraphprops.default", rolloutmgr_excludedparagraphprops_default));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "rolloutmgr.excludednodetypes.default", rolloutmgr_excludednodetypes_default));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "rolloutmgr.threadpool.maxsize", rolloutmgr_threadpool_maxsize));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "rolloutmgr.threadpool.maxshutdowntime", rolloutmgr_threadpool_maxshutdowntime));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "rolloutmgr.threadpool.priority", rolloutmgr_threadpool_priority));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "rolloutmgr.commit.size", rolloutmgr_commit_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "rolloutmgr.conflicthandling.enabled", rolloutmgr_conflicthandling_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_MSM_IMPL_ROLLOUT_MANAGER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_MSM_IMPL_ROLLOUT_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_msm_impl_servlets_audit_log_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; auditlogservlet_default_events_count: INTEGER_32; auditlogservlet_default_path: STRING_32): detachable COM_DAY_CQ_WCM_MSM_IMPL_SERVLETS_AUDIT_LOG_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: auditlogservlet_default_events_count  (optional)
			-- 
			-- argument: auditlogservlet_default_path  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_MSM_IMPL_SERVLETS_AUDIT_LOG_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.msm.impl.servlets.AuditLogServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlogservlet.default.events.count", auditlogservlet_default_events_count));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auditlogservlet.default.path", auditlogservlet_default_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_MSM_IMPL_SERVLETS_AUDIT_LOG_SERVLET_INFO } l_response.data ({ COM_DAY_CQ_WCM_MSM_IMPL_SERVLETS_AUDIT_LOG_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_notification_email_impl_email_channel (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; email_from: STRING_32): detachable COM_DAY_CQ_WCM_NOTIFICATION_EMAIL_IMPL_EMAIL_CHANNEL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: email_from  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_NOTIFICATION_EMAIL_IMPL_EMAIL_CHANNEL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.notification.email.impl.EmailChannel"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "email.from", email_from));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_NOTIFICATION_EMAIL_IMPL_EMAIL_CHANNEL_INFO } l_response.data ({ COM_DAY_CQ_WCM_NOTIFICATION_EMAIL_IMPL_EMAIL_CHANNEL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_notification_impl_notification_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_topics: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_NOTIFICATION_IMPL_NOTIFICATION_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_topics  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_NOTIFICATION_IMPL_NOTIFICATION_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.notification.impl.NotificationManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "event.topics", event_topics));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_NOTIFICATION_IMPL_NOTIFICATION_MANAGER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_NOTIFICATION_IMPL_NOTIFICATION_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_scripting_impl_bv_pmanager (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; com_day_cq_wcm_scripting_bvp_script_engines: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_SCRIPTING_IMPL_BVP_MANAGER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: com_day_cq_wcm_scripting_bvp_script_engines  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_SCRIPTING_IMPL_BVP_MANAGER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.scripting.impl.BVPManager"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "com.day.cq.wcm.scripting.bvp.script.engines", com_day_cq_wcm_scripting_bvp_script_engines));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_SCRIPTING_IMPL_BVP_MANAGER_INFO } l_response.data ({ COM_DAY_CQ_WCM_SCRIPTING_IMPL_BVP_MANAGER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_undo_undo_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cq_wcm_undo_enabled: BOOLEAN; cq_wcm_undo_path: STRING_32; cq_wcm_undo_validity: INTEGER_32; cq_wcm_undo_steps: INTEGER_32; cq_wcm_undo_persistence: STRING_32; cq_wcm_undo_persistence_mode: BOOLEAN; cq_wcm_undo_markermode: STRING_32; cq_wcm_undo_whitelist: detachable LIST [STRING_32]; cq_wcm_undo_blacklist: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_UNDO_UNDO_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cq_wcm_undo_enabled  (optional)
			-- 
			-- argument: cq_wcm_undo_path  (optional)
			-- 
			-- argument: cq_wcm_undo_validity  (optional)
			-- 
			-- argument: cq_wcm_undo_steps  (optional)
			-- 
			-- argument: cq_wcm_undo_persistence  (optional)
			-- 
			-- argument: cq_wcm_undo_persistence_mode  (optional)
			-- 
			-- argument: cq_wcm_undo_markermode  (optional)
			-- 
			-- argument: cq_wcm_undo_whitelist  (optional)
			-- 
			-- argument: cq_wcm_undo_blacklist  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_UNDO_UNDO_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.undo.UndoConfig"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.wcm.undo.enabled", cq_wcm_undo_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.wcm.undo.path", cq_wcm_undo_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.wcm.undo.validity", cq_wcm_undo_validity));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.wcm.undo.steps", cq_wcm_undo_steps));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.wcm.undo.persistence", cq_wcm_undo_persistence));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.wcm.undo.persistence.mode", cq_wcm_undo_persistence_mode));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.wcm.undo.markermode", cq_wcm_undo_markermode));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.undo.whitelist", cq_wcm_undo_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.undo.blacklist", cq_wcm_undo_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_UNDO_UNDO_CONFIG_INFO } l_response.data ({ COM_DAY_CQ_WCM_UNDO_UNDO_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_webservicesupport_impl_replication_event_listener (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; flush_agents: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_WEBSERVICESUPPORT_IMPL_REPLICATION_EVENT_LISTENER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: flush_agents  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_WEBSERVICESUPPORT_IMPL_REPLICATION_EVENT_LISTENER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.webservicesupport.impl.ReplicationEventListener"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "Flush agents", flush_agents));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_WEBSERVICESUPPORT_IMPL_REPLICATION_EVENT_LISTENER_INFO } l_response.data ({ COM_DAY_CQ_WCM_WEBSERVICESUPPORT_IMPL_REPLICATION_EVENT_LISTENER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_workflow_impl_wcm_workflow_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; event_filter: STRING_32; min_thread_pool_size: INTEGER_32; max_thread_pool_size: INTEGER_32; cq_wcm_workflow_terminate_on_activate: BOOLEAN; cq_wcm_worklfow_terminate_exclusion_list: detachable LIST [STRING_32]): detachable COM_DAY_CQ_WCM_WORKFLOW_IMPL_WCM_WORKFLOW_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: event_filter  (optional)
			-- 
			-- argument: min_thread_pool_size  (optional)
			-- 
			-- argument: max_thread_pool_size  (optional)
			-- 
			-- argument: cq_wcm_workflow_terminate_on_activate  (optional)
			-- 
			-- argument: cq_wcm_worklfow_terminate_exclusion_list  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_WORKFLOW_IMPL_WCM_WORKFLOW_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.workflow.impl.WcmWorkflowServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "event.filter", event_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "minThreadPoolSize", min_thread_pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxThreadPoolSize", max_thread_pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cq.wcm.workflow.terminate.on.activate", cq_wcm_workflow_terminate_on_activate));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cq.wcm.worklfow.terminate.exclusion.list", cq_wcm_worklfow_terminate_exclusion_list));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_WORKFLOW_IMPL_WCM_WORKFLOW_SERVICE_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WCM_WORKFLOW_IMPL_WCM_WORKFLOW_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_wcm_workflow_impl_workflow_package_info_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; workflowpackageinfoprovider_filter: detachable LIST [STRING_32]; workflowpackageinfoprovider_filter_rootpath: STRING_32): detachable COM_DAY_CQ_WCM_WORKFLOW_IMPL_WORKFLOW_PACKAGE_INFO_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: workflowpackageinfoprovider_filter  (optional)
			-- 
			-- argument: workflowpackageinfoprovider_filter_rootpath  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WCM_WORKFLOW_IMPL_WORKFLOW_PACKAGE_INFO_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.wcm.workflow.impl.WorkflowPackageInfoProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "workflowpackageinfoprovider.filter", workflowpackageinfoprovider_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "workflowpackageinfoprovider.filter.rootpath", workflowpackageinfoprovider_filter_rootpath));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WCM_WORKFLOW_IMPL_WORKFLOW_PACKAGE_INFO_PROVIDER_INFO } l_response.data ({ COM_DAY_CQ_WCM_WORKFLOW_IMPL_WORKFLOW_PACKAGE_INFO_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_widget_impl_html_library_manager_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; htmllibmanager_clientmanager: STRING_32; htmllibmanager_debug: BOOLEAN; htmllibmanager_debug_console: BOOLEAN; htmllibmanager_debug_init_js: STRING_32; htmllibmanager_defaultthemename: STRING_32; htmllibmanager_defaultuserthemename: STRING_32; htmllibmanager_firebuglite_path: STRING_32; htmllibmanager_force_cq_url_info: BOOLEAN; htmllibmanager_gzip: BOOLEAN; htmllibmanager_maxage: INTEGER_32; htmllibmanager_max_data_uri_size: INTEGER_32; htmllibmanager_minify: BOOLEAN; htmllibmanager_path_list: detachable LIST [STRING_32]; htmllibmanager_timing: BOOLEAN): detachable COM_DAY_CQ_WIDGET_IMPL_HTML_LIBRARY_MANAGER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: htmllibmanager_clientmanager  (optional)
			-- 
			-- argument: htmllibmanager_debug  (optional)
			-- 
			-- argument: htmllibmanager_debug_console  (optional)
			-- 
			-- argument: htmllibmanager_debug_init_js  (optional)
			-- 
			-- argument: htmllibmanager_defaultthemename  (optional)
			-- 
			-- argument: htmllibmanager_defaultuserthemename  (optional)
			-- 
			-- argument: htmllibmanager_firebuglite_path  (optional)
			-- 
			-- argument: htmllibmanager_force_cq_url_info  (optional)
			-- 
			-- argument: htmllibmanager_gzip  (optional)
			-- 
			-- argument: htmllibmanager_maxage  (optional)
			-- 
			-- argument: htmllibmanager_max_data_uri_size  (optional)
			-- 
			-- argument: htmllibmanager_minify  (optional)
			-- 
			-- argument: htmllibmanager_path_list  (optional)
			-- 
			-- argument: htmllibmanager_timing  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WIDGET_IMPL_HTML_LIBRARY_MANAGER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.widget.impl.HtmlLibraryManagerImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.clientmanager", htmllibmanager_clientmanager));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.debug", htmllibmanager_debug));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.debug.console", htmllibmanager_debug_console));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.debug.init.js", htmllibmanager_debug_init_js));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.defaultthemename", htmllibmanager_defaultthemename));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.defaultuserthemename", htmllibmanager_defaultuserthemename));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.firebuglite.path", htmllibmanager_firebuglite_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.forceCQUrlInfo", htmllibmanager_force_cq_url_info));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.gzip", htmllibmanager_gzip));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.maxage", htmllibmanager_maxage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.maxDataUriSize", htmllibmanager_max_data_uri_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.minify", htmllibmanager_minify));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "htmllibmanager.path.list", htmllibmanager_path_list));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "htmllibmanager.timing", htmllibmanager_timing));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WIDGET_IMPL_HTML_LIBRARY_MANAGER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WIDGET_IMPL_HTML_LIBRARY_MANAGER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_widget_impl_widget_extension_provider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; extendable_widgets: detachable LIST [STRING_32]; widgetextensionprovider_debug: BOOLEAN): detachable COM_DAY_CQ_WIDGET_IMPL_WIDGET_EXTENSION_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: extendable_widgets  (optional)
			-- 
			-- argument: widgetextensionprovider_debug  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WIDGET_IMPL_WIDGET_EXTENSION_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.widget.impl.WidgetExtensionProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "extendable.widgets", extendable_widgets));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "widgetextensionprovider.debug", widgetextensionprovider_debug));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WIDGET_IMPL_WIDGET_EXTENSION_PROVIDER_IMPL_INFO } l_response.data ({ COM_DAY_CQ_WIDGET_IMPL_WIDGET_EXTENSION_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_workflow_impl_email_email_notification_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; from_address: STRING_32; host_prefix: STRING_32; notify_onabort: BOOLEAN; notify_oncomplete: BOOLEAN; notify_oncontainercomplete: BOOLEAN; notify_useronly: BOOLEAN): detachable COM_DAY_CQ_WORKFLOW_IMPL_EMAIL_E_MAIL_NOTIFICATION_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: from_address  (optional)
			-- 
			-- argument: host_prefix  (optional)
			-- 
			-- argument: notify_onabort  (optional)
			-- 
			-- argument: notify_oncomplete  (optional)
			-- 
			-- argument: notify_oncontainercomplete  (optional)
			-- 
			-- argument: notify_useronly  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WORKFLOW_IMPL_EMAIL_E_MAIL_NOTIFICATION_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.workflow.impl.email.EMailNotificationService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "from.address", from_address));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "host.prefix", host_prefix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "notify.onabort", notify_onabort));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "notify.oncomplete", notify_oncomplete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "notify.oncontainercomplete", notify_oncontainercomplete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "notify.useronly", notify_useronly));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WORKFLOW_IMPL_EMAIL_E_MAIL_NOTIFICATION_SERVICE_INFO } l_response.data ({ COM_DAY_CQ_WORKFLOW_IMPL_EMAIL_E_MAIL_NOTIFICATION_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_cq_workflow_impl_email_task_email_notification_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; notify_onupdate: BOOLEAN; notify_oncomplete: BOOLEAN): detachable COM_DAY_CQ_WORKFLOW_IMPL_EMAIL_TASK_E_MAIL_NOTIFICATION_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: notify_onupdate  (optional)
			-- 
			-- argument: notify_oncomplete  (optional)
			-- 
			-- 
			-- Result COM_DAY_CQ_WORKFLOW_IMPL_EMAIL_TASK_E_MAIL_NOTIFICATION_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.cq.workflow.impl.email.TaskEMailNotificationService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "notify.onupdate", notify_onupdate));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "notify.oncomplete", notify_oncomplete));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CQ_WORKFLOW_IMPL_EMAIL_TASK_E_MAIL_NOTIFICATION_SERVICE_INFO } l_response.data ({ COM_DAY_CQ_WORKFLOW_IMPL_EMAIL_TASK_E_MAIL_NOTIFICATION_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_crx_security_token_impl_impl_token_authentication_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path: STRING_32; token_required_attr: STRING_32; token_alternate_url: STRING_32; token_encapsulated: BOOLEAN; skip_token_refresh: detachable LIST [STRING_32]): detachable COM_DAY_CRX_SECURITY_TOKEN_IMPL_IMPL_TOKEN_AUTHENTICATION_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: token_required_attr  (optional)
			-- 
			-- argument: token_alternate_url  (optional)
			-- 
			-- argument: token_encapsulated  (optional)
			-- 
			-- argument: skip_token_refresh  (optional)
			-- 
			-- 
			-- Result COM_DAY_CRX_SECURITY_TOKEN_IMPL_IMPL_TOKEN_AUTHENTICATION_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.crx.security.token.impl.impl.TokenAuthenticationHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token.required.attr", token_required_attr));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token.alternate.url", token_alternate_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token.encapsulated", token_encapsulated));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "skip.token.refresh", skip_token_refresh));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CRX_SECURITY_TOKEN_IMPL_IMPL_TOKEN_AUTHENTICATION_HANDLER_INFO } l_response.data ({ COM_DAY_CRX_SECURITY_TOKEN_IMPL_IMPL_TOKEN_AUTHENTICATION_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	com_day_crx_security_token_impl_token_cleanup_task (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enable_token_cleanup_task: BOOLEAN; scheduler_expression: STRING_32; batch_size: INTEGER_32): detachable COM_DAY_CRX_SECURITY_TOKEN_IMPL_TOKEN_CLEANUP_TASK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enable_token_cleanup_task  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- argument: batch_size  (optional)
			-- 
			-- 
			-- Result COM_DAY_CRX_SECURITY_TOKEN_IMPL_TOKEN_CLEANUP_TASK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/com.day.crx.security.token.impl.TokenCleanupTask"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.token.cleanup.task", enable_token_cleanup_task));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "batch.size", batch_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COM_DAY_CRX_SECURITY_TOKEN_IMPL_TOKEN_CLEANUP_TASK_INFO } l_response.data ({ COM_DAY_CRX_SECURITY_TOKEN_IMPL_TOKEN_CLEANUP_TASK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	guide_localization_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; supported_locales: detachable LIST [STRING_32]; localizable__properties: detachable LIST [STRING_32]): detachable GUIDE_LOCALIZATION_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: supported_locales  (optional)
			-- 
			-- argument: localizable__properties  (optional)
			-- 
			-- 
			-- Result GUIDE_LOCALIZATION_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/Guide Localization Service"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "supportedLocales", supported_locales));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "Localizable Properties", localizable__properties));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { GUIDE_LOCALIZATION_SERVICE_INFO } l_response.data ({ GUIDE_LOCALIZATION_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	messaging_user_component_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; priority: INTEGER_32): detachable MESSAGING_USER_COMPONENT_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: priority  (optional)
			-- 
			-- 
			-- Result MESSAGING_USER_COMPONENT_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/MessagingUserComponentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priority", priority));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { MESSAGING_USER_COMPONENT_FACTORY_INFO } l_response.data ({ MESSAGING_USER_COMPONENT_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_aries_jmx_framework_state_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; attribute_change_notification_enabled: BOOLEAN): detachable ORG_APACHE_ARIES_JMX_FRAMEWORK_STATE_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: attribute_change_notification_enabled  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_ARIES_JMX_FRAMEWORK_STATE_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.aries.jmx.framework.StateConfig"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "attributeChangeNotificationEnabled", attribute_change_notification_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_ARIES_JMX_FRAMEWORK_STATE_CONFIG_INFO } l_response.data ({ ORG_APACHE_ARIES_JMX_FRAMEWORK_STATE_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_eventadmin_impl_event_admin (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; org_apache_felix_eventadmin__thread_pool_size: INTEGER_32; org_apache_felix_eventadmin__async_to_sync_thread_ratio: REAL_32; org_apache_felix_eventadmin__timeout: INTEGER_32; org_apache_felix_eventadmin__require_topic: BOOLEAN; org_apache_felix_eventadmin__ignore_timeout: detachable LIST [STRING_32]; org_apache_felix_eventadmin__ignore_topic: detachable LIST [STRING_32]): detachable ORG_APACHE_FELIX_EVENTADMIN_IMPL_EVENT_ADMIN_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: org_apache_felix_eventadmin__thread_pool_size  (optional)
			-- 
			-- argument: org_apache_felix_eventadmin__async_to_sync_thread_ratio  (optional)
			-- 
			-- argument: org_apache_felix_eventadmin__timeout  (optional)
			-- 
			-- argument: org_apache_felix_eventadmin__require_topic  (optional)
			-- 
			-- argument: org_apache_felix_eventadmin__ignore_timeout  (optional)
			-- 
			-- argument: org_apache_felix_eventadmin__ignore_topic  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_EVENTADMIN_IMPL_EVENT_ADMIN_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.eventadmin.impl.EventAdmin"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.eventadmin.ThreadPoolSize", org_apache_felix_eventadmin__thread_pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.eventadmin.AsyncToSyncThreadRatio", org_apache_felix_eventadmin__async_to_sync_thread_ratio));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.eventadmin.Timeout", org_apache_felix_eventadmin__timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.eventadmin.RequireTopic", org_apache_felix_eventadmin__require_topic));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.eventadmin.IgnoreTimeout", org_apache_felix_eventadmin__ignore_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.eventadmin.IgnoreTopic", org_apache_felix_eventadmin__ignore_topic));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_EVENTADMIN_IMPL_EVENT_ADMIN_INFO } l_response.data ({ ORG_APACHE_FELIX_EVENTADMIN_IMPL_EVENT_ADMIN_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_http (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; org_apache_felix_http_host: STRING_32; org_apache_felix_http_enable: BOOLEAN; org_osgi_service_http_port: INTEGER_32; org_apache_felix_http_timeout: INTEGER_32; org_apache_felix_https_enable: BOOLEAN; org_osgi_service_http_port_secure: INTEGER_32; org_apache_felix_https_keystore: STRING_32; org_apache_felix_https_keystore_password: STRING_32; org_apache_felix_https_keystore_key_password: STRING_32; org_apache_felix_https_truststore: STRING_32; org_apache_felix_https_truststore_password: STRING_32; org_apache_felix_https_clientcertificate: STRING_32; org_apache_felix_http_context_path: STRING_32; org_apache_felix_http_mbeans: BOOLEAN; org_apache_felix_http_session_timeout: INTEGER_32; org_apache_felix_http_jetty_threadpool_max: INTEGER_32; org_apache_felix_http_jetty_acceptors: INTEGER_32; org_apache_felix_http_jetty_selectors: INTEGER_32; org_apache_felix_http_jetty_header_buffer_size: INTEGER_32; org_apache_felix_http_jetty_request_buffer_size: INTEGER_32; org_apache_felix_http_jetty_response_buffer_size: INTEGER_32; org_apache_felix_http_jetty_max_form_size: INTEGER_32; org_apache_felix_http_path_exclusions: detachable LIST [STRING_32]; org_apache_felix_https_jetty_ciphersuites_excluded: detachable LIST [STRING_32]; org_apache_felix_https_jetty_ciphersuites_included: detachable LIST [STRING_32]; org_apache_felix_http_jetty_send_server_header: BOOLEAN; org_apache_felix_https_jetty_protocols_included: detachable LIST [STRING_32]; org_apache_felix_https_jetty_protocols_excluded: detachable LIST [STRING_32]; org_apache_felix_proxy_load_balancer_connection_enable: BOOLEAN; org_apache_felix_https_jetty_renegotiate_allowed: BOOLEAN; org_apache_felix_https_jetty_session_cookie_http_only: BOOLEAN; org_apache_felix_https_jetty_session_cookie_secure: BOOLEAN; org_eclipse_jetty_servlet__session_id_path_parameter_name: STRING_32; org_eclipse_jetty_servlet__checking_remote_session_id_encoding: BOOLEAN; org_eclipse_jetty_servlet__session_cookie: STRING_32; org_eclipse_jetty_servlet__session_domain: STRING_32; org_eclipse_jetty_servlet__session_path: STRING_32; org_eclipse_jetty_servlet__max_age: INTEGER_32; org_apache_felix_http_name: STRING_32; org_apache_felix_jetty_gziphandler_enable: BOOLEAN; org_apache_felix_jetty_gzip_min_gzip_size: INTEGER_32; org_apache_felix_jetty_gzip_compression_level: INTEGER_32; org_apache_felix_jetty_gzip_inflate_buffer_size: INTEGER_32; org_apache_felix_jetty_gzip_sync_flush: BOOLEAN; org_apache_felix_jetty_gzip_excluded_user_agents: detachable LIST [STRING_32]; org_apache_felix_jetty_gzip_included_methods: detachable LIST [STRING_32]; org_apache_felix_jetty_gzip_excluded_methods: detachable LIST [STRING_32]; org_apache_felix_jetty_gzip_included_paths: detachable LIST [STRING_32]; org_apache_felix_jetty_gzip_excluded_paths: detachable LIST [STRING_32]; org_apache_felix_jetty_gzip_included_mime_types: detachable LIST [STRING_32]; org_apache_felix_jetty_gzip_excluded_mime_types: detachable LIST [STRING_32]; org_apache_felix_http_session_invalidate: BOOLEAN; org_apache_felix_http_session_uniqueid: BOOLEAN): detachable ORG_APACHE_FELIX_HTTP_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: org_apache_felix_http_host  (optional)
			-- 
			-- argument: org_apache_felix_http_enable  (optional)
			-- 
			-- argument: org_osgi_service_http_port  (optional)
			-- 
			-- argument: org_apache_felix_http_timeout  (optional)
			-- 
			-- argument: org_apache_felix_https_enable  (optional)
			-- 
			-- argument: org_osgi_service_http_port_secure  (optional)
			-- 
			-- argument: org_apache_felix_https_keystore  (optional)
			-- 
			-- argument: org_apache_felix_https_keystore_password  (optional)
			-- 
			-- argument: org_apache_felix_https_keystore_key_password  (optional)
			-- 
			-- argument: org_apache_felix_https_truststore  (optional)
			-- 
			-- argument: org_apache_felix_https_truststore_password  (optional)
			-- 
			-- argument: org_apache_felix_https_clientcertificate  (optional)
			-- 
			-- argument: org_apache_felix_http_context_path  (optional)
			-- 
			-- argument: org_apache_felix_http_mbeans  (optional)
			-- 
			-- argument: org_apache_felix_http_session_timeout  (optional)
			-- 
			-- argument: org_apache_felix_http_jetty_threadpool_max  (optional)
			-- 
			-- argument: org_apache_felix_http_jetty_acceptors  (optional)
			-- 
			-- argument: org_apache_felix_http_jetty_selectors  (optional)
			-- 
			-- argument: org_apache_felix_http_jetty_header_buffer_size  (optional)
			-- 
			-- argument: org_apache_felix_http_jetty_request_buffer_size  (optional)
			-- 
			-- argument: org_apache_felix_http_jetty_response_buffer_size  (optional)
			-- 
			-- argument: org_apache_felix_http_jetty_max_form_size  (optional)
			-- 
			-- argument: org_apache_felix_http_path_exclusions  (optional)
			-- 
			-- argument: org_apache_felix_https_jetty_ciphersuites_excluded  (optional)
			-- 
			-- argument: org_apache_felix_https_jetty_ciphersuites_included  (optional)
			-- 
			-- argument: org_apache_felix_http_jetty_send_server_header  (optional)
			-- 
			-- argument: org_apache_felix_https_jetty_protocols_included  (optional)
			-- 
			-- argument: org_apache_felix_https_jetty_protocols_excluded  (optional)
			-- 
			-- argument: org_apache_felix_proxy_load_balancer_connection_enable  (optional)
			-- 
			-- argument: org_apache_felix_https_jetty_renegotiate_allowed  (optional)
			-- 
			-- argument: org_apache_felix_https_jetty_session_cookie_http_only  (optional)
			-- 
			-- argument: org_apache_felix_https_jetty_session_cookie_secure  (optional)
			-- 
			-- argument: org_eclipse_jetty_servlet__session_id_path_parameter_name  (optional)
			-- 
			-- argument: org_eclipse_jetty_servlet__checking_remote_session_id_encoding  (optional)
			-- 
			-- argument: org_eclipse_jetty_servlet__session_cookie  (optional)
			-- 
			-- argument: org_eclipse_jetty_servlet__session_domain  (optional)
			-- 
			-- argument: org_eclipse_jetty_servlet__session_path  (optional)
			-- 
			-- argument: org_eclipse_jetty_servlet__max_age  (optional)
			-- 
			-- argument: org_apache_felix_http_name  (optional)
			-- 
			-- argument: org_apache_felix_jetty_gziphandler_enable  (optional)
			-- 
			-- argument: org_apache_felix_jetty_gzip_min_gzip_size  (optional)
			-- 
			-- argument: org_apache_felix_jetty_gzip_compression_level  (optional)
			-- 
			-- argument: org_apache_felix_jetty_gzip_inflate_buffer_size  (optional)
			-- 
			-- argument: org_apache_felix_jetty_gzip_sync_flush  (optional)
			-- 
			-- argument: org_apache_felix_jetty_gzip_excluded_user_agents  (optional)
			-- 
			-- argument: org_apache_felix_jetty_gzip_included_methods  (optional)
			-- 
			-- argument: org_apache_felix_jetty_gzip_excluded_methods  (optional)
			-- 
			-- argument: org_apache_felix_jetty_gzip_included_paths  (optional)
			-- 
			-- argument: org_apache_felix_jetty_gzip_excluded_paths  (optional)
			-- 
			-- argument: org_apache_felix_jetty_gzip_included_mime_types  (optional)
			-- 
			-- argument: org_apache_felix_jetty_gzip_excluded_mime_types  (optional)
			-- 
			-- argument: org_apache_felix_http_session_invalidate  (optional)
			-- 
			-- argument: org_apache_felix_http_session_uniqueid  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_HTTP_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.http"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.host", org_apache_felix_http_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.enable", org_apache_felix_http_enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.osgi.service.http.port", org_osgi_service_http_port));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.timeout", org_apache_felix_http_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.enable", org_apache_felix_https_enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.osgi.service.http.port.secure", org_osgi_service_http_port_secure));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.keystore", org_apache_felix_https_keystore));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.keystore.password", org_apache_felix_https_keystore_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.keystore.key.password", org_apache_felix_https_keystore_key_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.truststore", org_apache_felix_https_truststore));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.truststore.password", org_apache_felix_https_truststore_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.clientcertificate", org_apache_felix_https_clientcertificate));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.context_path", org_apache_felix_http_context_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.mbeans", org_apache_felix_http_mbeans));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.session.timeout", org_apache_felix_http_session_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.jetty.threadpool.max", org_apache_felix_http_jetty_threadpool_max));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.jetty.acceptors", org_apache_felix_http_jetty_acceptors));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.jetty.selectors", org_apache_felix_http_jetty_selectors));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.jetty.headerBufferSize", org_apache_felix_http_jetty_header_buffer_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.jetty.requestBufferSize", org_apache_felix_http_jetty_request_buffer_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.jetty.responseBufferSize", org_apache_felix_http_jetty_response_buffer_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.jetty.maxFormSize", org_apache_felix_http_jetty_max_form_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.http.path_exclusions", org_apache_felix_http_path_exclusions));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.https.jetty.ciphersuites.excluded", org_apache_felix_https_jetty_ciphersuites_excluded));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.https.jetty.ciphersuites.included", org_apache_felix_https_jetty_ciphersuites_included));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.jetty.sendServerHeader", org_apache_felix_http_jetty_send_server_header));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.https.jetty.protocols.included", org_apache_felix_https_jetty_protocols_included));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.https.jetty.protocols.excluded", org_apache_felix_https_jetty_protocols_excluded));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.proxy.load.balancer.connection.enable", org_apache_felix_proxy_load_balancer_connection_enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.jetty.renegotiateAllowed", org_apache_felix_https_jetty_renegotiate_allowed));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.jetty.session.cookie.httpOnly", org_apache_felix_https_jetty_session_cookie_http_only));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.jetty.session.cookie.secure", org_apache_felix_https_jetty_session_cookie_secure));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.eclipse.jetty.servlet.SessionIdPathParameterName", org_eclipse_jetty_servlet__session_id_path_parameter_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.eclipse.jetty.servlet.CheckingRemoteSessionIdEncoding", org_eclipse_jetty_servlet__checking_remote_session_id_encoding));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.eclipse.jetty.servlet.SessionCookie", org_eclipse_jetty_servlet__session_cookie));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.eclipse.jetty.servlet.SessionDomain", org_eclipse_jetty_servlet__session_domain));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.eclipse.jetty.servlet.SessionPath", org_eclipse_jetty_servlet__session_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.eclipse.jetty.servlet.MaxAge", org_eclipse_jetty_servlet__max_age));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.name", org_apache_felix_http_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.jetty.gziphandler.enable", org_apache_felix_jetty_gziphandler_enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.jetty.gzip.minGzipSize", org_apache_felix_jetty_gzip_min_gzip_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.jetty.gzip.compressionLevel", org_apache_felix_jetty_gzip_compression_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.jetty.gzip.inflateBufferSize", org_apache_felix_jetty_gzip_inflate_buffer_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.jetty.gzip.syncFlush", org_apache_felix_jetty_gzip_sync_flush));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.jetty.gzip.excludedUserAgents", org_apache_felix_jetty_gzip_excluded_user_agents));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.jetty.gzip.includedMethods", org_apache_felix_jetty_gzip_included_methods));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.jetty.gzip.excludedMethods", org_apache_felix_jetty_gzip_excluded_methods));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.jetty.gzip.includedPaths", org_apache_felix_jetty_gzip_included_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.jetty.gzip.excludedPaths", org_apache_felix_jetty_gzip_excluded_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.jetty.gzip.includedMimeTypes", org_apache_felix_jetty_gzip_included_mime_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.felix.jetty.gzip.excludedMimeTypes", org_apache_felix_jetty_gzip_excluded_mime_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.session.invalidate", org_apache_felix_http_session_invalidate));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.http.session.uniqueid", org_apache_felix_http_session_uniqueid));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_HTTP_INFO } l_response.data ({ ORG_APACHE_FELIX_HTTP_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_http_sslfilter_ssl_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; ssl_forward_header: STRING_32; ssl_forward_value: STRING_32; ssl_forward_cert_header: STRING_32; rewrite_absolute_urls: BOOLEAN): detachable ORG_APACHE_FELIX_HTTP_SSLFILTER_SSL_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: ssl_forward_header  (optional)
			-- 
			-- argument: ssl_forward_value  (optional)
			-- 
			-- argument: ssl_forward_cert_header  (optional)
			-- 
			-- argument: rewrite_absolute_urls  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_HTTP_SSLFILTER_SSL_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.http.sslfilter.SslFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ssl-forward.header", ssl_forward_header));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ssl-forward.value", ssl_forward_value));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ssl-forward-cert.header", ssl_forward_cert_header));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "rewrite.absolute.urls", rewrite_absolute_urls));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_HTTP_SSLFILTER_SSL_FILTER_INFO } l_response.data ({ ORG_APACHE_FELIX_HTTP_SSLFILTER_SSL_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_jaas_configuration_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; jaas_control_flag: STRING_32; jaas_ranking: INTEGER_32; jaas_realm_name: STRING_32; jaas_classname: STRING_32; jaas_options: detachable LIST [STRING_32]): detachable ORG_APACHE_FELIX_JAAS_CONFIGURATION_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: jaas_control_flag  (optional)
			-- 
			-- argument: jaas_ranking  (optional)
			-- 
			-- argument: jaas_realm_name  (optional)
			-- 
			-- argument: jaas_classname  (optional)
			-- 
			-- argument: jaas_options  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_JAAS_CONFIGURATION_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.jaas.Configuration.factory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.controlFlag", jaas_control_flag));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.ranking", jaas_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.realmName", jaas_realm_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.classname", jaas_classname));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "jaas.options", jaas_options));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_JAAS_CONFIGURATION_FACTORY_INFO } l_response.data ({ ORG_APACHE_FELIX_JAAS_CONFIGURATION_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_jaas_configuration_spi (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; jaas_default_realm_name: STRING_32; jaas_config_provider_name: STRING_32; jaas_global_config_policy: STRING_32): detachable ORG_APACHE_FELIX_JAAS_CONFIGURATION_SPI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: jaas_default_realm_name  (optional)
			-- 
			-- argument: jaas_config_provider_name  (optional)
			-- 
			-- argument: jaas_global_config_policy  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_JAAS_CONFIGURATION_SPI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.jaas.ConfigurationSpi"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.defaultRealmName", jaas_default_realm_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.configProviderName", jaas_config_provider_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.globalConfigPolicy", jaas_global_config_policy));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_JAAS_CONFIGURATION_SPI_INFO } l_response.data ({ ORG_APACHE_FELIX_JAAS_CONFIGURATION_SPI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_scr_scr_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; ds_loglevel: INTEGER_32; ds_factory_enabled: BOOLEAN; ds_delayed_keep_instances: BOOLEAN; ds_lock_timeout_milliseconds: INTEGER_32; ds_stop_timeout_milliseconds: INTEGER_32; ds_global_extender: BOOLEAN): detachable ORG_APACHE_FELIX_SCR_SCR_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: ds_loglevel  (optional)
			-- 
			-- argument: ds_factory_enabled  (optional)
			-- 
			-- argument: ds_delayed_keep_instances  (optional)
			-- 
			-- argument: ds_lock_timeout_milliseconds  (optional)
			-- 
			-- argument: ds_stop_timeout_milliseconds  (optional)
			-- 
			-- argument: ds_global_extender  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_SCR_SCR_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.scr.ScrService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ds.loglevel", ds_loglevel));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ds.factory.enabled", ds_factory_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ds.delayed.keepInstances", ds_delayed_keep_instances));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ds.lock.timeout.milliseconds", ds_lock_timeout_milliseconds));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ds.stop.timeout.milliseconds", ds_stop_timeout_milliseconds));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ds.global.extender", ds_global_extender));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_SCR_SCR_SERVICE_INFO } l_response.data ({ ORG_APACHE_FELIX_SCR_SCR_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_systemready_impl_components_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; components_list: detachable LIST [STRING_32]; type: STRING_32): detachable ORG_APACHE_FELIX_SYSTEMREADY_IMPL_COMPONENTS_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: components_list  (optional)
			-- 
			-- argument: type  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_SYSTEMREADY_IMPL_COMPONENTS_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.systemready.impl.ComponentsCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "components.list", components_list));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "type", type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_SYSTEMREADY_IMPL_COMPONENTS_CHECK_INFO } l_response.data ({ ORG_APACHE_FELIX_SYSTEMREADY_IMPL_COMPONENTS_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_systemready_impl_framework_start_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; timeout: INTEGER_32; target_start_level: INTEGER_32; target_start_level_prop_name: STRING_32; type: STRING_32): detachable ORG_APACHE_FELIX_SYSTEMREADY_IMPL_FRAMEWORK_START_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: timeout  (optional)
			-- 
			-- argument: target_start_level  (optional)
			-- 
			-- argument: target_start_level_prop_name  (optional)
			-- 
			-- argument: type  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_SYSTEMREADY_IMPL_FRAMEWORK_START_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.systemready.impl.FrameworkStartCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "timeout", timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "target.start.level", target_start_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "target.start.level.prop.name", target_start_level_prop_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "type", type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_SYSTEMREADY_IMPL_FRAMEWORK_START_CHECK_INFO } l_response.data ({ ORG_APACHE_FELIX_SYSTEMREADY_IMPL_FRAMEWORK_START_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_systemready_impl_services_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; services_list: detachable LIST [STRING_32]; type: STRING_32): detachable ORG_APACHE_FELIX_SYSTEMREADY_IMPL_SERVICES_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: services_list  (optional)
			-- 
			-- argument: type  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_SYSTEMREADY_IMPL_SERVICES_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.systemready.impl.ServicesCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "services.list", services_list));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "type", type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_SYSTEMREADY_IMPL_SERVICES_CHECK_INFO } l_response.data ({ ORG_APACHE_FELIX_SYSTEMREADY_IMPL_SERVICES_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_systemready_impl_servlet_system_alive_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; osgi_http_whiteboard_servlet_pattern: STRING_32; osgi_http_whiteboard_context_select: STRING_32): detachable ORG_APACHE_FELIX_SYSTEMREADY_IMPL_SERVLET_SYSTEM_ALIVE_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: osgi_http_whiteboard_servlet_pattern  (optional)
			-- 
			-- argument: osgi_http_whiteboard_context_select  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_SYSTEMREADY_IMPL_SERVLET_SYSTEM_ALIVE_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.systemready.impl.servlet.SystemAliveServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "osgi.http.whiteboard.servlet.pattern", osgi_http_whiteboard_servlet_pattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "osgi.http.whiteboard.context.select", osgi_http_whiteboard_context_select));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_SYSTEMREADY_IMPL_SERVLET_SYSTEM_ALIVE_SERVLET_INFO } l_response.data ({ ORG_APACHE_FELIX_SYSTEMREADY_IMPL_SERVLET_SYSTEM_ALIVE_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_systemready_impl_servlet_system_ready_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; osgi_http_whiteboard_servlet_pattern: STRING_32; osgi_http_whiteboard_context_select: STRING_32): detachable ORG_APACHE_FELIX_SYSTEMREADY_IMPL_SERVLET_SYSTEM_READY_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: osgi_http_whiteboard_servlet_pattern  (optional)
			-- 
			-- argument: osgi_http_whiteboard_context_select  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_SYSTEMREADY_IMPL_SERVLET_SYSTEM_READY_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.systemready.impl.servlet.SystemReadyServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "osgi.http.whiteboard.servlet.pattern", osgi_http_whiteboard_servlet_pattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "osgi.http.whiteboard.context.select", osgi_http_whiteboard_context_select));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_SYSTEMREADY_IMPL_SERVLET_SYSTEM_READY_SERVLET_INFO } l_response.data ({ ORG_APACHE_FELIX_SYSTEMREADY_IMPL_SERVLET_SYSTEM_READY_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_systemready_system_ready_monitor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; poll_interval: INTEGER_32): detachable ORG_APACHE_FELIX_SYSTEMREADY_SYSTEM_READY_MONITOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: poll_interval  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_SYSTEMREADY_SYSTEM_READY_MONITOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.systemready.SystemReadyMonitor"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "poll.interval", poll_interval));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_SYSTEMREADY_SYSTEM_READY_MONITOR_INFO } l_response.data ({ ORG_APACHE_FELIX_SYSTEMREADY_SYSTEM_READY_MONITOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_webconsole_internal_servlet_osgi_manager (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; manager_root: STRING_32; http_service_filter: STRING_32; default_render: STRING_32; realm: STRING_32; username: STRING_32; password: STRING_32; category: STRING_32; locale: STRING_32; loglevel: INTEGER_32; plugins: STRING_32): detachable ORG_APACHE_FELIX_WEBCONSOLE_INTERNAL_SERVLET_OSGI_MANAGER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: manager_root  (optional)
			-- 
			-- argument: http_service_filter  (optional)
			-- 
			-- argument: default_render  (optional)
			-- 
			-- argument: realm  (optional)
			-- 
			-- argument: username  (optional)
			-- 
			-- argument: password  (optional)
			-- 
			-- argument: category  (optional)
			-- 
			-- argument: locale  (optional)
			-- 
			-- argument: loglevel  (optional)
			-- 
			-- argument: plugins  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_WEBCONSOLE_INTERNAL_SERVLET_OSGI_MANAGER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.webconsole.internal.servlet.OsgiManager"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "manager.root", manager_root));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "http.service.filter", http_service_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.render", default_render));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "realm", realm));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "username", username));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "password", password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "category", category));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "locale", locale));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "loglevel", loglevel));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "plugins", plugins));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_WEBCONSOLE_INTERNAL_SERVLET_OSGI_MANAGER_INFO } l_response.data ({ ORG_APACHE_FELIX_WEBCONSOLE_INTERNAL_SERVLET_OSGI_MANAGER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_webconsole_plugins_event_internal_plugin_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_size: INTEGER_32): detachable ORG_APACHE_FELIX_WEBCONSOLE_PLUGINS_EVENT_INTERNAL_PLUGIN_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_size  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_WEBCONSOLE_PLUGINS_EVENT_INTERNAL_PLUGIN_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.webconsole.plugins.event.internal.PluginServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "max.size", max_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_WEBCONSOLE_PLUGINS_EVENT_INTERNAL_PLUGIN_SERVLET_INFO } l_response.data ({ ORG_APACHE_FELIX_WEBCONSOLE_PLUGINS_EVENT_INTERNAL_PLUGIN_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_felix_webconsole_plugins_memoryusage_internal_memory_usage_co (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; felix_memoryusage_dump_threshold: INTEGER_32; felix_memoryusage_dump_interval: INTEGER_32; felix_memoryusage_dump_location: STRING_32): detachable ORG_APACHE_FELIX_WEBCONSOLE_PLUGINS_MEMORYUSAGE_INTERNAL_MEMORY_USAGE_CO_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: felix_memoryusage_dump_threshold  (optional)
			-- 
			-- argument: felix_memoryusage_dump_interval  (optional)
			-- 
			-- argument: felix_memoryusage_dump_location  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_FELIX_WEBCONSOLE_PLUGINS_MEMORYUSAGE_INTERNAL_MEMORY_USAGE_CO_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.felix.webconsole.plugins.memoryusage.internal.MemoryUsageConfigurator"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "felix.memoryusage.dump.threshold", felix_memoryusage_dump_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "felix.memoryusage.dump.interval", felix_memoryusage_dump_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "felix.memoryusage.dump.location", felix_memoryusage_dump_location));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_FELIX_WEBCONSOLE_PLUGINS_MEMORYUSAGE_INTERNAL_MEMORY_USAGE_CO_INFO } l_response.data ({ ORG_APACHE_FELIX_WEBCONSOLE_PLUGINS_MEMORYUSAGE_INTERNAL_MEMORY_USAGE_CO_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_http_proxyconfigurator (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; proxy_enabled: BOOLEAN; proxy_host: STRING_32; proxy_port: INTEGER_32; proxy_user: STRING_32; proxy_password: STRING_32; proxy_exceptions: detachable LIST [STRING_32]): detachable ORG_APACHE_HTTP_PROXYCONFIGURATOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: proxy_enabled  (optional)
			-- 
			-- argument: proxy_host  (optional)
			-- 
			-- argument: proxy_port  (optional)
			-- 
			-- argument: proxy_user  (optional)
			-- 
			-- argument: proxy_password  (optional)
			-- 
			-- argument: proxy_exceptions  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_HTTP_PROXYCONFIGURATOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.http.proxyconfigurator"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.enabled", proxy_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.host", proxy_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.port", proxy_port));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.user", proxy_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.password", proxy_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "proxy.exceptions", proxy_exceptions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_HTTP_PROXYCONFIGURATOR_INFO } l_response.data ({ ORG_APACHE_HTTP_PROXYCONFIGURATOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_blob_datastore_data_store_text_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; dir: STRING_32): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_BLOB_DATASTORE_DATA_STORE_TEXT_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: dir  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_BLOB_DATASTORE_DATA_STORE_TEXT_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.blob.datastore.DataStoreTextProviderService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dir", dir));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_BLOB_DATASTORE_DATA_STORE_TEXT_PROVIDER_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_BLOB_DATASTORE_DATA_STORE_TEXT_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_blob_datastore_file_data_store (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path: STRING_32): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_BLOB_DATASTORE_FILE_DATA_STORE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_BLOB_DATASTORE_FILE_DATA_STORE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.blob.datastore.FileDataStore"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_BLOB_DATASTORE_FILE_DATA_STORE_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_BLOB_DATASTORE_FILE_DATA_STORE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_document_document_node_store_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; mongouri: STRING_32; db: STRING_32; socket_keep_alive: BOOLEAN; cache: INTEGER_32; node_cache_percentage: INTEGER_32; prev_doc_cache_percentage: INTEGER_32; children_cache_percentage: INTEGER_32; diff_cache_percentage: INTEGER_32; cache_segment_count: INTEGER_32; cache_stack_move_distance: INTEGER_32; blob_cache_size: INTEGER_32; persistent_cache: STRING_32; journal_cache: STRING_32; custom_blob_store: BOOLEAN; journal_gc_interval: INTEGER_32; journal_gc_max_age: INTEGER_32; prefetch_external_changes: BOOLEAN; role: STRING_32; version_gc_max_age_in_secs: INTEGER_32; version_gc_expression: STRING_32; version_gc_time_limit_in_secs: INTEGER_32; blob_gc_max_age_in_secs: INTEGER_32; blob_track_snapshot_interval_in_secs: INTEGER_32; repository_home: STRING_32; max_replication_lag_in_secs: INTEGER_32; document_store_type: STRING_32; bundling_disabled: BOOLEAN; update_limit: INTEGER_32; persistent_cache_includes: detachable LIST [STRING_32]; lease_check_mode: STRING_32): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_DOCUMENT_DOCUMENT_NODE_STORE_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: mongouri  (optional)
			-- 
			-- argument: db  (optional)
			-- 
			-- argument: socket_keep_alive  (optional)
			-- 
			-- argument: cache  (optional)
			-- 
			-- argument: node_cache_percentage  (optional)
			-- 
			-- argument: prev_doc_cache_percentage  (optional)
			-- 
			-- argument: children_cache_percentage  (optional)
			-- 
			-- argument: diff_cache_percentage  (optional)
			-- 
			-- argument: cache_segment_count  (optional)
			-- 
			-- argument: cache_stack_move_distance  (optional)
			-- 
			-- argument: blob_cache_size  (optional)
			-- 
			-- argument: persistent_cache  (optional)
			-- 
			-- argument: journal_cache  (optional)
			-- 
			-- argument: custom_blob_store  (optional)
			-- 
			-- argument: journal_gc_interval  (optional)
			-- 
			-- argument: journal_gc_max_age  (optional)
			-- 
			-- argument: prefetch_external_changes  (optional)
			-- 
			-- argument: role  (optional)
			-- 
			-- argument: version_gc_max_age_in_secs  (optional)
			-- 
			-- argument: version_gc_expression  (optional)
			-- 
			-- argument: version_gc_time_limit_in_secs  (optional)
			-- 
			-- argument: blob_gc_max_age_in_secs  (optional)
			-- 
			-- argument: blob_track_snapshot_interval_in_secs  (optional)
			-- 
			-- argument: repository_home  (optional)
			-- 
			-- argument: max_replication_lag_in_secs  (optional)
			-- 
			-- argument: document_store_type  (optional)
			-- 
			-- argument: bundling_disabled  (optional)
			-- 
			-- argument: update_limit  (optional)
			-- 
			-- argument: persistent_cache_includes  (optional)
			-- 
			-- argument: lease_check_mode  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_DOCUMENT_DOCUMENT_NODE_STORE_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "mongouri", mongouri));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "db", db));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "socketKeepAlive", socket_keep_alive));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cache", cache));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "nodeCachePercentage", node_cache_percentage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "prevDocCachePercentage", prev_doc_cache_percentage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "childrenCachePercentage", children_cache_percentage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "diffCachePercentage", diff_cache_percentage));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cacheSegmentCount", cache_segment_count));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cacheStackMoveDistance", cache_stack_move_distance));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "blobCacheSize", blob_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "persistentCache", persistent_cache));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "journalCache", journal_cache));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "customBlobStore", custom_blob_store));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "journalGCInterval", journal_gc_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "journalGCMaxAge", journal_gc_max_age));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "prefetchExternalChanges", prefetch_external_changes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "role", role));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "versionGcMaxAgeInSecs", version_gc_max_age_in_secs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "versionGCExpression", version_gc_expression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "versionGCTimeLimitInSecs", version_gc_time_limit_in_secs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "blobGcMaxAgeInSecs", blob_gc_max_age_in_secs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "blobTrackSnapshotIntervalInSecs", blob_track_snapshot_interval_in_secs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repository.home", repository_home));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxReplicationLagInSecs", max_replication_lag_in_secs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "documentStoreType", document_store_type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "bundlingDisabled", bundling_disabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "updateLimit", update_limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "persistentCacheIncludes", persistent_cache_includes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "leaseCheckMode", lease_check_mode));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_DOCUMENT_DOCUMENT_NODE_STORE_SERVICE_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_DOCUMENT_DOCUMENT_NODE_STORE_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_document_document_node_store_service_pre (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; persistent_cache_includes: detachable LIST [STRING_32]): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_DOCUMENT_DOCUMENT_NODE_STORE_SERVICE_PRE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: persistent_cache_includes  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_DOCUMENT_DOCUMENT_NODE_STORE_SERVICE_PRE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreServicePreset"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "persistentCacheIncludes", persistent_cache_includes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_DOCUMENT_DOCUMENT_NODE_STORE_SERVICE_PRE_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_DOCUMENT_DOCUMENT_NODE_STORE_SERVICE_PRE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_document_secondary_secondary_store_cac (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; included_paths: detachable LIST [STRING_32]; enable_async_observer: BOOLEAN; observer_queue_size: INTEGER_32): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_DOCUMENT_SECONDARY_SECONDARY_STORE_CAC_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: included_paths  (optional)
			-- 
			-- argument: enable_async_observer  (optional)
			-- 
			-- argument: observer_queue_size  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_DOCUMENT_SECONDARY_SECONDARY_STORE_CAC_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.secondary.SecondaryStoreCacheService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "includedPaths", included_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableAsyncObserver", enable_async_observer));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "observerQueueSize", observer_queue_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_DOCUMENT_SECONDARY_SECONDARY_STORE_CAC_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_DOCUMENT_SECONDARY_SECONDARY_STORE_CAC_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_index_async_indexer_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; async_configs: detachable LIST [STRING_32]; lease_time_out_minutes: INTEGER_32; failing_index_timeout_seconds: INTEGER_32; error_warn_interval_seconds: INTEGER_32): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_ASYNC_INDEXER_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: async_configs  (optional)
			-- 
			-- argument: lease_time_out_minutes  (optional)
			-- 
			-- argument: failing_index_timeout_seconds  (optional)
			-- 
			-- argument: error_warn_interval_seconds  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_ASYNC_INDEXER_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.AsyncIndexerService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "asyncConfigs", async_configs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "leaseTimeOutMinutes", lease_time_out_minutes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "failingIndexTimeoutSeconds", failing_index_timeout_seconds));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "errorWarnIntervalSeconds", error_warn_interval_seconds));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_ASYNC_INDEXER_SERVICE_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_ASYNC_INDEXER_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_index_lucene_lucene_index_provider_serv (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; disabled: BOOLEAN; var_debug: BOOLEAN; local_index_dir: STRING_32; enable_open_index_async: BOOLEAN; thread_pool_size: INTEGER_32; prefetch_index_files: BOOLEAN; extracted_text_cache_size_in_mb: INTEGER_32; extracted_text_cache_expiry_in_secs: INTEGER_32; always_use_pre_extracted_cache: BOOLEAN; boolean_clause_limit: INTEGER_32; enable_hybrid_indexing: BOOLEAN; hybrid_queue_size: INTEGER_32; disable_stored_index_definition: BOOLEAN; deleted_blobs_collection_enabled: BOOLEAN; prop_index_cleaner_interval_in_secs: INTEGER_32; enable_single_blob_index_files: BOOLEAN): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_LUCENE_LUCENE_INDEX_PROVIDER_SERV_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: disabled  (optional)
			-- 
			-- argument: var_debug  (optional)
			-- 
			-- argument: local_index_dir  (optional)
			-- 
			-- argument: enable_open_index_async  (optional)
			-- 
			-- argument: thread_pool_size  (optional)
			-- 
			-- argument: prefetch_index_files  (optional)
			-- 
			-- argument: extracted_text_cache_size_in_mb  (optional)
			-- 
			-- argument: extracted_text_cache_expiry_in_secs  (optional)
			-- 
			-- argument: always_use_pre_extracted_cache  (optional)
			-- 
			-- argument: boolean_clause_limit  (optional)
			-- 
			-- argument: enable_hybrid_indexing  (optional)
			-- 
			-- argument: hybrid_queue_size  (optional)
			-- 
			-- argument: disable_stored_index_definition  (optional)
			-- 
			-- argument: deleted_blobs_collection_enabled  (optional)
			-- 
			-- argument: prop_index_cleaner_interval_in_secs  (optional)
			-- 
			-- argument: enable_single_blob_index_files  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_LUCENE_LUCENE_INDEX_PROVIDER_SERV_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexProviderService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "disabled", disabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "debug", var_debug));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "localIndexDir", local_index_dir));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableOpenIndexAsync", enable_open_index_async));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "threadPoolSize", thread_pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "prefetchIndexFiles", prefetch_index_files));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "extractedTextCacheSizeInMB", extracted_text_cache_size_in_mb));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "extractedTextCacheExpiryInSecs", extracted_text_cache_expiry_in_secs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "alwaysUsePreExtractedCache", always_use_pre_extracted_cache));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "booleanClauseLimit", boolean_clause_limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableHybridIndexing", enable_hybrid_indexing));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hybridQueueSize", hybrid_queue_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "disableStoredIndexDefinition", disable_stored_index_definition));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "deletedBlobsCollectionEnabled", deleted_blobs_collection_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "propIndexCleanerIntervalInSecs", prop_index_cleaner_interval_in_secs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableSingleBlobIndexFiles", enable_single_blob_index_files));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_LUCENE_LUCENE_INDEX_PROVIDER_SERV_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_LUCENE_LUCENE_INDEX_PROVIDER_SERV_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_index_solr_osgi_embedded_solr_server_co (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; solr_home_path: STRING_32; solr_core_name: STRING_32): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_EMBEDDED_SOLR_SERVER_CO_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: solr_home_path  (optional)
			-- 
			-- argument: solr_core_name  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_EMBEDDED_SOLR_SERVER_CO_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.EmbeddedSolrServerConfigurationProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.home.path", solr_home_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.core.name", solr_core_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_EMBEDDED_SOLR_SERVER_CO_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_EMBEDDED_SOLR_SERVER_CO_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_index_solr_osgi_node_state_solr_servers (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_NODE_STATE_SOLR_SERVERS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_NODE_STATE_SOLR_SERVERS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.NodeStateSolrServersObserverService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_NODE_STATE_SOLR_SERVERS_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_NODE_STATE_SOLR_SERVERS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_index_solr_osgi_oak_solr_configuration (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path_desc_field: STRING_32; path_child_field: STRING_32; path_parent_field: STRING_32; path_exact_field: STRING_32; catch_all_field: STRING_32; collapsed_path_field: STRING_32; path_depth_field: STRING_32; commit_policy: STRING_32; rows: INTEGER_32; path_restrictions: BOOLEAN; property_restrictions: BOOLEAN; primarytypes_restrictions: BOOLEAN; ignored_properties: detachable LIST [STRING_32]; used_properties: detachable LIST [STRING_32]; type_mappings: detachable LIST [STRING_32]; property_mappings: detachable LIST [STRING_32]; collapse_jcrcontent_nodes: BOOLEAN): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_OAK_SOLR_CONFIGURATION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path_desc_field  (optional)
			-- 
			-- argument: path_child_field  (optional)
			-- 
			-- argument: path_parent_field  (optional)
			-- 
			-- argument: path_exact_field  (optional)
			-- 
			-- argument: catch_all_field  (optional)
			-- 
			-- argument: collapsed_path_field  (optional)
			-- 
			-- argument: path_depth_field  (optional)
			-- 
			-- argument: commit_policy  (optional)
			-- 
			-- argument: rows  (optional)
			-- 
			-- argument: path_restrictions  (optional)
			-- 
			-- argument: property_restrictions  (optional)
			-- 
			-- argument: primarytypes_restrictions  (optional)
			-- 
			-- argument: ignored_properties  (optional)
			-- 
			-- argument: used_properties  (optional)
			-- 
			-- argument: type_mappings  (optional)
			-- 
			-- argument: property_mappings  (optional)
			-- 
			-- argument: collapse_jcrcontent_nodes  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_OAK_SOLR_CONFIGURATION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.OakSolrConfigurationProviderService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path.desc.field", path_desc_field));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path.child.field", path_child_field));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path.parent.field", path_parent_field));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path.exact.field", path_exact_field));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "catch.all.field", catch_all_field));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "collapsed.path.field", collapsed_path_field));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path.depth.field", path_depth_field));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "commit.policy", commit_policy));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "rows", rows));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path.restrictions", path_restrictions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "property.restrictions", property_restrictions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "primarytypes.restrictions", primarytypes_restrictions));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "ignored.properties", ignored_properties));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "used.properties", used_properties));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "type.mappings", type_mappings));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "property.mappings", property_mappings));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "collapse.jcrcontent.nodes", collapse_jcrcontent_nodes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_OAK_SOLR_CONFIGURATION_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_OAK_SOLR_CONFIGURATION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_index_solr_osgi_remote_solr_server_conf (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; solr_http_url: STRING_32; solr_zk_host: STRING_32; solr_collection: STRING_32; solr_socket_timeout: INTEGER_32; solr_connection_timeout: INTEGER_32; solr_shards_no: INTEGER_32; solr_replication_factor: INTEGER_32; solr_conf_dir: STRING_32): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_REMOTE_SOLR_SERVER_CONF_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: solr_http_url  (optional)
			-- 
			-- argument: solr_zk_host  (optional)
			-- 
			-- argument: solr_collection  (optional)
			-- 
			-- argument: solr_socket_timeout  (optional)
			-- 
			-- argument: solr_connection_timeout  (optional)
			-- 
			-- argument: solr_shards_no  (optional)
			-- 
			-- argument: solr_replication_factor  (optional)
			-- 
			-- argument: solr_conf_dir  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_REMOTE_SOLR_SERVER_CONF_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.RemoteSolrServerConfigurationProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.http.url", solr_http_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.zk.host", solr_zk_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.collection", solr_collection));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.socket.timeout", solr_socket_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.connection.timeout", solr_connection_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.shards.no", solr_shards_no));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.replication.factor", solr_replication_factor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "solr.conf.dir", solr_conf_dir));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_REMOTE_SOLR_SERVER_CONF_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_REMOTE_SOLR_SERVER_CONF_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_index_solr_osgi_solr_query_index_provid (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; query_aggregation: BOOLEAN): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_SOLR_QUERY_INDEX_PROVID_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: query_aggregation  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_SOLR_QUERY_INDEX_PROVID_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.SolrQueryIndexProviderService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "query.aggregation", query_aggregation));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_SOLR_QUERY_INDEX_PROVID_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_SOLR_QUERY_INDEX_PROVID_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_index_solr_osgi_solr_server_provider_se (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; server_type: STRING_32): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_SOLR_SERVER_PROVIDER_SE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: server_type  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_SOLR_SERVER_PROVIDER_SE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.SolrServerProviderService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "server.type", server_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_SOLR_SERVER_PROVIDER_SE_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_INDEX_SOLR_OSGI_SOLR_SERVER_PROVIDER_SE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_metric_statistics_provider_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; provider_type: STRING_32): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_METRIC_STATISTICS_PROVIDER_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: provider_type  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_METRIC_STATISTICS_PROVIDER_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.metric.StatisticsProviderFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "providerType", provider_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_METRIC_STATISTICS_PROVIDER_FACTORY_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_METRIC_STATISTICS_PROVIDER_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_plugins_observation_change_collector_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_items: INTEGER_32; max_path_depth: INTEGER_32; enabled: BOOLEAN): detachable ORG_APACHE_JACKRABBIT_OAK_PLUGINS_OBSERVATION_CHANGE_COLLECTOR_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_items  (optional)
			-- 
			-- argument: max_path_depth  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_PLUGINS_OBSERVATION_CHANGE_COLLECTOR_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.observation.ChangeCollectorProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxItems", max_items));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxPathDepth", max_path_depth));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_PLUGINS_OBSERVATION_CHANGE_COLLECTOR_PROVIDER_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_PLUGINS_OBSERVATION_CHANGE_COLLECTOR_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_query_query_engine_settings_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; query_limit_in_memory: INTEGER_32; query_limit_reads: INTEGER_32; query_fail_traversal: BOOLEAN; fast_query_size: BOOLEAN): detachable ORG_APACHE_JACKRABBIT_OAK_QUERY_QUERY_ENGINE_SETTINGS_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: query_limit_in_memory  (optional)
			-- 
			-- argument: query_limit_reads  (optional)
			-- 
			-- argument: query_fail_traversal  (optional)
			-- 
			-- argument: fast_query_size  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_QUERY_QUERY_ENGINE_SETTINGS_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.query.QueryEngineSettingsService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queryLimitInMemory", query_limit_in_memory));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queryLimitReads", query_limit_reads));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queryFailTraversal", query_fail_traversal));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "fastQuerySize", fast_query_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_QUERY_QUERY_ENGINE_SETTINGS_SERVICE_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_QUERY_QUERY_ENGINE_SETTINGS_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_security_authentication_authentication_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; org_apache_jackrabbit_oak_authentication_app_name: STRING_32; org_apache_jackrabbit_oak_authentication_config_spi_name: STRING_32): detachable ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHENTICATION_AUTHENTICATION_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: org_apache_jackrabbit_oak_authentication_app_name  (optional)
			-- 
			-- argument: org_apache_jackrabbit_oak_authentication_config_spi_name  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHENTICATION_AUTHENTICATION_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.AuthenticationConfigurationImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.jackrabbit.oak.authentication.appName", org_apache_jackrabbit_oak_authentication_app_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.jackrabbit.oak.authentication.configSpiName", org_apache_jackrabbit_oak_authentication_config_spi_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHENTICATION_AUTHENTICATION_CONFIG_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHENTICATION_AUTHENTICATION_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_security_authentication_ldap_impl_ldap_identi (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; provider_name: STRING_32; host_name: STRING_32; host_port: INTEGER_32; host_ssl: BOOLEAN; host_tls: BOOLEAN; host_no_cert_check: BOOLEAN; bind_dn: STRING_32; bind_password: STRING_32; search_timeout: STRING_32; admin_pool_max_active: INTEGER_32; admin_pool_lookup_on_validate: BOOLEAN; user_pool_max_active: INTEGER_32; user_pool_lookup_on_validate: BOOLEAN; user_base_dn: STRING_32; user_objectclass: detachable LIST [STRING_32]; user_id_attribute: STRING_32; user_extra_filter: STRING_32; user_make_dn_path: BOOLEAN; group_base_dn: STRING_32; group_objectclass: detachable LIST [STRING_32]; group_name_attribute: STRING_32; group_extra_filter: STRING_32; group_make_dn_path: BOOLEAN; group_member_attribute: STRING_32; use_uid_for_ext_id: BOOLEAN; customattributes: detachable LIST [STRING_32]): detachable ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHENTICATION_LDAP_IMPL_LDAP_IDENTI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: provider_name  (optional)
			-- 
			-- argument: host_name  (optional)
			-- 
			-- argument: host_port  (optional)
			-- 
			-- argument: host_ssl  (optional)
			-- 
			-- argument: host_tls  (optional)
			-- 
			-- argument: host_no_cert_check  (optional)
			-- 
			-- argument: bind_dn  (optional)
			-- 
			-- argument: bind_password  (optional)
			-- 
			-- argument: search_timeout  (optional)
			-- 
			-- argument: admin_pool_max_active  (optional)
			-- 
			-- argument: admin_pool_lookup_on_validate  (optional)
			-- 
			-- argument: user_pool_max_active  (optional)
			-- 
			-- argument: user_pool_lookup_on_validate  (optional)
			-- 
			-- argument: user_base_dn  (optional)
			-- 
			-- argument: user_objectclass  (optional)
			-- 
			-- argument: user_id_attribute  (optional)
			-- 
			-- argument: user_extra_filter  (optional)
			-- 
			-- argument: user_make_dn_path  (optional)
			-- 
			-- argument: group_base_dn  (optional)
			-- 
			-- argument: group_objectclass  (optional)
			-- 
			-- argument: group_name_attribute  (optional)
			-- 
			-- argument: group_extra_filter  (optional)
			-- 
			-- argument: group_make_dn_path  (optional)
			-- 
			-- argument: group_member_attribute  (optional)
			-- 
			-- argument: use_uid_for_ext_id  (optional)
			-- 
			-- argument: customattributes  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHENTICATION_LDAP_IMPL_LDAP_IDENTI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.name", provider_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "host.name", host_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "host.port", host_port));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "host.ssl", host_ssl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "host.tls", host_tls));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "host.noCertCheck", host_no_cert_check));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "bind.dn", bind_dn));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "bind.password", bind_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "searchTimeout", search_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "adminPool.maxActive", admin_pool_max_active));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "adminPool.lookupOnValidate", admin_pool_lookup_on_validate));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "userPool.maxActive", user_pool_max_active));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "userPool.lookupOnValidate", user_pool_lookup_on_validate));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user.baseDN", user_base_dn));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "user.objectclass", user_objectclass));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user.idAttribute", user_id_attribute));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user.extraFilter", user_extra_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user.makeDnPath", user_make_dn_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "group.baseDN", group_base_dn));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "group.objectclass", group_objectclass));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "group.nameAttribute", group_name_attribute));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "group.extraFilter", group_extra_filter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "group.makeDnPath", group_make_dn_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "group.memberAttribute", group_member_attribute));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "useUidForExtId", use_uid_for_ext_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "customattributes", customattributes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHENTICATION_LDAP_IMPL_LDAP_IDENTI_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHENTICATION_LDAP_IMPL_LDAP_IDENTI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_security_authentication_token_token_configura (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; token_expiration: STRING_32; token_length: STRING_32; token_refresh: BOOLEAN; token_cleanup_threshold: INTEGER_32; password_hash_algorithm: STRING_32; password_hash_iterations: INTEGER_32; password_salt_size: INTEGER_32): detachable ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHENTICATION_TOKEN_TOKEN_CONFIGURA_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: token_expiration  (optional)
			-- 
			-- argument: token_length  (optional)
			-- 
			-- argument: token_refresh  (optional)
			-- 
			-- argument: token_cleanup_threshold  (optional)
			-- 
			-- argument: password_hash_algorithm  (optional)
			-- 
			-- argument: password_hash_iterations  (optional)
			-- 
			-- argument: password_salt_size  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHENTICATION_TOKEN_TOKEN_CONFIGURA_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.token.TokenConfigurationImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tokenExpiration", token_expiration));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tokenLength", token_length));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tokenRefresh", token_refresh));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tokenCleanupThreshold", token_cleanup_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "passwordHashAlgorithm", password_hash_algorithm));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "passwordHashIterations", password_hash_iterations));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "passwordSaltSize", password_salt_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHENTICATION_TOKEN_TOKEN_CONFIGURA_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHENTICATION_TOKEN_TOKEN_CONFIGURA_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_security_authorization_authorization_configur (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; permissions_jr2: STRING_32; import_behavior: STRING_32; read_paths: detachable LIST [STRING_32]; administrative_principals: detachable LIST [STRING_32]; configuration_ranking: INTEGER_32): detachable ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHORIZATION_AUTHORIZATION_CONFIGUR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: permissions_jr2  (optional)
			-- 
			-- argument: import_behavior  (optional)
			-- 
			-- argument: read_paths  (optional)
			-- 
			-- argument: administrative_principals  (optional)
			-- 
			-- argument: configuration_ranking  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHORIZATION_AUTHORIZATION_CONFIGUR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.security.authorization.AuthorizationConfigurationImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "permissionsJr2", permissions_jr2));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "importBehavior", import_behavior));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "readPaths", read_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "administrativePrincipals", administrative_principals));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "configurationRanking", configuration_ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHORIZATION_AUTHORIZATION_CONFIGUR_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SECURITY_AUTHORIZATION_AUTHORIZATION_CONFIGUR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_security_internal_security_provider_registrati (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; required_service_pids: detachable LIST [STRING_32]; authorization_composition_type: STRING_32): detachable ORG_APACHE_JACKRABBIT_OAK_SECURITY_INTERNAL_SECURITY_PROVIDER_REGISTRATI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: required_service_pids  (optional)
			-- 
			-- argument: authorization_composition_type  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SECURITY_INTERNAL_SECURITY_PROVIDER_REGISTRATI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.security.internal.SecurityProviderRegistration"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "requiredServicePids", required_service_pids));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "authorizationCompositionType", authorization_composition_type));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SECURITY_INTERNAL_SECURITY_PROVIDER_REGISTRATI_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SECURITY_INTERNAL_SECURITY_PROVIDER_REGISTRATI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_security_user_random_authorizable_node_name (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; length: INTEGER_32): detachable ORG_APACHE_JACKRABBIT_OAK_SECURITY_USER_RANDOM_AUTHORIZABLE_NODE_NAME_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: length  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SECURITY_USER_RANDOM_AUTHORIZABLE_NODE_NAME_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.security.user.RandomAuthorizableNodeName"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "length", length));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SECURITY_USER_RANDOM_AUTHORIZABLE_NODE_NAME_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SECURITY_USER_RANDOM_AUTHORIZABLE_NODE_NAME_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_security_user_user_configuration_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; users_path: STRING_32; groups_path: STRING_32; system_relative_path: STRING_32; default_depth: INTEGER_32; import_behavior: STRING_32; password_hash_algorithm: STRING_32; password_hash_iterations: INTEGER_32; password_salt_size: INTEGER_32; omit_admin_pw: BOOLEAN; support_auto_save: BOOLEAN; password_max_age: INTEGER_32; initial_password_change: BOOLEAN; password_history_size: INTEGER_32; password_expiry_for_admin: BOOLEAN; cache_expiration: INTEGER_32; enable_rf_c7613_usercase_mapped_profile: BOOLEAN): detachable ORG_APACHE_JACKRABBIT_OAK_SECURITY_USER_USER_CONFIGURATION_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: users_path  (optional)
			-- 
			-- argument: groups_path  (optional)
			-- 
			-- argument: system_relative_path  (optional)
			-- 
			-- argument: default_depth  (optional)
			-- 
			-- argument: import_behavior  (optional)
			-- 
			-- argument: password_hash_algorithm  (optional)
			-- 
			-- argument: password_hash_iterations  (optional)
			-- 
			-- argument: password_salt_size  (optional)
			-- 
			-- argument: omit_admin_pw  (optional)
			-- 
			-- argument: support_auto_save  (optional)
			-- 
			-- argument: password_max_age  (optional)
			-- 
			-- argument: initial_password_change  (optional)
			-- 
			-- argument: password_history_size  (optional)
			-- 
			-- argument: password_expiry_for_admin  (optional)
			-- 
			-- argument: cache_expiration  (optional)
			-- 
			-- argument: enable_rf_c7613_usercase_mapped_profile  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SECURITY_USER_USER_CONFIGURATION_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.security.user.UserConfigurationImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "usersPath", users_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "groupsPath", groups_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "systemRelativePath", system_relative_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultDepth", default_depth));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "importBehavior", import_behavior));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "passwordHashAlgorithm", password_hash_algorithm));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "passwordHashIterations", password_hash_iterations));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "passwordSaltSize", password_salt_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "omitAdminPw", omit_admin_pw));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "supportAutoSave", support_auto_save));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "passwordMaxAge", password_max_age));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "initialPasswordChange", initial_password_change));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "passwordHistorySize", password_history_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "passwordExpiryForAdmin", password_expiry_for_admin));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cacheExpiration", cache_expiration));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableRFC7613UsercaseMappedProfile", enable_rf_c7613_usercase_mapped_profile));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SECURITY_USER_USER_CONFIGURATION_IMPL_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SECURITY_USER_USER_CONFIGURATION_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_segment_azure_azure_segment_store_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; account_name: STRING_32; container_name: STRING_32; access_key: STRING_32; root_path: STRING_32; connection_ur_l: STRING_32): detachable ORG_APACHE_JACKRABBIT_OAK_SEGMENT_AZURE_AZURE_SEGMENT_STORE_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: account_name  (optional)
			-- 
			-- argument: container_name  (optional)
			-- 
			-- argument: access_key  (optional)
			-- 
			-- argument: root_path  (optional)
			-- 
			-- argument: connection_ur_l  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SEGMENT_AZURE_AZURE_SEGMENT_STORE_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.segment.azure.AzureSegmentStoreService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "accountName", account_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "containerName", container_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "accessKey", access_key));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "rootPath", root_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connectionURL", connection_ur_l));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SEGMENT_AZURE_AZURE_SEGMENT_STORE_SERVICE_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SEGMENT_AZURE_AZURE_SEGMENT_STORE_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_segment_segment_node_store_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; repository_home: STRING_32; tarmk_mode: STRING_32; tarmk_size: INTEGER_32; segment_cache_size: INTEGER_32; string_cache_size: INTEGER_32; template_cache_size: INTEGER_32; string_deduplication_cache_size: INTEGER_32; template_deduplication_cache_size: INTEGER_32; node_deduplication_cache_size: INTEGER_32; pause_compaction: BOOLEAN; compaction_retry_count: INTEGER_32; compaction_force_timeout: INTEGER_32; compaction_size_delta_estimation: INTEGER_32; compaction_disable_estimation: BOOLEAN; compaction_retained_generations: INTEGER_32; compaction_memory_threshold: INTEGER_32; compaction_progress_log: INTEGER_32; standby: BOOLEAN; custom_blob_store: BOOLEAN; custom_segment_store: BOOLEAN; split_persistence: BOOLEAN; repository_backup_dir: STRING_32; blob_gc_max_age_in_secs: INTEGER_32; blob_track_snapshot_interval_in_secs: INTEGER_32; role: STRING_32; register_descriptors: BOOLEAN; dispatch_changes: BOOLEAN): detachable ORG_APACHE_JACKRABBIT_OAK_SEGMENT_SEGMENT_NODE_STORE_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: repository_home  (optional)
			-- 
			-- argument: tarmk_mode  (optional)
			-- 
			-- argument: tarmk_size  (optional)
			-- 
			-- argument: segment_cache_size  (optional)
			-- 
			-- argument: string_cache_size  (optional)
			-- 
			-- argument: template_cache_size  (optional)
			-- 
			-- argument: string_deduplication_cache_size  (optional)
			-- 
			-- argument: template_deduplication_cache_size  (optional)
			-- 
			-- argument: node_deduplication_cache_size  (optional)
			-- 
			-- argument: pause_compaction  (optional)
			-- 
			-- argument: compaction_retry_count  (optional)
			-- 
			-- argument: compaction_force_timeout  (optional)
			-- 
			-- argument: compaction_size_delta_estimation  (optional)
			-- 
			-- argument: compaction_disable_estimation  (optional)
			-- 
			-- argument: compaction_retained_generations  (optional)
			-- 
			-- argument: compaction_memory_threshold  (optional)
			-- 
			-- argument: compaction_progress_log  (optional)
			-- 
			-- argument: standby  (optional)
			-- 
			-- argument: custom_blob_store  (optional)
			-- 
			-- argument: custom_segment_store  (optional)
			-- 
			-- argument: split_persistence  (optional)
			-- 
			-- argument: repository_backup_dir  (optional)
			-- 
			-- argument: blob_gc_max_age_in_secs  (optional)
			-- 
			-- argument: blob_track_snapshot_interval_in_secs  (optional)
			-- 
			-- argument: role  (optional)
			-- 
			-- argument: register_descriptors  (optional)
			-- 
			-- argument: dispatch_changes  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SEGMENT_SEGMENT_NODE_STORE_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repository.home", repository_home));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tarmk.mode", tarmk_mode));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tarmk.size", tarmk_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "segmentCache.size", segment_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "stringCache.size", string_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "templateCache.size", template_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "stringDeduplicationCache.size", string_deduplication_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "templateDeduplicationCache.size", template_deduplication_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "nodeDeduplicationCache.size", node_deduplication_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pauseCompaction", pause_compaction));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.retryCount", compaction_retry_count));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.force.timeout", compaction_force_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.sizeDeltaEstimation", compaction_size_delta_estimation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.disableEstimation", compaction_disable_estimation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.retainedGenerations", compaction_retained_generations));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.memoryThreshold", compaction_memory_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.progressLog", compaction_progress_log));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "standby", standby));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "customBlobStore", custom_blob_store));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "customSegmentStore", custom_segment_store));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "splitPersistence", split_persistence));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repository.backup.dir", repository_backup_dir));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "blobGcMaxAgeInSecs", blob_gc_max_age_in_secs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "blobTrackSnapshotIntervalInSecs", blob_track_snapshot_interval_in_secs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "role", role));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "registerDescriptors", register_descriptors));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dispatchChanges", dispatch_changes));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SEGMENT_SEGMENT_NODE_STORE_FACTORY_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SEGMENT_SEGMENT_NODE_STORE_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_segment_segment_node_store_monitor_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; commits_tracker_writer_groups: detachable LIST [STRING_32]): detachable ORG_APACHE_JACKRABBIT_OAK_SEGMENT_SEGMENT_NODE_STORE_MONITOR_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: commits_tracker_writer_groups  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SEGMENT_SEGMENT_NODE_STORE_MONITOR_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreMonitorService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "commitsTrackerWriterGroups", commits_tracker_writer_groups));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SEGMENT_SEGMENT_NODE_STORE_MONITOR_SERVICE_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SEGMENT_SEGMENT_NODE_STORE_MONITOR_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_segment_segment_node_store_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; repository_home: STRING_32; tarmk_mode: STRING_32; tarmk_size: INTEGER_32; segment_cache_size: INTEGER_32; string_cache_size: INTEGER_32; template_cache_size: INTEGER_32; string_deduplication_cache_size: INTEGER_32; template_deduplication_cache_size: INTEGER_32; node_deduplication_cache_size: INTEGER_32; pause_compaction: BOOLEAN; compaction_retry_count: INTEGER_32; compaction_force_timeout: INTEGER_32; compaction_size_delta_estimation: INTEGER_32; compaction_disable_estimation: BOOLEAN; compaction_retained_generations: INTEGER_32; compaction_memory_threshold: INTEGER_32; compaction_progress_log: INTEGER_32; standby: BOOLEAN; custom_blob_store: BOOLEAN; custom_segment_store: BOOLEAN; split_persistence: BOOLEAN; repository_backup_dir: STRING_32; blob_gc_max_age_in_secs: INTEGER_32; blob_track_snapshot_interval_in_secs: INTEGER_32): detachable ORG_APACHE_JACKRABBIT_OAK_SEGMENT_SEGMENT_NODE_STORE_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: repository_home  (optional)
			-- 
			-- argument: tarmk_mode  (optional)
			-- 
			-- argument: tarmk_size  (optional)
			-- 
			-- argument: segment_cache_size  (optional)
			-- 
			-- argument: string_cache_size  (optional)
			-- 
			-- argument: template_cache_size  (optional)
			-- 
			-- argument: string_deduplication_cache_size  (optional)
			-- 
			-- argument: template_deduplication_cache_size  (optional)
			-- 
			-- argument: node_deduplication_cache_size  (optional)
			-- 
			-- argument: pause_compaction  (optional)
			-- 
			-- argument: compaction_retry_count  (optional)
			-- 
			-- argument: compaction_force_timeout  (optional)
			-- 
			-- argument: compaction_size_delta_estimation  (optional)
			-- 
			-- argument: compaction_disable_estimation  (optional)
			-- 
			-- argument: compaction_retained_generations  (optional)
			-- 
			-- argument: compaction_memory_threshold  (optional)
			-- 
			-- argument: compaction_progress_log  (optional)
			-- 
			-- argument: standby  (optional)
			-- 
			-- argument: custom_blob_store  (optional)
			-- 
			-- argument: custom_segment_store  (optional)
			-- 
			-- argument: split_persistence  (optional)
			-- 
			-- argument: repository_backup_dir  (optional)
			-- 
			-- argument: blob_gc_max_age_in_secs  (optional)
			-- 
			-- argument: blob_track_snapshot_interval_in_secs  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SEGMENT_SEGMENT_NODE_STORE_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repository.home", repository_home));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tarmk.mode", tarmk_mode));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tarmk.size", tarmk_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "segmentCache.size", segment_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "stringCache.size", string_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "templateCache.size", template_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "stringDeduplicationCache.size", string_deduplication_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "templateDeduplicationCache.size", template_deduplication_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "nodeDeduplicationCache.size", node_deduplication_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pauseCompaction", pause_compaction));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.retryCount", compaction_retry_count));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.force.timeout", compaction_force_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.sizeDeltaEstimation", compaction_size_delta_estimation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.disableEstimation", compaction_disable_estimation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.retainedGenerations", compaction_retained_generations));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.memoryThreshold", compaction_memory_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compaction.progressLog", compaction_progress_log));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "standby", standby));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "customBlobStore", custom_blob_store));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "customSegmentStore", custom_segment_store));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "splitPersistence", split_persistence));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "repository.backup.dir", repository_backup_dir));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "blobGcMaxAgeInSecs", blob_gc_max_age_in_secs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "blobTrackSnapshotIntervalInSecs", blob_track_snapshot_interval_in_secs));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SEGMENT_SEGMENT_NODE_STORE_SERVICE_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SEGMENT_SEGMENT_NODE_STORE_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_segment_standby_store_standby_store_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; org_apache_sling_installer_configuration_persist: BOOLEAN; mode: STRING_32; port: INTEGER_32; primary_host: STRING_32; interval: INTEGER_32; primary_allowed_client_ip_ranges: detachable LIST [STRING_32]; secure: BOOLEAN; standby_readtimeout: INTEGER_32; standby_autoclean: BOOLEAN): detachable ORG_APACHE_JACKRABBIT_OAK_SEGMENT_STANDBY_STORE_STANDBY_STORE_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: org_apache_sling_installer_configuration_persist  (optional)
			-- 
			-- argument: mode  (optional)
			-- 
			-- argument: port  (optional)
			-- 
			-- argument: primary_host  (optional)
			-- 
			-- argument: interval  (optional)
			-- 
			-- argument: primary_allowed_client_ip_ranges  (optional)
			-- 
			-- argument: secure  (optional)
			-- 
			-- argument: standby_readtimeout  (optional)
			-- 
			-- argument: standby_autoclean  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SEGMENT_STANDBY_STORE_STANDBY_STORE_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.segment.standby.store.StandbyStoreService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.installer.configuration.persist", org_apache_sling_installer_configuration_persist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "mode", mode));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "port", port));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "primary.host", primary_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "interval", interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "primary.allowed-client-ip-ranges", primary_allowed_client_ip_ranges));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "secure", secure));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "standby.readtimeout", standby_readtimeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "standby.autoclean", standby_autoclean));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SEGMENT_STANDBY_STORE_STANDBY_STORE_SERVICE_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SEGMENT_STANDBY_STORE_STANDBY_STORE_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_spi_security_authentication_external_impl_de (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; handler_name: STRING_32; user_expiration_time: STRING_32; user_auto_membership: detachable LIST [STRING_32]; user_property_mapping: detachable LIST [STRING_32]; user_path_prefix: STRING_32; user_membership_exp_time: STRING_32; user_membership_nesting_depth: INTEGER_32; user_dynamic_membership: BOOLEAN; user_disable_missing: BOOLEAN; group_expiration_time: STRING_32; group_auto_membership: detachable LIST [STRING_32]; group_property_mapping: detachable LIST [STRING_32]; group_path_prefix: STRING_32; enable_rf_c7613_usercase_mapped_profile: BOOLEAN): detachable ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHENTICATION_EXTERNAL_IMPL_DE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: handler_name  (optional)
			-- 
			-- argument: user_expiration_time  (optional)
			-- 
			-- argument: user_auto_membership  (optional)
			-- 
			-- argument: user_property_mapping  (optional)
			-- 
			-- argument: user_path_prefix  (optional)
			-- 
			-- argument: user_membership_exp_time  (optional)
			-- 
			-- argument: user_membership_nesting_depth  (optional)
			-- 
			-- argument: user_dynamic_membership  (optional)
			-- 
			-- argument: user_disable_missing  (optional)
			-- 
			-- argument: group_expiration_time  (optional)
			-- 
			-- argument: group_auto_membership  (optional)
			-- 
			-- argument: group_property_mapping  (optional)
			-- 
			-- argument: group_path_prefix  (optional)
			-- 
			-- argument: enable_rf_c7613_usercase_mapped_profile  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHENTICATION_EXTERNAL_IMPL_DE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.DefaultSyncHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "handler.name", handler_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user.expirationTime", user_expiration_time));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "user.autoMembership", user_auto_membership));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "user.propertyMapping", user_property_mapping));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user.pathPrefix", user_path_prefix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user.membershipExpTime", user_membership_exp_time));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user.membershipNestingDepth", user_membership_nesting_depth));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user.dynamicMembership", user_dynamic_membership));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user.disableMissing", user_disable_missing));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "group.expirationTime", group_expiration_time));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "group.autoMembership", group_auto_membership));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "group.propertyMapping", group_property_mapping));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "group.pathPrefix", group_path_prefix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableRFC7613UsercaseMappedProfile", enable_rf_c7613_usercase_mapped_profile));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHENTICATION_EXTERNAL_IMPL_DE_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHENTICATION_EXTERNAL_IMPL_DE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_spi_security_authentication_external_impl_ex (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; jaas_ranking: INTEGER_32; jaas_control_flag: STRING_32; jaas_realm_name: STRING_32; idp_name: STRING_32; sync_handler_name: STRING_32): detachable ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHENTICATION_EXTERNAL_IMPL_EX_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: jaas_ranking  (optional)
			-- 
			-- argument: jaas_control_flag  (optional)
			-- 
			-- argument: jaas_realm_name  (optional)
			-- 
			-- argument: idp_name  (optional)
			-- 
			-- argument: sync_handler_name  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHENTICATION_EXTERNAL_IMPL_EX_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.ExternalLoginModuleFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.ranking", jaas_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.controlFlag", jaas_control_flag));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jaas.realmName", jaas_realm_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "idp.name", idp_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sync.handlerName", sync_handler_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHENTICATION_EXTERNAL_IMPL_EX_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHENTICATION_EXTERNAL_IMPL_EX_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_spi_security_authentication_external_impl_pr (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; protect_external_id: BOOLEAN): detachable ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHENTICATION_EXTERNAL_IMPL_PR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: protect_external_id  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHENTICATION_EXTERNAL_IMPL_PR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.principal.ExternalPrincipalConfiguration"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "protectExternalId", protect_external_id));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHENTICATION_EXTERNAL_IMPL_PR_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHENTICATION_EXTERNAL_IMPL_PR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_spi_security_authorization_cug_impl_cug_confi (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; cug_supported_paths: detachable LIST [STRING_32]; cug_enabled: BOOLEAN; configuration_ranking: INTEGER_32): detachable ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHORIZATION_CUG_IMPL_CUG_CONFI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: cug_supported_paths  (optional)
			-- 
			-- argument: cug_enabled  (optional)
			-- 
			-- argument: configuration_ranking  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHORIZATION_CUG_IMPL_CUG_CONFI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authorization.cug.impl.CugConfiguration"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "cugSupportedPaths", cug_supported_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cugEnabled", cug_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "configurationRanking", configuration_ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHORIZATION_CUG_IMPL_CUG_CONFI_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHORIZATION_CUG_IMPL_CUG_CONFI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_spi_security_authorization_cug_impl_cug_exclu (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; principal_names: detachable LIST [STRING_32]): detachable ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHORIZATION_CUG_IMPL_CUG_EXCLU_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: principal_names  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHORIZATION_CUG_IMPL_CUG_EXCLU_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authorization.cug.impl.CugExcludeImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "principalNames", principal_names));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHORIZATION_CUG_IMPL_CUG_EXCLU_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_AUTHORIZATION_CUG_IMPL_CUG_EXCLU_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_oak_spi_security_user_action_default_authorizable (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled_actions: STRING_32; user_privilege_names: detachable LIST [STRING_32]; group_privilege_names: detachable LIST [STRING_32]; constraint: STRING_32): detachable ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_USER_ACTION_DEFAULT_AUTHORIZABLE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled_actions  (optional)
			-- 
			-- argument: user_privilege_names  (optional)
			-- 
			-- argument: group_privilege_names  (optional)
			-- 
			-- argument: constraint  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_USER_ACTION_DEFAULT_AUTHORIZABLE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.user.action.DefaultAuthorizableActionProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabledActions", enabled_actions));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "userPrivilegeNames", user_privilege_names));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "groupPrivilegeNames", group_privilege_names));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "constraint", constraint));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_USER_ACTION_DEFAULT_AUTHORIZABLE_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_OAK_SPI_SECURITY_USER_ACTION_DEFAULT_AUTHORIZABLE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_vault_packaging_impl_packaging_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; package_roots: detachable LIST [STRING_32]): detachable ORG_APACHE_JACKRABBIT_VAULT_PACKAGING_IMPL_PACKAGING_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: package_roots  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_VAULT_PACKAGING_IMPL_PACKAGING_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.vault.packaging.impl.PackagingImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "packageRoots", package_roots));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_VAULT_PACKAGING_IMPL_PACKAGING_IMPL_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_VAULT_PACKAGING_IMPL_PACKAGING_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_jackrabbit_vault_packaging_registry_impl_fs_package_registry (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; home_path: STRING_32): detachable ORG_APACHE_JACKRABBIT_VAULT_PACKAGING_REGISTRY_IMPL_FS_PACKAGE_REGISTRY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: home_path  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_JACKRABBIT_VAULT_PACKAGING_REGISTRY_IMPL_FS_PACKAGE_REGISTRY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.jackrabbit.vault.packaging.registry.impl.FSPackageRegistry"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "homePath", home_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_JACKRABBIT_VAULT_PACKAGING_REGISTRY_IMPL_FS_PACKAGE_REGISTRY_INFO } l_response.data ({ ORG_APACHE_JACKRABBIT_VAULT_PACKAGING_REGISTRY_IMPL_FS_PACKAGE_REGISTRY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_auth_core_impl_logout_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_methods: detachable LIST [STRING_32]; sling_servlet_paths: STRING_32): detachable ORG_APACHE_SLING_AUTH_CORE_IMPL_LOGOUT_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_methods  (optional)
			-- 
			-- argument: sling_servlet_paths  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_AUTH_CORE_IMPL_LOGOUT_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.auth.core.impl.LogoutServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.servlet.methods", sling_servlet_methods));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.servlet.paths", sling_servlet_paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_AUTH_CORE_IMPL_LOGOUT_SERVLET_INFO } l_response.data ({ ORG_APACHE_SLING_AUTH_CORE_IMPL_LOGOUT_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_caconfig_impl_configuration_bindings_value_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN): detachable ORG_APACHE_SLING_CACONFIG_IMPL_CONFIGURATION_BINDINGS_VALUE_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_CACONFIG_IMPL_CONFIGURATION_BINDINGS_VALUE_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.caconfig.impl.ConfigurationBindingsValueProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_CACONFIG_IMPL_CONFIGURATION_BINDINGS_VALUE_PROVIDER_INFO } l_response.data ({ ORG_APACHE_SLING_CACONFIG_IMPL_CONFIGURATION_BINDINGS_VALUE_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_caconfig_impl_configuration_resolver_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; config_bucket_names: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_CACONFIG_IMPL_CONFIGURATION_RESOLVER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: config_bucket_names  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_CACONFIG_IMPL_CONFIGURATION_RESOLVER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.caconfig.impl.ConfigurationResolverImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "configBucketNames", config_bucket_names));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_CACONFIG_IMPL_CONFIGURATION_RESOLVER_IMPL_INFO } l_response.data ({ ORG_APACHE_SLING_CACONFIG_IMPL_CONFIGURATION_RESOLVER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_caconfig_impl_def_default_configuration_inheritance_stra (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN; config_property_inheritance_property_names: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_CACONFIG_IMPL_DEF_DEFAULT_CONFIGURATION_INHERITANCE_STRA_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: config_property_inheritance_property_names  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_CACONFIG_IMPL_DEF_DEFAULT_CONFIGURATION_INHERITANCE_STRA_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.caconfig.impl.def.DefaultConfigurationInheritanceStrategy"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "configPropertyInheritancePropertyNames", config_property_inheritance_property_names));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_CACONFIG_IMPL_DEF_DEFAULT_CONFIGURATION_INHERITANCE_STRA_INFO } l_response.data ({ ORG_APACHE_SLING_CACONFIG_IMPL_DEF_DEFAULT_CONFIGURATION_INHERITANCE_STRA_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_caconfig_impl_def_default_configuration_persistence_stra (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN): detachable ORG_APACHE_SLING_CACONFIG_IMPL_DEF_DEFAULT_CONFIGURATION_PERSISTENCE_STRA_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_CACONFIG_IMPL_DEF_DEFAULT_CONFIGURATION_PERSISTENCE_STRA_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.caconfig.impl.def.DefaultConfigurationPersistenceStrategy"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_CACONFIG_IMPL_DEF_DEFAULT_CONFIGURATION_PERSISTENCE_STRA_INFO } l_response.data ({ ORG_APACHE_SLING_CACONFIG_IMPL_DEF_DEFAULT_CONFIGURATION_PERSISTENCE_STRA_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_caconfig_impl_override_osgi_configuration_override_provi (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; description: STRING_32; overrides: detachable LIST [STRING_32]; enabled: BOOLEAN; service_ranking: INTEGER_32): detachable ORG_APACHE_SLING_CACONFIG_IMPL_OVERRIDE_OSGI_CONFIGURATION_OVERRIDE_PROVI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: description  (optional)
			-- 
			-- argument: overrides  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_CACONFIG_IMPL_OVERRIDE_OSGI_CONFIGURATION_OVERRIDE_PROVI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.caconfig.impl.override.OsgiConfigurationOverrideProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "description", description));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "overrides", overrides));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_CACONFIG_IMPL_OVERRIDE_OSGI_CONFIGURATION_OVERRIDE_PROVI_INFO } l_response.data ({ ORG_APACHE_SLING_CACONFIG_IMPL_OVERRIDE_OSGI_CONFIGURATION_OVERRIDE_PROVI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_caconfig_impl_override_system_property_configuration_ove (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN; service_ranking: INTEGER_32): detachable ORG_APACHE_SLING_CACONFIG_IMPL_OVERRIDE_SYSTEM_PROPERTY_CONFIGURATION_OVE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_CACONFIG_IMPL_OVERRIDE_SYSTEM_PROPERTY_CONFIGURATION_OVE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.caconfig.impl.override.SystemPropertyConfigurationOverrideProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_CACONFIG_IMPL_OVERRIDE_SYSTEM_PROPERTY_CONFIGURATION_OVE_INFO } l_response.data ({ ORG_APACHE_SLING_CACONFIG_IMPL_OVERRIDE_SYSTEM_PROPERTY_CONFIGURATION_OVE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_caconfig_management_impl_configuration_management_setti (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; ignore_property_name_regex: detachable LIST [STRING_32]; config_collection_properties_resource_names: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_CACONFIG_MANAGEMENT_IMPL_CONFIGURATION_MANAGEMENT_SETTI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: ignore_property_name_regex  (optional)
			-- 
			-- argument: config_collection_properties_resource_names  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_CACONFIG_MANAGEMENT_IMPL_CONFIGURATION_MANAGEMENT_SETTI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.caconfig.management.impl.ConfigurationManagementSettingsImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "ignorePropertyNameRegex", ignore_property_name_regex));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "configCollectionPropertiesResourceNames", config_collection_properties_resource_names));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_CACONFIG_MANAGEMENT_IMPL_CONFIGURATION_MANAGEMENT_SETTI_INFO } l_response.data ({ ORG_APACHE_SLING_CACONFIG_MANAGEMENT_IMPL_CONFIGURATION_MANAGEMENT_SETTI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_caconfig_resource_impl_def_default_configuration_resour (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN; config_path: STRING_32; fallback_paths: detachable LIST [STRING_32]; config_collection_inheritance_property_names: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_CACONFIG_RESOURCE_IMPL_DEF_DEFAULT_CONFIGURATION_RESOUR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: config_path  (optional)
			-- 
			-- argument: fallback_paths  (optional)
			-- 
			-- argument: config_collection_inheritance_property_names  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_CACONFIG_RESOURCE_IMPL_DEF_DEFAULT_CONFIGURATION_RESOUR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.caconfig.resource.impl.def.DefaultConfigurationResourceResolvingStrategy"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "configPath", config_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "fallbackPaths", fallback_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "configCollectionInheritancePropertyNames", config_collection_inheritance_property_names));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_CACONFIG_RESOURCE_IMPL_DEF_DEFAULT_CONFIGURATION_RESOUR_INFO } l_response.data ({ ORG_APACHE_SLING_CACONFIG_RESOURCE_IMPL_DEF_DEFAULT_CONFIGURATION_RESOUR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_caconfig_resource_impl_def_default_context_path_strategy (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; enabled: BOOLEAN; config_ref_resource_names: detachable LIST [STRING_32]; config_ref_property_names: detachable LIST [STRING_32]; service_ranking: INTEGER_32): detachable ORG_APACHE_SLING_CACONFIG_RESOURCE_IMPL_DEF_DEFAULT_CONTEXT_PATH_STRATEGY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: config_ref_resource_names  (optional)
			-- 
			-- argument: config_ref_property_names  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_CACONFIG_RESOURCE_IMPL_DEF_DEFAULT_CONTEXT_PATH_STRATEGY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.caconfig.resource.impl.def.DefaultContextPathStrategy"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "configRefResourceNames", config_ref_resource_names));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "configRefPropertyNames", config_ref_property_names));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_CACONFIG_RESOURCE_IMPL_DEF_DEFAULT_CONTEXT_PATH_STRATEGY_INFO } l_response.data ({ ORG_APACHE_SLING_CACONFIG_RESOURCE_IMPL_DEF_DEFAULT_CONTEXT_PATH_STRATEGY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_commons_html_internal_tagsoup_html_parser (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; parser_features: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_COMMONS_HTML_INTERNAL_TAGSOUP_HTML_PARSER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: parser_features  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_COMMONS_HTML_INTERNAL_TAGSOUP_HTML_PARSER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.commons.html.internal.TagsoupHtmlParser"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "parser.features", parser_features));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_COMMONS_HTML_INTERNAL_TAGSOUP_HTML_PARSER_INFO } l_response.data ({ ORG_APACHE_SLING_COMMONS_HTML_INTERNAL_TAGSOUP_HTML_PARSER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_commons_log_log_manager (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; org_apache_sling_commons_log_level: STRING_32; org_apache_sling_commons_log_file: STRING_32; org_apache_sling_commons_log_file_number: INTEGER_32; org_apache_sling_commons_log_file_size: STRING_32; org_apache_sling_commons_log_pattern: STRING_32; org_apache_sling_commons_log_configuration_file: STRING_32; org_apache_sling_commons_log_packaging_data_enabled: BOOLEAN; org_apache_sling_commons_log_max_caller_data_depth: INTEGER_32; org_apache_sling_commons_log_max_old_file_count_in_dump: INTEGER_32; org_apache_sling_commons_log_num_of_lines: INTEGER_32): detachable ORG_APACHE_SLING_COMMONS_LOG_LOG_MANAGER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_level  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_file  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_file_number  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_file_size  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_pattern  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_configuration_file  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_packaging_data_enabled  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_max_caller_data_depth  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_max_old_file_count_in_dump  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_num_of_lines  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_COMMONS_LOG_LOG_MANAGER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.commons.log.LogManager"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.level", org_apache_sling_commons_log_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.file", org_apache_sling_commons_log_file));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.file.number", org_apache_sling_commons_log_file_number));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.file.size", org_apache_sling_commons_log_file_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.pattern", org_apache_sling_commons_log_pattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.configurationFile", org_apache_sling_commons_log_configuration_file));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.packagingDataEnabled", org_apache_sling_commons_log_packaging_data_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.maxCallerDataDepth", org_apache_sling_commons_log_max_caller_data_depth));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.maxOldFileCountInDump", org_apache_sling_commons_log_max_old_file_count_in_dump));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.numOfLines", org_apache_sling_commons_log_num_of_lines));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_COMMONS_LOG_LOG_MANAGER_INFO } l_response.data ({ ORG_APACHE_SLING_COMMONS_LOG_LOG_MANAGER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_commons_log_log_manager_factory_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; org_apache_sling_commons_log_level: STRING_32; org_apache_sling_commons_log_file: STRING_32; org_apache_sling_commons_log_pattern: STRING_32; org_apache_sling_commons_log_names: detachable LIST [STRING_32]; org_apache_sling_commons_log_additiv: BOOLEAN): detachable ORG_APACHE_SLING_COMMONS_LOG_LOG_MANAGER_FACTORY_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_level  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_file  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_pattern  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_names  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_additiv  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_COMMONS_LOG_LOG_MANAGER_FACTORY_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.commons.log.LogManager.factory.config"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.level", org_apache_sling_commons_log_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.file", org_apache_sling_commons_log_file));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.pattern", org_apache_sling_commons_log_pattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.sling.commons.log.names", org_apache_sling_commons_log_names));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.additiv", org_apache_sling_commons_log_additiv));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_COMMONS_LOG_LOG_MANAGER_FACTORY_CONFIG_INFO } l_response.data ({ ORG_APACHE_SLING_COMMONS_LOG_LOG_MANAGER_FACTORY_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_commons_log_log_manager_factory_writer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; org_apache_sling_commons_log_file: STRING_32; org_apache_sling_commons_log_file_number: INTEGER_32; org_apache_sling_commons_log_file_size: STRING_32; org_apache_sling_commons_log_file_buffered: BOOLEAN): detachable ORG_APACHE_SLING_COMMONS_LOG_LOG_MANAGER_FACTORY_WRITER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_file  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_file_number  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_file_size  (optional)
			-- 
			-- argument: org_apache_sling_commons_log_file_buffered  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_COMMONS_LOG_LOG_MANAGER_FACTORY_WRITER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.commons.log.LogManager.factory.writer"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.file", org_apache_sling_commons_log_file));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.file.number", org_apache_sling_commons_log_file_number));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.file.size", org_apache_sling_commons_log_file_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.commons.log.file.buffered", org_apache_sling_commons_log_file_buffered));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_COMMONS_LOG_LOG_MANAGER_FACTORY_WRITER_INFO } l_response.data ({ ORG_APACHE_SLING_COMMONS_LOG_LOG_MANAGER_FACTORY_WRITER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_commons_metrics_internal_log_reporter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; period: INTEGER_32; time_unit: STRING_32; level: STRING_32; logger_name: STRING_32; prefix: STRING_32; pattern: STRING_32; registry_name: STRING_32): detachable ORG_APACHE_SLING_COMMONS_METRICS_INTERNAL_LOG_REPORTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: period  (optional)
			-- 
			-- argument: time_unit  (optional)
			-- 
			-- argument: level  (optional)
			-- 
			-- argument: logger_name  (optional)
			-- 
			-- argument: prefix  (optional)
			-- 
			-- argument: pattern  (optional)
			-- 
			-- argument: registry_name  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_COMMONS_METRICS_INTERNAL_LOG_REPORTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.commons.metrics.internal.LogReporter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "period", period));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "timeUnit", time_unit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "level", level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "loggerName", logger_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "prefix", prefix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pattern", pattern));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "registryName", registry_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_COMMONS_METRICS_INTERNAL_LOG_REPORTER_INFO } l_response.data ({ ORG_APACHE_SLING_COMMONS_METRICS_INTERNAL_LOG_REPORTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_commons_metrics_rrd4j_impl_codahale_metrics_reporter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; datasources: detachable LIST [STRING_32]; step: INTEGER_32; archives: detachable LIST [STRING_32]; path: STRING_32): detachable ORG_APACHE_SLING_COMMONS_METRICS_RRD4J_IMPL_CODAHALE_METRICS_REPORTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: datasources  (optional)
			-- 
			-- argument: step  (optional)
			-- 
			-- argument: archives  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_COMMONS_METRICS_RRD4J_IMPL_CODAHALE_METRICS_REPORTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.commons.metrics.rrd4j.impl.CodahaleMetricsReporter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "datasources", datasources));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "step", step));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "archives", archives));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_COMMONS_METRICS_RRD4J_IMPL_CODAHALE_METRICS_REPORTER_INFO } l_response.data ({ ORG_APACHE_SLING_COMMONS_METRICS_RRD4J_IMPL_CODAHALE_METRICS_REPORTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_commons_mime_internal_mime_type_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; mime_types: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_COMMONS_MIME_INTERNAL_MIME_TYPE_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: mime_types  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_COMMONS_MIME_INTERNAL_MIME_TYPE_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.commons.mime.internal.MimeTypeServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "mime.types", mime_types));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_COMMONS_MIME_INTERNAL_MIME_TYPE_SERVICE_IMPL_INFO } l_response.data ({ ORG_APACHE_SLING_COMMONS_MIME_INTERNAL_MIME_TYPE_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_commons_scheduler_impl_quartz_scheduler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; pool_name: STRING_32; allowed_pool_names: detachable LIST [STRING_32]; scheduler_useleaderforsingle: BOOLEAN; metrics_filters: detachable LIST [STRING_32]; slow_threshold_millis: INTEGER_32): detachable ORG_APACHE_SLING_COMMONS_SCHEDULER_IMPL_QUARTZ_SCHEDULER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: pool_name  (optional)
			-- 
			-- argument: allowed_pool_names  (optional)
			-- 
			-- argument: scheduler_useleaderforsingle  (optional)
			-- 
			-- argument: metrics_filters  (optional)
			-- 
			-- argument: slow_threshold_millis  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_COMMONS_SCHEDULER_IMPL_QUARTZ_SCHEDULER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.commons.scheduler.impl.QuartzScheduler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "poolName", pool_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "allowedPoolNames", allowed_pool_names));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.useleaderforsingle", scheduler_useleaderforsingle));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "metrics.filters", metrics_filters));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "slowThresholdMillis", slow_threshold_millis));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_COMMONS_SCHEDULER_IMPL_QUARTZ_SCHEDULER_INFO } l_response.data ({ ORG_APACHE_SLING_COMMONS_SCHEDULER_IMPL_QUARTZ_SCHEDULER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_commons_scheduler_impl_scheduler_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_quartz_job_duration_acceptable: INTEGER_32): detachable ORG_APACHE_SLING_COMMONS_SCHEDULER_IMPL_SCHEDULER_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_quartz_job_duration_acceptable  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_COMMONS_SCHEDULER_IMPL_SCHEDULER_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.commons.scheduler.impl.SchedulerHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "max.quartzJob.duration.acceptable", max_quartz_job_duration_acceptable));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_COMMONS_SCHEDULER_IMPL_SCHEDULER_HEALTH_CHECK_INFO } l_response.data ({ ORG_APACHE_SLING_COMMONS_SCHEDULER_IMPL_SCHEDULER_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_commons_threads_impl_default_thread_pool_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; min_pool_size: INTEGER_32; max_pool_size: INTEGER_32; queue_size: INTEGER_32; max_thread_age: INTEGER_32; keep_alive_time: INTEGER_32; block_policy: STRING_32; shutdown_graceful: BOOLEAN; daemon: BOOLEAN; shutdown_wait_time: INTEGER_32; priority: STRING_32): detachable ORG_APACHE_SLING_COMMONS_THREADS_IMPL_DEFAULT_THREAD_POOL_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: min_pool_size  (optional)
			-- 
			-- argument: max_pool_size  (optional)
			-- 
			-- argument: queue_size  (optional)
			-- 
			-- argument: max_thread_age  (optional)
			-- 
			-- argument: keep_alive_time  (optional)
			-- 
			-- argument: block_policy  (optional)
			-- 
			-- argument: shutdown_graceful  (optional)
			-- 
			-- argument: daemon  (optional)
			-- 
			-- argument: shutdown_wait_time  (optional)
			-- 
			-- argument: priority  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_COMMONS_THREADS_IMPL_DEFAULT_THREAD_POOL_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.commons.threads.impl.DefaultThreadPool.factory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "minPoolSize", min_pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxPoolSize", max_pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queueSize", queue_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxThreadAge", max_thread_age));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "keepAliveTime", keep_alive_time));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "blockPolicy", block_policy));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "shutdownGraceful", shutdown_graceful));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "daemon", daemon));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "shutdownWaitTime", shutdown_wait_time));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "priority", priority));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_COMMONS_THREADS_IMPL_DEFAULT_THREAD_POOL_FACTORY_INFO } l_response.data ({ ORG_APACHE_SLING_COMMONS_THREADS_IMPL_DEFAULT_THREAD_POOL_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_datasource_data_source_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; datasource_name: STRING_32; datasource_svc_prop_name: STRING_32; driver_class_name: STRING_32; url: STRING_32; username: STRING_32; password: STRING_32; default_auto_commit: STRING_32; default_read_only: STRING_32; default_transaction_isolation: STRING_32; default_catalog: STRING_32; max_active: INTEGER_32; max_idle: INTEGER_32; min_idle: INTEGER_32; initial_size: INTEGER_32; max_wait: INTEGER_32; max_age: INTEGER_32; test_on_borrow: BOOLEAN; test_on_return: BOOLEAN; test_while_idle: BOOLEAN; validation_query: STRING_32; validation_query_timeout: INTEGER_32; time_between_eviction_runs_millis: INTEGER_32; min_evictable_idle_time_millis: INTEGER_32; connection_properties: STRING_32; init_sq_l: STRING_32; jdbc_interceptors: STRING_32; validation_interval: INTEGER_32; log_validation_errors: BOOLEAN; datasource_svc_properties: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_DATASOURCE_DATA_SOURCE_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: datasource_name  (optional)
			-- 
			-- argument: datasource_svc_prop_name  (optional)
			-- 
			-- argument: driver_class_name  (optional)
			-- 
			-- argument: url  (optional)
			-- 
			-- argument: username  (optional)
			-- 
			-- argument: password  (optional)
			-- 
			-- argument: default_auto_commit  (optional)
			-- 
			-- argument: default_read_only  (optional)
			-- 
			-- argument: default_transaction_isolation  (optional)
			-- 
			-- argument: default_catalog  (optional)
			-- 
			-- argument: max_active  (optional)
			-- 
			-- argument: max_idle  (optional)
			-- 
			-- argument: min_idle  (optional)
			-- 
			-- argument: initial_size  (optional)
			-- 
			-- argument: max_wait  (optional)
			-- 
			-- argument: max_age  (optional)
			-- 
			-- argument: test_on_borrow  (optional)
			-- 
			-- argument: test_on_return  (optional)
			-- 
			-- argument: test_while_idle  (optional)
			-- 
			-- argument: validation_query  (optional)
			-- 
			-- argument: validation_query_timeout  (optional)
			-- 
			-- argument: time_between_eviction_runs_millis  (optional)
			-- 
			-- argument: min_evictable_idle_time_millis  (optional)
			-- 
			-- argument: connection_properties  (optional)
			-- 
			-- argument: init_sq_l  (optional)
			-- 
			-- argument: jdbc_interceptors  (optional)
			-- 
			-- argument: validation_interval  (optional)
			-- 
			-- argument: log_validation_errors  (optional)
			-- 
			-- argument: datasource_svc_properties  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DATASOURCE_DATA_SOURCE_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.datasource.DataSourceFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "datasource.name", datasource_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "datasource.svc.prop.name", datasource_svc_prop_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "driverClassName", driver_class_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "url", url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "username", username));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "password", password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultAutoCommit", default_auto_commit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultReadOnly", default_read_only));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultTransactionIsolation", default_transaction_isolation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultCatalog", default_catalog));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxActive", max_active));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxIdle", max_idle));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "minIdle", min_idle));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "initialSize", initial_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxWait", max_wait));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxAge", max_age));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "testOnBorrow", test_on_borrow));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "testOnReturn", test_on_return));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "testWhileIdle", test_while_idle));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "validationQuery", validation_query));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "validationQueryTimeout", validation_query_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "timeBetweenEvictionRunsMillis", time_between_eviction_runs_millis));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "minEvictableIdleTimeMillis", min_evictable_idle_time_millis));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connectionProperties", connection_properties));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "initSQL", init_sq_l));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jdbcInterceptors", jdbc_interceptors));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "validationInterval", validation_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "logValidationErrors", log_validation_errors));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "datasource.svc.properties", datasource_svc_properties));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DATASOURCE_DATA_SOURCE_FACTORY_INFO } l_response.data ({ ORG_APACHE_SLING_DATASOURCE_DATA_SOURCE_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_datasource_jn_di_data_source_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; datasource_name: STRING_32; datasource_svc_prop_name: STRING_32; datasource_jndi_name: STRING_32; jndi_properties: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_DATASOURCE_JNDI_DATA_SOURCE_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: datasource_name  (optional)
			-- 
			-- argument: datasource_svc_prop_name  (optional)
			-- 
			-- argument: datasource_jndi_name  (optional)
			-- 
			-- argument: jndi_properties  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DATASOURCE_JNDI_DATA_SOURCE_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.datasource.JNDIDataSourceFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "datasource.name", datasource_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "datasource.svc.prop.name", datasource_svc_prop_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "datasource.jndi.name", datasource_jndi_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "jndi.properties", jndi_properties));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DATASOURCE_JNDI_DATA_SOURCE_FACTORY_INFO } l_response.data ({ ORG_APACHE_SLING_DATASOURCE_JNDI_DATA_SOURCE_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_discovery_oak_config (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; connector_ping_timeout: INTEGER_32; connector_ping_interval: INTEGER_32; discovery_lite_check_interval: INTEGER_32; cluster_sync_service_timeout: INTEGER_32; cluster_sync_service_interval: INTEGER_32; enable_sync_token: BOOLEAN; min_event_delay: INTEGER_32; socket_connect_timeout: INTEGER_32; so_timeout: INTEGER_32; topology_connector_urls: detachable LIST [STRING_32]; topology_connector_whitelist: detachable LIST [STRING_32]; auto_stop_local_loop_enabled: BOOLEAN; gzip_connector_requests_enabled: BOOLEAN; hmac_enabled: BOOLEAN; enable_encryption: BOOLEAN; shared_key: STRING_32; hmac_shared_key_tt_l: INTEGER_32; backoff_standby_factor: STRING_32; backoff_stable_factor: STRING_32): detachable ORG_APACHE_SLING_DISCOVERY_OAK_CONFIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: connector_ping_timeout  (optional)
			-- 
			-- argument: connector_ping_interval  (optional)
			-- 
			-- argument: discovery_lite_check_interval  (optional)
			-- 
			-- argument: cluster_sync_service_timeout  (optional)
			-- 
			-- argument: cluster_sync_service_interval  (optional)
			-- 
			-- argument: enable_sync_token  (optional)
			-- 
			-- argument: min_event_delay  (optional)
			-- 
			-- argument: socket_connect_timeout  (optional)
			-- 
			-- argument: so_timeout  (optional)
			-- 
			-- argument: topology_connector_urls  (optional)
			-- 
			-- argument: topology_connector_whitelist  (optional)
			-- 
			-- argument: auto_stop_local_loop_enabled  (optional)
			-- 
			-- argument: gzip_connector_requests_enabled  (optional)
			-- 
			-- argument: hmac_enabled  (optional)
			-- 
			-- argument: enable_encryption  (optional)
			-- 
			-- argument: shared_key  (optional)
			-- 
			-- argument: hmac_shared_key_tt_l  (optional)
			-- 
			-- argument: backoff_standby_factor  (optional)
			-- 
			-- argument: backoff_stable_factor  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISCOVERY_OAK_CONFIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.discovery.oak.Config"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connectorPingTimeout", connector_ping_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "connectorPingInterval", connector_ping_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "discoveryLiteCheckInterval", discovery_lite_check_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "clusterSyncServiceTimeout", cluster_sync_service_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "clusterSyncServiceInterval", cluster_sync_service_interval));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableSyncToken", enable_sync_token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "minEventDelay", min_event_delay));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "socketConnectTimeout", socket_connect_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "soTimeout", so_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "topologyConnectorUrls", topology_connector_urls));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "topologyConnectorWhitelist", topology_connector_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "autoStopLocalLoopEnabled", auto_stop_local_loop_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "gzipConnectorRequestsEnabled", gzip_connector_requests_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hmacEnabled", hmac_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enableEncryption", enable_encryption));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sharedKey", shared_key));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hmacSharedKeyTTL", hmac_shared_key_tt_l));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "backoffStandbyFactor", backoff_standby_factor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "backoffStableFactor", backoff_stable_factor));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISCOVERY_OAK_CONFIG_INFO } l_response.data ({ ORG_APACHE_SLING_DISCOVERY_OAK_CONFIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_discovery_oak_synchronized_clocks_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_name: STRING_32; hc_tags: detachable LIST [STRING_32]; hc_mbean_name: STRING_32): detachable ORG_APACHE_SLING_DISCOVERY_OAK_SYNCHRONIZED_CLOCKS_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_name  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: hc_mbean_name  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISCOVERY_OAK_SYNCHRONIZED_CLOCKS_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.discovery.oak.SynchronizedClocksHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.name", hc_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.mbean.name", hc_mbean_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISCOVERY_OAK_SYNCHRONIZED_CLOCKS_HEALTH_CHECK_INFO } l_response.data ({ ORG_APACHE_SLING_DISCOVERY_OAK_SYNCHRONIZED_CLOCKS_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_agent_impl_forward_distribution_agent_facto (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; title: STRING_32; details: STRING_32; enabled: BOOLEAN; service_name: STRING_32; log_level: STRING_32; allowed_roots: detachable LIST [STRING_32]; queue_processing_enabled: BOOLEAN; package_importer_endpoints: detachable LIST [STRING_32]; passive_queues: detachable LIST [STRING_32]; priority_queues: detachable LIST [STRING_32]; retry_strategy: STRING_32; retry_attempts: INTEGER_32; request_authorization_strategy_target: STRING_32; transport_secret_provider_target: STRING_32; package_builder_target: STRING_32; triggers_target: STRING_32; queue_provider: STRING_32; async_delivery: BOOLEAN; http_conn_timeout: INTEGER_32): detachable ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_FORWARD_DISTRIBUTION_AGENT_FACTO_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: title  (optional)
			-- 
			-- argument: details  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- argument: log_level  (optional)
			-- 
			-- argument: allowed_roots  (optional)
			-- 
			-- argument: queue_processing_enabled  (optional)
			-- 
			-- argument: package_importer_endpoints  (optional)
			-- 
			-- argument: passive_queues  (optional)
			-- 
			-- argument: priority_queues  (optional)
			-- 
			-- argument: retry_strategy  (optional)
			-- 
			-- argument: retry_attempts  (optional)
			-- 
			-- argument: request_authorization_strategy_target  (optional)
			-- 
			-- argument: transport_secret_provider_target  (optional)
			-- 
			-- argument: package_builder_target  (optional)
			-- 
			-- argument: triggers_target  (optional)
			-- 
			-- argument: queue_provider  (optional)
			-- 
			-- argument: async_delivery  (optional)
			-- 
			-- argument: http_conn_timeout  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_FORWARD_DISTRIBUTION_AGENT_FACTO_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.agent.impl.ForwardDistributionAgentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "title", title));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "details", details));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceName", service_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "log.level", log_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "allowed.roots", allowed_roots));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.processing.enabled", queue_processing_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "packageImporter.endpoints", package_importer_endpoints));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "passiveQueues", passive_queues));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "priorityQueues", priority_queues));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "retry.strategy", retry_strategy));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "retry.attempts", retry_attempts));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "requestAuthorizationStrategy.target", request_authorization_strategy_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "transportSecretProvider.target", transport_secret_provider_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "packageBuilder.target", package_builder_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "triggers.target", triggers_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.provider", queue_provider));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "async.delivery", async_delivery));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "http.conn.timeout", http_conn_timeout));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_FORWARD_DISTRIBUTION_AGENT_FACTO_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_FORWARD_DISTRIBUTION_AGENT_FACTO_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_agent_impl_privilege_distribution_request_a (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; jcr_privilege: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_PRIVILEGE_DISTRIBUTION_REQUEST_A_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: jcr_privilege  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_PRIVILEGE_DISTRIBUTION_REQUEST_A_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.agent.impl.PrivilegeDistributionRequestAuthorizationStrategyFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcrPrivilege", jcr_privilege));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_PRIVILEGE_DISTRIBUTION_REQUEST_A_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_PRIVILEGE_DISTRIBUTION_REQUEST_A_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_agent_impl_queue_distribution_agent_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; title: STRING_32; details: STRING_32; enabled: BOOLEAN; service_name: STRING_32; log_level: STRING_32; allowed_roots: detachable LIST [STRING_32]; request_authorization_strategy_target: STRING_32; queue_provider_factory_target: STRING_32; package_builder_target: STRING_32; triggers_target: STRING_32; priority_queues: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_QUEUE_DISTRIBUTION_AGENT_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: title  (optional)
			-- 
			-- argument: details  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- argument: log_level  (optional)
			-- 
			-- argument: allowed_roots  (optional)
			-- 
			-- argument: request_authorization_strategy_target  (optional)
			-- 
			-- argument: queue_provider_factory_target  (optional)
			-- 
			-- argument: package_builder_target  (optional)
			-- 
			-- argument: triggers_target  (optional)
			-- 
			-- argument: priority_queues  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_QUEUE_DISTRIBUTION_AGENT_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.agent.impl.QueueDistributionAgentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "title", title));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "details", details));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceName", service_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "log.level", log_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "allowed.roots", allowed_roots));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "requestAuthorizationStrategy.target", request_authorization_strategy_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queueProviderFactory.target", queue_provider_factory_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "packageBuilder.target", package_builder_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "triggers.target", triggers_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "priorityQueues", priority_queues));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_QUEUE_DISTRIBUTION_AGENT_FACTORY_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_QUEUE_DISTRIBUTION_AGENT_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_agent_impl_reverse_distribution_agent_facto (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; title: STRING_32; details: STRING_32; enabled: BOOLEAN; service_name: STRING_32; log_level: STRING_32; queue_processing_enabled: BOOLEAN; package_exporter_endpoints: detachable LIST [STRING_32]; pull_items: INTEGER_32; http_conn_timeout: INTEGER_32; request_authorization_strategy_target: STRING_32; transport_secret_provider_target: STRING_32; package_builder_target: STRING_32; triggers_target: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_REVERSE_DISTRIBUTION_AGENT_FACTO_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: title  (optional)
			-- 
			-- argument: details  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- argument: log_level  (optional)
			-- 
			-- argument: queue_processing_enabled  (optional)
			-- 
			-- argument: package_exporter_endpoints  (optional)
			-- 
			-- argument: pull_items  (optional)
			-- 
			-- argument: http_conn_timeout  (optional)
			-- 
			-- argument: request_authorization_strategy_target  (optional)
			-- 
			-- argument: transport_secret_provider_target  (optional)
			-- 
			-- argument: package_builder_target  (optional)
			-- 
			-- argument: triggers_target  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_REVERSE_DISTRIBUTION_AGENT_FACTO_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.agent.impl.ReverseDistributionAgentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "title", title));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "details", details));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceName", service_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "log.level", log_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.processing.enabled", queue_processing_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "packageExporter.endpoints", package_exporter_endpoints));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pull.items", pull_items));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "http.conn.timeout", http_conn_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "requestAuthorizationStrategy.target", request_authorization_strategy_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "transportSecretProvider.target", transport_secret_provider_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "packageBuilder.target", package_builder_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "triggers.target", triggers_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_REVERSE_DISTRIBUTION_AGENT_FACTO_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_REVERSE_DISTRIBUTION_AGENT_FACTO_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_agent_impl_simple_distribution_agent_factor (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; title: STRING_32; details: STRING_32; enabled: BOOLEAN; service_name: STRING_32; log_level: STRING_32; queue_processing_enabled: BOOLEAN; package_exporter_target: STRING_32; package_importer_target: STRING_32; request_authorization_strategy_target: STRING_32; triggers_target: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_SIMPLE_DISTRIBUTION_AGENT_FACTOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: title  (optional)
			-- 
			-- argument: details  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- argument: log_level  (optional)
			-- 
			-- argument: queue_processing_enabled  (optional)
			-- 
			-- argument: package_exporter_target  (optional)
			-- 
			-- argument: package_importer_target  (optional)
			-- 
			-- argument: request_authorization_strategy_target  (optional)
			-- 
			-- argument: triggers_target  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_SIMPLE_DISTRIBUTION_AGENT_FACTOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.agent.impl.SimpleDistributionAgentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "title", title));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "details", details));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceName", service_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "log.level", log_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.processing.enabled", queue_processing_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "packageExporter.target", package_exporter_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "packageImporter.target", package_importer_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "requestAuthorizationStrategy.target", request_authorization_strategy_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "triggers.target", triggers_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_SIMPLE_DISTRIBUTION_AGENT_FACTOR_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_SIMPLE_DISTRIBUTION_AGENT_FACTOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_agent_impl_sync_distribution_agent_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; title: STRING_32; details: STRING_32; enabled: BOOLEAN; service_name: STRING_32; log_level: STRING_32; queue_processing_enabled: BOOLEAN; passive_queues: detachable LIST [STRING_32]; package_exporter_endpoints: detachable LIST [STRING_32]; package_importer_endpoints: detachable LIST [STRING_32]; retry_strategy: STRING_32; retry_attempts: INTEGER_32; pull_items: INTEGER_32; http_conn_timeout: INTEGER_32; request_authorization_strategy_target: STRING_32; transport_secret_provider_target: STRING_32; package_builder_target: STRING_32; triggers_target: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_SYNC_DISTRIBUTION_AGENT_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: title  (optional)
			-- 
			-- argument: details  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- argument: log_level  (optional)
			-- 
			-- argument: queue_processing_enabled  (optional)
			-- 
			-- argument: passive_queues  (optional)
			-- 
			-- argument: package_exporter_endpoints  (optional)
			-- 
			-- argument: package_importer_endpoints  (optional)
			-- 
			-- argument: retry_strategy  (optional)
			-- 
			-- argument: retry_attempts  (optional)
			-- 
			-- argument: pull_items  (optional)
			-- 
			-- argument: http_conn_timeout  (optional)
			-- 
			-- argument: request_authorization_strategy_target  (optional)
			-- 
			-- argument: transport_secret_provider_target  (optional)
			-- 
			-- argument: package_builder_target  (optional)
			-- 
			-- argument: triggers_target  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_SYNC_DISTRIBUTION_AGENT_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.agent.impl.SyncDistributionAgentFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "title", title));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "details", details));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceName", service_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "log.level", log_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.processing.enabled", queue_processing_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "passiveQueues", passive_queues));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "packageExporter.endpoints", package_exporter_endpoints));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "packageImporter.endpoints", package_importer_endpoints));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "retry.strategy", retry_strategy));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "retry.attempts", retry_attempts));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pull.items", pull_items));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "http.conn.timeout", http_conn_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "requestAuthorizationStrategy.target", request_authorization_strategy_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "transportSecretProvider.target", transport_secret_provider_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "packageBuilder.target", package_builder_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "triggers.target", triggers_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_SYNC_DISTRIBUTION_AGENT_FACTORY_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_AGENT_IMPL_SYNC_DISTRIBUTION_AGENT_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_monitor_distribution_queue_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_name: STRING_32; hc_tags: detachable LIST [STRING_32]; hc_mbean_name: STRING_32; number_of_retries_allowed: INTEGER_32): detachable ORG_APACHE_SLING_DISTRIBUTION_MONITOR_DISTRIBUTION_QUEUE_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_name  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: hc_mbean_name  (optional)
			-- 
			-- argument: number_of_retries_allowed  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_MONITOR_DISTRIBUTION_QUEUE_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.monitor.DistributionQueueHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.name", hc_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.mbean.name", hc_mbean_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "numberOfRetriesAllowed", number_of_retries_allowed));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_MONITOR_DISTRIBUTION_QUEUE_HEALTH_CHECK_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_MONITOR_DISTRIBUTION_QUEUE_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_packaging_impl_exporter_agent_distributio (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; queue: STRING_32; drop_invalid_items: BOOLEAN; agent_target: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_EXPORTER_AGENT_DISTRIBUTIO_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: queue  (optional)
			-- 
			-- argument: drop_invalid_items  (optional)
			-- 
			-- argument: agent_target  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_EXPORTER_AGENT_DISTRIBUTIO_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.AgentDistributionPackageExporterFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue", queue));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "drop.invalid.items", drop_invalid_items));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "agent.target", agent_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_EXPORTER_AGENT_DISTRIBUTIO_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_EXPORTER_AGENT_DISTRIBUTIO_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_packaging_impl_exporter_local_distributio (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; package_builder_target: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_EXPORTER_LOCAL_DISTRIBUTIO_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: package_builder_target  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_EXPORTER_LOCAL_DISTRIBUTIO_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.LocalDistributionPackageExporterFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "packageBuilder.target", package_builder_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_EXPORTER_LOCAL_DISTRIBUTIO_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_EXPORTER_LOCAL_DISTRIBUTIO_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_packaging_impl_exporter_remote_distributi (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; endpoints: detachable LIST [STRING_32]; pull_items: INTEGER_32; package_builder_target: STRING_32; transport_secret_provider_target: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_EXPORTER_REMOTE_DISTRIBUTI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: endpoints  (optional)
			-- 
			-- argument: pull_items  (optional)
			-- 
			-- argument: package_builder_target  (optional)
			-- 
			-- argument: transport_secret_provider_target  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_EXPORTER_REMOTE_DISTRIBUTI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.RemoteDistributionPackageExporterFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "endpoints", endpoints));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pull.items", pull_items));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "packageBuilder.target", package_builder_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "transportSecretProvider.target", transport_secret_provider_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_EXPORTER_REMOTE_DISTRIBUTI_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_EXPORTER_REMOTE_DISTRIBUTI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_packaging_impl_importer_local_distributio (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; package_builder_target: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_IMPORTER_LOCAL_DISTRIBUTIO_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: package_builder_target  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_IMPORTER_LOCAL_DISTRIBUTIO_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.LocalDistributionPackageImporterFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "packageBuilder.target", package_builder_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_IMPORTER_LOCAL_DISTRIBUTIO_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_IMPORTER_LOCAL_DISTRIBUTIO_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_packaging_impl_importer_remote_distributi (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; endpoints: detachable LIST [STRING_32]; transport_secret_provider_target: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_IMPORTER_REMOTE_DISTRIBUTI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: endpoints  (optional)
			-- 
			-- argument: transport_secret_provider_target  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_IMPORTER_REMOTE_DISTRIBUTI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.RemoteDistributionPackageImporterFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "endpoints", endpoints));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "transportSecretProvider.target", transport_secret_provider_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_IMPORTER_REMOTE_DISTRIBUTI_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_IMPORTER_REMOTE_DISTRIBUTI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_packaging_impl_importer_repository_distri (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; service_name: STRING_32; path: STRING_32; privilege_name: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_IMPORTER_REPOSITORY_DISTRI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: privilege_name  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_IMPORTER_REPOSITORY_DISTRI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.RepositoryDistributionPackageImporterFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.name", service_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "privilege.name", privilege_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_IMPORTER_REPOSITORY_DISTRI_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_PACKAGING_IMPL_IMPORTER_REPOSITORY_DISTRI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_resources_impl_distribution_configuration (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; provider_roots: STRING_32; kind: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_RESOURCES_IMPL_DISTRIBUTION_CONFIGURATION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: provider_roots  (optional)
			-- 
			-- argument: kind  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_RESOURCES_IMPL_DISTRIBUTION_CONFIGURATION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.resources.impl.DistributionConfigurationResourceProviderFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.roots", provider_roots));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "kind", kind));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_RESOURCES_IMPL_DISTRIBUTION_CONFIGURATION_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_RESOURCES_IMPL_DISTRIBUTION_CONFIGURATION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_resources_impl_distribution_service_resour (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; provider_roots: STRING_32; kind: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_RESOURCES_IMPL_DISTRIBUTION_SERVICE_RESOUR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: provider_roots  (optional)
			-- 
			-- argument: kind  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_RESOURCES_IMPL_DISTRIBUTION_SERVICE_RESOUR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.resources.impl.DistributionServiceResourceProviderFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.roots", provider_roots));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "kind", kind));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_RESOURCES_IMPL_DISTRIBUTION_SERVICE_RESOUR_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_RESOURCES_IMPL_DISTRIBUTION_SERVICE_RESOUR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_serialization_impl_distribution_package_bu (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; type: STRING_32; format_target: STRING_32; temp_fs_folder: STRING_32; file_threshold: INTEGER_32; memory_unit: STRING_32; use_off_heap_memory: BOOLEAN; digest_algorithm: STRING_32; monitoring_queue_size: INTEGER_32; cleanup_delay: INTEGER_32; package_filters: detachable LIST [STRING_32]; property_filters: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_DISTRIBUTION_SERIALIZATION_IMPL_DISTRIBUTION_PACKAGE_BU_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: type  (optional)
			-- 
			-- argument: format_target  (optional)
			-- 
			-- argument: temp_fs_folder  (optional)
			-- 
			-- argument: file_threshold  (optional)
			-- 
			-- argument: memory_unit  (optional)
			-- 
			-- argument: use_off_heap_memory  (optional)
			-- 
			-- argument: digest_algorithm  (optional)
			-- 
			-- argument: monitoring_queue_size  (optional)
			-- 
			-- argument: cleanup_delay  (optional)
			-- 
			-- argument: package_filters  (optional)
			-- 
			-- argument: property_filters  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_SERIALIZATION_IMPL_DISTRIBUTION_PACKAGE_BU_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.serialization.impl.DistributionPackageBuilderFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "type", type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "format.target", format_target));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tempFsFolder", temp_fs_folder));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "fileThreshold", file_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "memoryUnit", memory_unit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "useOffHeapMemory", use_off_heap_memory));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "digestAlgorithm", digest_algorithm));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "monitoringQueueSize", monitoring_queue_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cleanupDelay", cleanup_delay));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "package.filters", package_filters));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "property.filters", property_filters));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_SERIALIZATION_IMPL_DISTRIBUTION_PACKAGE_BU_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_SERIALIZATION_IMPL_DISTRIBUTION_PACKAGE_BU_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_serialization_impl_vlt_vault_distribution (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; type: STRING_32; import_mode: STRING_32; acl_handling: STRING_32; package_roots: STRING_32; package_filters: detachable LIST [STRING_32]; property_filters: detachable LIST [STRING_32]; temp_fs_folder: STRING_32; use_binary_references: BOOLEAN; auto_save_threshold: INTEGER_32; cleanup_delay: INTEGER_32; file_threshold: INTEGER_32; mega_bytes: STRING_32; use_off_heap_memory: BOOLEAN; digest_algorithm: STRING_32; monitoring_queue_size: INTEGER_32; paths_mapping: detachable LIST [STRING_32]; strict_import: BOOLEAN): detachable ORG_APACHE_SLING_DISTRIBUTION_SERIALIZATION_IMPL_VLT_VAULT_DISTRIBUTION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: type  (optional)
			-- 
			-- argument: import_mode  (optional)
			-- 
			-- argument: acl_handling  (optional)
			-- 
			-- argument: package_roots  (optional)
			-- 
			-- argument: package_filters  (optional)
			-- 
			-- argument: property_filters  (optional)
			-- 
			-- argument: temp_fs_folder  (optional)
			-- 
			-- argument: use_binary_references  (optional)
			-- 
			-- argument: auto_save_threshold  (optional)
			-- 
			-- argument: cleanup_delay  (optional)
			-- 
			-- argument: file_threshold  (optional)
			-- 
			-- argument: mega_bytes  (optional)
			-- 
			-- argument: use_off_heap_memory  (optional)
			-- 
			-- argument: digest_algorithm  (optional)
			-- 
			-- argument: monitoring_queue_size  (optional)
			-- 
			-- argument: paths_mapping  (optional)
			-- 
			-- argument: strict_import  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_SERIALIZATION_IMPL_VLT_VAULT_DISTRIBUTION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.serialization.impl.vlt.VaultDistributionPackageBuilderFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "type", type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "importMode", import_mode));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "aclHandling", acl_handling));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "package.roots", package_roots));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "package.filters", package_filters));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "property.filters", property_filters));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tempFsFolder", temp_fs_folder));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "useBinaryReferences", use_binary_references));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "autoSaveThreshold", auto_save_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cleanupDelay", cleanup_delay));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "fileThreshold", file_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "MEGA_BYTES", mega_bytes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "useOffHeapMemory", use_off_heap_memory));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "digestAlgorithm", digest_algorithm));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "monitoringQueueSize", monitoring_queue_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "pathsMapping", paths_mapping));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "strictImport", strict_import));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_SERIALIZATION_IMPL_VLT_VAULT_DISTRIBUTION_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_SERIALIZATION_IMPL_VLT_VAULT_DISTRIBUTION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_transport_impl_user_credentials_distributi (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; username: STRING_32; password: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_TRANSPORT_IMPL_USER_CREDENTIALS_DISTRIBUTI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: username  (optional)
			-- 
			-- argument: password  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_TRANSPORT_IMPL_USER_CREDENTIALS_DISTRIBUTI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.transport.impl.UserCredentialsDistributionTransportSecretProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "username", username));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "password", password));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_TRANSPORT_IMPL_USER_CREDENTIALS_DISTRIBUTI_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_TRANSPORT_IMPL_USER_CREDENTIALS_DISTRIBUTI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_trigger_impl_distribution_event_distribute (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; path: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_DISTRIBUTION_EVENT_DISTRIBUTE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_DISTRIBUTION_EVENT_DISTRIBUTE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.DistributionEventDistributeDistributionTriggerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_DISTRIBUTION_EVENT_DISTRIBUTE_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_DISTRIBUTION_EVENT_DISTRIBUTE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_trigger_impl_jcr_event_distribution_trigger (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; path: STRING_32; ignored_paths_patterns: detachable LIST [STRING_32]; service_name: STRING_32; deep: BOOLEAN): detachable ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_JCR_EVENT_DISTRIBUTION_TRIGGER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: ignored_paths_patterns  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- argument: deep  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_JCR_EVENT_DISTRIBUTION_TRIGGER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.JcrEventDistributionTriggerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "ignoredPathsPatterns", ignored_paths_patterns));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceName", service_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "deep", deep));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_JCR_EVENT_DISTRIBUTION_TRIGGER_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_JCR_EVENT_DISTRIBUTION_TRIGGER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_trigger_impl_persisted_jcr_event_distributi (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; path: STRING_32; service_name: STRING_32; nuggets_path: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_PERSISTED_JCR_EVENT_DISTRIBUTI_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- argument: nuggets_path  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_PERSISTED_JCR_EVENT_DISTRIBUTI_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.PersistedJcrEventDistributionTriggerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceName", service_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "nuggetsPath", nuggets_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_PERSISTED_JCR_EVENT_DISTRIBUTI_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_PERSISTED_JCR_EVENT_DISTRIBUTI_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_trigger_impl_remote_event_distribution_trig (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; endpoint: STRING_32; transport_secret_provider_target: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_REMOTE_EVENT_DISTRIBUTION_TRIG_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: endpoint  (optional)
			-- 
			-- argument: transport_secret_provider_target  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_REMOTE_EVENT_DISTRIBUTION_TRIG_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.RemoteEventDistributionTriggerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endpoint", endpoint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "transportSecretProvider.target", transport_secret_provider_target));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_REMOTE_EVENT_DISTRIBUTION_TRIG_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_REMOTE_EVENT_DISTRIBUTION_TRIG_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_trigger_impl_resource_event_distribution_tr (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; path: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_RESOURCE_EVENT_DISTRIBUTION_TR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_RESOURCE_EVENT_DISTRIBUTION_TR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.ResourceEventDistributionTriggerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_RESOURCE_EVENT_DISTRIBUTION_TR_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_RESOURCE_EVENT_DISTRIBUTION_TR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_distribution_trigger_impl_scheduled_distribution_trigge (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; path: STRING_32; seconds: STRING_32; service_name: STRING_32): detachable ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_SCHEDULED_DISTRIBUTION_TRIGGE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: seconds  (optional)
			-- 
			-- argument: service_name  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_SCHEDULED_DISTRIBUTION_TRIGGE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.ScheduledDistributionTriggerFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "seconds", seconds));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceName", service_name));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_SCHEDULED_DISTRIBUTION_TRIGGE_INFO } l_response.data ({ ORG_APACHE_SLING_DISTRIBUTION_TRIGGER_IMPL_SCHEDULED_DISTRIBUTION_TRIGGE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_engine_impl_auth_sling_authenticator (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; osgi_http_whiteboard_context_select: STRING_32; osgi_http_whiteboard_listener: STRING_32; auth_sudo_cookie: STRING_32; auth_sudo_parameter: STRING_32; auth_annonymous: BOOLEAN; sling_auth_requirements: detachable LIST [STRING_32]; sling_auth_anonymous_user: STRING_32; sling_auth_anonymous_password: STRING_32; auth_http: STRING_32; auth_http_realm: STRING_32; auth_uri_suffix: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_ENGINE_IMPL_AUTH_SLING_AUTHENTICATOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: osgi_http_whiteboard_context_select  (optional)
			-- 
			-- argument: osgi_http_whiteboard_listener  (optional)
			-- 
			-- argument: auth_sudo_cookie  (optional)
			-- 
			-- argument: auth_sudo_parameter  (optional)
			-- 
			-- argument: auth_annonymous  (optional)
			-- 
			-- argument: sling_auth_requirements  (optional)
			-- 
			-- argument: sling_auth_anonymous_user  (optional)
			-- 
			-- argument: sling_auth_anonymous_password  (optional)
			-- 
			-- argument: auth_http  (optional)
			-- 
			-- argument: auth_http_realm  (optional)
			-- 
			-- argument: auth_uri_suffix  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_ENGINE_IMPL_AUTH_SLING_AUTHENTICATOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.engine.impl.auth.SlingAuthenticator"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "osgi.http.whiteboard.context.select", osgi_http_whiteboard_context_select));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "osgi.http.whiteboard.listener", osgi_http_whiteboard_listener));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.sudo.cookie", auth_sudo_cookie));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.sudo.parameter", auth_sudo_parameter));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.annonymous", auth_annonymous));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.auth.requirements", sling_auth_requirements));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.auth.anonymous.user", sling_auth_anonymous_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.auth.anonymous.password", sling_auth_anonymous_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.http", auth_http));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "auth.http.realm", auth_http_realm));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "auth.uri.suffix", auth_uri_suffix));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_ENGINE_IMPL_AUTH_SLING_AUTHENTICATOR_INFO } l_response.data ({ ORG_APACHE_SLING_ENGINE_IMPL_AUTH_SLING_AUTHENTICATOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_engine_impl_debug_request_progress_tracker_log_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; extensions: detachable LIST [STRING_32]; min_duration_ms: INTEGER_32; max_duration_ms: INTEGER_32; compact_log_format: BOOLEAN): detachable ORG_APACHE_SLING_ENGINE_IMPL_DEBUG_REQUEST_PROGRESS_TRACKER_LOG_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: extensions  (optional)
			-- 
			-- argument: min_duration_ms  (optional)
			-- 
			-- argument: max_duration_ms  (optional)
			-- 
			-- argument: compact_log_format  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_ENGINE_IMPL_DEBUG_REQUEST_PROGRESS_TRACKER_LOG_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.engine.impl.debug.RequestProgressTrackerLogFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "extensions", extensions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "minDurationMs", min_duration_ms));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxDurationMs", max_duration_ms));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "compactLogFormat", compact_log_format));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_ENGINE_IMPL_DEBUG_REQUEST_PROGRESS_TRACKER_LOG_FILTER_INFO } l_response.data ({ ORG_APACHE_SLING_ENGINE_IMPL_DEBUG_REQUEST_PROGRESS_TRACKER_LOG_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_engine_impl_log_request_logger (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; request_log_output: STRING_32; request_log_outputtype: INTEGER_32; request_log_enabled: BOOLEAN; access_log_output: STRING_32; access_log_outputtype: INTEGER_32; access_log_enabled: BOOLEAN): detachable ORG_APACHE_SLING_ENGINE_IMPL_LOG_REQUEST_LOGGER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: request_log_output  (optional)
			-- 
			-- argument: request_log_outputtype  (optional)
			-- 
			-- argument: request_log_enabled  (optional)
			-- 
			-- argument: access_log_output  (optional)
			-- 
			-- argument: access_log_outputtype  (optional)
			-- 
			-- argument: access_log_enabled  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_ENGINE_IMPL_LOG_REQUEST_LOGGER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.engine.impl.log.RequestLogger"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "request.log.output", request_log_output));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "request.log.outputtype", request_log_outputtype));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "request.log.enabled", request_log_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "access.log.output", access_log_output));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "access.log.outputtype", access_log_outputtype));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "access.log.enabled", access_log_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_ENGINE_IMPL_LOG_REQUEST_LOGGER_INFO } l_response.data ({ ORG_APACHE_SLING_ENGINE_IMPL_LOG_REQUEST_LOGGER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_engine_impl_log_request_logger_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; request_log_service_format: STRING_32; request_log_service_output: STRING_32; request_log_service_outputtype: INTEGER_32; request_log_service_onentry: BOOLEAN): detachable ORG_APACHE_SLING_ENGINE_IMPL_LOG_REQUEST_LOGGER_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: request_log_service_format  (optional)
			-- 
			-- argument: request_log_service_output  (optional)
			-- 
			-- argument: request_log_service_outputtype  (optional)
			-- 
			-- argument: request_log_service_onentry  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_ENGINE_IMPL_LOG_REQUEST_LOGGER_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.engine.impl.log.RequestLoggerService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "request.log.service.format", request_log_service_format));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "request.log.service.output", request_log_service_output));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "request.log.service.outputtype", request_log_service_outputtype));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "request.log.service.onentry", request_log_service_onentry));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_ENGINE_IMPL_LOG_REQUEST_LOGGER_SERVICE_INFO } l_response.data ({ ORG_APACHE_SLING_ENGINE_IMPL_LOG_REQUEST_LOGGER_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_engine_impl_sling_main_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_max_calls: INTEGER_32; sling_max_inclusions: INTEGER_32; sling_trace_allow: BOOLEAN; sling_max_record_requests: INTEGER_32; sling_store_pattern_requests: detachable LIST [STRING_32]; sling_serverinfo: STRING_32; sling_additional_response_headers: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_ENGINE_IMPL_SLING_MAIN_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_max_calls  (optional)
			-- 
			-- argument: sling_max_inclusions  (optional)
			-- 
			-- argument: sling_trace_allow  (optional)
			-- 
			-- argument: sling_max_record_requests  (optional)
			-- 
			-- argument: sling_store_pattern_requests  (optional)
			-- 
			-- argument: sling_serverinfo  (optional)
			-- 
			-- argument: sling_additional_response_headers  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_ENGINE_IMPL_SLING_MAIN_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.engine.impl.SlingMainServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.max.calls", sling_max_calls));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.max.inclusions", sling_max_inclusions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.trace.allow", sling_trace_allow));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.max.record.requests", sling_max_record_requests));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.store.pattern.requests", sling_store_pattern_requests));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.serverinfo", sling_serverinfo));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.additional.response.headers", sling_additional_response_headers));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_ENGINE_IMPL_SLING_MAIN_SERVLET_INFO } l_response.data ({ ORG_APACHE_SLING_ENGINE_IMPL_SLING_MAIN_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_engine_parameters (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_default_parameter_encoding: STRING_32; sling_default_max_parameters: INTEGER_32; file_location: STRING_32; file_threshold: INTEGER_32; file_max: INTEGER_32; request_max: INTEGER_32; sling_default_parameter_check_for_additional_container_parameters: BOOLEAN): detachable ORG_APACHE_SLING_ENGINE_PARAMETERS_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_default_parameter_encoding  (optional)
			-- 
			-- argument: sling_default_max_parameters  (optional)
			-- 
			-- argument: file_location  (optional)
			-- 
			-- argument: file_threshold  (optional)
			-- 
			-- argument: file_max  (optional)
			-- 
			-- argument: request_max  (optional)
			-- 
			-- argument: sling_default_parameter_check_for_additional_container_parameters  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_ENGINE_PARAMETERS_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.engine.parameters"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.default.parameter.encoding", sling_default_parameter_encoding));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.default.max.parameters", sling_default_max_parameters));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "file.location", file_location));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "file.threshold", file_threshold));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "file.max", file_max));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "request.max", request_max));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.default.parameter.checkForAdditionalContainerParameters", sling_default_parameter_check_for_additional_container_parameters));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_ENGINE_PARAMETERS_INFO } l_response.data ({ ORG_APACHE_SLING_ENGINE_PARAMETERS_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_event_impl_eventing_thread_pool (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; min_pool_size: INTEGER_32): detachable ORG_APACHE_SLING_EVENT_IMPL_EVENTING_THREAD_POOL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: min_pool_size  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_EVENT_IMPL_EVENTING_THREAD_POOL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.event.impl.EventingThreadPool"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "minPoolSize", min_pool_size));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_EVENT_IMPL_EVENTING_THREAD_POOL_INFO } l_response.data ({ ORG_APACHE_SLING_EVENT_IMPL_EVENTING_THREAD_POOL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_event_impl_jobs_default_job_manager (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; queue_priority: STRING_32; queue_retries: INTEGER_32; queue_retrydelay: INTEGER_32; queue_maxparallel: INTEGER_32): detachable ORG_APACHE_SLING_EVENT_IMPL_JOBS_DEFAULT_JOB_MANAGER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: queue_priority  (optional)
			-- 
			-- argument: queue_retries  (optional)
			-- 
			-- argument: queue_retrydelay  (optional)
			-- 
			-- argument: queue_maxparallel  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_EVENT_IMPL_JOBS_DEFAULT_JOB_MANAGER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.event.impl.jobs.DefaultJobManager"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.priority", queue_priority));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.retries", queue_retries));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.retrydelay", queue_retrydelay));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.maxparallel", queue_maxparallel));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_EVENT_IMPL_JOBS_DEFAULT_JOB_MANAGER_INFO } l_response.data ({ ORG_APACHE_SLING_EVENT_IMPL_JOBS_DEFAULT_JOB_MANAGER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_event_impl_jobs_jcr_persistence_handler (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; job_consumermanager_disable_distribution: BOOLEAN; startup_delay: INTEGER_32; cleanup_period: INTEGER_32): detachable ORG_APACHE_SLING_EVENT_IMPL_JOBS_JCR_PERSISTENCE_HANDLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: job_consumermanager_disable_distribution  (optional)
			-- 
			-- argument: startup_delay  (optional)
			-- 
			-- argument: cleanup_period  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_EVENT_IMPL_JOBS_JCR_PERSISTENCE_HANDLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.event.impl.jobs.jcr.PersistenceHandler"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "job.consumermanager.disableDistribution", job_consumermanager_disable_distribution));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startup.delay", startup_delay));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cleanup.period", cleanup_period));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_EVENT_IMPL_JOBS_JCR_PERSISTENCE_HANDLER_INFO } l_response.data ({ ORG_APACHE_SLING_EVENT_IMPL_JOBS_JCR_PERSISTENCE_HANDLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_event_impl_jobs_job_consumer_manager (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; org_apache_sling_installer_configuration_persist: BOOLEAN; job_consumermanager_whitelist: detachable LIST [STRING_32]; job_consumermanager_blacklist: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_EVENT_IMPL_JOBS_JOB_CONSUMER_MANAGER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: org_apache_sling_installer_configuration_persist  (optional)
			-- 
			-- argument: job_consumermanager_whitelist  (optional)
			-- 
			-- argument: job_consumermanager_blacklist  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_EVENT_IMPL_JOBS_JOB_CONSUMER_MANAGER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.event.impl.jobs.JobConsumerManager"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.installer.configuration.persist", org_apache_sling_installer_configuration_persist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "job.consumermanager.whitelist", job_consumermanager_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "job.consumermanager.blacklist", job_consumermanager_blacklist));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_EVENT_IMPL_JOBS_JOB_CONSUMER_MANAGER_INFO } l_response.data ({ ORG_APACHE_SLING_EVENT_IMPL_JOBS_JOB_CONSUMER_MANAGER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_event_jobs_queue_configuration (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; queue_name: STRING_32; queue_topics: detachable LIST [STRING_32]; queue_type: STRING_32; queue_priority: STRING_32; queue_retries: INTEGER_32; queue_retrydelay: INTEGER_32; queue_maxparallel: REAL_32; queue_keep_jobs: BOOLEAN; queue_prefer_run_on_creation_instance: BOOLEAN; queue_thread_pool_size: INTEGER_32; service_ranking: INTEGER_32): detachable ORG_APACHE_SLING_EVENT_JOBS_QUEUE_CONFIGURATION_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: queue_name  (optional)
			-- 
			-- argument: queue_topics  (optional)
			-- 
			-- argument: queue_type  (optional)
			-- 
			-- argument: queue_priority  (optional)
			-- 
			-- argument: queue_retries  (optional)
			-- 
			-- argument: queue_retrydelay  (optional)
			-- 
			-- argument: queue_maxparallel  (optional)
			-- 
			-- argument: queue_keep_jobs  (optional)
			-- 
			-- argument: queue_prefer_run_on_creation_instance  (optional)
			-- 
			-- argument: queue_thread_pool_size  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_EVENT_JOBS_QUEUE_CONFIGURATION_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.event.jobs.QueueConfiguration"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.name", queue_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "queue.topics", queue_topics));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.type", queue_type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.priority", queue_priority));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.retries", queue_retries));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.retrydelay", queue_retrydelay));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.maxparallel", queue_maxparallel));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.keepJobs", queue_keep_jobs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.preferRunOnCreationInstance", queue_prefer_run_on_creation_instance));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "queue.threadPoolSize", queue_thread_pool_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_EVENT_JOBS_QUEUE_CONFIGURATION_INFO } l_response.data ({ ORG_APACHE_SLING_EVENT_JOBS_QUEUE_CONFIGURATION_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_extensions_webconsolesecurityprovider_internal_sling_w (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; users: detachable LIST [STRING_32]; groups: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_EXTENSIONS_WEBCONSOLESECURITYPROVIDER_INTERNAL_SLING_W_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: users  (optional)
			-- 
			-- argument: groups  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_EXTENSIONS_WEBCONSOLESECURITYPROVIDER_INTERNAL_SLING_W_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.extensions.webconsolesecurityprovider.internal.SlingWebConsoleSecurityProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "users", users));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "groups", groups));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_EXTENSIONS_WEBCONSOLESECURITYPROVIDER_INTERNAL_SLING_W_INFO } l_response.data ({ ORG_APACHE_SLING_EXTENSIONS_WEBCONSOLESECURITYPROVIDER_INTERNAL_SLING_W_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_featureflags_feature (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; description: STRING_32; enabled: BOOLEAN): detachable ORG_APACHE_SLING_FEATUREFLAGS_FEATURE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: description  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_FEATUREFLAGS_FEATURE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.featureflags.Feature"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "description", description));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_FEATUREFLAGS_FEATURE_INFO } l_response.data ({ ORG_APACHE_SLING_FEATUREFLAGS_FEATURE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_featureflags_impl_configured_feature (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; name: STRING_32; description: STRING_32; enabled: BOOLEAN): detachable ORG_APACHE_SLING_FEATUREFLAGS_IMPL_CONFIGURED_FEATURE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: name  (optional)
			-- 
			-- argument: description  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_FEATUREFLAGS_IMPL_CONFIGURED_FEATURE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.featureflags.impl.ConfiguredFeature"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "description", description));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_FEATUREFLAGS_IMPL_CONFIGURED_FEATURE_INFO } l_response.data ({ ORG_APACHE_SLING_FEATUREFLAGS_IMPL_CONFIGURED_FEATURE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_hapi_impl_hapi_util_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; org_apache_sling_hapi_tools_resourcetype: STRING_32; org_apache_sling_hapi_tools_collectionresourcetype: STRING_32; org_apache_sling_hapi_tools_searchpaths: detachable LIST [STRING_32]; org_apache_sling_hapi_tools_externalurl: STRING_32; org_apache_sling_hapi_tools_enabled: BOOLEAN): detachable ORG_APACHE_SLING_HAPI_IMPL_H_API_UTIL_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: org_apache_sling_hapi_tools_resourcetype  (optional)
			-- 
			-- argument: org_apache_sling_hapi_tools_collectionresourcetype  (optional)
			-- 
			-- argument: org_apache_sling_hapi_tools_searchpaths  (optional)
			-- 
			-- argument: org_apache_sling_hapi_tools_externalurl  (optional)
			-- 
			-- argument: org_apache_sling_hapi_tools_enabled  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_HAPI_IMPL_H_API_UTIL_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.hapi.impl.HApiUtilImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.hapi.tools.resourcetype", org_apache_sling_hapi_tools_resourcetype));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.hapi.tools.collectionresourcetype", org_apache_sling_hapi_tools_collectionresourcetype));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.sling.hapi.tools.searchpaths", org_apache_sling_hapi_tools_searchpaths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.hapi.tools.externalurl", org_apache_sling_hapi_tools_externalurl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.hapi.tools.enabled", org_apache_sling_hapi_tools_enabled));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_HAPI_IMPL_H_API_UTIL_IMPL_INFO } l_response.data ({ ORG_APACHE_SLING_HAPI_IMPL_H_API_UTIL_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_hc_core_impl_composite_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_name: STRING_32; hc_tags: detachable LIST [STRING_32]; hc_mbean_name: STRING_32; filter_tags: detachable LIST [STRING_32]; filter_combine_tags_with_or: BOOLEAN): detachable ORG_APACHE_SLING_HC_CORE_IMPL_COMPOSITE_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_name  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: hc_mbean_name  (optional)
			-- 
			-- argument: filter_tags  (optional)
			-- 
			-- argument: filter_combine_tags_with_or  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_HC_CORE_IMPL_COMPOSITE_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.hc.core.impl.CompositeHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.name", hc_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.mbean.name", hc_mbean_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "filter.tags", filter_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter.combineTagsWithOr", filter_combine_tags_with_or));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_HC_CORE_IMPL_COMPOSITE_HEALTH_CHECK_INFO } l_response.data ({ ORG_APACHE_SLING_HC_CORE_IMPL_COMPOSITE_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_hc_core_impl_executor_health_check_executor_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; timeout_in_ms: INTEGER_32; long_running_future_threshold_for_critical_ms: INTEGER_32; result_cache_ttl_in_ms: INTEGER_32): detachable ORG_APACHE_SLING_HC_CORE_IMPL_EXECUTOR_HEALTH_CHECK_EXECUTOR_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: timeout_in_ms  (optional)
			-- 
			-- argument: long_running_future_threshold_for_critical_ms  (optional)
			-- 
			-- argument: result_cache_ttl_in_ms  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_HC_CORE_IMPL_EXECUTOR_HEALTH_CHECK_EXECUTOR_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.hc.core.impl.executor.HealthCheckExecutorImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "timeoutInMs", timeout_in_ms));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "longRunningFutureThresholdForCriticalMs", long_running_future_threshold_for_critical_ms));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resultCacheTtlInMs", result_cache_ttl_in_ms));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_HC_CORE_IMPL_EXECUTOR_HEALTH_CHECK_EXECUTOR_IMPL_INFO } l_response.data ({ ORG_APACHE_SLING_HC_CORE_IMPL_EXECUTOR_HEALTH_CHECK_EXECUTOR_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_hc_core_impl_jmx_attribute_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_name: STRING_32; hc_tags: detachable LIST [STRING_32]; hc_mbean_name: STRING_32; mbean_name: STRING_32; attribute_name: STRING_32; attribute_value_constraint: STRING_32): detachable ORG_APACHE_SLING_HC_CORE_IMPL_JMX_ATTRIBUTE_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_name  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: hc_mbean_name  (optional)
			-- 
			-- argument: mbean_name  (optional)
			-- 
			-- argument: attribute_name  (optional)
			-- 
			-- argument: attribute_value_constraint  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_HC_CORE_IMPL_JMX_ATTRIBUTE_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.hc.core.impl.JmxAttributeHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.name", hc_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.mbean.name", hc_mbean_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "mbean.name", mbean_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "attribute.name", attribute_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "attribute.value.constraint", attribute_value_constraint));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_HC_CORE_IMPL_JMX_ATTRIBUTE_HEALTH_CHECK_INFO } l_response.data ({ ORG_APACHE_SLING_HC_CORE_IMPL_JMX_ATTRIBUTE_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_hc_core_impl_scriptable_health_check (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; hc_name: STRING_32; hc_tags: detachable LIST [STRING_32]; hc_mbean_name: STRING_32; expression: STRING_32; language_extension: STRING_32): detachable ORG_APACHE_SLING_HC_CORE_IMPL_SCRIPTABLE_HEALTH_CHECK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: hc_name  (optional)
			-- 
			-- argument: hc_tags  (optional)
			-- 
			-- argument: hc_mbean_name  (optional)
			-- 
			-- argument: expression  (optional)
			-- 
			-- argument: language_extension  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_HC_CORE_IMPL_SCRIPTABLE_HEALTH_CHECK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.hc.core.impl.ScriptableHealthCheck"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.name", hc_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "hc.tags", hc_tags));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "hc.mbean.name", hc_mbean_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "expression", expression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "language.extension", language_extension));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_HC_CORE_IMPL_SCRIPTABLE_HEALTH_CHECK_INFO } l_response.data ({ ORG_APACHE_SLING_HC_CORE_IMPL_SCRIPTABLE_HEALTH_CHECK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_hc_core_impl_servlet_health_check_executor_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; servlet_path: STRING_32; disabled: BOOLEAN; cors_access_control_allow_origin: STRING_32): detachable ORG_APACHE_SLING_HC_CORE_IMPL_SERVLET_HEALTH_CHECK_EXECUTOR_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: servlet_path  (optional)
			-- 
			-- argument: disabled  (optional)
			-- 
			-- argument: cors_access_control_allow_origin  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_HC_CORE_IMPL_SERVLET_HEALTH_CHECK_EXECUTOR_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.hc.core.impl.servlet.HealthCheckExecutorServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "servletPath", servlet_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "disabled", disabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cors.accessControlAllowOrigin", cors_access_control_allow_origin));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_HC_CORE_IMPL_SERVLET_HEALTH_CHECK_EXECUTOR_SERVLET_INFO } l_response.data ({ ORG_APACHE_SLING_HC_CORE_IMPL_SERVLET_HEALTH_CHECK_EXECUTOR_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_hc_core_impl_servlet_result_txt_verbose_serializer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; total_width: INTEGER_32; col_width_name: INTEGER_32; col_width_result: INTEGER_32; col_width_timing: INTEGER_32): detachable ORG_APACHE_SLING_HC_CORE_IMPL_SERVLET_RESULT_TXT_VERBOSE_SERIALIZER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: total_width  (optional)
			-- 
			-- argument: col_width_name  (optional)
			-- 
			-- argument: col_width_result  (optional)
			-- 
			-- argument: col_width_timing  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_HC_CORE_IMPL_SERVLET_RESULT_TXT_VERBOSE_SERIALIZER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.hc.core.impl.servlet.ResultTxtVerboseSerializer"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "totalWidth", total_width));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "colWidthName", col_width_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "colWidthResult", col_width_result));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "colWidthTiming", col_width_timing));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_HC_CORE_IMPL_SERVLET_RESULT_TXT_VERBOSE_SERIALIZER_INFO } l_response.data ({ ORG_APACHE_SLING_HC_CORE_IMPL_SERVLET_RESULT_TXT_VERBOSE_SERIALIZER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_i18n_impl_i18_nfilter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; sling_filter_scope: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_I18N_IMPL_I18_N_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: sling_filter_scope  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_I18N_IMPL_I18_N_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.i18n.impl.I18NFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.filter.scope", sling_filter_scope));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_I18N_IMPL_I18_N_FILTER_INFO } l_response.data ({ ORG_APACHE_SLING_I18N_IMPL_I18_N_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_i18n_impl_jcr_resource_bundle_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; locale_default: STRING_32; preload_bundles: BOOLEAN; invalidation_delay: INTEGER_32): detachable ORG_APACHE_SLING_I18N_IMPL_JCR_RESOURCE_BUNDLE_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: locale_default  (optional)
			-- 
			-- argument: preload_bundles  (optional)
			-- 
			-- argument: invalidation_delay  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_I18N_IMPL_JCR_RESOURCE_BUNDLE_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.i18n.impl.JcrResourceBundleProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "locale.default", locale_default));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "preload.bundles", preload_bundles));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "invalidation.delay", invalidation_delay));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_I18N_IMPL_JCR_RESOURCE_BUNDLE_PROVIDER_INFO } l_response.data ({ ORG_APACHE_SLING_I18N_IMPL_JCR_RESOURCE_BUNDLE_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_installer_provider_jcr_impl_jcr_installer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; handler_schemes: detachable LIST [STRING_32]; sling_jcrinstall_folder_name_regexp: STRING_32; sling_jcrinstall_folder_max_depth: INTEGER_32; sling_jcrinstall_search_path: detachable LIST [STRING_32]; sling_jcrinstall_new_config_path: STRING_32; sling_jcrinstall_signal_path: STRING_32; sling_jcrinstall_enable_writeback: BOOLEAN): detachable ORG_APACHE_SLING_INSTALLER_PROVIDER_JCR_IMPL_JCR_INSTALLER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: handler_schemes  (optional)
			-- 
			-- argument: sling_jcrinstall_folder_name_regexp  (optional)
			-- 
			-- argument: sling_jcrinstall_folder_max_depth  (optional)
			-- 
			-- argument: sling_jcrinstall_search_path  (optional)
			-- 
			-- argument: sling_jcrinstall_new_config_path  (optional)
			-- 
			-- argument: sling_jcrinstall_signal_path  (optional)
			-- 
			-- argument: sling_jcrinstall_enable_writeback  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_INSTALLER_PROVIDER_JCR_IMPL_JCR_INSTALLER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.installer.provider.jcr.impl.JcrInstaller"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "handler.schemes", handler_schemes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.jcrinstall.folder.name.regexp", sling_jcrinstall_folder_name_regexp));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.jcrinstall.folder.max.depth", sling_jcrinstall_folder_max_depth));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.jcrinstall.search.path", sling_jcrinstall_search_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.jcrinstall.new.config.path", sling_jcrinstall_new_config_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.jcrinstall.signal.path", sling_jcrinstall_signal_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.jcrinstall.enable.writeback", sling_jcrinstall_enable_writeback));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_INSTALLER_PROVIDER_JCR_IMPL_JCR_INSTALLER_INFO } l_response.data ({ ORG_APACHE_SLING_INSTALLER_PROVIDER_JCR_IMPL_JCR_INSTALLER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_base_internal_login_admin_whitelist (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; whitelist_bypass: BOOLEAN; whitelist_bundles_regexp: STRING_32): detachable ORG_APACHE_SLING_JCR_BASE_INTERNAL_LOGIN_ADMIN_WHITELIST_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: whitelist_bypass  (optional)
			-- 
			-- argument: whitelist_bundles_regexp  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_BASE_INTERNAL_LOGIN_ADMIN_WHITELIST_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.base.internal.LoginAdminWhitelist"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "whitelist.bypass", whitelist_bypass));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "whitelist.bundles.regexp", whitelist_bundles_regexp));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_BASE_INTERNAL_LOGIN_ADMIN_WHITELIST_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_BASE_INTERNAL_LOGIN_ADMIN_WHITELIST_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_base_internal_login_admin_whitelist_fragment (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; whitelist_name: STRING_32; whitelist_bundles: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_JCR_BASE_INTERNAL_LOGIN_ADMIN_WHITELIST_FRAGMENT_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: whitelist_name  (optional)
			-- 
			-- argument: whitelist_bundles  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_BASE_INTERNAL_LOGIN_ADMIN_WHITELIST_FRAGMENT_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.base.internal.LoginAdminWhitelist.fragment"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "whitelist.name", whitelist_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "whitelist.bundles", whitelist_bundles));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_BASE_INTERNAL_LOGIN_ADMIN_WHITELIST_FRAGMENT_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_BASE_INTERNAL_LOGIN_ADMIN_WHITELIST_FRAGMENT_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_davex_impl_servlets_sling_dav_ex_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; var_alias: STRING_32; dav_create_absolute_uri: BOOLEAN; dav_protectedhandlers: STRING_32): detachable ORG_APACHE_SLING_JCR_DAVEX_IMPL_SERVLETS_SLING_DAV_EX_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: var_alias  (optional)
			-- 
			-- argument: dav_create_absolute_uri  (optional)
			-- 
			-- argument: dav_protectedhandlers  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_DAVEX_IMPL_SERVLETS_SLING_DAV_EX_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "alias", var_alias));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dav.create-absolute-uri", dav_create_absolute_uri));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dav.protectedhandlers", dav_protectedhandlers));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_DAVEX_IMPL_SERVLETS_SLING_DAV_EX_SERVLET_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_DAVEX_IMPL_SERVLETS_SLING_DAV_EX_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_jackrabbit_server_jndi_registration_support (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; java_naming_factory_initial: STRING_32; java_naming_provider_url: STRING_32): detachable ORG_APACHE_SLING_JCR_JACKRABBIT_SERVER_JNDI_REGISTRATION_SUPPORT_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: java_naming_factory_initial  (optional)
			-- 
			-- argument: java_naming_provider_url  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_JACKRABBIT_SERVER_JNDI_REGISTRATION_SUPPORT_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.jackrabbit.server.JndiRegistrationSupport"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "java.naming.factory.initial", java_naming_factory_initial));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "java.naming.provider.url", java_naming_provider_url));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_JACKRABBIT_SERVER_JNDI_REGISTRATION_SUPPORT_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_JACKRABBIT_SERVER_JNDI_REGISTRATION_SUPPORT_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_jackrabbit_server_rmi_registration_support (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; port: INTEGER_32): detachable ORG_APACHE_SLING_JCR_JACKRABBIT_SERVER_RMI_REGISTRATION_SUPPORT_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: port  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_JACKRABBIT_SERVER_RMI_REGISTRATION_SUPPORT_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.jackrabbit.server.RmiRegistrationSupport"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "port", port));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_JACKRABBIT_SERVER_RMI_REGISTRATION_SUPPORT_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_JACKRABBIT_SERVER_RMI_REGISTRATION_SUPPORT_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_repoinit_impl_repository_initializer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; references: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_JCR_REPOINIT_IMPL_REPOSITORY_INITIALIZER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: references  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_REPOINIT_IMPL_REPOSITORY_INITIALIZER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.repoinit.impl.RepositoryInitializer"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "references", references));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_REPOINIT_IMPL_REPOSITORY_INITIALIZER_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_REPOINIT_IMPL_REPOSITORY_INITIALIZER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_repoinit_repository_initializer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; references: detachable LIST [STRING_32]; scripts: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_JCR_REPOINIT_REPOSITORY_INITIALIZER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: references  (optional)
			-- 
			-- argument: scripts  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_REPOINIT_REPOSITORY_INITIALIZER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.repoinit.RepositoryInitializer"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "references", references));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "scripts", scripts));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_REPOINIT_REPOSITORY_INITIALIZER_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_REPOINIT_REPOSITORY_INITIALIZER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_resource_internal_jcr_resource_resolver_factory_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; resource_resolver_searchpath: detachable LIST [STRING_32]; resource_resolver_manglenamespaces: BOOLEAN; resource_resolver_allow_direct: BOOLEAN; resource_resolver_required_providers: detachable LIST [STRING_32]; resource_resolver_required_providernames: detachable LIST [STRING_32]; resource_resolver_virtual: detachable LIST [STRING_32]; resource_resolver_mapping: detachable LIST [STRING_32]; resource_resolver_map_location: STRING_32; resource_resolver_map_observation: detachable LIST [STRING_32]; resource_resolver_default_vanity_redirect_status: INTEGER_32; resource_resolver_enable_vanitypath: BOOLEAN; resource_resolver_vanitypath_max_entries: INTEGER_32; resource_resolver_vanitypath_max_entries_startup: BOOLEAN; resource_resolver_vanitypath_bloomfilter_max_bytes: INTEGER_32; resource_resolver_optimize_alias_resolution: BOOLEAN; resource_resolver_vanitypath_whitelist: detachable LIST [STRING_32]; resource_resolver_vanitypath_blacklist: detachable LIST [STRING_32]; resource_resolver_vanity_precedence: BOOLEAN; resource_resolver_providerhandling_paranoid: BOOLEAN; resource_resolver_log_closing: BOOLEAN; resource_resolver_log_unclosed: BOOLEAN): detachable ORG_APACHE_SLING_JCR_RESOURCE_INTERNAL_JCR_RESOURCE_RESOLVER_FACTORY_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: resource_resolver_searchpath  (optional)
			-- 
			-- argument: resource_resolver_manglenamespaces  (optional)
			-- 
			-- argument: resource_resolver_allow_direct  (optional)
			-- 
			-- argument: resource_resolver_required_providers  (optional)
			-- 
			-- argument: resource_resolver_required_providernames  (optional)
			-- 
			-- argument: resource_resolver_virtual  (optional)
			-- 
			-- argument: resource_resolver_mapping  (optional)
			-- 
			-- argument: resource_resolver_map_location  (optional)
			-- 
			-- argument: resource_resolver_map_observation  (optional)
			-- 
			-- argument: resource_resolver_default_vanity_redirect_status  (optional)
			-- 
			-- argument: resource_resolver_enable_vanitypath  (optional)
			-- 
			-- argument: resource_resolver_vanitypath_max_entries  (optional)
			-- 
			-- argument: resource_resolver_vanitypath_max_entries_startup  (optional)
			-- 
			-- argument: resource_resolver_vanitypath_bloomfilter_max_bytes  (optional)
			-- 
			-- argument: resource_resolver_optimize_alias_resolution  (optional)
			-- 
			-- argument: resource_resolver_vanitypath_whitelist  (optional)
			-- 
			-- argument: resource_resolver_vanitypath_blacklist  (optional)
			-- 
			-- argument: resource_resolver_vanity_precedence  (optional)
			-- 
			-- argument: resource_resolver_providerhandling_paranoid  (optional)
			-- 
			-- argument: resource_resolver_log_closing  (optional)
			-- 
			-- argument: resource_resolver_log_unclosed  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_RESOURCE_INTERNAL_JCR_RESOURCE_RESOLVER_FACTORY_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.resource.internal.JcrResourceResolverFactoryImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resource.resolver.searchpath", resource_resolver_searchpath));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.manglenamespaces", resource_resolver_manglenamespaces));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.allowDirect", resource_resolver_allow_direct));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resource.resolver.required.providers", resource_resolver_required_providers));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resource.resolver.required.providernames", resource_resolver_required_providernames));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resource.resolver.virtual", resource_resolver_virtual));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resource.resolver.mapping", resource_resolver_mapping));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.map.location", resource_resolver_map_location));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resource.resolver.map.observation", resource_resolver_map_observation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.default.vanity.redirect.status", resource_resolver_default_vanity_redirect_status));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.enable.vanitypath", resource_resolver_enable_vanitypath));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.vanitypath.maxEntries", resource_resolver_vanitypath_max_entries));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.vanitypath.maxEntries.startup", resource_resolver_vanitypath_max_entries_startup));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.vanitypath.bloomfilter.maxBytes", resource_resolver_vanitypath_bloomfilter_max_bytes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.optimize.alias.resolution", resource_resolver_optimize_alias_resolution));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resource.resolver.vanitypath.whitelist", resource_resolver_vanitypath_whitelist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "resource.resolver.vanitypath.blacklist", resource_resolver_vanitypath_blacklist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.vanity.precedence", resource_resolver_vanity_precedence));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.providerhandling.paranoid", resource_resolver_providerhandling_paranoid));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.log.closing", resource_resolver_log_closing));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "resource.resolver.log.unclosed", resource_resolver_log_unclosed));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_RESOURCE_INTERNAL_JCR_RESOURCE_RESOLVER_FACTORY_IMPL_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_RESOURCE_INTERNAL_JCR_RESOURCE_RESOLVER_FACTORY_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_resource_internal_jcr_system_user_validator (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; allow_only_system_user: BOOLEAN): detachable ORG_APACHE_SLING_JCR_RESOURCE_INTERNAL_JCR_SYSTEM_USER_VALIDATOR_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: allow_only_system_user  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_RESOURCE_INTERNAL_JCR_SYSTEM_USER_VALIDATOR_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.resource.internal.JcrSystemUserValidator"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "allow.only.system.user", allow_only_system_user));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_RESOURCE_INTERNAL_JCR_SYSTEM_USER_VALIDATOR_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_RESOURCE_INTERNAL_JCR_SYSTEM_USER_VALIDATOR_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_resourcesecurity_impl_resource_access_gate_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; path: STRING_32; checkpath_prefix: STRING_32; jcr_path: STRING_32): detachable ORG_APACHE_SLING_JCR_RESOURCESECURITY_IMPL_RESOURCE_ACCESS_GATE_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- argument: checkpath_prefix  (optional)
			-- 
			-- argument: jcr_path  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_RESOURCESECURITY_IMPL_RESOURCE_ACCESS_GATE_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.resourcesecurity.impl.ResourceAccessGateFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "checkpath.prefix", checkpath_prefix));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcrPath", jcr_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_RESOURCESECURITY_IMPL_RESOURCE_ACCESS_GATE_FACTORY_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_RESOURCESECURITY_IMPL_RESOURCE_ACCESS_GATE_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_webdav_impl_handler_default_handler_service (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; type_collections: STRING_32; type_noncollections: STRING_32; type_content: STRING_32): detachable ORG_APACHE_SLING_JCR_WEBDAV_IMPL_HANDLER_DEFAULT_HANDLER_SERVICE_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: type_collections  (optional)
			-- 
			-- argument: type_noncollections  (optional)
			-- 
			-- argument: type_content  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_WEBDAV_IMPL_HANDLER_DEFAULT_HANDLER_SERVICE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.webdav.impl.handler.DefaultHandlerService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "type.collections", type_collections));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "type.noncollections", type_noncollections));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "type.content", type_content));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_WEBDAV_IMPL_HANDLER_DEFAULT_HANDLER_SERVICE_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_WEBDAV_IMPL_HANDLER_DEFAULT_HANDLER_SERVICE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_webdav_impl_handler_dir_listing_export_handler_servic (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32): detachable ORG_APACHE_SLING_JCR_WEBDAV_IMPL_HANDLER_DIR_LISTING_EXPORT_HANDLER_SERVIC_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_WEBDAV_IMPL_HANDLER_DIR_LISTING_EXPORT_HANDLER_SERVIC_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.webdav.impl.handler.DirListingExportHandlerService"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_WEBDAV_IMPL_HANDLER_DIR_LISTING_EXPORT_HANDLER_SERVIC_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_WEBDAV_IMPL_HANDLER_DIR_LISTING_EXPORT_HANDLER_SERVIC_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jcr_webdav_impl_servlets_simple_web_dav_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; dav_root: STRING_32; dav_create_absolute_uri: BOOLEAN; dav_realm: STRING_32; collection_types: detachable LIST [STRING_32]; filter_prefixes: detachable LIST [STRING_32]; filter_types: STRING_32; filter_uris: STRING_32; type_collections: STRING_32; type_noncollections: STRING_32; type_content: STRING_32): detachable ORG_APACHE_SLING_JCR_WEBDAV_IMPL_SERVLETS_SIMPLE_WEB_DAV_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: dav_root  (optional)
			-- 
			-- argument: dav_create_absolute_uri  (optional)
			-- 
			-- argument: dav_realm  (optional)
			-- 
			-- argument: collection_types  (optional)
			-- 
			-- argument: filter_prefixes  (optional)
			-- 
			-- argument: filter_types  (optional)
			-- 
			-- argument: filter_uris  (optional)
			-- 
			-- argument: type_collections  (optional)
			-- 
			-- argument: type_noncollections  (optional)
			-- 
			-- argument: type_content  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JCR_WEBDAV_IMPL_SERVLETS_SIMPLE_WEB_DAV_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jcr.webdav.impl.servlets.SimpleWebDavServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dav.root", dav_root));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dav.create-absolute-uri", dav_create_absolute_uri));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dav.realm", dav_realm));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "collection.types", collection_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "filter.prefixes", filter_prefixes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter.types", filter_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter.uris", filter_uris));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "type.collections", type_collections));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "type.noncollections", type_noncollections));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "type.content", type_content));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JCR_WEBDAV_IMPL_SERVLETS_SIMPLE_WEB_DAV_SERVLET_INFO } l_response.data ({ ORG_APACHE_SLING_JCR_WEBDAV_IMPL_SERVLETS_SIMPLE_WEB_DAV_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_jmx_provider_impl_jm_xresource_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; provider_roots: STRING_32): detachable ORG_APACHE_SLING_JMX_PROVIDER_IMPL_JMX_RESOURCE_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: provider_roots  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_JMX_PROVIDER_IMPL_JMX_RESOURCE_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.jmx.provider.impl.JMXResourceProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "provider.roots", provider_roots));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_JMX_PROVIDER_IMPL_JMX_RESOURCE_PROVIDER_INFO } l_response.data ({ ORG_APACHE_SLING_JMX_PROVIDER_IMPL_JMX_RESOURCE_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_models_impl_model_adapter_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; osgi_http_whiteboard_listener: STRING_32; osgi_http_whiteboard_context_select: STRING_32; max_recursion_depth: INTEGER_32; cleanup_job_period: INTEGER_32): detachable ORG_APACHE_SLING_MODELS_IMPL_MODEL_ADAPTER_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: osgi_http_whiteboard_listener  (optional)
			-- 
			-- argument: osgi_http_whiteboard_context_select  (optional)
			-- 
			-- argument: max_recursion_depth  (optional)
			-- 
			-- argument: cleanup_job_period  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_MODELS_IMPL_MODEL_ADAPTER_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.models.impl.ModelAdapterFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "osgi.http.whiteboard.listener", osgi_http_whiteboard_listener));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "osgi.http.whiteboard.context.select", osgi_http_whiteboard_context_select));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "max.recursion.depth", max_recursion_depth));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cleanup.job.period", cleanup_job_period));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_MODELS_IMPL_MODEL_ADAPTER_FACTORY_INFO } l_response.data ({ ORG_APACHE_SLING_MODELS_IMPL_MODEL_ADAPTER_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_models_jacksonexporter_impl_resource_module_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; max_recursion_levels: INTEGER_32): detachable ORG_APACHE_SLING_MODELS_JACKSONEXPORTER_IMPL_RESOURCE_MODULE_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: max_recursion_levels  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_MODELS_JACKSONEXPORTER_IMPL_RESOURCE_MODULE_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.models.jacksonexporter.impl.ResourceModuleProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "max.recursion.levels", max_recursion_levels));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_MODELS_JACKSONEXPORTER_IMPL_RESOURCE_MODULE_PROVIDER_INFO } l_response.data ({ ORG_APACHE_SLING_MODELS_JACKSONEXPORTER_IMPL_RESOURCE_MODULE_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_resource_inventory_impl_resource_inventory_printer_facto (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; felix_inventory_printer_name: STRING_32; felix_inventory_printer_title: STRING_32; path: STRING_32): detachable ORG_APACHE_SLING_RESOURCE_INVENTORY_IMPL_RESOURCE_INVENTORY_PRINTER_FACTO_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: felix_inventory_printer_name  (optional)
			-- 
			-- argument: felix_inventory_printer_title  (optional)
			-- 
			-- argument: path  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_RESOURCE_INVENTORY_IMPL_RESOURCE_INVENTORY_PRINTER_FACTO_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.resource.inventory.impl.ResourceInventoryPrinterFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "felix.inventory.printer.name", felix_inventory_printer_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "felix.inventory.printer.title", felix_inventory_printer_title));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_RESOURCE_INVENTORY_IMPL_RESOURCE_INVENTORY_PRINTER_FACTO_INFO } l_response.data ({ ORG_APACHE_SLING_RESOURCE_INVENTORY_IMPL_RESOURCE_INVENTORY_PRINTER_FACTO_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_resourcemerger_impl_merged_resource_provider_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; merge_root: STRING_32; merge_read_only: BOOLEAN): detachable ORG_APACHE_SLING_RESOURCEMERGER_IMPL_MERGED_RESOURCE_PROVIDER_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: merge_root  (optional)
			-- 
			-- argument: merge_read_only  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_RESOURCEMERGER_IMPL_MERGED_RESOURCE_PROVIDER_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.resourcemerger.impl.MergedResourceProviderFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "merge.root", merge_root));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "merge.readOnly", merge_read_only));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_RESOURCEMERGER_IMPL_MERGED_RESOURCE_PROVIDER_FACTORY_INFO } l_response.data ({ ORG_APACHE_SLING_RESOURCEMERGER_IMPL_MERGED_RESOURCE_PROVIDER_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_resourcemerger_picker_overriding (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; merge_root: STRING_32; merge_read_only: BOOLEAN): detachable ORG_APACHE_SLING_RESOURCEMERGER_PICKER_OVERRIDING_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: merge_root  (optional)
			-- 
			-- argument: merge_read_only  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_RESOURCEMERGER_PICKER_OVERRIDING_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.resourcemerger.picker.overriding"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "merge.root", merge_root));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "merge.readOnly", merge_read_only));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_RESOURCEMERGER_PICKER_OVERRIDING_INFO } l_response.data ({ ORG_APACHE_SLING_RESOURCEMERGER_PICKER_OVERRIDING_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_scripting_core_impl_script_cache_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; org_apache_sling_scripting_cache_size: INTEGER_32; org_apache_sling_scripting_cache_additional_extensions: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_SCRIPTING_CORE_IMPL_SCRIPT_CACHE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: org_apache_sling_scripting_cache_size  (optional)
			-- 
			-- argument: org_apache_sling_scripting_cache_additional_extensions  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SCRIPTING_CORE_IMPL_SCRIPT_CACHE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.scripting.core.impl.ScriptCacheImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.scripting.cache.size", org_apache_sling_scripting_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.sling.scripting.cache.additional_extensions", org_apache_sling_scripting_cache_additional_extensions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SCRIPTING_CORE_IMPL_SCRIPT_CACHE_IMPL_INFO } l_response.data ({ ORG_APACHE_SLING_SCRIPTING_CORE_IMPL_SCRIPT_CACHE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_scripting_core_impl_scripting_resource_resolver_provider (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; log_stacktrace_onclose: BOOLEAN): detachable ORG_APACHE_SLING_SCRIPTING_CORE_IMPL_SCRIPTING_RESOURCE_RESOLVER_PROVIDER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: log_stacktrace_onclose  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SCRIPTING_CORE_IMPL_SCRIPTING_RESOURCE_RESOLVER_PROVIDER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.scripting.core.impl.ScriptingResourceResolverProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "log.stacktrace.onclose", log_stacktrace_onclose));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SCRIPTING_CORE_IMPL_SCRIPTING_RESOURCE_RESOLVER_PROVIDER_INFO } l_response.data ({ ORG_APACHE_SLING_SCRIPTING_CORE_IMPL_SCRIPTING_RESOURCE_RESOLVER_PROVIDER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_scripting_java_impl_java_script_engine_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; java_classdebuginfo: BOOLEAN; java_java_encoding: STRING_32; java_compiler_source_vm: STRING_32; java_compiler_target_vm: STRING_32): detachable ORG_APACHE_SLING_SCRIPTING_JAVA_IMPL_JAVA_SCRIPT_ENGINE_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: java_classdebuginfo  (optional)
			-- 
			-- argument: java_java_encoding  (optional)
			-- 
			-- argument: java_compiler_source_vm  (optional)
			-- 
			-- argument: java_compiler_target_vm  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SCRIPTING_JAVA_IMPL_JAVA_SCRIPT_ENGINE_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.scripting.java.impl.JavaScriptEngineFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "java.classdebuginfo", java_classdebuginfo));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "java.javaEncoding", java_java_encoding));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "java.compilerSourceVM", java_compiler_source_vm));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "java.compilerTargetVM", java_compiler_target_vm));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SCRIPTING_JAVA_IMPL_JAVA_SCRIPT_ENGINE_FACTORY_INFO } l_response.data ({ ORG_APACHE_SLING_SCRIPTING_JAVA_IMPL_JAVA_SCRIPT_ENGINE_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_scripting_javascript_internal_rhino_java_script_engine_fa (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; org_apache_sling_scripting_javascript_rhino_opt_level: INTEGER_32): detachable ORG_APACHE_SLING_SCRIPTING_JAVASCRIPT_INTERNAL_RHINO_JAVA_SCRIPT_ENGINE_FA_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: org_apache_sling_scripting_javascript_rhino_opt_level  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SCRIPTING_JAVASCRIPT_INTERNAL_RHINO_JAVA_SCRIPT_ENGINE_FA_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.scripting.javascript.internal.RhinoJavaScriptEngineFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.sling.scripting.javascript.rhino.optLevel", org_apache_sling_scripting_javascript_rhino_opt_level));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SCRIPTING_JAVASCRIPT_INTERNAL_RHINO_JAVA_SCRIPT_ENGINE_FA_INFO } l_response.data ({ ORG_APACHE_SLING_SCRIPTING_JAVASCRIPT_INTERNAL_RHINO_JAVA_SCRIPT_ENGINE_FA_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_scripting_jsp_jsp_script_engine_factory (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; jasper_compiler_target_vm: STRING_32; jasper_compiler_source_vm: STRING_32; jasper_classdebuginfo: BOOLEAN; jasper_enable_pooling: BOOLEAN; jasper_ie_class_id: STRING_32; jasper_gen_string_as_char_array: BOOLEAN; jasper_keepgenerated: BOOLEAN; jasper_mappedfile: BOOLEAN; jasper_trim_spaces: BOOLEAN; jasper_display_source_fragments: BOOLEAN; default_is_session: BOOLEAN): detachable ORG_APACHE_SLING_SCRIPTING_JSP_JSP_SCRIPT_ENGINE_FACTORY_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: jasper_compiler_target_vm  (optional)
			-- 
			-- argument: jasper_compiler_source_vm  (optional)
			-- 
			-- argument: jasper_classdebuginfo  (optional)
			-- 
			-- argument: jasper_enable_pooling  (optional)
			-- 
			-- argument: jasper_ie_class_id  (optional)
			-- 
			-- argument: jasper_gen_string_as_char_array  (optional)
			-- 
			-- argument: jasper_keepgenerated  (optional)
			-- 
			-- argument: jasper_mappedfile  (optional)
			-- 
			-- argument: jasper_trim_spaces  (optional)
			-- 
			-- argument: jasper_display_source_fragments  (optional)
			-- 
			-- argument: default_is_session  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SCRIPTING_JSP_JSP_SCRIPT_ENGINE_FACTORY_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.scripting.jsp.JspScriptEngineFactory"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jasper.compilerTargetVM", jasper_compiler_target_vm));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jasper.compilerSourceVM", jasper_compiler_source_vm));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jasper.classdebuginfo", jasper_classdebuginfo));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jasper.enablePooling", jasper_enable_pooling));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jasper.ieClassId", jasper_ie_class_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jasper.genStringAsCharArray", jasper_gen_string_as_char_array));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jasper.keepgenerated", jasper_keepgenerated));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jasper.mappedfile", jasper_mappedfile));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jasper.trimSpaces", jasper_trim_spaces));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jasper.displaySourceFragments", jasper_display_source_fragments));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.is.session", default_is_session));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SCRIPTING_JSP_JSP_SCRIPT_ENGINE_FACTORY_INFO } l_response.data ({ ORG_APACHE_SLING_SCRIPTING_JSP_JSP_SCRIPT_ENGINE_FACTORY_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_scripting_sightly_js_impl_jsapi_sly_bindings_values_prov (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; org_apache_sling_scripting_sightly_js_bindings: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_SCRIPTING_SIGHTLY_JS_IMPL_JSAPI_SLY_BINDINGS_VALUES_PROV_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: org_apache_sling_scripting_sightly_js_bindings  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SCRIPTING_SIGHTLY_JS_IMPL_JSAPI_SLY_BINDINGS_VALUES_PROV_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.scripting.sightly.js.impl.jsapi.SlyBindingsValuesProvider"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "org.apache.sling.scripting.sightly.js.bindings", org_apache_sling_scripting_sightly_js_bindings));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SCRIPTING_SIGHTLY_JS_IMPL_JSAPI_SLY_BINDINGS_VALUES_PROV_INFO } l_response.data ({ ORG_APACHE_SLING_SCRIPTING_SIGHTLY_JS_IMPL_JSAPI_SLY_BINDINGS_VALUES_PROV_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_security_impl_content_disposition_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_content_disposition_paths: detachable LIST [STRING_32]; sling_content_disposition_excluded_paths: detachable LIST [STRING_32]; sling_content_disposition_all_paths: BOOLEAN): detachable ORG_APACHE_SLING_SECURITY_IMPL_CONTENT_DISPOSITION_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_content_disposition_paths  (optional)
			-- 
			-- argument: sling_content_disposition_excluded_paths  (optional)
			-- 
			-- argument: sling_content_disposition_all_paths  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SECURITY_IMPL_CONTENT_DISPOSITION_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.security.impl.ContentDispositionFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.content.disposition.paths", sling_content_disposition_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.content.disposition.excluded.paths", sling_content_disposition_excluded_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.content.disposition.all.paths", sling_content_disposition_all_paths));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SECURITY_IMPL_CONTENT_DISPOSITION_FILTER_INFO } l_response.data ({ ORG_APACHE_SLING_SECURITY_IMPL_CONTENT_DISPOSITION_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_security_impl_referrer_filter (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; allow_empty: BOOLEAN; allow_hosts: detachable LIST [STRING_32]; allow_hosts_regexp: detachable LIST [STRING_32]; filter_methods: detachable LIST [STRING_32]; exclude_agents_regexp: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_SECURITY_IMPL_REFERRER_FILTER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: allow_empty  (optional)
			-- 
			-- argument: allow_hosts  (optional)
			-- 
			-- argument: allow_hosts_regexp  (optional)
			-- 
			-- argument: filter_methods  (optional)
			-- 
			-- argument: exclude_agents_regexp  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SECURITY_IMPL_REFERRER_FILTER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.security.impl.ReferrerFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "allow.empty", allow_empty));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "allow.hosts", allow_hosts));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "allow.hosts.regexp", allow_hosts_regexp));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "filter.methods", filter_methods));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "exclude.agents.regexp", exclude_agents_regexp));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SECURITY_IMPL_REFERRER_FILTER_INFO } l_response.data ({ ORG_APACHE_SLING_SECURITY_IMPL_REFERRER_FILTER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_serviceusermapping_impl_service_user_mapper_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; user_mapping: detachable LIST [STRING_32]; user_default: STRING_32; user_enable_default_mapping: BOOLEAN; require_validation: BOOLEAN): detachable ORG_APACHE_SLING_SERVICEUSERMAPPING_IMPL_SERVICE_USER_MAPPER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: user_mapping  (optional)
			-- 
			-- argument: user_default  (optional)
			-- 
			-- argument: user_enable_default_mapping  (optional)
			-- 
			-- argument: require_validation  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SERVICEUSERMAPPING_IMPL_SERVICE_USER_MAPPER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.serviceusermapping.impl.ServiceUserMapperImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "user.mapping", user_mapping));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user.default", user_default));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user.enable.default.mapping", user_enable_default_mapping));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "require.validation", require_validation));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SERVICEUSERMAPPING_IMPL_SERVICE_USER_MAPPER_IMPL_INFO } l_response.data ({ ORG_APACHE_SLING_SERVICEUSERMAPPING_IMPL_SERVICE_USER_MAPPER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_serviceusermapping_impl_service_user_mapper_impl_amended (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; service_ranking: INTEGER_32; user_mapping: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_SERVICEUSERMAPPING_IMPL_SERVICE_USER_MAPPER_IMPL_AMENDED_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: service_ranking  (optional)
			-- 
			-- argument: user_mapping  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SERVICEUSERMAPPING_IMPL_SERVICE_USER_MAPPER_IMPL_AMENDED_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.serviceusermapping.impl.ServiceUserMapperImpl.amended"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "user.mapping", user_mapping));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SERVICEUSERMAPPING_IMPL_SERVICE_USER_MAPPER_IMPL_AMENDED_INFO } l_response.data ({ ORG_APACHE_SLING_SERVICEUSERMAPPING_IMPL_SERVICE_USER_MAPPER_IMPL_AMENDED_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_servlets_get_default_get_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; aliases: detachable LIST [STRING_32]; index: BOOLEAN; index_files: detachable LIST [STRING_32]; enable_html: BOOLEAN; enable_json: BOOLEAN; enable_txt: BOOLEAN; enable_xml: BOOLEAN; json_maximumresults: INTEGER_32; ecma_suport: BOOLEAN): detachable ORG_APACHE_SLING_SERVLETS_GET_DEFAULT_GET_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: aliases  (optional)
			-- 
			-- argument: index  (optional)
			-- 
			-- argument: index_files  (optional)
			-- 
			-- argument: enable_html  (optional)
			-- 
			-- argument: enable_json  (optional)
			-- 
			-- argument: enable_txt  (optional)
			-- 
			-- argument: enable_xml  (optional)
			-- 
			-- argument: json_maximumresults  (optional)
			-- 
			-- argument: ecma_suport  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SERVLETS_GET_DEFAULT_GET_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.servlets.get.DefaultGetServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "aliases", aliases));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "index", index));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "index.files", index_files));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.html", enable_html));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.json", enable_json));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.txt", enable_txt));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.xml", enable_xml));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "json.maximumresults", json_maximumresults));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ecmaSuport", ecma_suport));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SERVLETS_GET_DEFAULT_GET_SERVLET_INFO } l_response.data ({ ORG_APACHE_SLING_SERVLETS_GET_DEFAULT_GET_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_servlets_get_impl_version_version_info_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_servlet_selectors: detachable LIST [STRING_32]; ecma_suport: BOOLEAN): detachable ORG_APACHE_SLING_SERVLETS_GET_IMPL_VERSION_VERSION_INFO_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_servlet_selectors  (optional)
			-- 
			-- argument: ecma_suport  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SERVLETS_GET_IMPL_VERSION_VERSION_INFO_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.servlets.get.impl.version.VersionInfoServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "sling.servlet.selectors", sling_servlet_selectors));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ecmaSuport", ecma_suport));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SERVLETS_GET_IMPL_VERSION_VERSION_INFO_SERVLET_INFO } l_response.data ({ ORG_APACHE_SLING_SERVLETS_GET_IMPL_VERSION_VERSION_INFO_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_servlets_post_impl_helper_chunk_clean_up_task (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; scheduler_expression: STRING_32; scheduler_concurrent: BOOLEAN; chunk_cleanup_age: INTEGER_32): detachable ORG_APACHE_SLING_SERVLETS_POST_IMPL_HELPER_CHUNK_CLEAN_UP_TASK_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: scheduler_expression  (optional)
			-- 
			-- argument: scheduler_concurrent  (optional)
			-- 
			-- argument: chunk_cleanup_age  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SERVLETS_POST_IMPL_HELPER_CHUNK_CLEAN_UP_TASK_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.servlets.post.impl.helper.ChunkCleanUpTask"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.expression", scheduler_expression));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "scheduler.concurrent", scheduler_concurrent));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "chunk.cleanup.age", chunk_cleanup_age));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SERVLETS_POST_IMPL_HELPER_CHUNK_CLEAN_UP_TASK_INFO } l_response.data ({ ORG_APACHE_SLING_SERVLETS_POST_IMPL_HELPER_CHUNK_CLEAN_UP_TASK_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_servlets_post_impl_sling_post_servlet (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; servlet_post_date_formats: detachable LIST [STRING_32]; servlet_post_node_name_hints: detachable LIST [STRING_32]; servlet_post_node_name_max_length: INTEGER_32; servlet_post_checkin_new_versionable_nodes: BOOLEAN; servlet_post_auto_checkout: BOOLEAN; servlet_post_auto_checkin: BOOLEAN; servlet_post_ignore_pattern: STRING_32): detachable ORG_APACHE_SLING_SERVLETS_POST_IMPL_SLING_POST_SERVLET_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: servlet_post_date_formats  (optional)
			-- 
			-- argument: servlet_post_node_name_hints  (optional)
			-- 
			-- argument: servlet_post_node_name_max_length  (optional)
			-- 
			-- argument: servlet_post_checkin_new_versionable_nodes  (optional)
			-- 
			-- argument: servlet_post_auto_checkout  (optional)
			-- 
			-- argument: servlet_post_auto_checkin  (optional)
			-- 
			-- argument: servlet_post_ignore_pattern  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SERVLETS_POST_IMPL_SLING_POST_SERVLET_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.servlets.post.impl.SlingPostServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "servlet.post.dateFormats", servlet_post_date_formats));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "servlet.post.nodeNameHints", servlet_post_node_name_hints));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "servlet.post.nodeNameMaxLength", servlet_post_node_name_max_length));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "servlet.post.checkinNewVersionableNodes", servlet_post_checkin_new_versionable_nodes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "servlet.post.autoCheckout", servlet_post_auto_checkout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "servlet.post.autoCheckin", servlet_post_auto_checkin));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "servlet.post.ignorePattern", servlet_post_ignore_pattern));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SERVLETS_POST_IMPL_SLING_POST_SERVLET_INFO } l_response.data ({ ORG_APACHE_SLING_SERVLETS_POST_IMPL_SLING_POST_SERVLET_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_servlets_resolver_sling_servlet_resolver (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; servletresolver_servlet_root: STRING_32; servletresolver_cache_size: INTEGER_32; servletresolver_paths: detachable LIST [STRING_32]; servletresolver_default_extensions: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_SERVLETS_RESOLVER_SLING_SERVLET_RESOLVER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: servletresolver_servlet_root  (optional)
			-- 
			-- argument: servletresolver_cache_size  (optional)
			-- 
			-- argument: servletresolver_paths  (optional)
			-- 
			-- argument: servletresolver_default_extensions  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SERVLETS_RESOLVER_SLING_SERVLET_RESOLVER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.servlets.resolver.SlingServletResolver"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "servletresolver.servletRoot", servletresolver_servlet_root));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "servletresolver.cacheSize", servletresolver_cache_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "servletresolver.paths", servletresolver_paths));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "servletresolver.defaultExtensions", servletresolver_default_extensions));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SERVLETS_RESOLVER_SLING_SERVLET_RESOLVER_INFO } l_response.data ({ ORG_APACHE_SLING_SERVLETS_RESOLVER_SLING_SERVLET_RESOLVER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_settings_impl_sling_settings_service_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; sling_name: STRING_32; sling_description: STRING_32): detachable ORG_APACHE_SLING_SETTINGS_IMPL_SLING_SETTINGS_SERVICE_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: sling_name  (optional)
			-- 
			-- argument: sling_description  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_SETTINGS_IMPL_SLING_SETTINGS_SERVICE_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.settings.impl.SlingSettingsServiceImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.name", sling_name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sling.description", sling_description));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_SETTINGS_IMPL_SLING_SETTINGS_SERVICE_IMPL_INFO } l_response.data ({ ORG_APACHE_SLING_SETTINGS_IMPL_SLING_SETTINGS_SERVICE_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_startupfilter_impl_startup_filter_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; active_by_default: BOOLEAN; default_message: STRING_32): detachable ORG_APACHE_SLING_STARTUPFILTER_IMPL_STARTUP_FILTER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: active_by_default  (optional)
			-- 
			-- argument: default_message  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_STARTUPFILTER_IMPL_STARTUP_FILTER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.startupfilter.impl.StartupFilterImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "active.by.default", active_by_default));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "default.message", default_message));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_STARTUPFILTER_IMPL_STARTUP_FILTER_IMPL_INFO } l_response.data ({ ORG_APACHE_SLING_STARTUPFILTER_IMPL_STARTUP_FILTER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_tenant_internal_tenant_provider_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; tenant_root: STRING_32; tenant_path_matcher: detachable LIST [STRING_32]): detachable ORG_APACHE_SLING_TENANT_INTERNAL_TENANT_PROVIDER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: tenant_root  (optional)
			-- 
			-- argument: tenant_path_matcher  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_TENANT_INTERNAL_TENANT_PROVIDER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.tenant.internal.TenantProviderImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "tenant.root", tenant_root));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "tenant.path.matcher", tenant_path_matcher));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_TENANT_INTERNAL_TENANT_PROVIDER_IMPL_INFO } l_response.data ({ ORG_APACHE_SLING_TENANT_INTERNAL_TENANT_PROVIDER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_tracer_internal_log_tracer (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; tracer_sets: detachable LIST [STRING_32]; enabled: BOOLEAN; servlet_enabled: BOOLEAN; recording_cache_size_in_mb: INTEGER_32; recording_cache_duration_in_secs: INTEGER_32; recording_compression_enabled: BOOLEAN; gzip_response: BOOLEAN): detachable ORG_APACHE_SLING_TRACER_INTERNAL_LOG_TRACER_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: tracer_sets  (optional)
			-- 
			-- argument: enabled  (optional)
			-- 
			-- argument: servlet_enabled  (optional)
			-- 
			-- argument: recording_cache_size_in_mb  (optional)
			-- 
			-- argument: recording_cache_duration_in_secs  (optional)
			-- 
			-- argument: recording_compression_enabled  (optional)
			-- 
			-- argument: gzip_response  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_TRACER_INTERNAL_LOG_TRACER_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.tracer.internal.LogTracer"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "tracerSets", tracer_sets));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enabled", enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "servletEnabled", servlet_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "recordingCacheSizeInMB", recording_cache_size_in_mb));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "recordingCacheDurationInSecs", recording_cache_duration_in_secs));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "recordingCompressionEnabled", recording_compression_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "gzipResponse", gzip_response));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_TRACER_INTERNAL_LOG_TRACER_INFO } l_response.data ({ ORG_APACHE_SLING_TRACER_INTERNAL_LOG_TRACER_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	org_apache_sling_xss_impl_xs_sfilter_impl (post: BOOLEAN; apply: BOOLEAN; delete: BOOLEAN; action: STRING_32; location: STRING_32; propertylist: detachable LIST [STRING_32]; policy_path: STRING_32): detachable ORG_APACHE_SLING_XSS_IMPL_XSS_FILTER_IMPL_INFO
			-- 
			-- 
			-- 
			-- argument: post  (optional)
			-- 
			-- argument: apply  (optional)
			-- 
			-- argument: delete  (optional)
			-- 
			-- argument: action  (optional)
			-- 
			-- argument: location  (optional)
			-- 
			-- argument: propertylist  (optional)
			-- 
			-- argument: policy_path  (optional)
			-- 
			-- 
			-- Result ORG_APACHE_SLING_XSS_IMPL_XSS_FILTER_IMPL_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/system/console/configMgr/org.apache.sling.xss.impl.XSSFilterImpl"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "post", post));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "apply", apply));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "delete", delete));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "action", action));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "$location", location));
			l_request.fill_query_params(api_client.parameter_to_tuple("csv", "propertylist", propertylist));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "policyPath", policy_path));


			if attached {STRING} api_client.select_header_accept (<<"application/json", "text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORG_APACHE_SLING_XSS_IMPL_XSS_FILTER_IMPL_INFO } l_response.data ({ ORG_APACHE_SLING_XSS_IMPL_XSS_FILTER_IMPL_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	


end
