package org.openapitools.client.api

import argonaut._
import argonaut.EncodeJson._
import argonaut.DecodeJson._

import java.io.File
import java.net.URLEncoder
import java.util.UUID

import org.http4s._
import org.http4s.{EntityDecoder, EntityEncoder}
import org.http4s.argonaut._
import org.http4s.client._
import org.http4s.client.blaze.PooledHttp1Client
import org.http4s.headers._

import org.joda.time.DateTime

import scalaz.concurrent.Task

import HelperCodecs._

object ConfigmgrApi {

  val client = PooledHttp1Client()

  def escape(value: String): String = URLEncoder.encode(value, "utf-8").replaceAll("\\+", "%20")

  def adaptiveFormAndInteractiveCommunicationWebChannelConfiguration(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], showPlaceholder: Boolean, maximumCacheEntries: Integer, afScriptingCompatversion: String, makeFileNameUnique: Boolean, generatingCompliantData: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], showPlaceholderQuery: QueryParam[Boolean], maximumCacheEntriesQuery: QueryParam[Integer], afScriptingCompatversionQuery: QueryParam[String], makeFileNameUniqueQuery: QueryParam[Boolean], generatingCompliantDataQuery: QueryParam[Boolean]): Task[AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo] = jsonOf[AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo]

    val path = "/system/console/configMgr/Adaptive Form and Interactive Communication Web Channel Configuration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("showPlaceholder", Some(showPlaceholderQuery.toParamString(showPlaceholder))), ("maximumCacheEntries", Some(maximumCacheEntriesQuery.toParamString(maximumCacheEntries))), ("afScriptingCompatversion", Some(af.scripting.compatversionQuery.toParamString(af.scripting.compatversion))), ("makeFileNameUnique", Some(makeFileNameUniqueQuery.toParamString(makeFileNameUnique))), ("generatingCompliantData", Some(generatingCompliantDataQuery.toParamString(generatingCompliantData))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo](req)

    } yield resp
  }
  
  def adaptiveFormAndInteractiveCommunicationWebChannelThemeConfigur(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fontList: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fontListQuery: QueryParam[List[String]]): Task[AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo] = jsonOf[AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo]

    val path = "/system/console/configMgr/Adaptive Form and Interactive Communication Web Channel Theme Configuration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fontList", Some(fontListQuery.toParamString(fontList))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo](req)

    } yield resp
  }
  
  def analyticsComponentQueryCacheService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsComponentQueryCacheSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsComponentQueryCacheSizeQuery: QueryParam[Integer]): Task[AnalyticsComponentQueryCacheServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[AnalyticsComponentQueryCacheServiceInfo] = jsonOf[AnalyticsComponentQueryCacheServiceInfo]

    val path = "/system/console/configMgr/Analytics Component Query Cache Service"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsComponentQueryCacheSize", Some(cq.analytics.component.query.cache.sizeQuery.toParamString(cq.analytics.component.query.cache.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[AnalyticsComponentQueryCacheServiceInfo](req)

    } yield resp
  }
  
  def apacheSlingHealthCheckResultHTMLSerializer(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], styleString: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], styleStringQuery: QueryParam[String]): Task[ApacheSlingHealthCheckResultHTMLSerializerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ApacheSlingHealthCheckResultHTMLSerializerInfo] = jsonOf[ApacheSlingHealthCheckResultHTMLSerializerInfo]

    val path = "/system/console/configMgr/Apache Sling Health Check Result HTML Serializer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("styleString", Some(styleStringQuery.toParamString(styleString))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ApacheSlingHealthCheckResultHTMLSerializerInfo](req)

    } yield resp
  }
  
  def comAdobeAemFormsndocumentsConfigAEMFormsManagerConfiguration(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], formsManagerConfigIncludeOOTBTemplates: Boolean, formsManagerConfigIncludeDeprecatedTemplates: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], formsManagerConfigIncludeOOTBTemplatesQuery: QueryParam[Boolean], formsManagerConfigIncludeDeprecatedTemplatesQuery: QueryParam[Boolean]): Task[ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo] = jsonOf[ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo]

    val path = "/system/console/configMgr/com.adobe.aem.formsndocuments.config.AEMFormsManagerConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("formsManagerConfigIncludeOOTBTemplates", Some(formsManagerConfig.includeOOTBTemplatesQuery.toParamString(formsManagerConfig.includeOOTBTemplates))), ("formsManagerConfigIncludeDeprecatedTemplates", Some(formsManagerConfig.includeDeprecatedTemplatesQuery.toParamString(formsManagerConfig.includeDeprecatedTemplates))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo](req)

    } yield resp
  }
  
  def comAdobeAemTransactionCoreImplTransactionRecorder(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], isTransactionRecordingEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], isTransactionRecordingEnabledQuery: QueryParam[Boolean]): Task[ComAdobeAemTransactionCoreImplTransactionRecorderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeAemTransactionCoreImplTransactionRecorderInfo] = jsonOf[ComAdobeAemTransactionCoreImplTransactionRecorderInfo]

    val path = "/system/console/configMgr/com.adobe.aem.transaction.core.impl.TransactionRecorder"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("isTransactionRecordingEnabled", Some(isTransactionRecordingEnabledQuery.toParamString(isTransactionRecordingEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeAemTransactionCoreImplTransactionRecorderInfo](req)

    } yield resp
  }
  
  def comAdobeAemUpgradePrechecksHcImplDeprecateIndexesHC(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String]): Task[ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo] = jsonOf[ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo]

    val path = "/system/console/configMgr/com.adobe.aem.upgrade.prechecks.hc.impl.DeprecateIndexesHC"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo](req)

    } yield resp
  }
  
  def comAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHC(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String]): Task[ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo] = jsonOf[ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo]

    val path = "/system/console/configMgr/com.adobe.aem.upgrade.prechecks.hc.impl.ReplicationAgentsDisabledHC"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo](req)

    } yield resp
  }
  
  def comAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], preUpgradeMaintenanceTasks: List[String], preUpgradeHcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], preUpgradeMaintenanceTasksQuery: QueryParam[List[String]], preUpgradeHcTagsQuery: QueryParam[List[String]]): Task[ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo] = jsonOf[ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo]

    val path = "/system/console/configMgr/com.adobe.aem.upgrade.prechecks.mbean.impl.PreUpgradeTasksMBeanImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("preUpgradeMaintenanceTasks", Some(pre-upgrade.maintenance.tasksQuery.toParamString(pre-upgrade.maintenance.tasks))), ("preUpgradeHcTags", Some(pre-upgrade.hc.tagsQuery.toParamString(pre-upgrade.hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo](req)

    } yield resp
  }
  
  def comAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], rootPath: String, fixInconsistencies: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], rootPathQuery: QueryParam[String], fixInconsistenciesQuery: QueryParam[Boolean]): Task[ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo] = jsonOf[ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo]

    val path = "/system/console/configMgr/com.adobe.aem.upgrade.prechecks.tasks.impl.ConsistencyCheckTaskImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("rootPath", Some(root.pathQuery.toParamString(root.path))), ("fixInconsistencies", Some(fix.inconsistenciesQuery.toParamString(fix.inconsistencies))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqAccountApiAccountManagementService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAccountmanagerTokenValidityPeriod: Integer, cqAccountmanagerConfigRequestnewaccountMail: String, cqAccountmanagerConfigRequestnewpwdMail: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAccountmanagerTokenValidityPeriodQuery: QueryParam[Integer], cqAccountmanagerConfigRequestnewaccountMailQuery: QueryParam[String], cqAccountmanagerConfigRequestnewpwdMailQuery: QueryParam[String]): Task[ComAdobeCqAccountApiAccountManagementServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqAccountApiAccountManagementServiceInfo] = jsonOf[ComAdobeCqAccountApiAccountManagementServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.account.api.AccountManagementService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAccountmanagerTokenValidityPeriod", Some(cq.accountmanager.token.validity.periodQuery.toParamString(cq.accountmanager.token.validity.period))), ("cqAccountmanagerConfigRequestnewaccountMail", Some(cq.accountmanager.config.requestnewaccount.mailQuery.toParamString(cq.accountmanager.config.requestnewaccount.mail))), ("cqAccountmanagerConfigRequestnewpwdMail", Some(cq.accountmanager.config.requestnewpwd.mailQuery.toParamString(cq.accountmanager.config.requestnewpwd.mail))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqAccountApiAccountManagementServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqAccountImplAccountManagementServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAccountmanagerConfigInformnewaccountMail: String, cqAccountmanagerConfigInformnewpwdMail: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAccountmanagerConfigInformnewaccountMailQuery: QueryParam[String], cqAccountmanagerConfigInformnewpwdMailQuery: QueryParam[String]): Task[ComAdobeCqAccountImplAccountManagementServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqAccountImplAccountManagementServletInfo] = jsonOf[ComAdobeCqAccountImplAccountManagementServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.account.impl.AccountManagementServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAccountmanagerConfigInformnewaccountMail", Some(cq.accountmanager.config.informnewaccount.mailQuery.toParamString(cq.accountmanager.config.informnewaccount.mail))), ("cqAccountmanagerConfigInformnewpwdMail", Some(cq.accountmanager.config.informnewpwd.mailQuery.toParamString(cq.accountmanager.config.informnewpwd.mail))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqAccountImplAccountManagementServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqAddressImplLocationLocationListServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAddressLocationDefaultMaxResults: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAddressLocationDefaultMaxResultsQuery: QueryParam[Integer]): Task[ComAdobeCqAddressImplLocationLocationListServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqAddressImplLocationLocationListServletInfo] = jsonOf[ComAdobeCqAddressImplLocationLocationListServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.address.impl.location.LocationListServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAddressLocationDefaultMaxResults", Some(cq.address.location.default.maxResultsQuery.toParamString(cq.address.location.default.maxResults))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqAddressImplLocationLocationListServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqAuditPurgeDam(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], auditlogRuleName: String, auditlogRuleContentpath: String, auditlogRuleMinimumage: Integer, auditlogRuleTypes: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], auditlogRuleNameQuery: QueryParam[String], auditlogRuleContentpathQuery: QueryParam[String], auditlogRuleMinimumageQuery: QueryParam[Integer], auditlogRuleTypesQuery: QueryParam[String]): Task[ComAdobeCqAuditPurgeDamInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqAuditPurgeDamInfo] = jsonOf[ComAdobeCqAuditPurgeDamInfo]

    val path = "/system/console/configMgr/com.adobe.cq.audit.purge.Dam"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("auditlogRuleName", Some(auditlog.rule.nameQuery.toParamString(auditlog.rule.name))), ("auditlogRuleContentpath", Some(auditlog.rule.contentpathQuery.toParamString(auditlog.rule.contentpath))), ("auditlogRuleMinimumage", Some(auditlog.rule.minimumageQuery.toParamString(auditlog.rule.minimumage))), ("auditlogRuleTypes", Some(auditlog.rule.typesQuery.toParamString(auditlog.rule.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqAuditPurgeDamInfo](req)

    } yield resp
  }
  
  def comAdobeCqAuditPurgePages(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], auditlogRuleName: String, auditlogRuleContentpath: String, auditlogRuleMinimumage: Integer, auditlogRuleTypes: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], auditlogRuleNameQuery: QueryParam[String], auditlogRuleContentpathQuery: QueryParam[String], auditlogRuleMinimumageQuery: QueryParam[Integer], auditlogRuleTypesQuery: QueryParam[String]): Task[ComAdobeCqAuditPurgePagesInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqAuditPurgePagesInfo] = jsonOf[ComAdobeCqAuditPurgePagesInfo]

    val path = "/system/console/configMgr/com.adobe.cq.audit.purge.Pages"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("auditlogRuleName", Some(auditlog.rule.nameQuery.toParamString(auditlog.rule.name))), ("auditlogRuleContentpath", Some(auditlog.rule.contentpathQuery.toParamString(auditlog.rule.contentpath))), ("auditlogRuleMinimumage", Some(auditlog.rule.minimumageQuery.toParamString(auditlog.rule.minimumage))), ("auditlogRuleTypes", Some(auditlog.rule.typesQuery.toParamString(auditlog.rule.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqAuditPurgePagesInfo](req)

    } yield resp
  }
  
  def comAdobeCqAuditPurgeReplication(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], auditlogRuleName: String, auditlogRuleContentpath: String, auditlogRuleMinimumage: Integer, auditlogRuleTypes: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], auditlogRuleNameQuery: QueryParam[String], auditlogRuleContentpathQuery: QueryParam[String], auditlogRuleMinimumageQuery: QueryParam[Integer], auditlogRuleTypesQuery: QueryParam[String]): Task[ComAdobeCqAuditPurgeReplicationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqAuditPurgeReplicationInfo] = jsonOf[ComAdobeCqAuditPurgeReplicationInfo]

    val path = "/system/console/configMgr/com.adobe.cq.audit.purge.Replication"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("auditlogRuleName", Some(auditlog.rule.nameQuery.toParamString(auditlog.rule.name))), ("auditlogRuleContentpath", Some(auditlog.rule.contentpathQuery.toParamString(auditlog.rule.contentpath))), ("auditlogRuleMinimumage", Some(auditlog.rule.minimumageQuery.toParamString(auditlog.rule.minimumage))), ("auditlogRuleTypes", Some(auditlog.rule.typesQuery.toParamString(auditlog.rule.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqAuditPurgeReplicationInfo](req)

    } yield resp
  }
  
  def comAdobeCqCdnRewriterImplAWSCloudFrontRewriter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, keypairId: String, keypairAlias: String, cdnrewriterAttributes: List[String], cdnRewriterDistributionDomain: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], keypairIdQuery: QueryParam[String], keypairAliasQuery: QueryParam[String], cdnrewriterAttributesQuery: QueryParam[List[String]], cdnRewriterDistributionDomainQuery: QueryParam[String]): Task[ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo] = jsonOf[ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.AWSCloudFrontRewriter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("keypairId", Some(keypair.idQuery.toParamString(keypair.id))), ("keypairAlias", Some(keypair.aliasQuery.toParamString(keypair.alias))), ("cdnrewriterAttributes", Some(cdnrewriter.attributesQuery.toParamString(cdnrewriter.attributes))), ("cdnRewriterDistributionDomain", Some(cdn.rewriter.distribution.domainQuery.toParamString(cdn.rewriter.distribution.domain))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo](req)

    } yield resp
  }
  
  def comAdobeCqCdnRewriterImplCDNConfigServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cdnConfigDistributionDomain: String, cdnConfigEnableRewriting: Boolean, cdnConfigPathPrefixes: List[String], cdnConfigCdnttl: Integer, cdnConfigApplicationProtocol: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cdnConfigDistributionDomainQuery: QueryParam[String], cdnConfigEnableRewritingQuery: QueryParam[Boolean], cdnConfigPathPrefixesQuery: QueryParam[List[String]], cdnConfigCdnttlQuery: QueryParam[Integer], cdnConfigApplicationProtocolQuery: QueryParam[String]): Task[ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo] = jsonOf[ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.CDNConfigServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cdnConfigDistributionDomain", Some(cdn.config.distribution.domainQuery.toParamString(cdn.config.distribution.domain))), ("cdnConfigEnableRewriting", Some(cdn.config.enable.rewritingQuery.toParamString(cdn.config.enable.rewriting))), ("cdnConfigPathPrefixes", Some(cdn.config.path.prefixesQuery.toParamString(cdn.config.path.prefixes))), ("cdnConfigCdnttl", Some(cdn.config.cdnttlQuery.toParamString(cdn.config.cdnttl))), ("cdnConfigApplicationProtocol", Some(cdn.config.application.protocolQuery.toParamString(cdn.config.application.protocol))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqCdnRewriterImplCDNRewriter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, cdnrewriterAttributes: List[String], cdnRewriterDistributionDomain: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], cdnrewriterAttributesQuery: QueryParam[List[String]], cdnRewriterDistributionDomainQuery: QueryParam[String]): Task[ComAdobeCqCdnRewriterImplCDNRewriterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCdnRewriterImplCDNRewriterInfo] = jsonOf[ComAdobeCqCdnRewriterImplCDNRewriterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.CDNRewriter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("cdnrewriterAttributes", Some(cdnrewriter.attributesQuery.toParamString(cdnrewriter.attributes))), ("cdnRewriterDistributionDomain", Some(cdn.rewriter.distribution.domainQuery.toParamString(cdn.rewriter.distribution.domain))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCdnRewriterImplCDNRewriterInfo](req)

    } yield resp
  }
  
  def comAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandle(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], flushAgents: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], flushAgentsQuery: QueryParam[List[String]]): Task[ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo] = jsonOf[ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo]

    val path = "/system/console/configMgr/com.adobe.cq.cloudconfig.core.impl.ConfigurationReplicationEventHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("flushAgents", Some(flush.agentsQuery.toParamString(flush.agents))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommerceImplAssetDynamicImageHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommerceAssetHandlerActive: Boolean, cqCommerceAssetHandlerName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommerceAssetHandlerActiveQuery: QueryParam[Boolean], cqCommerceAssetHandlerNameQuery: QueryParam[String]): Task[ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo] = jsonOf[ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.impl.asset.DynamicImageHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommerceAssetHandlerActive", Some(cq.commerce.asset.handler.activeQuery.toParamString(cq.commerce.asset.handler.active))), ("cqCommerceAssetHandlerName", Some(cq.commerce.asset.handler.nameQuery.toParamString(cq.commerce.asset.handler.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommerceImplAssetProductAssetHandlerProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommerceAssetHandlerFallback: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommerceAssetHandlerFallbackQuery: QueryParam[String]): Task[ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo] = jsonOf[ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.impl.asset.ProductAssetHandlerProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommerceAssetHandlerFallback", Some(cq.commerce.asset.handler.fallbackQuery.toParamString(cq.commerce.asset.handler.fallback))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommerceImplAssetStaticImageHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommerceAssetHandlerActive: Boolean, cqCommerceAssetHandlerName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommerceAssetHandlerActiveQuery: QueryParam[Boolean], cqCommerceAssetHandlerNameQuery: QueryParam[String]): Task[ComAdobeCqCommerceImplAssetStaticImageHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommerceImplAssetStaticImageHandlerInfo] = jsonOf[ComAdobeCqCommerceImplAssetStaticImageHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.impl.asset.StaticImageHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommerceAssetHandlerActive", Some(cq.commerce.asset.handler.activeQuery.toParamString(cq.commerce.asset.handler.active))), ("cqCommerceAssetHandlerName", Some(cq.commerce.asset.handler.nameQuery.toParamString(cq.commerce.asset.handler.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommerceImplAssetStaticImageHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommerceImplAssetVideoHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommerceAssetHandlerActive: Boolean, cqCommerceAssetHandlerName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommerceAssetHandlerActiveQuery: QueryParam[Boolean], cqCommerceAssetHandlerNameQuery: QueryParam[String]): Task[ComAdobeCqCommerceImplAssetVideoHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommerceImplAssetVideoHandlerInfo] = jsonOf[ComAdobeCqCommerceImplAssetVideoHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.impl.asset.VideoHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommerceAssetHandlerActive", Some(cq.commerce.asset.handler.activeQuery.toParamString(cq.commerce.asset.handler.active))), ("cqCommerceAssetHandlerName", Some(cq.commerce.asset.handler.nameQuery.toParamString(cq.commerce.asset.handler.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommerceImplAssetVideoHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommerceImplPromotionPromotionManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommercePromotionRoot: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommercePromotionRootQuery: QueryParam[String]): Task[ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo] = jsonOf[ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.impl.promotion.PromotionManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommercePromotionRoot", Some(cq.commerce.promotion.rootQuery.toParamString(cq.commerce.promotion.root))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommerceCataloggeneratorBucketsize: Integer, cqCommerceCataloggeneratorBucketname: String, cqCommerceCataloggeneratorExcludedtemplateproperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommerceCataloggeneratorBucketsizeQuery: QueryParam[Integer], cqCommerceCataloggeneratorBucketnameQuery: QueryParam[String], cqCommerceCataloggeneratorExcludedtemplatepropertiesQuery: QueryParam[List[String]]): Task[ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo] = jsonOf[ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.pim.impl.cataloggenerator.CatalogGeneratorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommerceCataloggeneratorBucketsize", Some(cq.commerce.cataloggenerator.bucketsizeQuery.toParamString(cq.commerce.cataloggenerator.bucketsize))), ("cqCommerceCataloggeneratorBucketname", Some(cq.commerce.cataloggenerator.bucketnameQuery.toParamString(cq.commerce.cataloggenerator.bucketname))), ("cqCommerceCataloggeneratorExcludedtemplateproperties", Some(cq.commerce.cataloggenerator.excludedtemplatepropertiesQuery.toParamString(cq.commerce.cataloggenerator.excludedtemplateproperties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommercePimImplPageEventListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommercePageeventlistenerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommercePageeventlistenerEnabledQuery: QueryParam[Boolean]): Task[ComAdobeCqCommercePimImplPageEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommercePimImplPageEventListenerInfo] = jsonOf[ComAdobeCqCommercePimImplPageEventListenerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.pim.impl.PageEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommercePageeventlistenerEnabled", Some(cq.commerce.pageeventlistener.enabledQuery.toParamString(cq.commerce.pageeventlistener.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommercePimImplPageEventListenerInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommercePimImplProductfeedProductFeedServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], feedGeneratorAlgorithm: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], feedGeneratorAlgorithmQuery: QueryParam[String]): Task[ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo] = jsonOf[ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.pim.impl.productfeed.ProductFeedServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("feedGeneratorAlgorithm", Some(Feed generator algorithmQuery.toParamString(Feed generator algorithm))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqContentinsightImplReportingServicesSettingsProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], reportingservicesUrl: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], reportingservicesUrlQuery: QueryParam[String]): Task[ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo] = jsonOf[ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.contentinsight.impl.ReportingServicesSettingsProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("reportingservicesUrl", Some(reportingservices.urlQuery.toParamString(reportingservices.url))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqContentinsightImplServletsBrightEdgeProxyServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], brightedgeUrl: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], brightedgeUrlQuery: QueryParam[String]): Task[ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo] = jsonOf[ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.contentinsight.impl.servlets.BrightEdgeProxyServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("brightedgeUrl", Some(brightedge.urlQuery.toParamString(brightedge.url))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqContentinsightImplServletsReportingServicesProxyServle(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], reportingservicesProxyWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], reportingservicesProxyWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo] = jsonOf[ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo]

    val path = "/system/console/configMgr/com.adobe.cq.contentinsight.impl.servlets.ReportingServicesProxyServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("reportingservicesProxyWhitelist", Some(reportingservices.proxy.whitelistQuery.toParamString(reportingservices.proxy.whitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamCfmImplComponentComponentConfigImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], damCfmComponentResourceType: String, damCfmComponentFileReferenceProp: String, damCfmComponentElementsProp: String, damCfmComponentVariationProp: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], damCfmComponentResourceTypeQuery: QueryParam[String], damCfmComponentFileReferencePropQuery: QueryParam[String], damCfmComponentElementsPropQuery: QueryParam[String], damCfmComponentVariationPropQuery: QueryParam[String]): Task[ComAdobeCqDamCfmImplComponentComponentConfigImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamCfmImplComponentComponentConfigImplInfo] = jsonOf[ComAdobeCqDamCfmImplComponentComponentConfigImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.component.ComponentConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("damCfmComponentResourceType", Some(dam.cfm.component.resourceTypeQuery.toParamString(dam.cfm.component.resourceType))), ("damCfmComponentFileReferenceProp", Some(dam.cfm.component.fileReferencePropQuery.toParamString(dam.cfm.component.fileReferenceProp))), ("damCfmComponentElementsProp", Some(dam.cfm.component.elementsPropQuery.toParamString(dam.cfm.component.elementsProp))), ("damCfmComponentVariationProp", Some(dam.cfm.component.variationPropQuery.toParamString(dam.cfm.component.variationProp))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamCfmImplComponentComponentConfigImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamCfmImplConfFeatureConfigImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], damCfmResourceTypes: List[String], damCfmReferenceProperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], damCfmResourceTypesQuery: QueryParam[List[String]], damCfmReferencePropertiesQuery: QueryParam[List[String]]): Task[ComAdobeCqDamCfmImplConfFeatureConfigImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamCfmImplConfFeatureConfigImplInfo] = jsonOf[ComAdobeCqDamCfmImplConfFeatureConfigImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.conf.FeatureConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("damCfmResourceTypes", Some(dam.cfm.resourceTypesQuery.toParamString(dam.cfm.resourceTypes))), ("damCfmReferenceProperties", Some(dam.cfm.referencePropertiesQuery.toParamString(dam.cfm.referenceProperties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamCfmImplConfFeatureConfigImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamCfmImplContentRewriterAssetProcessor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pipelineType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pipelineTypeQuery: QueryParam[String]): Task[ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo] = jsonOf[ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.AssetProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pipelineType", Some(pipeline.typeQuery.toParamString(pipeline.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamCfmImplContentRewriterParRangeFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pipelineType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pipelineTypeQuery: QueryParam[String]): Task[ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo] = jsonOf[ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.ParRangeFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pipelineType", Some(pipeline.typeQuery.toParamString(pipeline.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamCfmImplContentRewriterPayloadFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pipelineType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pipelineTypeQuery: QueryParam[String]): Task[ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo] = jsonOf[ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.PayloadFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pipelineType", Some(pipeline.typeQuery.toParamString(pipeline.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamDmProcessImagePTiffManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxMemory: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxMemoryQuery: QueryParam[Integer]): Task[ComAdobeCqDamDmProcessImagePTiffManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamDmProcessImagePTiffManagerImplInfo] = jsonOf[ComAdobeCqDamDmProcessImagePTiffManagerImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.dm.process.image.PTiffManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxMemory", Some(maxMemoryQuery.toParamString(maxMemory))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamDmProcessImagePTiffManagerImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorker(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], dmreplicateonmodifyEnabled: Boolean, dmreplicateonmodifyForcesyncdeletes: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], dmreplicateonmodifyEnabledQuery: QueryParam[Boolean], dmreplicateonmodifyForcesyncdeletesQuery: QueryParam[Boolean]): Task[ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo] = jsonOf[ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.ips.impl.replication.trigger.ReplicateOnModifyWorker"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("dmreplicateonmodifyEnabled", Some(dmreplicateonmodify.enabledQuery.toParamString(dmreplicateonmodify.enabled))), ("dmreplicateonmodifyForcesyncdeletes", Some(dmreplicateonmodify.forcesyncdeletesQuery.toParamString(dmreplicateonmodify.forcesyncdeletes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamMacSyncHelperImplMACSyncClientImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeDamMacSyncClientSoTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeDamMacSyncClientSoTimeoutQuery: QueryParam[Integer]): Task[ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo] = jsonOf[ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.mac.sync.helper.impl.MACSyncClientImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeDamMacSyncClientSoTimeout", Some(com.adobe.dam.mac.sync.client.so.timeoutQuery.toParamString(com.adobe.dam.mac.sync.client.so.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamMacSyncImplDAMSyncServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeCqDamMacSyncDamsyncserviceRegisteredPaths: List[String], comAdobeCqDamMacSyncDamsyncserviceSyncRenditions: Boolean, comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMs: Integer, comAdobeCqDamMacSyncDamsyncservicePlatform: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeCqDamMacSyncDamsyncserviceRegisteredPathsQuery: QueryParam[List[String]], comAdobeCqDamMacSyncDamsyncserviceSyncRenditionsQuery: QueryParam[Boolean], comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMsQuery: QueryParam[Integer], comAdobeCqDamMacSyncDamsyncservicePlatformQuery: QueryParam[String]): Task[ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo] = jsonOf[ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.mac.sync.impl.DAMSyncServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeCqDamMacSyncDamsyncserviceRegisteredPaths", Some(com.adobe.cq.dam.mac.sync.damsyncservice.registered_pathsQuery.toParamString(com.adobe.cq.dam.mac.sync.damsyncservice.registered_paths))), ("comAdobeCqDamMacSyncDamsyncserviceSyncRenditions", Some(com.adobe.cq.dam.mac.sync.damsyncservice.sync.renditionsQuery.toParamString(com.adobe.cq.dam.mac.sync.damsyncservice.sync.renditions))), ("comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMs", Some(com.adobe.cq.dam.mac.sync.damsyncservice.replicate.thread.wait.msQuery.toParamString(com.adobe.cq.dam.mac.sync.damsyncservice.replicate.thread.wait.ms))), ("comAdobeCqDamMacSyncDamsyncservicePlatform", Some(com.adobe.cq.dam.mac.sync.damsyncservice.platformQuery.toParamString(com.adobe.cq.dam.mac.sync.damsyncservice.platform))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamProcessorNuiImplNuiAssetProcessor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], nuiEnabled: Boolean, nuiServiceUrl: String, nuiApiKey: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nuiEnabledQuery: QueryParam[Boolean], nuiServiceUrlQuery: QueryParam[String], nuiApiKeyQuery: QueryParam[String]): Task[ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo] = jsonOf[ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.processor.nui.impl.NuiAssetProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("nuiEnabled", Some(nuiEnabledQuery.toParamString(nuiEnabled))), ("nuiServiceUrl", Some(nuiServiceUrlQuery.toParamString(nuiServiceUrl))), ("nuiApiKey", Some(nuiApiKeyQuery.toParamString(nuiApiKey))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamS7imagingImplIsImageServerComponent(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], tcpPort: String, allowRemoteAccess: Boolean, maxRenderRgnPixels: String, maxMessageSize: String, randomAccessUrlTimeout: Integer, workerThreads: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], tcpPortQuery: QueryParam[String], allowRemoteAccessQuery: QueryParam[Boolean], maxRenderRgnPixelsQuery: QueryParam[String], maxMessageSizeQuery: QueryParam[String], randomAccessUrlTimeoutQuery: QueryParam[Integer], workerThreadsQuery: QueryParam[Integer]): Task[ComAdobeCqDamS7imagingImplIsImageServerComponentInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamS7imagingImplIsImageServerComponentInfo] = jsonOf[ComAdobeCqDamS7imagingImplIsImageServerComponentInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.s7imaging.impl.is.ImageServerComponent"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("tcpPort", Some(TcpPortQuery.toParamString(TcpPort))), ("allowRemoteAccess", Some(AllowRemoteAccessQuery.toParamString(AllowRemoteAccess))), ("maxRenderRgnPixels", Some(MaxRenderRgnPixelsQuery.toParamString(MaxRenderRgnPixels))), ("maxMessageSize", Some(MaxMessageSizeQuery.toParamString(MaxMessageSize))), ("randomAccessUrlTimeout", Some(RandomAccessUrlTimeoutQuery.toParamString(RandomAccessUrlTimeout))), ("workerThreads", Some(WorkerThreadsQuery.toParamString(WorkerThreads))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamS7imagingImplIsImageServerComponentInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamS7imagingImplPsPlatformServerServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cacheEnable: Boolean, cacheRootPaths: List[String], cacheMaxSize: Integer, cacheMaxEntries: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cacheEnableQuery: QueryParam[Boolean], cacheRootPathsQuery: QueryParam[List[String]], cacheMaxSizeQuery: QueryParam[Integer], cacheMaxEntriesQuery: QueryParam[Integer]): Task[ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo] = jsonOf[ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.s7imaging.impl.ps.PlatformServerServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cacheEnable", Some(cache.enableQuery.toParamString(cache.enable))), ("cacheRootPaths", Some(cache.rootPathsQuery.toParamString(cache.rootPaths))), ("cacheMaxSize", Some(cache.maxSizeQuery.toParamString(cache.maxSize))), ("cacheMaxEntries", Some(cache.maxEntriesQuery.toParamString(cache.maxEntries))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamWebdavImplIoAssetIOHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, pathPrefix: String, createVersion: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], pathPrefixQuery: QueryParam[String], createVersionQuery: QueryParam[Boolean]): Task[ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo] = jsonOf[ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.AssetIOHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("pathPrefix", Some(pathPrefixQuery.toParamString(pathPrefix))), ("createVersion", Some(createVersionQuery.toParamString(createVersion))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJob(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamWebdavVersionLinkingEnable: Boolean, cqDamWebdavVersionLinkingSchedulerPeriod: Integer, cqDamWebdavVersionLinkingStagingTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamWebdavVersionLinkingEnableQuery: QueryParam[Boolean], cqDamWebdavVersionLinkingSchedulerPeriodQuery: QueryParam[Integer], cqDamWebdavVersionLinkingStagingTimeoutQuery: QueryParam[Integer]): Task[ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo] = jsonOf[ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.DamWebdavVersionLinkingJob"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamWebdavVersionLinkingEnable", Some(cq.dam.webdav.version.linking.enableQuery.toParamString(cq.dam.webdav.version.linking.enable))), ("cqDamWebdavVersionLinkingSchedulerPeriod", Some(cq.dam.webdav.version.linking.scheduler.periodQuery.toParamString(cq.dam.webdav.version.linking.scheduler.period))), ("cqDamWebdavVersionLinkingStagingTimeout", Some(cq.dam.webdav.version.linking.staging.timeoutQuery.toParamString(cq.dam.webdav.version.linking.staging.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamWebdavImplIoSpecialFilesHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comDayCqDamCoreImplIoSpecialFilesHandlerFilepatters: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comDayCqDamCoreImplIoSpecialFilesHandlerFilepattersQuery: QueryParam[List[String]]): Task[ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo] = jsonOf[ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.SpecialFilesHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comDayCqDamCoreImplIoSpecialFilesHandlerFilepatters", Some(com.day.cq.dam.core.impl.io.SpecialFilesHandler.filepattersQuery.toParamString(com.day.cq.dam.core.impl.io.SpecialFilesHandler.filepatters))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqDeserfwImplDeserializationFirewallImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], firewallDeserializationWhitelist: List[String], firewallDeserializationBlacklist: List[String], firewallDeserializationDiagnostics: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], firewallDeserializationWhitelistQuery: QueryParam[List[String]], firewallDeserializationBlacklistQuery: QueryParam[List[String]], firewallDeserializationDiagnosticsQuery: QueryParam[String]): Task[ComAdobeCqDeserfwImplDeserializationFirewallImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDeserfwImplDeserializationFirewallImplInfo] = jsonOf[ComAdobeCqDeserfwImplDeserializationFirewallImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.deserfw.impl.DeserializationFirewallImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("firewallDeserializationWhitelist", Some(firewall.deserialization.whitelistQuery.toParamString(firewall.deserialization.whitelist))), ("firewallDeserializationBlacklist", Some(firewall.deserialization.blacklistQuery.toParamString(firewall.deserialization.blacklist))), ("firewallDeserializationDiagnostics", Some(firewall.deserialization.diagnosticsQuery.toParamString(firewall.deserialization.diagnostics))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDeserfwImplDeserializationFirewallImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDtmImplServiceDTMWebServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], connectionTimeout: Integer, socketTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], connectionTimeoutQuery: QueryParam[Integer], socketTimeoutQuery: QueryParam[Integer]): Task[ComAdobeCqDtmImplServiceDTMWebServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDtmImplServiceDTMWebServiceImplInfo] = jsonOf[ComAdobeCqDtmImplServiceDTMWebServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dtm.impl.service.DTMWebServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("connectionTimeout", Some(connection.timeoutQuery.toParamString(connection.timeout))), ("socketTimeout", Some(socket.timeoutQuery.toParamString(socket.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDtmImplServiceDTMWebServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDtmImplServletsDTMDeployHookServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], dtmStagingIpWhitelist: List[String], dtmProductionIpWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], dtmStagingIpWhitelistQuery: QueryParam[List[String]], dtmProductionIpWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqDtmImplServletsDTMDeployHookServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDtmImplServletsDTMDeployHookServletInfo] = jsonOf[ComAdobeCqDtmImplServletsDTMDeployHookServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dtm.impl.servlets.DTMDeployHookServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("dtmStagingIpWhitelist", Some(dtm.staging.ip.whitelistQuery.toParamString(dtm.staging.ip.whitelist))), ("dtmProductionIpWhitelist", Some(dtm.production.ip.whitelistQuery.toParamString(dtm.production.ip.whitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDtmImplServletsDTMDeployHookServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqDtmReactorImplServiceWebServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], endpointUri: String, connectionTimeout: Integer, socketTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], endpointUriQuery: QueryParam[String], connectionTimeoutQuery: QueryParam[Integer], socketTimeoutQuery: QueryParam[Integer]): Task[ComAdobeCqDtmReactorImplServiceWebServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDtmReactorImplServiceWebServiceImplInfo] = jsonOf[ComAdobeCqDtmReactorImplServiceWebServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dtm.reactor.impl.service.WebServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("endpointUri", Some(endpointUriQuery.toParamString(endpointUri))), ("connectionTimeout", Some(connectionTimeoutQuery.toParamString(connectionTimeout))), ("socketTimeout", Some(socketTimeoutQuery.toParamString(socketTimeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDtmReactorImplServiceWebServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqExperiencelogImplExperienceLogConfigServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, disabledForGroups: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], disabledForGroupsQuery: QueryParam[List[String]]): Task[ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo] = jsonOf[ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.experiencelog.impl.ExperienceLogConfigServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("disabledForGroups", Some(disabledForGroupsQuery.toParamString(disabledForGroups))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqHcContentPackagesHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String, packageNames: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String], packageNamesQuery: QueryParam[List[String]]): Task[ComAdobeCqHcContentPackagesHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqHcContentPackagesHealthCheckInfo] = jsonOf[ComAdobeCqHcContentPackagesHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.cq.hc.ContentPackagesHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))), ("packageNames", Some(package.namesQuery.toParamString(package.names))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqHcContentPackagesHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeCqHistoryImplHistoryRequestFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], historyRequestFilterExcludedSelectors: List[String], historyRequestFilterExcludedExtensions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], historyRequestFilterExcludedSelectorsQuery: QueryParam[List[String]], historyRequestFilterExcludedExtensionsQuery: QueryParam[List[String]]): Task[ComAdobeCqHistoryImplHistoryRequestFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqHistoryImplHistoryRequestFilterInfo] = jsonOf[ComAdobeCqHistoryImplHistoryRequestFilterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.history.impl.HistoryRequestFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("historyRequestFilterExcludedSelectors", Some(history.requestFilter.excludedSelectorsQuery.toParamString(history.requestFilter.excludedSelectors))), ("historyRequestFilterExcludedExtensions", Some(history.requestFilter.excludedExtensionsQuery.toParamString(history.requestFilter.excludedExtensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqHistoryImplHistoryRequestFilterInfo](req)

    } yield resp
  }
  
  def comAdobeCqHistoryImplHistoryServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], historyServiceResourceTypes: List[String], historyServicePathFilter: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], historyServiceResourceTypesQuery: QueryParam[List[String]], historyServicePathFilterQuery: QueryParam[List[String]]): Task[ComAdobeCqHistoryImplHistoryServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqHistoryImplHistoryServiceImplInfo] = jsonOf[ComAdobeCqHistoryImplHistoryServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.history.impl.HistoryServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("historyServiceResourceTypes", Some(history.service.resourceTypesQuery.toParamString(history.service.resourceTypes))), ("historyServicePathFilter", Some(history.service.pathFilterQuery.toParamString(history.service.pathFilter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqHistoryImplHistoryServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqInboxImplTypeproviderItemTypeProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], inboxImplTypeproviderRegistrypaths: List[String], inboxImplTypeproviderLegacypaths: List[String], inboxImplTypeproviderDefaulturlFailureitem: String, inboxImplTypeproviderDefaulturlWorkitem: String, inboxImplTypeproviderDefaulturlTask: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], inboxImplTypeproviderRegistrypathsQuery: QueryParam[List[String]], inboxImplTypeproviderLegacypathsQuery: QueryParam[List[String]], inboxImplTypeproviderDefaulturlFailureitemQuery: QueryParam[String], inboxImplTypeproviderDefaulturlWorkitemQuery: QueryParam[String], inboxImplTypeproviderDefaulturlTaskQuery: QueryParam[String]): Task[ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo] = jsonOf[ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.inbox.impl.typeprovider.ItemTypeProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("inboxImplTypeproviderRegistrypaths", Some(inbox.impl.typeprovider.registrypathsQuery.toParamString(inbox.impl.typeprovider.registrypaths))), ("inboxImplTypeproviderLegacypaths", Some(inbox.impl.typeprovider.legacypathsQuery.toParamString(inbox.impl.typeprovider.legacypaths))), ("inboxImplTypeproviderDefaulturlFailureitem", Some(inbox.impl.typeprovider.defaulturl.failureitemQuery.toParamString(inbox.impl.typeprovider.defaulturl.failureitem))), ("inboxImplTypeproviderDefaulturlWorkitem", Some(inbox.impl.typeprovider.defaulturl.workitemQuery.toParamString(inbox.impl.typeprovider.defaulturl.workitem))), ("inboxImplTypeproviderDefaulturlTask", Some(inbox.impl.typeprovider.defaulturl.taskQuery.toParamString(inbox.impl.typeprovider.defaulturl.task))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqProjectsImplServletProjectImageServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], imageQuality: String, imageSupportedResolutions: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], imageQualityQuery: QueryParam[String], imageSupportedResolutionsQuery: QueryParam[String]): Task[ComAdobeCqProjectsImplServletProjectImageServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqProjectsImplServletProjectImageServletInfo] = jsonOf[ComAdobeCqProjectsImplServletProjectImageServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.projects.impl.servlet.ProjectImageServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("imageQuality", Some(image.qualityQuery.toParamString(image.quality))), ("imageSupportedResolutions", Some(image.supported.resolutionsQuery.toParamString(image.supported.resolutions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqProjectsImplServletProjectImageServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqProjectsPurgeScheduler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], scheduledpurgeName: String, scheduledpurgePurgeActive: Boolean, scheduledpurgeTemplates: List[String], scheduledpurgePurgeGroups: Boolean, scheduledpurgePurgeAssets: Boolean, scheduledpurgeTerminateRunningWorkflows: Boolean, scheduledpurgeDaysold: Integer, scheduledpurgeSaveThreshold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], scheduledpurgeNameQuery: QueryParam[String], scheduledpurgePurgeActiveQuery: QueryParam[Boolean], scheduledpurgeTemplatesQuery: QueryParam[List[String]], scheduledpurgePurgeGroupsQuery: QueryParam[Boolean], scheduledpurgePurgeAssetsQuery: QueryParam[Boolean], scheduledpurgeTerminateRunningWorkflowsQuery: QueryParam[Boolean], scheduledpurgeDaysoldQuery: QueryParam[Integer], scheduledpurgeSaveThresholdQuery: QueryParam[Integer]): Task[ComAdobeCqProjectsPurgeSchedulerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqProjectsPurgeSchedulerInfo] = jsonOf[ComAdobeCqProjectsPurgeSchedulerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.projects.purge.Scheduler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("scheduledpurgeName", Some(scheduledpurge.nameQuery.toParamString(scheduledpurge.name))), ("scheduledpurgePurgeActive", Some(scheduledpurge.purgeActiveQuery.toParamString(scheduledpurge.purgeActive))), ("scheduledpurgeTemplates", Some(scheduledpurge.templatesQuery.toParamString(scheduledpurge.templates))), ("scheduledpurgePurgeGroups", Some(scheduledpurge.purgeGroupsQuery.toParamString(scheduledpurge.purgeGroups))), ("scheduledpurgePurgeAssets", Some(scheduledpurge.purgeAssetsQuery.toParamString(scheduledpurge.purgeAssets))), ("scheduledpurgeTerminateRunningWorkflows", Some(scheduledpurge.terminateRunningWorkflowsQuery.toParamString(scheduledpurge.terminateRunningWorkflows))), ("scheduledpurgeDaysold", Some(scheduledpurge.daysoldQuery.toParamString(scheduledpurge.daysold))), ("scheduledpurgeSaveThreshold", Some(scheduledpurge.saveThresholdQuery.toParamString(scheduledpurge.saveThreshold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqProjectsPurgeSchedulerInfo](req)

    } yield resp
  }
  
  def comAdobeCqScheduledExporterImplScheduledExporterImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], includePaths: List[String], exporterUser: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], includePathsQuery: QueryParam[List[String]], exporterUserQuery: QueryParam[String]): Task[ComAdobeCqScheduledExporterImplScheduledExporterImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScheduledExporterImplScheduledExporterImplInfo] = jsonOf[ComAdobeCqScheduledExporterImplScheduledExporterImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.scheduled.exporter.impl.ScheduledExporterImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("includePaths", Some(include.pathsQuery.toParamString(include.paths))), ("exporterUser", Some(exporter.userQuery.toParamString(exporter.user))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScheduledExporterImplScheduledExporterImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeCqScreensAnalyticsImplUrl: String, comAdobeCqScreensAnalyticsImplApikey: String, comAdobeCqScreensAnalyticsImplProject: String, comAdobeCqScreensAnalyticsImplEnvironment: String, comAdobeCqScreensAnalyticsImplSendFrequency: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeCqScreensAnalyticsImplUrlQuery: QueryParam[String], comAdobeCqScreensAnalyticsImplApikeyQuery: QueryParam[String], comAdobeCqScreensAnalyticsImplProjectQuery: QueryParam[String], comAdobeCqScreensAnalyticsImplEnvironmentQuery: QueryParam[String], comAdobeCqScreensAnalyticsImplSendFrequencyQuery: QueryParam[Integer]): Task[ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo] = jsonOf[ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.analytics.impl.ScreensAnalyticsServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeCqScreensAnalyticsImplUrl", Some(com.adobe.cq.screens.analytics.impl.urlQuery.toParamString(com.adobe.cq.screens.analytics.impl.url))), ("comAdobeCqScreensAnalyticsImplApikey", Some(com.adobe.cq.screens.analytics.impl.apikeyQuery.toParamString(com.adobe.cq.screens.analytics.impl.apikey))), ("comAdobeCqScreensAnalyticsImplProject", Some(com.adobe.cq.screens.analytics.impl.projectQuery.toParamString(com.adobe.cq.screens.analytics.impl.project))), ("comAdobeCqScreensAnalyticsImplEnvironment", Some(com.adobe.cq.screens.analytics.impl.environmentQuery.toParamString(com.adobe.cq.screens.analytics.impl.environment))), ("comAdobeCqScreensAnalyticsImplSendFrequency", Some(com.adobe.cq.screens.analytics.impl.sendFrequencyQuery.toParamString(com.adobe.cq.screens.analytics.impl.sendFrequency))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensDeviceImplDeviceService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeAemScreensPlayerPingfrequency: Integer, comAdobeAemScreensDevicePaswordSpecialchars: String, comAdobeAemScreensDevicePaswordMinlowercasechars: Integer, comAdobeAemScreensDevicePaswordMinuppercasechars: Integer, comAdobeAemScreensDevicePaswordMinnumberchars: Integer, comAdobeAemScreensDevicePaswordMinspecialchars: Integer, comAdobeAemScreensDevicePaswordMinlength: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeAemScreensPlayerPingfrequencyQuery: QueryParam[Integer], comAdobeAemScreensDevicePaswordSpecialcharsQuery: QueryParam[String], comAdobeAemScreensDevicePaswordMinlowercasecharsQuery: QueryParam[Integer], comAdobeAemScreensDevicePaswordMinuppercasecharsQuery: QueryParam[Integer], comAdobeAemScreensDevicePaswordMinnumbercharsQuery: QueryParam[Integer], comAdobeAemScreensDevicePaswordMinspecialcharsQuery: QueryParam[Integer], comAdobeAemScreensDevicePaswordMinlengthQuery: QueryParam[Integer]): Task[ComAdobeCqScreensDeviceImplDeviceServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensDeviceImplDeviceServiceInfo] = jsonOf[ComAdobeCqScreensDeviceImplDeviceServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.device.impl.DeviceService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeAemScreensPlayerPingfrequency", Some(com.adobe.aem.screens.player.pingfrequencyQuery.toParamString(com.adobe.aem.screens.player.pingfrequency))), ("comAdobeAemScreensDevicePaswordSpecialchars", Some(com.adobe.aem.screens.device.pasword.specialcharsQuery.toParamString(com.adobe.aem.screens.device.pasword.specialchars))), ("comAdobeAemScreensDevicePaswordMinlowercasechars", Some(com.adobe.aem.screens.device.pasword.minlowercasecharsQuery.toParamString(com.adobe.aem.screens.device.pasword.minlowercasechars))), ("comAdobeAemScreensDevicePaswordMinuppercasechars", Some(com.adobe.aem.screens.device.pasword.minuppercasecharsQuery.toParamString(com.adobe.aem.screens.device.pasword.minuppercasechars))), ("comAdobeAemScreensDevicePaswordMinnumberchars", Some(com.adobe.aem.screens.device.pasword.minnumbercharsQuery.toParamString(com.adobe.aem.screens.device.pasword.minnumberchars))), ("comAdobeAemScreensDevicePaswordMinspecialchars", Some(com.adobe.aem.screens.device.pasword.minspecialcharsQuery.toParamString(com.adobe.aem.screens.device.pasword.minspecialchars))), ("comAdobeAemScreensDevicePaswordMinlength", Some(com.adobe.aem.screens.device.pasword.minlengthQuery.toParamString(com.adobe.aem.screens.device.pasword.minlength))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensDeviceImplDeviceServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensDeviceRegistrationImplRegistrationServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], deviceRegistrationTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], deviceRegistrationTimeoutQuery: QueryParam[Integer]): Task[ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo] = jsonOf[ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.device.registration.impl.RegistrationServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("deviceRegistrationTimeout", Some(deviceRegistrationTimeoutQuery.toParamString(deviceRegistrationTimeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensImplHandlerChannelsUpdateHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqPagesupdatehandlerImageresourcetypes: List[String], cqPagesupdatehandlerProductresourcetypes: List[String], cqPagesupdatehandlerVideoresourcetypes: List[String], cqPagesupdatehandlerDynamicsequenceresourcetypes: List[String], cqPagesupdatehandlerPreviewmodepaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqPagesupdatehandlerImageresourcetypesQuery: QueryParam[List[String]], cqPagesupdatehandlerProductresourcetypesQuery: QueryParam[List[String]], cqPagesupdatehandlerVideoresourcetypesQuery: QueryParam[List[String]], cqPagesupdatehandlerDynamicsequenceresourcetypesQuery: QueryParam[List[String]], cqPagesupdatehandlerPreviewmodepathsQuery: QueryParam[List[String]]): Task[ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo] = jsonOf[ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.impl.handler.ChannelsUpdateHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqPagesupdatehandlerImageresourcetypes", Some(cq.pagesupdatehandler.imageresourcetypesQuery.toParamString(cq.pagesupdatehandler.imageresourcetypes))), ("cqPagesupdatehandlerProductresourcetypes", Some(cq.pagesupdatehandler.productresourcetypesQuery.toParamString(cq.pagesupdatehandler.productresourcetypes))), ("cqPagesupdatehandlerVideoresourcetypes", Some(cq.pagesupdatehandler.videoresourcetypesQuery.toParamString(cq.pagesupdatehandler.videoresourcetypes))), ("cqPagesupdatehandlerDynamicsequenceresourcetypes", Some(cq.pagesupdatehandler.dynamicsequenceresourcetypesQuery.toParamString(cq.pagesupdatehandler.dynamicsequenceresourcetypes))), ("cqPagesupdatehandlerPreviewmodepaths", Some(cq.pagesupdatehandler.previewmodepathsQuery.toParamString(cq.pagesupdatehandler.previewmodepaths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJob(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String]): Task[ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo] = jsonOf[ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.impl.jobs.DistributedDevicesStatiUpdateJob"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensImplRemoteImplDistributedHttpClientImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeAemScreensImplRemoteRequestTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeAemScreensImplRemoteRequestTimeoutQuery: QueryParam[Integer]): Task[ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo] = jsonOf[ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.impl.remote.impl.DistributedHttpClientImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeAemScreensImplRemoteRequestTimeout", Some(com.adobe.aem.screens.impl.remote.request_timeoutQuery.toParamString(com.adobe.aem.screens.impl.remote.request_timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensImplScreensChannelPostProcessor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], screensChannelsPropertiesToRemove: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], screensChannelsPropertiesToRemoveQuery: QueryParam[List[String]]): Task[ComAdobeCqScreensImplScreensChannelPostProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensImplScreensChannelPostProcessorInfo] = jsonOf[ComAdobeCqScreensImplScreensChannelPostProcessorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.impl.ScreensChannelPostProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("screensChannelsPropertiesToRemove", Some(screens.channels.properties.to.removeQuery.toParamString(screens.channels.properties.to.remove))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensImplScreensChannelPostProcessorInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensMonitoringImplScreensMonitoringServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPath: List[String], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequency: String, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeout: Integer, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipients: String, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserver: String, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpport: Integer, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetls: Boolean, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsername: String, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPassword: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPathQuery: QueryParam[List[String]], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequencyQuery: QueryParam[String], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeoutQuery: QueryParam[Integer], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipientsQuery: QueryParam[String], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserverQuery: QueryParam[String], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpportQuery: QueryParam[Integer], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetlsQuery: QueryParam[Boolean], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsernameQuery: QueryParam[String], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPasswordQuery: QueryParam[String]): Task[ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo] = jsonOf[ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPath", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.projectPathQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.projectPath))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequency", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.scheduleFrequencyQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.scheduleFrequency))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeout", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.pingTimeoutQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.pingTimeout))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipients", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.recipientsQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.recipients))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserver", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpserverQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpserver))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpport", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpportQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpport))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetls", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.usetlsQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.usetls))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsername", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.usernameQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.username))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPassword", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.passwordQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.password))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensMqActivemqImplArtemisJMSProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, globalSize: Integer, maxDiskUsage: Integer, persistenceEnabled: Boolean, threadPoolMaxSize: Integer, scheduledThreadPoolMaxSize: Integer, gracefulShutdownTimeout: Integer, queues: List[String], topics: List[String], addressesMaxDeliveryAttempts: Integer, addressesExpiryDelay: Integer, addressesAddressFullMessagePolicy: String, addressesMaxSizeBytes: Integer, addressesPageSizeBytes: Integer, addressesPageCacheMaxSize: Integer, clusterUser: String, clusterPassword: String, clusterCallTimeout: Integer, clusterCallFailoverTimeout: Integer, clusterClientFailureCheckPeriod: Integer, clusterNotificationAttempts: Integer, clusterNotificationInterval: Integer, idCacheSize: Integer, clusterConfirmationWindowSize: Integer, clusterConnectionTtl: Integer, clusterDuplicateDetection: Boolean, clusterInitialConnectAttempts: Integer, clusterMaxRetryInterval: Integer, clusterMinLargeMessageSize: Integer, clusterProducerWindowSize: Integer, clusterReconnectAttempts: Integer, clusterRetryInterval: Integer, clusterRetryIntervalMultiplier: BigDecimal)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], globalSizeQuery: QueryParam[Integer], maxDiskUsageQuery: QueryParam[Integer], persistenceEnabledQuery: QueryParam[Boolean], threadPoolMaxSizeQuery: QueryParam[Integer], scheduledThreadPoolMaxSizeQuery: QueryParam[Integer], gracefulShutdownTimeoutQuery: QueryParam[Integer], queuesQuery: QueryParam[List[String]], topicsQuery: QueryParam[List[String]], addressesMaxDeliveryAttemptsQuery: QueryParam[Integer], addressesExpiryDelayQuery: QueryParam[Integer], addressesAddressFullMessagePolicyQuery: QueryParam[String], addressesMaxSizeBytesQuery: QueryParam[Integer], addressesPageSizeBytesQuery: QueryParam[Integer], addressesPageCacheMaxSizeQuery: QueryParam[Integer], clusterUserQuery: QueryParam[String], clusterPasswordQuery: QueryParam[String], clusterCallTimeoutQuery: QueryParam[Integer], clusterCallFailoverTimeoutQuery: QueryParam[Integer], clusterClientFailureCheckPeriodQuery: QueryParam[Integer], clusterNotificationAttemptsQuery: QueryParam[Integer], clusterNotificationIntervalQuery: QueryParam[Integer], idCacheSizeQuery: QueryParam[Integer], clusterConfirmationWindowSizeQuery: QueryParam[Integer], clusterConnectionTtlQuery: QueryParam[Integer], clusterDuplicateDetectionQuery: QueryParam[Boolean], clusterInitialConnectAttemptsQuery: QueryParam[Integer], clusterMaxRetryIntervalQuery: QueryParam[Integer], clusterMinLargeMessageSizeQuery: QueryParam[Integer], clusterProducerWindowSizeQuery: QueryParam[Integer], clusterReconnectAttemptsQuery: QueryParam[Integer], clusterRetryIntervalQuery: QueryParam[Integer], clusterRetryIntervalMultiplierQuery: QueryParam[BigDecimal]): Task[ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo] = jsonOf[ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.mq.activemq.impl.ArtemisJMSProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("globalSize", Some(global.sizeQuery.toParamString(global.size))), ("maxDiskUsage", Some(max.disk.usageQuery.toParamString(max.disk.usage))), ("persistenceEnabled", Some(persistence.enabledQuery.toParamString(persistence.enabled))), ("threadPoolMaxSize", Some(thread.pool.max.sizeQuery.toParamString(thread.pool.max.size))), ("scheduledThreadPoolMaxSize", Some(scheduled.thread.pool.max.sizeQuery.toParamString(scheduled.thread.pool.max.size))), ("gracefulShutdownTimeout", Some(graceful.shutdown.timeoutQuery.toParamString(graceful.shutdown.timeout))), ("queues", Some(queuesQuery.toParamString(queues))), ("topics", Some(topicsQuery.toParamString(topics))), ("addressesMaxDeliveryAttempts", Some(addresses.max.delivery.attemptsQuery.toParamString(addresses.max.delivery.attempts))), ("addressesExpiryDelay", Some(addresses.expiry.delayQuery.toParamString(addresses.expiry.delay))), ("addressesAddressFullMessagePolicy", Some(addresses.address.full.message.policyQuery.toParamString(addresses.address.full.message.policy))), ("addressesMaxSizeBytes", Some(addresses.max.size.bytesQuery.toParamString(addresses.max.size.bytes))), ("addressesPageSizeBytes", Some(addresses.page.size.bytesQuery.toParamString(addresses.page.size.bytes))), ("addressesPageCacheMaxSize", Some(addresses.page.cache.max.sizeQuery.toParamString(addresses.page.cache.max.size))), ("clusterUser", Some(cluster.userQuery.toParamString(cluster.user))), ("clusterPassword", Some(cluster.passwordQuery.toParamString(cluster.password))), ("clusterCallTimeout", Some(cluster.call.timeoutQuery.toParamString(cluster.call.timeout))), ("clusterCallFailoverTimeout", Some(cluster.call.failover.timeoutQuery.toParamString(cluster.call.failover.timeout))), ("clusterClientFailureCheckPeriod", Some(cluster.client.failure.check.periodQuery.toParamString(cluster.client.failure.check.period))), ("clusterNotificationAttempts", Some(cluster.notification.attemptsQuery.toParamString(cluster.notification.attempts))), ("clusterNotificationInterval", Some(cluster.notification.intervalQuery.toParamString(cluster.notification.interval))), ("idCacheSize", Some(id.cache.sizeQuery.toParamString(id.cache.size))), ("clusterConfirmationWindowSize", Some(cluster.confirmation.window.sizeQuery.toParamString(cluster.confirmation.window.size))), ("clusterConnectionTtl", Some(cluster.connection.ttlQuery.toParamString(cluster.connection.ttl))), ("clusterDuplicateDetection", Some(cluster.duplicate.detectionQuery.toParamString(cluster.duplicate.detection))), ("clusterInitialConnectAttempts", Some(cluster.initial.connect.attemptsQuery.toParamString(cluster.initial.connect.attempts))), ("clusterMaxRetryInterval", Some(cluster.max.retry.intervalQuery.toParamString(cluster.max.retry.interval))), ("clusterMinLargeMessageSize", Some(cluster.min.large.message.sizeQuery.toParamString(cluster.min.large.message.size))), ("clusterProducerWindowSize", Some(cluster.producer.window.sizeQuery.toParamString(cluster.producer.window.size))), ("clusterReconnectAttempts", Some(cluster.reconnect.attemptsQuery.toParamString(cluster.reconnect.attempts))), ("clusterRetryInterval", Some(cluster.retry.intervalQuery.toParamString(cluster.retry.interval))), ("clusterRetryIntervalMultiplier", Some(cluster.retry.interval.multiplierQuery.toParamString(cluster.retry.interval.multiplier))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPath: List[String], comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequency: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPathQuery: QueryParam[List[String]], comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequencyQuery: QueryParam[String]): Task[ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo] = jsonOf[ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPath", Some(com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.projectPathQuery.toParamString(com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.projectPath))), ("comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequency", Some(com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.scheduleFrequencyQuery.toParamString(com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.scheduleFrequency))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensOfflinecontentImplOfflineContentServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], disableSmartSync: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], disableSmartSyncQuery: QueryParam[Boolean]): Task[ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo] = jsonOf[ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.offlinecontent.impl.OfflineContentServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("disableSmartSync", Some(disableSmartSyncQuery.toParamString(disableSmartSync))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensSegmentationImplSegmentationFeatureFlag(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enableDataTriggeredContent: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableDataTriggeredContentQuery: QueryParam[Boolean]): Task[ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo] = jsonOf[ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.segmentation.impl.SegmentationFeatureFlag"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enableDataTriggeredContent", Some(enableDataTriggeredContentQuery.toParamString(enableDataTriggeredContent))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo](req)

    } yield resp
  }
  
  def comAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthCh(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo] = jsonOf[ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo]

    val path = "/system/console/configMgr/com.adobe.cq.security.hc.bundles.impl.HtmlLibraryManagerConfigHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo](req)

    } yield resp
  }
  
  def comAdobeCqSecurityHcBundlesImplWcmFilterHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo] = jsonOf[ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.cq.security.hc.bundles.impl.WcmFilterHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], dispatcherAddress: String, dispatcherFilterAllowed: List[String], dispatcherFilterBlocked: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], dispatcherAddressQuery: QueryParam[String], dispatcherFilterAllowedQuery: QueryParam[List[String]], dispatcherFilterBlockedQuery: QueryParam[List[String]]): Task[ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo] = jsonOf[ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.cq.security.hc.dispatcher.impl.DispatcherAccessHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("dispatcherAddress", Some(dispatcher.addressQuery.toParamString(dispatcher.address))), ("dispatcherFilterAllowed", Some(dispatcher.filter.allowedQuery.toParamString(dispatcher.filter.allowed))), ("dispatcherFilterBlocked", Some(dispatcher.filter.blockedQuery.toParamString(dispatcher.filter.blocked))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeCqSecurityHcPackagesImplExampleContentHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo] = jsonOf[ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.cq.security.hc.packages.impl.ExampleContentHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeCqSecurityHcWebserverImplClickjackingHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], webserverAddress: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], webserverAddressQuery: QueryParam[String]): Task[ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo] = jsonOf[ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.cq.security.hc.webserver.impl.ClickjackingHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("webserverAddress", Some(webserver.addressQuery.toParamString(webserver.address))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialAccountverificationImplAccountManagementConfigIm(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enable: Boolean, ttl1: Integer, ttl2: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableQuery: QueryParam[Boolean], ttl1Query: QueryParam[Integer], ttl2Query: QueryParam[Integer]): Task[ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo] = jsonOf[ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.accountverification.impl.AccountManagementConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enable", Some(enableQuery.toParamString(enable))), ("ttl1", Some(ttl1Query.toParamString(ttl1))), ("ttl2", Some(ttl2Query.toParamString(ttl2))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialActivitystreamsClientImplSocialActivityComponen(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo] = jsonOf[ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.activitystreams.client.impl.SocialActivityComponentFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCo(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo] = jsonOf[ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.activitystreams.client.impl.SocialActivityStreamComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialActivitystreamsListenerImplEventListenerHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String, eventFilter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String], eventFilterQuery: QueryParam[String]): Task[ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo] = jsonOf[ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.EventListenerHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialActivitystreamsListenerImplModerationEventExten(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], accepted: Boolean, ranked: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], acceptedQuery: QueryParam[Boolean], rankedQuery: QueryParam[Integer]): Task[ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo] = jsonOf[ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.ModerationEventExtension"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("accepted", Some(acceptedQuery.toParamString(accepted))), ("ranked", Some(rankedQuery.toParamString(ranked))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialActivitystreamsListenerImplRatingEventActivityS(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], ranking: Integer, enable: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], rankingQuery: QueryParam[Integer], enableQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo] = jsonOf[ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.RatingEventActivitySuppressor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("ranking", Some(rankingQuery.toParamString(ranking))), ("enable", Some(enableQuery.toParamString(enable))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialActivitystreamsListenerImplResourceActivityStre(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], streamPath: String, streamName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], streamPathQuery: QueryParam[String], streamNameQuery: QueryParam[String]): Task[ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo] = jsonOf[ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.ResourceActivityStreamProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("streamPath", Some(streamPathQuery.toParamString(streamPath))), ("streamName", Some(streamNameQuery.toParamString(streamName))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsI(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxRetry: Integer, fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxRetryQuery: QueryParam[Integer], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo] = jsonOf[ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.calendar.client.endpoints.impl.CalendarOperationsImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxRetry", Some(MaxRetryQuery.toParamString(MaxRetry))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCalendarClientOperationextensionsEventAttachmen(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], attachmentTypeBlacklist: String, extensionOrder: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[String], extensionOrderQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo] = jsonOf[ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.calendar.client.operationextensions.EventAttachment"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))), ("extensionOrder", Some(extension.orderQuery.toParamString(extension.order))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCalendarServletsTimeZoneServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], timezonesExpirytime: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], timezonesExpirytimeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCalendarServletsTimeZoneServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCalendarServletsTimeZoneServletInfo] = jsonOf[ComAdobeCqSocialCalendarServletsTimeZoneServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.calendar.servlets.TimeZoneServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("timezonesExpirytime", Some(timezones.expirytimeQuery.toParamString(timezones.expirytime))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCalendarServletsTimeZoneServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEvent(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], ranking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], rankingQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo] = jsonOf[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.CommentDeleteEventActivitySuppressor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("ranking", Some(rankingQuery.toParamString(ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSe(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo] = jsonOf[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.CommentOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperati(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo] = jsonOf[ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.TranslationOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialC(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], numUserLimit: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], numUserLimitQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo] = jsonOf[ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.comments.listing.impl.SearchCommentSocialComponentListProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("numUserLimit", Some(numUserLimitQuery.toParamString(numUserLimit))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPos(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enableScheduledPostsSearch: Boolean, numberOfMinutes: Integer, maxSearchLimit: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableScheduledPostsSearchQuery: QueryParam[Boolean], numberOfMinutesQuery: QueryParam[Integer], maxSearchLimitQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo] = jsonOf[ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.comments.scheduler.impl.SearchScheduledPosts"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enableScheduledPostsSearch", Some(enableScheduledPostsSearchQuery.toParamString(enableScheduledPostsSearch))), ("numberOfMinutes", Some(numberOfMinutesQuery.toParamString(numberOfMinutes))), ("maxSearchLimit", Some(maxSearchLimitQuery.toParamString(maxSearchLimit))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsCorsCORSAuthenticationFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], corsEnabling: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], corsEnablingQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo] = jsonOf[ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.cors.CORSAuthenticationFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("corsEnabling", Some(cors.enablingQuery.toParamString(cors.enabling))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.AndroidEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], contextPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], contextPathQuery: QueryParam[String]): Task[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CommentEmailBuilderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("contextPath", Some(context.pathQuery.toParamString(context.path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String]): Task[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CommentEmailEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CustomEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImp(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], patternTime: String, patternNewline: String, patternDayOfMonth: String, patternMonth: String, patternYear: String, patternDate: String, patternDateTime: String, patternEmail: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], patternTimeQuery: QueryParam[String], patternNewlineQuery: QueryParam[String], patternDayOfMonthQuery: QueryParam[String], patternMonthQuery: QueryParam[String], patternYearQuery: QueryParam[String], patternDateQuery: QueryParam[String], patternDateTimeQuery: QueryParam[String], patternEmailQuery: QueryParam[String]): Task[ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailQuotedTextPatternsImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("patternTime", Some(pattern.timeQuery.toParamString(pattern.time))), ("patternNewline", Some(pattern.newlineQuery.toParamString(pattern.newline))), ("patternDayOfMonth", Some(pattern.dayOfMonthQuery.toParamString(pattern.dayOfMonth))), ("patternMonth", Some(pattern.monthQuery.toParamString(pattern.month))), ("patternYear", Some(pattern.yearQuery.toParamString(pattern.year))), ("patternDate", Some(pattern.dateQuery.toParamString(pattern.date))), ("patternDateTime", Some(pattern.dateTimeQuery.toParamString(pattern.dateTime))), ("patternEmail", Some(pattern.emailQuery.toParamString(pattern.email))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImp(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], emailName: String, emailCreatePostFromReply: Boolean, emailAddCommentIdTo: String, emailSubjectMaximumLength: Integer, emailReplyToAddress: String, emailReplyToDelimiter: String, emailTrackerIdPrefixInSubject: String, emailTrackerIdPrefixInBody: String, emailAsHTML: Boolean, emailDefaultUserName: String, emailTemplatesRootPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], emailNameQuery: QueryParam[String], emailCreatePostFromReplyQuery: QueryParam[Boolean], emailAddCommentIdToQuery: QueryParam[String], emailSubjectMaximumLengthQuery: QueryParam[Integer], emailReplyToAddressQuery: QueryParam[String], emailReplyToDelimiterQuery: QueryParam[String], emailTrackerIdPrefixInSubjectQuery: QueryParam[String], emailTrackerIdPrefixInBodyQuery: QueryParam[String], emailAsHTMLQuery: QueryParam[Boolean], emailDefaultUserNameQuery: QueryParam[String], emailTemplatesRootPathQuery: QueryParam[String]): Task[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailReplyConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("emailName", Some(email.nameQuery.toParamString(email.name))), ("emailCreatePostFromReply", Some(email.createPostFromReplyQuery.toParamString(email.createPostFromReply))), ("emailAddCommentIdTo", Some(email.addCommentIdToQuery.toParamString(email.addCommentIdTo))), ("emailSubjectMaximumLength", Some(email.subjectMaximumLengthQuery.toParamString(email.subjectMaximumLength))), ("emailReplyToAddress", Some(email.replyToAddressQuery.toParamString(email.replyToAddress))), ("emailReplyToDelimiter", Some(email.replyToDelimiterQuery.toParamString(email.replyToDelimiter))), ("emailTrackerIdPrefixInSubject", Some(email.trackerIdPrefixInSubjectQuery.toParamString(email.trackerIdPrefixInSubject))), ("emailTrackerIdPrefixInBody", Some(email.trackerIdPrefixInBodyQuery.toParamString(email.trackerIdPrefixInBody))), ("emailAsHTML", Some(email.asHTMLQuery.toParamString(email.asHTML))), ("emailDefaultUserName", Some(email.defaultUserNameQuery.toParamString(email.defaultUserName))), ("emailTemplatesRootPath", Some(email.templates.rootPathQuery.toParamString(email.templates.rootPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplEmailReplyImporter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], connectProtocol: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], connectProtocolQuery: QueryParam[String]): Task[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailReplyImporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("connectProtocol", Some(connectProtocolQuery.toParamString(connectProtocol))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.GmailEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.IOSEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.MacmailEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.OutLookEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], replyEmailPatterns: List[String], priorityOrder: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], replyEmailPatternsQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.UnknownEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.YahooEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUpload(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], numberOfDays: Integer, ageOfFile: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], numberOfDaysQuery: QueryParam[Integer], ageOfFileQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo] = jsonOf[ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.maintainance.impl.DeleteTempUGCImageUploads"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("numberOfDays", Some(numberOfDaysQuery.toParamString(numberOfDays))), ("ageOfFile", Some(ageOfFileQuery.toParamString(ageOfFile))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String, eventFilter: String, verbs: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String], eventFilterQuery: QueryParam[String], verbsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo] = jsonOf[ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.ugclimiter.impl.UGCLimiterServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("verbs", Some(verbsQuery.toParamString(verbs))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimit(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enable: Boolean, uGCLimit: Integer, ugcLimitDuration: Integer, domains: List[String], toList: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableQuery: QueryParam[Boolean], uGCLimitQuery: QueryParam[Integer], ugcLimitDurationQuery: QueryParam[Integer], domainsQuery: QueryParam[List[String]], toListQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo] = jsonOf[ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.ugclimitsconfig.impl.CommunityUserUGCLimitsConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enable", Some(enableQuery.toParamString(enable))), ("uGCLimit", Some(UGCLimitQuery.toParamString(UGCLimit))), ("ugcLimitDuration", Some(ugcLimitDurationQuery.toParamString(ugcLimitDuration))), ("domains", Some(domainsQuery.toParamString(domains))), ("toList", Some(toListQuery.toParamString(toList))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialConnectOauthImplFacebookProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String, oauthCloudConfigRoot: String, providerConfigRoot: String, providerConfigCreateTagsEnabled: Boolean, providerConfigUserFolder: String, providerConfigFacebookFetchFields: Boolean, providerConfigFacebookFields: List[String], providerConfigRefreshUserdataEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String], oauthCloudConfigRootQuery: QueryParam[String], providerConfigRootQuery: QueryParam[String], providerConfigCreateTagsEnabledQuery: QueryParam[Boolean], providerConfigUserFolderQuery: QueryParam[String], providerConfigFacebookFetchFieldsQuery: QueryParam[Boolean], providerConfigFacebookFieldsQuery: QueryParam[List[String]], providerConfigRefreshUserdataEnabledQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo] = jsonOf[ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.FacebookProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))), ("oauthCloudConfigRoot", Some(oauth.cloud.config.rootQuery.toParamString(oauth.cloud.config.root))), ("providerConfigRoot", Some(provider.config.rootQuery.toParamString(provider.config.root))), ("providerConfigCreateTagsEnabled", Some(provider.config.create.tags.enabledQuery.toParamString(provider.config.create.tags.enabled))), ("providerConfigUserFolder", Some(provider.config.user.folderQuery.toParamString(provider.config.user.folder))), ("providerConfigFacebookFetchFields", Some(provider.config.facebook.fetch.fieldsQuery.toParamString(provider.config.facebook.fetch.fields))), ("providerConfigFacebookFields", Some(provider.config.facebook.fieldsQuery.toParamString(provider.config.facebook.fields))), ("providerConfigRefreshUserdataEnabled", Some(provider.config.refresh.userdata.enabledQuery.toParamString(provider.config.refresh.userdata.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandle(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: List[String], serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer]): Task[ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo] = jsonOf[ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.SocialOAuthAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapper(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], facebook: List[String], twitter: List[String], providerConfigUserFolder: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], facebookQuery: QueryParam[List[String]], twitterQuery: QueryParam[List[String]], providerConfigUserFolderQuery: QueryParam[String]): Task[ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo] = jsonOf[ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.SocialOAuthUserProfileMapper"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("facebook", Some(facebookQuery.toParamString(facebook))), ("twitter", Some(twitterQuery.toParamString(twitter))), ("providerConfigUserFolder", Some(provider.config.user.folderQuery.toParamString(provider.config.user.folder))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialConnectOauthImplTwitterProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String, oauthCloudConfigRoot: String, providerConfigRoot: String, providerConfigUserFolder: String, providerConfigTwitterEnableParams: Boolean, providerConfigTwitterParams: List[String], providerConfigRefreshUserdataEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String], oauthCloudConfigRootQuery: QueryParam[String], providerConfigRootQuery: QueryParam[String], providerConfigUserFolderQuery: QueryParam[String], providerConfigTwitterEnableParamsQuery: QueryParam[Boolean], providerConfigTwitterParamsQuery: QueryParam[List[String]], providerConfigRefreshUserdataEnabledQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo] = jsonOf[ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.TwitterProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))), ("oauthCloudConfigRoot", Some(oauth.cloud.config.rootQuery.toParamString(oauth.cloud.config.root))), ("providerConfigRoot", Some(provider.config.rootQuery.toParamString(provider.config.root))), ("providerConfigUserFolder", Some(provider.config.user.folderQuery.toParamString(provider.config.user.folder))), ("providerConfigTwitterEnableParams", Some(provider.config.twitter.enable.paramsQuery.toParamString(provider.config.twitter.enable.params))), ("providerConfigTwitterParams", Some(provider.config.twitter.paramsQuery.toParamString(provider.config.twitter.params))), ("providerConfigRefreshUserdataEnabled", Some(provider.config.refresh.userdata.enabledQuery.toParamString(provider.config.refresh.userdata.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmen(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqSocialContentFragmentsServicesEnabled: Boolean, cqSocialContentFragmentsServicesWaitTimeSeconds: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqSocialContentFragmentsServicesEnabledQuery: QueryParam[Boolean], cqSocialContentFragmentsServicesWaitTimeSecondsQuery: QueryParam[Integer]): Task[ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo] = jsonOf[ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.content.fragments.services.impl.CommunitiesFragmentCreationServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqSocialContentFragmentsServicesEnabled", Some(cq.social.content.fragments.services.enabledQuery.toParamString(cq.social.content.fragments.services.enabled))), ("cqSocialContentFragmentsServicesWaitTimeSeconds", Some(cq.social.content.fragments.services.waitTimeSecondsQuery.toParamString(cq.social.content.fragments.services.waitTimeSeconds))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialDatastoreAsImplASResourceProviderFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], versionId: String, cacheOn: Boolean, concurrencyLevel: Integer, cacheStartSize: Integer, cacheTtl: Integer, cacheSize: Integer, timeLimit: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], versionIdQuery: QueryParam[String], cacheOnQuery: QueryParam[Boolean], concurrencyLevelQuery: QueryParam[Integer], cacheStartSizeQuery: QueryParam[Integer], cacheTtlQuery: QueryParam[Integer], cacheSizeQuery: QueryParam[Integer], timeLimitQuery: QueryParam[Integer]): Task[ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo] = jsonOf[ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.datastore.as.impl.ASResourceProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("versionId", Some(version.idQuery.toParamString(version.id))), ("cacheOn", Some(cache.onQuery.toParamString(cache.on))), ("concurrencyLevel", Some(concurrency.levelQuery.toParamString(concurrency.level))), ("cacheStartSize", Some(cache.start.sizeQuery.toParamString(cache.start.size))), ("cacheTtl", Some(cache.ttlQuery.toParamString(cache.ttl))), ("cacheSize", Some(cache.sizeQuery.toParamString(cache.size))), ("timeLimit", Some(time.limitQuery.toParamString(time.limit))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], solrZkTimeout: String, solrCommit: String, cacheOn: Boolean, concurrencyLevel: Integer, cacheStartSize: Integer, cacheTtl: Integer, cacheSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], solrZkTimeoutQuery: QueryParam[String], solrCommitQuery: QueryParam[String], cacheOnQuery: QueryParam[Boolean], concurrencyLevelQuery: QueryParam[Integer], cacheStartSizeQuery: QueryParam[Integer], cacheTtlQuery: QueryParam[Integer], cacheSizeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo] = jsonOf[ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.datastore.op.impl.SocialMSResourceProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("solrZkTimeout", Some(solr.zk.timeoutQuery.toParamString(solr.zk.timeout))), ("solrCommit", Some(solr.commitQuery.toParamString(solr.commit))), ("cacheOn", Some(cache.onQuery.toParamString(cache.on))), ("concurrencyLevel", Some(concurrency.levelQuery.toParamString(concurrency.level))), ("cacheStartSize", Some(cache.start.sizeQuery.toParamString(cache.start.size))), ("cacheTtl", Some(cache.ttlQuery.toParamString(cache.ttl))), ("cacheSize", Some(cache.sizeQuery.toParamString(cache.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], solrZkTimeout: String, solrCommit: String, cacheOn: Boolean, concurrencyLevel: Integer, cacheStartSize: Integer, cacheTtl: Integer, cacheSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], solrZkTimeoutQuery: QueryParam[String], solrCommitQuery: QueryParam[String], cacheOnQuery: QueryParam[Boolean], concurrencyLevelQuery: QueryParam[Integer], cacheStartSizeQuery: QueryParam[Integer], cacheTtlQuery: QueryParam[Integer], cacheSizeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo] = jsonOf[ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.datastore.rdb.impl.SocialRDBResourceProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("solrZkTimeout", Some(solr.zk.timeoutQuery.toParamString(solr.zk.timeout))), ("solrCommit", Some(solr.commitQuery.toParamString(solr.commit))), ("cacheOn", Some(cache.onQuery.toParamString(cache.on))), ("concurrencyLevel", Some(concurrency.levelQuery.toParamString(concurrency.level))), ("cacheStartSize", Some(cache.start.sizeQuery.toParamString(cache.start.size))), ("cacheTtl", Some(cache.ttlQuery.toParamString(cache.ttl))), ("cacheSize", Some(cache.sizeQuery.toParamString(cache.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorF(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], isMemberCheck: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], isMemberCheckQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo] = jsonOf[ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.enablement.adaptors.EnablementLearningPathAdaptorFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("isMemberCheck", Some(isMemberCheckQuery.toParamString(isMemberCheck))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFacto(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], isMemberCheck: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], isMemberCheckQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo] = jsonOf[ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.enablement.adaptors.EnablementResourceAdaptorFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("isMemberCheck", Some(isMemberCheckQuery.toParamString(isMemberCheck))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialEnablementLearningpathEndpointsImplEnablementL(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo] = jsonOf[ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.enablement.learningpath.endpoints.impl.EnablementLearningPathModelOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialEnablementResourceEndpointsImplEnablementResou(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo] = jsonOf[ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.enablement.resource.endpoints.impl.EnablementResourceModelOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialEnablementServicesImplAuthorMarkerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer]): Task[ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo] = jsonOf[ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.enablement.services.impl.AuthorMarkerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGe(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletSelectors: String, slingServletExtensions: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletSelectorsQuery: QueryParam[String], slingServletExtensionsQuery: QueryParam[String]): Task[ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo] = jsonOf[ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.filelibrary.client.endpoints.FilelibraryDownloadGetServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("slingServletExtensions", Some(sling.servlet.extensionsQuery.toParamString(sling.servlet.extensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOpera(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo] = jsonOf[ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.filelibrary.client.endpoints.impl.FileLibraryOperationsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialForumClientEndpointsImplForumOperationsService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo] = jsonOf[ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.forum.client.endpoints.impl.ForumOperationsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialForumDispatcherImplFlushOperations(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], extensionOrder: Integer, flushForumontopic: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], extensionOrderQuery: QueryParam[Integer], flushForumontopicQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo] = jsonOf[ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.forum.dispatcher.impl.FlushOperations"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("extensionOrder", Some(extension.orderQuery.toParamString(extension.order))), ("flushForumontopic", Some(flush.forumontopicQuery.toParamString(flush.forumontopic))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialGroupClientImplCommunityGroupCollectionComponen(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], groupListingPaginationEnable: Boolean, groupListingLazyloadingEnable: Boolean, pageSize: Integer, priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], groupListingPaginationEnableQuery: QueryParam[Boolean], groupListingLazyloadingEnableQuery: QueryParam[Boolean], pageSizeQuery: QueryParam[Integer], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo] = jsonOf[ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.group.client.impl.CommunityGroupCollectionComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("groupListingPaginationEnable", Some(group.listing.pagination.enableQuery.toParamString(group.listing.pagination.enable))), ("groupListingLazyloadingEnable", Some(group.listing.lazyloading.enableQuery.toParamString(group.listing.lazyloading.enable))), ("pageSize", Some(page.sizeQuery.toParamString(page.size))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialGroupImplGroupServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxWaitTime: Integer, minWaitBetweenRetries: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxWaitTimeQuery: QueryParam[Integer], minWaitBetweenRetriesQuery: QueryParam[Integer]): Task[ComAdobeCqSocialGroupImplGroupServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialGroupImplGroupServiceImplInfo] = jsonOf[ComAdobeCqSocialGroupImplGroupServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.group.impl.GroupServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxWaitTime", Some(maxWaitTimeQuery.toParamString(maxWaitTime))), ("minWaitBetweenRetries", Some(minWaitBetweenRetriesQuery.toParamString(minWaitBetweenRetries))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialGroupImplGroupServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialHandlebarsGuavaTemplateCacheImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], parameterGuavaCacheEnabled: Boolean, parameterGuavaCacheParams: String, parameterGuavaCacheReload: Boolean, serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], parameterGuavaCacheEnabledQuery: QueryParam[Boolean], parameterGuavaCacheParamsQuery: QueryParam[String], parameterGuavaCacheReloadQuery: QueryParam[Boolean], serviceRankingQuery: QueryParam[Integer]): Task[ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo] = jsonOf[ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.handlebars.GuavaTemplateCacheImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("parameterGuavaCacheEnabled", Some(parameter.guava.cache.enabledQuery.toParamString(parameter.guava.cache.enabled))), ("parameterGuavaCacheParams", Some(parameter.guava.cache.paramsQuery.toParamString(parameter.guava.cache.params))), ("parameterGuavaCacheReload", Some(parameter.guava.cache.reloadQuery.toParamString(parameter.guava.cache.reload))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsS(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo] = jsonOf[ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ideation.client.endpoints.impl.IdeationOperationsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialJournalClientEndpointsImplJournalOperationsSer(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo] = jsonOf[ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.journal.client.endpoints.impl.JournalOperationsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfile(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo] = jsonOf[ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.members.endpoints.impl.CommunityMemberGroupProfileOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileO(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo] = jsonOf[ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.members.endpoints.impl.CommunityMemberUserProfileOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentF(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], everyoneLimit: Integer, priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], everyoneLimitQuery: QueryParam[Integer], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo] = jsonOf[ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.members.impl.CommunityMemberGroupProfileComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("everyoneLimit", Some(everyoneLimitQuery.toParamString(everyoneLimit))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialMessagingClientEndpointsImplMessagingOperation(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], messageProperties: List[String], messageBoxSizeLimit: Integer, messageCountLimit: Integer, notifyFailure: Boolean, failureMessageFrom: String, failureTemplatePath: String, maxRetries: Integer, minWaitBetweenRetries: Integer, countUpdatePoolSize: Integer, inboxPath: String, sentitemsPath: String, supportAttachments: Boolean, supportGroupMessaging: Boolean, maxTotalRecipients: Integer, batchSize: Integer, maxTotalAttachmentSize: Integer, attachmentTypeBlacklist: List[String], allowedAttachmentTypes: List[String], serviceSelector: String, fieldWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], messagePropertiesQuery: QueryParam[List[String]], messageBoxSizeLimitQuery: QueryParam[Integer], messageCountLimitQuery: QueryParam[Integer], notifyFailureQuery: QueryParam[Boolean], failureMessageFromQuery: QueryParam[String], failureTemplatePathQuery: QueryParam[String], maxRetriesQuery: QueryParam[Integer], minWaitBetweenRetriesQuery: QueryParam[Integer], countUpdatePoolSizeQuery: QueryParam[Integer], inboxPathQuery: QueryParam[String], sentitemsPathQuery: QueryParam[String], supportAttachmentsQuery: QueryParam[Boolean], supportGroupMessagingQuery: QueryParam[Boolean], maxTotalRecipientsQuery: QueryParam[Integer], batchSizeQuery: QueryParam[Integer], maxTotalAttachmentSizeQuery: QueryParam[Integer], attachmentTypeBlacklistQuery: QueryParam[List[String]], allowedAttachmentTypesQuery: QueryParam[List[String]], serviceSelectorQuery: QueryParam[String], fieldWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo] = jsonOf[ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.messaging.client.endpoints.impl.MessagingOperationsServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("messageProperties", Some(message.propertiesQuery.toParamString(message.properties))), ("messageBoxSizeLimit", Some(messageBoxSizeLimitQuery.toParamString(messageBoxSizeLimit))), ("messageCountLimit", Some(messageCountLimitQuery.toParamString(messageCountLimit))), ("notifyFailure", Some(notifyFailureQuery.toParamString(notifyFailure))), ("failureMessageFrom", Some(failureMessageFromQuery.toParamString(failureMessageFrom))), ("failureTemplatePath", Some(failureTemplatePathQuery.toParamString(failureTemplatePath))), ("maxRetries", Some(maxRetriesQuery.toParamString(maxRetries))), ("minWaitBetweenRetries", Some(minWaitBetweenRetriesQuery.toParamString(minWaitBetweenRetries))), ("countUpdatePoolSize", Some(countUpdatePoolSizeQuery.toParamString(countUpdatePoolSize))), ("inboxPath", Some(inbox.pathQuery.toParamString(inbox.path))), ("sentitemsPath", Some(sentitems.pathQuery.toParamString(sentitems.path))), ("supportAttachments", Some(supportAttachmentsQuery.toParamString(supportAttachments))), ("supportGroupMessaging", Some(supportGroupMessagingQuery.toParamString(supportGroupMessaging))), ("maxTotalRecipients", Some(maxTotalRecipientsQuery.toParamString(maxTotalRecipients))), ("batchSize", Some(batchSizeQuery.toParamString(batchSize))), ("maxTotalAttachmentSize", Some(maxTotalAttachmentSizeQuery.toParamString(maxTotalAttachmentSize))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))), ("allowedAttachmentTypes", Some(allowedAttachmentTypesQuery.toParamString(allowedAttachmentTypes))), ("serviceSelector", Some(serviceSelectorQuery.toParamString(serviceSelector))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialModerationDashboardApiFilterGroupSocialComponen(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], resourceTypeFilters: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], resourceTypeFiltersQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo] = jsonOf[ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.FilterGroupSocialComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("resourceTypeFilters", Some(resourceType.filtersQuery.toParamString(resourceType.filters))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialModerationDashboardApiModerationDashboardSocial(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo] = jsonOf[ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.ModerationDashboardSocialComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialModerationDashboardApiUserDetailsSocialComponen(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo] = jsonOf[ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.UserDetailsSocialComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialModerationDashboardInternalImplFilterGroupSoci(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], resourceTypeFilters: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], resourceTypeFiltersQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo] = jsonOf[ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.internal.impl.FilterGroupSocialComponentFactoryV2"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("resourceTypeFilters", Some(resourceType.filtersQuery.toParamString(resourceType.filters))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialNotificationsImplMentionsRouter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String, eventFilter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String], eventFilterQuery: QueryParam[String]): Task[ComAdobeCqSocialNotificationsImplMentionsRouterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialNotificationsImplMentionsRouterInfo] = jsonOf[ComAdobeCqSocialNotificationsImplMentionsRouterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.notifications.impl.MentionsRouter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialNotificationsImplMentionsRouterInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialNotificationsImplNotificationManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxUnreadNotificationCount: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxUnreadNotificationCountQuery: QueryParam[Integer]): Task[ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo] = jsonOf[ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.notifications.impl.NotificationManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxUnreadNotificationCount", Some(max.unread.notification.countQuery.toParamString(max.unread.notification.count))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialNotificationsImplNotificationsRouter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String, eventFilter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String], eventFilterQuery: QueryParam[String]): Task[ComAdobeCqSocialNotificationsImplNotificationsRouterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialNotificationsImplNotificationsRouterInfo] = jsonOf[ComAdobeCqSocialNotificationsImplNotificationsRouterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.notifications.impl.NotificationsRouter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialNotificationsImplNotificationsRouterInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServic(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo] = jsonOf[ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.qna.client.endpoints.impl.QnaForumOperationsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportI(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqSocialReportingAnalyticsPollingImporterInterval: Integer, cqSocialReportingAnalyticsPollingImporterPageSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqSocialReportingAnalyticsPollingImporterIntervalQuery: QueryParam[Integer], cqSocialReportingAnalyticsPollingImporterPageSizeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo] = jsonOf[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.AnalyticsReportImporterServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqSocialReportingAnalyticsPollingImporterInterval", Some(cq.social.reporting.analytics.polling.importer.intervalQuery.toParamString(cq.social.reporting.analytics.polling.importer.interval))), ("cqSocialReportingAnalyticsPollingImporterPageSize", Some(cq.social.reporting.analytics.polling.importer.pageSizeQuery.toParamString(cq.social.reporting.analytics.polling.importer.pageSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportM(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], reportFetchDelay: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], reportFetchDelayQuery: QueryParam[Integer]): Task[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo] = jsonOf[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.AnalyticsReportManagementServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("reportFetchDelay", Some(report.fetch.delayQuery.toParamString(report.fetch.delay))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportS(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqSocialConsoleAnalyticsSitesMapping: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqSocialConsoleAnalyticsSitesMappingQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo] = jsonOf[ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.SiteTrendReportSocialComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqSocialConsoleAnalyticsSitesMapping", Some(cq.social.console.analytics.sites.mappingQuery.toParamString(cq.social.console.analytics.sites.mapping))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialReviewClientEndpointsImplReviewOperationsServi(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo] = jsonOf[ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.review.client.endpoints.impl.ReviewOperationsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialScfCoreOperationsImplSocialOperationsServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletSelectors: String, slingServletExtensions: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletSelectorsQuery: QueryParam[String], slingServletExtensionsQuery: QueryParam[String]): Task[ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo] = jsonOf[ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.scf.core.operations.impl.SocialOperationsServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("slingServletExtensions", Some(sling.servlet.extensionsQuery.toParamString(sling.servlet.extensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialScfEndpointsImplDefaultSocialGetServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletSelectors: List[String], slingServletExtensions: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletSelectorsQuery: QueryParam[List[String]], slingServletExtensionsQuery: QueryParam[String]): Task[ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo] = jsonOf[ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.scf.endpoints.impl.DefaultSocialGetServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("slingServletExtensions", Some(sling.servlet.extensionsQuery.toParamString(sling.servlet.extensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialScoringImplScoringEventListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String, eventFilter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String], eventFilterQuery: QueryParam[String]): Task[ComAdobeCqSocialScoringImplScoringEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialScoringImplScoringEventListenerInfo] = jsonOf[ComAdobeCqSocialScoringImplScoringEventListenerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.scoring.impl.ScoringEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialScoringImplScoringEventListenerInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialServiceusersInternalImplServiceUserWrapperImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enableFallback: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableFallbackQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo] = jsonOf[ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.serviceusers.internal.impl.ServiceUserWrapperImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enableFallback", Some(enableFallbackQuery.toParamString(enableFallback))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSiteEndpointsImplSiteOperationService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], sitePathFilters: List[String], sitePackageGroup: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], sitePathFiltersQuery: QueryParam[List[String]], sitePackageGroupQuery: QueryParam[String]): Task[ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo] = jsonOf[ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.site.endpoints.impl.SiteOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("sitePathFilters", Some(sitePathFiltersQuery.toParamString(sitePathFilters))), ("sitePackageGroup", Some(sitePackageGroupQuery.toParamString(sitePackageGroup))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceIm(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqSocialConsoleAnalyticsComponents: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqSocialConsoleAnalyticsComponentsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo] = jsonOf[ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.site.impl.AnalyticsComponentConfigurationServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqSocialConsoleAnalyticsComponents", Some(cq.social.console.analytics.componentsQuery.toParamString(cq.social.console.analytics.components))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSiteImplSiteConfiguratorImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], componentsUsingTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], componentsUsingTagsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo] = jsonOf[ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.site.impl.SiteConfiguratorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("componentsUsingTags", Some(componentsUsingTagsQuery.toParamString(componentsUsingTags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSrpImplSocialSolrConnector(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], srpType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], srpTypeQuery: QueryParam[String]): Task[ComAdobeCqSocialSrpImplSocialSolrConnectorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSrpImplSocialSolrConnectorInfo] = jsonOf[ComAdobeCqSocialSrpImplSocialSolrConnectorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.srp.impl.SocialSolrConnector"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("srpType", Some(srp.typeQuery.toParamString(srp.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSrpImplSocialSolrConnectorInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSyncImplDiffChangesObserver(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, agentName: String, diffPath: String, propertyNames: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], agentNameQuery: QueryParam[String], diffPathQuery: QueryParam[String], propertyNamesQuery: QueryParam[String]): Task[ComAdobeCqSocialSyncImplDiffChangesObserverInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSyncImplDiffChangesObserverInfo] = jsonOf[ComAdobeCqSocialSyncImplDiffChangesObserverInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.sync.impl.DiffChangesObserver"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("agentName", Some(agentNameQuery.toParamString(agentName))), ("diffPath", Some(diffPathQuery.toParamString(diffPath))), ("propertyNames", Some(propertyNamesQuery.toParamString(propertyNames))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSyncImplDiffChangesObserverInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSyncImplGroupSyncListenerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], nodetypes: List[String], ignorableprops: List[String], ignorablenodes: String, enabled: Boolean, distfolders: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nodetypesQuery: QueryParam[List[String]], ignorablepropsQuery: QueryParam[List[String]], ignorablenodesQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], distfoldersQuery: QueryParam[String]): Task[ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo] = jsonOf[ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.sync.impl.GroupSyncListenerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("nodetypes", Some(nodetypesQuery.toParamString(nodetypes))), ("ignorableprops", Some(ignorablepropsQuery.toParamString(ignorableprops))), ("ignorablenodes", Some(ignorablenodesQuery.toParamString(ignorablenodes))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("distfolders", Some(distfoldersQuery.toParamString(distfolders))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSyncImplPublisherSyncServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], activeRunModes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], activeRunModesQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo] = jsonOf[ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.sync.impl.PublisherSyncServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("activeRunModes", Some(activeRunModesQuery.toParamString(activeRunModes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSyncImplUserSyncListenerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], nodetypes: List[String], ignorableprops: List[String], ignorablenodes: List[String], enabled: Boolean, distfolders: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nodetypesQuery: QueryParam[List[String]], ignorablepropsQuery: QueryParam[List[String]], ignorablenodesQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], distfoldersQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialSyncImplUserSyncListenerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSyncImplUserSyncListenerImplInfo] = jsonOf[ComAdobeCqSocialSyncImplUserSyncListenerImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.sync.impl.UserSyncListenerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("nodetypes", Some(nodetypesQuery.toParamString(nodetypes))), ("ignorableprops", Some(ignorablepropsQuery.toParamString(ignorableprops))), ("ignorablenodes", Some(ignorablenodesQuery.toParamString(ignorablenodes))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("distfolders", Some(distfoldersQuery.toParamString(distfolders))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSyncImplUserSyncListenerImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialTranslationImplTranslationServiceConfigManager(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], translateLanguage: String, translateDisplay: String, translateAttribution: Boolean, translateCaching: String, translateSmartRendering: String, translateCachingDuration: String, translateSessionSaveInterval: String, translateSessionSaveBatchLimit: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], translateLanguageQuery: QueryParam[String], translateDisplayQuery: QueryParam[String], translateAttributionQuery: QueryParam[Boolean], translateCachingQuery: QueryParam[String], translateSmartRenderingQuery: QueryParam[String], translateCachingDurationQuery: QueryParam[String], translateSessionSaveIntervalQuery: QueryParam[String], translateSessionSaveBatchLimitQuery: QueryParam[String]): Task[ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo] = jsonOf[ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.translation.impl.TranslationServiceConfigManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("translateLanguage", Some(translate.languageQuery.toParamString(translate.language))), ("translateDisplay", Some(translate.displayQuery.toParamString(translate.display))), ("translateAttribution", Some(translate.attributionQuery.toParamString(translate.attribution))), ("translateCaching", Some(translate.cachingQuery.toParamString(translate.caching))), ("translateSmartRendering", Some(translate.smart.renderingQuery.toParamString(translate.smart.rendering))), ("translateCachingDuration", Some(translate.caching.durationQuery.toParamString(translate.caching.duration))), ("translateSessionSaveInterval", Some(translate.session.save.intervalQuery.toParamString(translate.session.save.interval))), ("translateSessionSaveBatchLimit", Some(translate.session.save.batchLimitQuery.toParamString(translate.session.save.batchLimit))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialTranslationImplUGCLanguageDetector(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String, eventFilter: String, translateListenerType: List[String], translatePropertyList: List[String], poolSize: Integer, maxPoolSize: Integer, queueSize: Integer, keepAliveTime: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String], eventFilterQuery: QueryParam[String], translateListenerTypeQuery: QueryParam[List[String]], translatePropertyListQuery: QueryParam[List[String]], poolSizeQuery: QueryParam[Integer], maxPoolSizeQuery: QueryParam[Integer], queueSizeQuery: QueryParam[Integer], keepAliveTimeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo] = jsonOf[ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.translation.impl.UGCLanguageDetector"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("translateListenerType", Some(translate.listener.typeQuery.toParamString(translate.listener.type))), ("translatePropertyList", Some(translate.property.listQuery.toParamString(translate.property.list))), ("poolSize", Some(poolSizeQuery.toParamString(poolSize))), ("maxPoolSize", Some(maxPoolSizeQuery.toParamString(maxPoolSize))), ("queueSize", Some(queueSizeQuery.toParamString(queueSize))), ("keepAliveTime", Some(keepAliveTimeQuery.toParamString(keepAliveTime))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseDispatcherImplFlushServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], threadPoolSize: Integer, delayTime: Integer, workerSleepTime: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], threadPoolSizeQuery: QueryParam[Integer], delayTimeQuery: QueryParam[Integer], workerSleepTimeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo] = jsonOf[ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.dispatcher.impl.FlushServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("threadPoolSize", Some(threadPoolSizeQuery.toParamString(threadPoolSize))), ("delayTime", Some(delayTimeQuery.toParamString(delayTime))), ("workerSleepTime", Some(workerSleepTimeQuery.toParamString(workerSleepTime))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseImplAysncReverseReplicatorImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], poolSize: Integer, maxPoolSize: Integer, queueSize: Integer, keepAliveTime: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], poolSizeQuery: QueryParam[Integer], maxPoolSizeQuery: QueryParam[Integer], queueSizeQuery: QueryParam[Integer], keepAliveTimeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo] = jsonOf[ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.AysncReverseReplicatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("poolSize", Some(poolSizeQuery.toParamString(poolSize))), ("maxPoolSize", Some(maxPoolSizeQuery.toParamString(maxPoolSize))), ("queueSize", Some(queueSizeQuery.toParamString(queueSize))), ("keepAliveTime", Some(keepAliveTimeQuery.toParamString(keepAliveTime))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseImplPublisherConfigurationImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], isPrimaryPublisher: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], isPrimaryPublisherQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo] = jsonOf[ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.PublisherConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("isPrimaryPublisher", Some(isPrimaryPublisherQuery.toParamString(isPrimaryPublisher))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseImplSocialUtilsImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], legacyCloudUGCPathMapping: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], legacyCloudUGCPathMappingQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo] = jsonOf[ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.SocialUtilsImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("legacyCloudUGCPathMapping", Some(legacyCloudUGCPathMappingQuery.toParamString(legacyCloudUGCPathMapping))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseModerationImplAutoModerationImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], automoderationSequence: List[String], automoderationOnfailurestop: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], automoderationSequenceQuery: QueryParam[List[String]], automoderationOnfailurestopQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo] = jsonOf[ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.moderation.impl.AutoModerationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("automoderationSequence", Some(automoderation.sequenceQuery.toParamString(automoderation.sequence))), ("automoderationOnfailurestop", Some(automoderation.onfailurestopQuery.toParamString(automoderation.onfailurestop))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseModerationImplSentimentProcess(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], watchwordsPositive: List[String], watchwordsNegative: List[String], watchwordsPath: String, sentimentPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], watchwordsPositiveQuery: QueryParam[List[String]], watchwordsNegativeQuery: QueryParam[List[String]], watchwordsPathQuery: QueryParam[String], sentimentPathQuery: QueryParam[String]): Task[ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo] = jsonOf[ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.moderation.impl.SentimentProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("watchwordsPositive", Some(watchwords.positiveQuery.toParamString(watchwords.positive))), ("watchwordsNegative", Some(watchwords.negativeQuery.toParamString(watchwords.negative))), ("watchwordsPath", Some(watchwords.pathQuery.toParamString(watchwords.path))), ("sentimentPath", Some(sentiment.pathQuery.toParamString(sentiment.path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackli(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultAttachmentTypeBlacklist: List[String], baselineAttachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultAttachmentTypeBlacklistQuery: QueryParam[List[String]], baselineAttachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo] = jsonOf[ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.security.impl.DefaultAttachmentTypeBlacklistService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultAttachmentTypeBlacklist", Some(default.attachment.type.blacklistQuery.toParamString(default.attachment.type.blacklist))), ("baselineAttachmentTypeBlacklist", Some(baseline.attachment.type.blacklistQuery.toParamString(baseline.attachment.type.blacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], parameterWhitelist: List[String], parameterWhitelistPrefixes: List[String], binaryParameterWhitelist: List[String], modifierWhitelist: List[String], operationWhitelist: List[String], operationWhitelistPrefixes: List[String], typehintWhitelist: List[String], resourcetypeWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], parameterWhitelistQuery: QueryParam[List[String]], parameterWhitelistPrefixesQuery: QueryParam[List[String]], binaryParameterWhitelistQuery: QueryParam[List[String]], modifierWhitelistQuery: QueryParam[List[String]], operationWhitelistQuery: QueryParam[List[String]], operationWhitelistPrefixesQuery: QueryParam[List[String]], typehintWhitelistQuery: QueryParam[List[String]], resourcetypeWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo] = jsonOf[ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.security.impl.SaferSlingPostValidatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("parameterWhitelist", Some(parameter.whitelistQuery.toParamString(parameter.whitelist))), ("parameterWhitelistPrefixes", Some(parameter.whitelist.prefixesQuery.toParamString(parameter.whitelist.prefixes))), ("binaryParameterWhitelist", Some(binary.parameter.whitelistQuery.toParamString(binary.parameter.whitelist))), ("modifierWhitelist", Some(modifier.whitelistQuery.toParamString(modifier.whitelist))), ("operationWhitelist", Some(operation.whitelistQuery.toParamString(operation.whitelist))), ("operationWhitelistPrefixes", Some(operation.whitelist.prefixesQuery.toParamString(operation.whitelist.prefixes))), ("typehintWhitelist", Some(typehint.whitelistQuery.toParamString(typehint.whitelist))), ("resourcetypeWhitelist", Some(resourcetype.whitelistQuery.toParamString(resourcetype.whitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletExtensions: String, slingServletPaths: String, slingServletMethods: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletExtensionsQuery: QueryParam[String], slingServletPathsQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[String]): Task[ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo] = jsonOf[ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.user.endpoints.impl.UsersGroupFromPublishServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletExtensions", Some(sling.servlet.extensionsQuery.toParamString(sling.servlet.extensions))), ("slingServletPaths", Some(sling.servlet.pathsQuery.toParamString(sling.servlet.paths))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUserImplTransportHttpToPublisher(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enable: Boolean, agentConfiguration: List[String], contextPath: String, disabledCipherSuites: List[String], enabledCipherSuites: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableQuery: QueryParam[Boolean], agentConfigurationQuery: QueryParam[List[String]], contextPathQuery: QueryParam[String], disabledCipherSuitesQuery: QueryParam[List[String]], enabledCipherSuitesQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialUserImplTransportHttpToPublisherInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUserImplTransportHttpToPublisherInfo] = jsonOf[ComAdobeCqSocialUserImplTransportHttpToPublisherInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.user.impl.transport.HttpToPublisher"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enable", Some(enableQuery.toParamString(enable))), ("agentConfiguration", Some(agent.configurationQuery.toParamString(agent.configuration))), ("contextPath", Some(context.pathQuery.toParamString(context.path))), ("disabledCipherSuites", Some(disabled.cipher.suitesQuery.toParamString(disabled.cipher.suites))), ("enabledCipherSuites", Some(enabled.cipher.suitesQuery.toParamString(enabled.cipher.suites))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUserImplTransportHttpToPublisherInfo](req)

    } yield resp
  }
  
  def comAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFact(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], resourceTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], resourceTypesQuery: QueryParam[List[String]]): Task[ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo] = jsonOf[ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo]

    val path = "/system/console/configMgr/com.adobe.cq.ui.wcm.commons.internal.servlets.rte.RTEFilterServletFactory.amended"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("resourceTypes", Some(resource.typesQuery.toParamString(resource.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo](req)

    } yield resp
  }
  
  def comAdobeCqUpgradesCleanupImplUpgradeContentCleanup(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], deletePathRegexps: List[String], deleteSql2Query: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], deletePathRegexpsQuery: QueryParam[List[String]], deleteSql2QueryQuery: QueryParam[String]): Task[ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo] = jsonOf[ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo]

    val path = "/system/console/configMgr/com.adobe.cq.upgrades.cleanup.impl.UpgradeContentCleanup"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("deletePathRegexps", Some(delete.path.regexpsQuery.toParamString(delete.path.regexps))), ("deleteSql2Query", Some(delete.sql2.queryQuery.toParamString(delete.sql2.query))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo](req)

    } yield resp
  }
  
  def comAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanup(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], deleteNameRegexps: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], deleteNameRegexpsQuery: QueryParam[List[String]]): Task[ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo] = jsonOf[ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo]

    val path = "/system/console/configMgr/com.adobe.cq.upgrades.cleanup.impl.UpgradeInstallFolderCleanup"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("deleteNameRegexps", Some(delete.name.regexpsQuery.toParamString(delete.name.regexps))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], threshold: Integer, jobTopicName: String, emailEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], thresholdQuery: QueryParam[Integer], jobTopicNameQuery: QueryParam[String], emailEnabledQuery: QueryParam[Boolean]): Task[ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo] = jsonOf[ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncDeleteConfigProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("threshold", Some(thresholdQuery.toParamString(threshold))), ("jobTopicName", Some(jobTopicNameQuery.toParamString(jobTopicName))), ("emailEnabled", Some(emailEnabledQuery.toParamString(emailEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTask(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, jobPurgeThreshold: Integer, jobPurgeMaxJobs: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], jobPurgeThresholdQuery: QueryParam[Integer], jobPurgeMaxJobsQuery: QueryParam[Integer]): Task[ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo] = jsonOf[ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncJobCleanUpTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("jobPurgeThreshold", Some(job.purge.thresholdQuery.toParamString(job.purge.threshold))), ("jobPurgeMaxJobs", Some(job.purge.max.jobsQuery.toParamString(job.purge.max.jobs))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], threshold: Integer, jobTopicName: String, emailEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], thresholdQuery: QueryParam[Integer], jobTopicNameQuery: QueryParam[String], emailEnabledQuery: QueryParam[Boolean]): Task[ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo] = jsonOf[ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncMoveConfigProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("threshold", Some(thresholdQuery.toParamString(threshold))), ("jobTopicName", Some(jobTopicNameQuery.toParamString(jobTopicName))), ("emailEnabled", Some(emailEnabledQuery.toParamString(emailEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], threshold: Integer, jobTopicName: String, emailEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], thresholdQuery: QueryParam[Integer], jobTopicNameQuery: QueryParam[String], emailEnabledQuery: QueryParam[Boolean]): Task[ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo] = jsonOf[ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncPageMoveConfigProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("threshold", Some(thresholdQuery.toParamString(threshold))), ("jobTopicName", Some(jobTopicNameQuery.toParamString(jobTopicName))), ("emailEnabled", Some(emailEnabledQuery.toParamString(emailEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmLaunchesImplLaunchesEventHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String, launchesEventhandlerThreadpoolMaxsize: Integer, launchesEventhandlerThreadpoolPriority: String, launchesEventhandlerUpdatelastmodification: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String], launchesEventhandlerThreadpoolMaxsizeQuery: QueryParam[Integer], launchesEventhandlerThreadpoolPriorityQuery: QueryParam[String], launchesEventhandlerUpdatelastmodificationQuery: QueryParam[Boolean]): Task[ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo] = jsonOf[ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.launches.impl.LaunchesEventHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("launchesEventhandlerThreadpoolMaxsize", Some(launches.eventhandler.threadpool.maxsizeQuery.toParamString(launches.eventhandler.threadpool.maxsize))), ("launchesEventhandlerThreadpoolPriority", Some(launches.eventhandler.threadpool.priorityQuery.toParamString(launches.eventhandler.threadpool.priority))), ("launchesEventhandlerUpdatelastmodification", Some(launches.eventhandler.updatelastmodificationQuery.toParamString(launches.eventhandler.updatelastmodification))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmMobileQrcodeServletQRCodeImageGenerator(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmQrcodeServletWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmQrcodeServletWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo] = jsonOf[ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.mobile.qrcode.servlet.QRCodeImageGenerator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmQrcodeServletWhitelist", Some(cq.wcm.qrcode.servlet.whitelistQuery.toParamString(cq.wcm.qrcode.servlet.whitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmStyleInternalComponentStyleInfoCacheImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], size: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], sizeQuery: QueryParam[Integer]): Task[ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo] = jsonOf[ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.style.internal.ComponentStyleInfoCacheImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("size", Some(sizeQuery.toParamString(size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmTranslationImplTranslationPlatformConfigurationImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], syncTranslationStateSchedulingFormat: String, schedulingRepeatTranslationSchedulingFormat: String, syncTranslationStateLockTimeoutInMinutes: String, exportFormat: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], syncTranslationStateSchedulingFormatQuery: QueryParam[String], schedulingRepeatTranslationSchedulingFormatQuery: QueryParam[String], syncTranslationStateLockTimeoutInMinutesQuery: QueryParam[String], exportFormatQuery: QueryParam[String]): Task[ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo] = jsonOf[ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.translation.impl.TranslationPlatformConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("syncTranslationStateSchedulingFormat", Some(syncTranslationState.schedulingFormatQuery.toParamString(syncTranslationState.schedulingFormat))), ("schedulingRepeatTranslationSchedulingFormat", Some(schedulingRepeatTranslation.schedulingFormatQuery.toParamString(schedulingRepeatTranslation.schedulingFormat))), ("syncTranslationStateLockTimeoutInMinutes", Some(syncTranslationState.lockTimeoutInMinutesQuery.toParamString(syncTranslationState.lockTimeoutInMinutes))), ("exportFormat", Some(export.formatQuery.toParamString(export.format))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo](req)

    } yield resp
  }
  
  def comAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], portalOutboxes: List[String], draftDataService: String, draftMetadataService: String, submitDataService: String, submitMetadataService: String, pendingSignDataService: String, pendingSignMetadataService: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], portalOutboxesQuery: QueryParam[List[String]], draftDataServiceQuery: QueryParam[String], draftMetadataServiceQuery: QueryParam[String], submitDataServiceQuery: QueryParam[String], submitMetadataServiceQuery: QueryParam[String], pendingSignDataServiceQuery: QueryParam[String], pendingSignMetadataServiceQuery: QueryParam[String]): Task[ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo] = jsonOf[ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo]

    val path = "/system/console/configMgr/com.adobe.fd.fp.config.FormsPortalDraftsandSubmissionConfigService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("portalOutboxes", Some(portal.outboxesQuery.toParamString(portal.outboxes))), ("draftDataService", Some(draft.data.serviceQuery.toParamString(draft.data.service))), ("draftMetadataService", Some(draft.metadata.serviceQuery.toParamString(draft.metadata.service))), ("submitDataService", Some(submit.data.serviceQuery.toParamString(submit.data.service))), ("submitMetadataService", Some(submit.metadata.serviceQuery.toParamString(submit.metadata.service))), ("pendingSignDataService", Some(pendingSign.data.serviceQuery.toParamString(pendingSign.data.service))), ("pendingSignMetadataService", Some(pendingSign.metadata.serviceQuery.toParamString(pendingSign.metadata.service))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo](req)

    } yield resp
  }
  
  def comAdobeFdFpConfigFormsPortalSchedulerService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], formportalInterval: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], formportalIntervalQuery: QueryParam[String]): Task[ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo] = jsonOf[ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo]

    val path = "/system/console/configMgr/com.adobe.fd.fp.config.FormsPortalSchedulerService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("formportalInterval", Some(formportal.intervalQuery.toParamString(formportal.interval))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo](req)

    } yield resp
  }
  
  def comAdobeFormsCommonServiceImplDefaultDataProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], alloweddataFileLocations: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], alloweddataFileLocationsQuery: QueryParam[List[String]]): Task[ComAdobeFormsCommonServiceImplDefaultDataProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeFormsCommonServiceImplDefaultDataProviderInfo] = jsonOf[ComAdobeFormsCommonServiceImplDefaultDataProviderInfo]

    val path = "/system/console/configMgr/com.adobe.forms.common.service.impl.DefaultDataProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("alloweddataFileLocations", Some(alloweddataFileLocationsQuery.toParamString(alloweddataFileLocations))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeFormsCommonServiceImplDefaultDataProviderInfo](req)

    } yield resp
  }
  
  def comAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImp(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], tempStorageConfig: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], tempStorageConfigQuery: QueryParam[String]): Task[ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo] = jsonOf[ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo]

    val path = "/system/console/configMgr/com.adobe.forms.common.service.impl.FormsCommonConfigurationServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("tempStorageConfig", Some(tempStorageConfigQuery.toParamString(tempStorageConfig))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo](req)

    } yield resp
  }
  
  def comAdobeFormsCommonServletTempCleanUpTask(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, durationForTemporaryStorage: String, durationForAnonymousStorage: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], durationForTemporaryStorageQuery: QueryParam[String], durationForAnonymousStorageQuery: QueryParam[String]): Task[ComAdobeFormsCommonServletTempCleanUpTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeFormsCommonServletTempCleanUpTaskInfo] = jsonOf[ComAdobeFormsCommonServletTempCleanUpTaskInfo]

    val path = "/system/console/configMgr/com.adobe.forms.common.servlet.TempCleanUpTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("durationForTemporaryStorage", Some(Duration for Temporary StorageQuery.toParamString(Duration for Temporary Storage))), ("durationForAnonymousStorage", Some(Duration for Anonymous StorageQuery.toParamString(Duration for Anonymous Storage))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeFormsCommonServletTempCleanUpTaskInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAcpPlatformPlatformServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], queryLimit: Integer, fileTypeExtensionMap: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], queryLimitQuery: QueryParam[Integer], fileTypeExtensionMapQuery: QueryParam[List[String]]): Task[ComAdobeGraniteAcpPlatformPlatformServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAcpPlatformPlatformServletInfo] = jsonOf[ComAdobeGraniteAcpPlatformPlatformServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.acp.platform.PlatformServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("queryLimit", Some(query.limitQuery.toParamString(query.limit))), ("fileTypeExtensionMap", Some(file.type.extension.mapQuery.toParamString(file.type.extension.map))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAcpPlatformPlatformServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteActivitystreamsImplActivityManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], aggregateRelationships: List[String], aggregateDescendVirtual: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], aggregateRelationshipsQuery: QueryParam[List[String]], aggregateDescendVirtualQuery: QueryParam[Boolean]): Task[ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo] = jsonOf[ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.activitystreams.impl.ActivityManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("aggregateRelationships", Some(aggregate.relationshipsQuery.toParamString(aggregate.relationships))), ("aggregateDescendVirtual", Some(aggregate.descend.virtualQuery.toParamString(aggregate.descend.virtual))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAnalyzerBaseSystemStatusServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], disabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], disabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo] = jsonOf[ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.analyzer.base.SystemStatusServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("disabled", Some(disabledQuery.toParamString(disabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], disabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], disabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo] = jsonOf[ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.analyzer.scripts.compile.AllScriptsCompilerServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("disabled", Some(disabledQuery.toParamString(disabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteApicontrollerFilterResolverHookFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeCqCdnCdnRewriter: String, comAdobeCqCloudConfigComponents: String, comAdobeCqCloudConfigCore: String, comAdobeCqCloudConfigUi: String, comAdobeCqComAdobeCqEditor: String, comAdobeCqComAdobeCqProjectsCore: String, comAdobeCqComAdobeCqProjectsWcmCore: String, comAdobeCqComAdobeCqUiCommons: String, comAdobeCqComAdobeCqWcmStyle: String, comAdobeCqCqActivitymapIntegration: String, comAdobeCqCqContexthubCommons: String, comAdobeCqCqDtm: String, comAdobeCqCqHealthcheck: String, comAdobeCqCqMultisiteTargeting: String, comAdobeCqCqPreUpgradeCleanup: String, comAdobeCqCqProductInfoProvider: String, comAdobeCqCqRestSites: String, comAdobeCqCqSecurityHc: String, comAdobeCqDamCqDamSvgHandler: String, comAdobeCqDamCqScene7Imaging: String, comAdobeCqDtmReactorCore: String, comAdobeCqDtmReactorUi: String, comAdobeCqExpJspelResolver: String, comAdobeCqInboxCqInbox: String, comAdobeCqJsonSchemaParser: String, comAdobeCqMediaCqMediaPublishingDpsFpCore: String, comAdobeCqMobileCqMobileCaas: String, comAdobeCqMobileCqMobileIndexBuilder: String, comAdobeCqMobileCqMobilePhonegapBuild: String, comAdobeCqMyspell: String, comAdobeCqSampleWeRetailCore: String, comAdobeCqScreensComAdobeCqScreensDcc: String, comAdobeCqScreensComAdobeCqScreensMqCore: String, comAdobeCqSocialCqSocialAsProvider: String, comAdobeCqSocialCqSocialBadgingBasicImpl: String, comAdobeCqSocialCqSocialBadgingImpl: String, comAdobeCqSocialCqSocialCalendarImpl: String, comAdobeCqSocialCqSocialContentFragmentsImpl: String, comAdobeCqSocialCqSocialEnablementImpl: String, comAdobeCqSocialCqSocialGraphImpl: String, comAdobeCqSocialCqSocialIdeationImpl: String, comAdobeCqSocialCqSocialJcrProvider: String, comAdobeCqSocialCqSocialMembersImpl: String, comAdobeCqSocialCqSocialMsProvider: String, comAdobeCqSocialCqSocialNotificationsChannelsWeb: String, comAdobeCqSocialCqSocialNotificationsImpl: String, comAdobeCqSocialCqSocialRdbProvider: String, comAdobeCqSocialCqSocialScfImpl: String, comAdobeCqSocialCqSocialScoringBasicImpl: String, comAdobeCqSocialCqSocialScoringImpl: String, comAdobeCqSocialCqSocialServiceusersImpl: String, comAdobeCqSocialCqSocialSrpImpl: String, comAdobeCqSocialCqSocialUgcbaseImpl: String, comAdobeDamCqDamCfmImpl: String, comAdobeFormsFoundationFormsFoundationBase: String, comAdobeGraniteApicontroller: String, comAdobeGraniteAssetCore: String, comAdobeGraniteAuthSso: String, comAdobeGraniteBundlesHcImpl: String, comAdobeGraniteCompatRouter: String, comAdobeGraniteConf: String, comAdobeGraniteConfUiCore: String, comAdobeGraniteCors: String, comAdobeGraniteCrxExplorer: String, comAdobeGraniteCrxdeLite: String, comAdobeGraniteCryptoConfig: String, comAdobeGraniteCryptoExtension: String, comAdobeGraniteCryptoFile: String, comAdobeGraniteCryptoJcr: String, comAdobeGraniteCsrf: String, comAdobeGraniteDistributionCore: String, comAdobeGraniteDropwizardMetrics: String, comAdobeGraniteFragsImpl: String, comAdobeGraniteGibson: String, comAdobeGraniteInfocollector: String, comAdobeGraniteInstallerFactoryPackages: String, comAdobeGraniteJettySsl: String, comAdobeGraniteJobsAsync: String, comAdobeGraniteMaintenanceOak: String, comAdobeGraniteMonitoringCore: String, comAdobeGraniteQueries: String, comAdobeGraniteReplicationHcImpl: String, comAdobeGraniteRepositoryChecker: String, comAdobeGraniteRepositoryHcImpl: String, comAdobeGraniteRestAssets: String, comAdobeGraniteSecurityUi: String, comAdobeGraniteStartup: String, comAdobeGraniteTagsoup: String, comAdobeGraniteTaskmanagementCore: String, comAdobeGraniteTaskmanagementWorkflow: String, comAdobeGraniteUiClientlibsCompilerLess: String, comAdobeGraniteUiClientlibsProcessorGcc: String, comAdobeGraniteWebconsolePlugins: String, comAdobeGraniteWorkflowConsole: String, comAdobeXmpWorkerFilesNativeFragmentLinux: String, comAdobeXmpWorkerFilesNativeFragmentMacosx: String, comAdobeXmpWorkerFilesNativeFragmentWin: String, comDayCommonsOsgiWrapperSimpleJndi: String, comDayCqCqAuthhandler: String, comDayCqCqCompatConfigupdate: String, comDayCqCqLicensebranding: String, comDayCqCqNotifcationImpl: String, comDayCqCqReplicationAudit: String, comDayCqCqSearchExt: String, comDayCqDamCqDamAnnotationPrint: String, comDayCqDamCqDamAssetUsage: String, comDayCqDamCqDamS7dam: String, comDayCqDamCqDamSimilaritysearch: String, comDayCqDamDamWebdavSupport: String, comDayCqPreUpgradeTasks: String, comDayCqReplicationExtensions: String, comDayCqWcmCqMsmCore: String, comDayCqWcmCqWcmTranslation: String, dayCommonsJrawio: String, orgApacheAriesJmxWhiteboard: String, orgApacheFelixHttpSslfilter: String, orgApacheFelixOrgApacheFelixThreaddump: String, orgApacheFelixWebconsolePluginsDs: String, orgApacheFelixWebconsolePluginsEvent: String, orgApacheFelixWebconsolePluginsMemoryusage: String, orgApacheFelixWebconsolePluginsPackageadmin: String, orgApacheJackrabbitOakAuthLdap: String, orgApacheJackrabbitOakSegmentTar: String, orgApacheJackrabbitOakSolrOsgi: String, orgApacheSlingBundleresourceImpl: String, orgApacheSlingCommonsFsclassloader: String, orgApacheSlingCommonsLogWebconsole: String, orgApacheSlingDatasource: String, orgApacheSlingDiscoveryBase: String, orgApacheSlingDiscoveryOak: String, orgApacheSlingDiscoverySupport: String, orgApacheSlingDistributionApi: String, orgApacheSlingDistributionCore: String, orgApacheSlingExtensionsWebconsolesecurityprovider: String, orgApacheSlingHcWebconsole: String, orgApacheSlingInstallerConsole: String, orgApacheSlingInstallerProviderFile: String, orgApacheSlingInstallerProviderJcr: String, orgApacheSlingJcrDavex: String, orgApacheSlingJcrResourcesecurity: String, orgApacheSlingJmxProvider: String, orgApacheSlingLaunchpadInstaller: String, orgApacheSlingModelsImpl: String, orgApacheSlingRepoinitParser: String, orgApacheSlingResourceInventory: String, orgApacheSlingResourceresolver: String, orgApacheSlingScriptingJavascript: String, orgApacheSlingScriptingJst: String, orgApacheSlingScriptingSightlyJsProvider: String, orgApacheSlingScriptingSightlyModelsProvider: String, orgApacheSlingSecurity: String, orgApacheSlingServletsCompat: String, orgApacheSlingServletsGet: String, orgApacheSlingStartupfilterDisabler: String, orgApacheSlingTracer: String, weRetailClientAppCore: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeCqCdnCdnRewriterQuery: QueryParam[String], comAdobeCqCloudConfigComponentsQuery: QueryParam[String], comAdobeCqCloudConfigCoreQuery: QueryParam[String], comAdobeCqCloudConfigUiQuery: QueryParam[String], comAdobeCqComAdobeCqEditorQuery: QueryParam[String], comAdobeCqComAdobeCqProjectsCoreQuery: QueryParam[String], comAdobeCqComAdobeCqProjectsWcmCoreQuery: QueryParam[String], comAdobeCqComAdobeCqUiCommonsQuery: QueryParam[String], comAdobeCqComAdobeCqWcmStyleQuery: QueryParam[String], comAdobeCqCqActivitymapIntegrationQuery: QueryParam[String], comAdobeCqCqContexthubCommonsQuery: QueryParam[String], comAdobeCqCqDtmQuery: QueryParam[String], comAdobeCqCqHealthcheckQuery: QueryParam[String], comAdobeCqCqMultisiteTargetingQuery: QueryParam[String], comAdobeCqCqPreUpgradeCleanupQuery: QueryParam[String], comAdobeCqCqProductInfoProviderQuery: QueryParam[String], comAdobeCqCqRestSitesQuery: QueryParam[String], comAdobeCqCqSecurityHcQuery: QueryParam[String], comAdobeCqDamCqDamSvgHandlerQuery: QueryParam[String], comAdobeCqDamCqScene7ImagingQuery: QueryParam[String], comAdobeCqDtmReactorCoreQuery: QueryParam[String], comAdobeCqDtmReactorUiQuery: QueryParam[String], comAdobeCqExpJspelResolverQuery: QueryParam[String], comAdobeCqInboxCqInboxQuery: QueryParam[String], comAdobeCqJsonSchemaParserQuery: QueryParam[String], comAdobeCqMediaCqMediaPublishingDpsFpCoreQuery: QueryParam[String], comAdobeCqMobileCqMobileCaasQuery: QueryParam[String], comAdobeCqMobileCqMobileIndexBuilderQuery: QueryParam[String], comAdobeCqMobileCqMobilePhonegapBuildQuery: QueryParam[String], comAdobeCqMyspellQuery: QueryParam[String], comAdobeCqSampleWeRetailCoreQuery: QueryParam[String], comAdobeCqScreensComAdobeCqScreensDccQuery: QueryParam[String], comAdobeCqScreensComAdobeCqScreensMqCoreQuery: QueryParam[String], comAdobeCqSocialCqSocialAsProviderQuery: QueryParam[String], comAdobeCqSocialCqSocialBadgingBasicImplQuery: QueryParam[String], comAdobeCqSocialCqSocialBadgingImplQuery: QueryParam[String], comAdobeCqSocialCqSocialCalendarImplQuery: QueryParam[String], comAdobeCqSocialCqSocialContentFragmentsImplQuery: QueryParam[String], comAdobeCqSocialCqSocialEnablementImplQuery: QueryParam[String], comAdobeCqSocialCqSocialGraphImplQuery: QueryParam[String], comAdobeCqSocialCqSocialIdeationImplQuery: QueryParam[String], comAdobeCqSocialCqSocialJcrProviderQuery: QueryParam[String], comAdobeCqSocialCqSocialMembersImplQuery: QueryParam[String], comAdobeCqSocialCqSocialMsProviderQuery: QueryParam[String], comAdobeCqSocialCqSocialNotificationsChannelsWebQuery: QueryParam[String], comAdobeCqSocialCqSocialNotificationsImplQuery: QueryParam[String], comAdobeCqSocialCqSocialRdbProviderQuery: QueryParam[String], comAdobeCqSocialCqSocialScfImplQuery: QueryParam[String], comAdobeCqSocialCqSocialScoringBasicImplQuery: QueryParam[String], comAdobeCqSocialCqSocialScoringImplQuery: QueryParam[String], comAdobeCqSocialCqSocialServiceusersImplQuery: QueryParam[String], comAdobeCqSocialCqSocialSrpImplQuery: QueryParam[String], comAdobeCqSocialCqSocialUgcbaseImplQuery: QueryParam[String], comAdobeDamCqDamCfmImplQuery: QueryParam[String], comAdobeFormsFoundationFormsFoundationBaseQuery: QueryParam[String], comAdobeGraniteApicontrollerQuery: QueryParam[String], comAdobeGraniteAssetCoreQuery: QueryParam[String], comAdobeGraniteAuthSsoQuery: QueryParam[String], comAdobeGraniteBundlesHcImplQuery: QueryParam[String], comAdobeGraniteCompatRouterQuery: QueryParam[String], comAdobeGraniteConfQuery: QueryParam[String], comAdobeGraniteConfUiCoreQuery: QueryParam[String], comAdobeGraniteCorsQuery: QueryParam[String], comAdobeGraniteCrxExplorerQuery: QueryParam[String], comAdobeGraniteCrxdeLiteQuery: QueryParam[String], comAdobeGraniteCryptoConfigQuery: QueryParam[String], comAdobeGraniteCryptoExtensionQuery: QueryParam[String], comAdobeGraniteCryptoFileQuery: QueryParam[String], comAdobeGraniteCryptoJcrQuery: QueryParam[String], comAdobeGraniteCsrfQuery: QueryParam[String], comAdobeGraniteDistributionCoreQuery: QueryParam[String], comAdobeGraniteDropwizardMetricsQuery: QueryParam[String], comAdobeGraniteFragsImplQuery: QueryParam[String], comAdobeGraniteGibsonQuery: QueryParam[String], comAdobeGraniteInfocollectorQuery: QueryParam[String], comAdobeGraniteInstallerFactoryPackagesQuery: QueryParam[String], comAdobeGraniteJettySslQuery: QueryParam[String], comAdobeGraniteJobsAsyncQuery: QueryParam[String], comAdobeGraniteMaintenanceOakQuery: QueryParam[String], comAdobeGraniteMonitoringCoreQuery: QueryParam[String], comAdobeGraniteQueriesQuery: QueryParam[String], comAdobeGraniteReplicationHcImplQuery: QueryParam[String], comAdobeGraniteRepositoryCheckerQuery: QueryParam[String], comAdobeGraniteRepositoryHcImplQuery: QueryParam[String], comAdobeGraniteRestAssetsQuery: QueryParam[String], comAdobeGraniteSecurityUiQuery: QueryParam[String], comAdobeGraniteStartupQuery: QueryParam[String], comAdobeGraniteTagsoupQuery: QueryParam[String], comAdobeGraniteTaskmanagementCoreQuery: QueryParam[String], comAdobeGraniteTaskmanagementWorkflowQuery: QueryParam[String], comAdobeGraniteUiClientlibsCompilerLessQuery: QueryParam[String], comAdobeGraniteUiClientlibsProcessorGccQuery: QueryParam[String], comAdobeGraniteWebconsolePluginsQuery: QueryParam[String], comAdobeGraniteWorkflowConsoleQuery: QueryParam[String], comAdobeXmpWorkerFilesNativeFragmentLinuxQuery: QueryParam[String], comAdobeXmpWorkerFilesNativeFragmentMacosxQuery: QueryParam[String], comAdobeXmpWorkerFilesNativeFragmentWinQuery: QueryParam[String], comDayCommonsOsgiWrapperSimpleJndiQuery: QueryParam[String], comDayCqCqAuthhandlerQuery: QueryParam[String], comDayCqCqCompatConfigupdateQuery: QueryParam[String], comDayCqCqLicensebrandingQuery: QueryParam[String], comDayCqCqNotifcationImplQuery: QueryParam[String], comDayCqCqReplicationAuditQuery: QueryParam[String], comDayCqCqSearchExtQuery: QueryParam[String], comDayCqDamCqDamAnnotationPrintQuery: QueryParam[String], comDayCqDamCqDamAssetUsageQuery: QueryParam[String], comDayCqDamCqDamS7damQuery: QueryParam[String], comDayCqDamCqDamSimilaritysearchQuery: QueryParam[String], comDayCqDamDamWebdavSupportQuery: QueryParam[String], comDayCqPreUpgradeTasksQuery: QueryParam[String], comDayCqReplicationExtensionsQuery: QueryParam[String], comDayCqWcmCqMsmCoreQuery: QueryParam[String], comDayCqWcmCqWcmTranslationQuery: QueryParam[String], dayCommonsJrawioQuery: QueryParam[String], orgApacheAriesJmxWhiteboardQuery: QueryParam[String], orgApacheFelixHttpSslfilterQuery: QueryParam[String], orgApacheFelixOrgApacheFelixThreaddumpQuery: QueryParam[String], orgApacheFelixWebconsolePluginsDsQuery: QueryParam[String], orgApacheFelixWebconsolePluginsEventQuery: QueryParam[String], orgApacheFelixWebconsolePluginsMemoryusageQuery: QueryParam[String], orgApacheFelixWebconsolePluginsPackageadminQuery: QueryParam[String], orgApacheJackrabbitOakAuthLdapQuery: QueryParam[String], orgApacheJackrabbitOakSegmentTarQuery: QueryParam[String], orgApacheJackrabbitOakSolrOsgiQuery: QueryParam[String], orgApacheSlingBundleresourceImplQuery: QueryParam[String], orgApacheSlingCommonsFsclassloaderQuery: QueryParam[String], orgApacheSlingCommonsLogWebconsoleQuery: QueryParam[String], orgApacheSlingDatasourceQuery: QueryParam[String], orgApacheSlingDiscoveryBaseQuery: QueryParam[String], orgApacheSlingDiscoveryOakQuery: QueryParam[String], orgApacheSlingDiscoverySupportQuery: QueryParam[String], orgApacheSlingDistributionApiQuery: QueryParam[String], orgApacheSlingDistributionCoreQuery: QueryParam[String], orgApacheSlingExtensionsWebconsolesecurityproviderQuery: QueryParam[String], orgApacheSlingHcWebconsoleQuery: QueryParam[String], orgApacheSlingInstallerConsoleQuery: QueryParam[String], orgApacheSlingInstallerProviderFileQuery: QueryParam[String], orgApacheSlingInstallerProviderJcrQuery: QueryParam[String], orgApacheSlingJcrDavexQuery: QueryParam[String], orgApacheSlingJcrResourcesecurityQuery: QueryParam[String], orgApacheSlingJmxProviderQuery: QueryParam[String], orgApacheSlingLaunchpadInstallerQuery: QueryParam[String], orgApacheSlingModelsImplQuery: QueryParam[String], orgApacheSlingRepoinitParserQuery: QueryParam[String], orgApacheSlingResourceInventoryQuery: QueryParam[String], orgApacheSlingResourceresolverQuery: QueryParam[String], orgApacheSlingScriptingJavascriptQuery: QueryParam[String], orgApacheSlingScriptingJstQuery: QueryParam[String], orgApacheSlingScriptingSightlyJsProviderQuery: QueryParam[String], orgApacheSlingScriptingSightlyModelsProviderQuery: QueryParam[String], orgApacheSlingSecurityQuery: QueryParam[String], orgApacheSlingServletsCompatQuery: QueryParam[String], orgApacheSlingServletsGetQuery: QueryParam[String], orgApacheSlingStartupfilterDisablerQuery: QueryParam[String], orgApacheSlingTracerQuery: QueryParam[String], weRetailClientAppCoreQuery: QueryParam[String]): Task[ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo] = jsonOf[ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo]

    val path = "/system/console/configMgr/com.adobe.granite.apicontroller.FilterResolverHookFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeCqCdnCdnRewriter", Some(com.adobe.cq.cdn.cdn-rewriterQuery.toParamString(com.adobe.cq.cdn.cdn-rewriter))), ("comAdobeCqCloudConfigComponents", Some(com.adobe.cq.cloud-config.componentsQuery.toParamString(com.adobe.cq.cloud-config.components))), ("comAdobeCqCloudConfigCore", Some(com.adobe.cq.cloud-config.coreQuery.toParamString(com.adobe.cq.cloud-config.core))), ("comAdobeCqCloudConfigUi", Some(com.adobe.cq.cloud-config.uiQuery.toParamString(com.adobe.cq.cloud-config.ui))), ("comAdobeCqComAdobeCqEditor", Some(com.adobe.cq.com.adobe.cq.editorQuery.toParamString(com.adobe.cq.com.adobe.cq.editor))), ("comAdobeCqComAdobeCqProjectsCore", Some(com.adobe.cq.com.adobe.cq.projects.coreQuery.toParamString(com.adobe.cq.com.adobe.cq.projects.core))), ("comAdobeCqComAdobeCqProjectsWcmCore", Some(com.adobe.cq.com.adobe.cq.projects.wcm.coreQuery.toParamString(com.adobe.cq.com.adobe.cq.projects.wcm.core))), ("comAdobeCqComAdobeCqUiCommons", Some(com.adobe.cq.com.adobe.cq.ui.commonsQuery.toParamString(com.adobe.cq.com.adobe.cq.ui.commons))), ("comAdobeCqComAdobeCqWcmStyle", Some(com.adobe.cq.com.adobe.cq.wcm.styleQuery.toParamString(com.adobe.cq.com.adobe.cq.wcm.style))), ("comAdobeCqCqActivitymapIntegration", Some(com.adobe.cq.cq-activitymap-integrationQuery.toParamString(com.adobe.cq.cq-activitymap-integration))), ("comAdobeCqCqContexthubCommons", Some(com.adobe.cq.cq-contexthub-commonsQuery.toParamString(com.adobe.cq.cq-contexthub-commons))), ("comAdobeCqCqDtm", Some(com.adobe.cq.cq-dtmQuery.toParamString(com.adobe.cq.cq-dtm))), ("comAdobeCqCqHealthcheck", Some(com.adobe.cq.cq-healthcheckQuery.toParamString(com.adobe.cq.cq-healthcheck))), ("comAdobeCqCqMultisiteTargeting", Some(com.adobe.cq.cq-multisite-targetingQuery.toParamString(com.adobe.cq.cq-multisite-targeting))), ("comAdobeCqCqPreUpgradeCleanup", Some(com.adobe.cq.cq-pre-upgrade-cleanupQuery.toParamString(com.adobe.cq.cq-pre-upgrade-cleanup))), ("comAdobeCqCqProductInfoProvider", Some(com.adobe.cq.cq-product-info-providerQuery.toParamString(com.adobe.cq.cq-product-info-provider))), ("comAdobeCqCqRestSites", Some(com.adobe.cq.cq-rest-sitesQuery.toParamString(com.adobe.cq.cq-rest-sites))), ("comAdobeCqCqSecurityHc", Some(com.adobe.cq.cq-security-hcQuery.toParamString(com.adobe.cq.cq-security-hc))), ("comAdobeCqDamCqDamSvgHandler", Some(com.adobe.cq.dam.cq-dam-svg-handlerQuery.toParamString(com.adobe.cq.dam.cq-dam-svg-handler))), ("comAdobeCqDamCqScene7Imaging", Some(com.adobe.cq.dam.cq-scene7-imagingQuery.toParamString(com.adobe.cq.dam.cq-scene7-imaging))), ("comAdobeCqDtmReactorCore", Some(com.adobe.cq.dtm-reactor.coreQuery.toParamString(com.adobe.cq.dtm-reactor.core))), ("comAdobeCqDtmReactorUi", Some(com.adobe.cq.dtm-reactor.uiQuery.toParamString(com.adobe.cq.dtm-reactor.ui))), ("comAdobeCqExpJspelResolver", Some(com.adobe.cq.exp-jspel-resolverQuery.toParamString(com.adobe.cq.exp-jspel-resolver))), ("comAdobeCqInboxCqInbox", Some(com.adobe.cq.inbox.cq-inboxQuery.toParamString(com.adobe.cq.inbox.cq-inbox))), ("comAdobeCqJsonSchemaParser", Some(com.adobe.cq.json-schema-parserQuery.toParamString(com.adobe.cq.json-schema-parser))), ("comAdobeCqMediaCqMediaPublishingDpsFpCore", Some(com.adobe.cq.media.cq-media-publishing-dps-fp-coreQuery.toParamString(com.adobe.cq.media.cq-media-publishing-dps-fp-core))), ("comAdobeCqMobileCqMobileCaas", Some(com.adobe.cq.mobile.cq-mobile-caasQuery.toParamString(com.adobe.cq.mobile.cq-mobile-caas))), ("comAdobeCqMobileCqMobileIndexBuilder", Some(com.adobe.cq.mobile.cq-mobile-index-builderQuery.toParamString(com.adobe.cq.mobile.cq-mobile-index-builder))), ("comAdobeCqMobileCqMobilePhonegapBuild", Some(com.adobe.cq.mobile.cq-mobile-phonegap-buildQuery.toParamString(com.adobe.cq.mobile.cq-mobile-phonegap-build))), ("comAdobeCqMyspell", Some(com.adobe.cq.myspellQuery.toParamString(com.adobe.cq.myspell))), ("comAdobeCqSampleWeRetailCore", Some(com.adobe.cq.sample.we.retail.coreQuery.toParamString(com.adobe.cq.sample.we.retail.core))), ("comAdobeCqScreensComAdobeCqScreensDcc", Some(com.adobe.cq.screens.com.adobe.cq.screens.dccQuery.toParamString(com.adobe.cq.screens.com.adobe.cq.screens.dcc))), ("comAdobeCqScreensComAdobeCqScreensMqCore", Some(com.adobe.cq.screens.com.adobe.cq.screens.mq.coreQuery.toParamString(com.adobe.cq.screens.com.adobe.cq.screens.mq.core))), ("comAdobeCqSocialCqSocialAsProvider", Some(com.adobe.cq.social.cq-social-as-providerQuery.toParamString(com.adobe.cq.social.cq-social-as-provider))), ("comAdobeCqSocialCqSocialBadgingBasicImpl", Some(com.adobe.cq.social.cq-social-badging-basic-implQuery.toParamString(com.adobe.cq.social.cq-social-badging-basic-impl))), ("comAdobeCqSocialCqSocialBadgingImpl", Some(com.adobe.cq.social.cq-social-badging-implQuery.toParamString(com.adobe.cq.social.cq-social-badging-impl))), ("comAdobeCqSocialCqSocialCalendarImpl", Some(com.adobe.cq.social.cq-social-calendar-implQuery.toParamString(com.adobe.cq.social.cq-social-calendar-impl))), ("comAdobeCqSocialCqSocialContentFragmentsImpl", Some(com.adobe.cq.social.cq-social-content-fragments-implQuery.toParamString(com.adobe.cq.social.cq-social-content-fragments-impl))), ("comAdobeCqSocialCqSocialEnablementImpl", Some(com.adobe.cq.social.cq-social-enablement-implQuery.toParamString(com.adobe.cq.social.cq-social-enablement-impl))), ("comAdobeCqSocialCqSocialGraphImpl", Some(com.adobe.cq.social.cq-social-graph-implQuery.toParamString(com.adobe.cq.social.cq-social-graph-impl))), ("comAdobeCqSocialCqSocialIdeationImpl", Some(com.adobe.cq.social.cq-social-ideation-implQuery.toParamString(com.adobe.cq.social.cq-social-ideation-impl))), ("comAdobeCqSocialCqSocialJcrProvider", Some(com.adobe.cq.social.cq-social-jcr-providerQuery.toParamString(com.adobe.cq.social.cq-social-jcr-provider))), ("comAdobeCqSocialCqSocialMembersImpl", Some(com.adobe.cq.social.cq-social-members-implQuery.toParamString(com.adobe.cq.social.cq-social-members-impl))), ("comAdobeCqSocialCqSocialMsProvider", Some(com.adobe.cq.social.cq-social-ms-providerQuery.toParamString(com.adobe.cq.social.cq-social-ms-provider))), ("comAdobeCqSocialCqSocialNotificationsChannelsWeb", Some(com.adobe.cq.social.cq-social-notifications-channels-webQuery.toParamString(com.adobe.cq.social.cq-social-notifications-channels-web))), ("comAdobeCqSocialCqSocialNotificationsImpl", Some(com.adobe.cq.social.cq-social-notifications-implQuery.toParamString(com.adobe.cq.social.cq-social-notifications-impl))), ("comAdobeCqSocialCqSocialRdbProvider", Some(com.adobe.cq.social.cq-social-rdb-providerQuery.toParamString(com.adobe.cq.social.cq-social-rdb-provider))), ("comAdobeCqSocialCqSocialScfImpl", Some(com.adobe.cq.social.cq-social-scf-implQuery.toParamString(com.adobe.cq.social.cq-social-scf-impl))), ("comAdobeCqSocialCqSocialScoringBasicImpl", Some(com.adobe.cq.social.cq-social-scoring-basic-implQuery.toParamString(com.adobe.cq.social.cq-social-scoring-basic-impl))), ("comAdobeCqSocialCqSocialScoringImpl", Some(com.adobe.cq.social.cq-social-scoring-implQuery.toParamString(com.adobe.cq.social.cq-social-scoring-impl))), ("comAdobeCqSocialCqSocialServiceusersImpl", Some(com.adobe.cq.social.cq-social-serviceusers-implQuery.toParamString(com.adobe.cq.social.cq-social-serviceusers-impl))), ("comAdobeCqSocialCqSocialSrpImpl", Some(com.adobe.cq.social.cq-social-srp-implQuery.toParamString(com.adobe.cq.social.cq-social-srp-impl))), ("comAdobeCqSocialCqSocialUgcbaseImpl", Some(com.adobe.cq.social.cq-social-ugcbase-implQuery.toParamString(com.adobe.cq.social.cq-social-ugcbase-impl))), ("comAdobeDamCqDamCfmImpl", Some(com.adobe.dam.cq-dam-cfm-implQuery.toParamString(com.adobe.dam.cq-dam-cfm-impl))), ("comAdobeFormsFoundationFormsFoundationBase", Some(com.adobe.forms.foundation-forms-foundation-baseQuery.toParamString(com.adobe.forms.foundation-forms-foundation-base))), ("comAdobeGraniteApicontroller", Some(com.adobe.granite.apicontrollerQuery.toParamString(com.adobe.granite.apicontroller))), ("comAdobeGraniteAssetCore", Some(com.adobe.granite.asset.coreQuery.toParamString(com.adobe.granite.asset.core))), ("comAdobeGraniteAuthSso", Some(com.adobe.granite.auth.ssoQuery.toParamString(com.adobe.granite.auth.sso))), ("comAdobeGraniteBundlesHcImpl", Some(com.adobe.granite.bundles.hc.implQuery.toParamString(com.adobe.granite.bundles.hc.impl))), ("comAdobeGraniteCompatRouter", Some(com.adobe.granite.compat-routerQuery.toParamString(com.adobe.granite.compat-router))), ("comAdobeGraniteConf", Some(com.adobe.granite.confQuery.toParamString(com.adobe.granite.conf))), ("comAdobeGraniteConfUiCore", Some(com.adobe.granite.conf.ui.coreQuery.toParamString(com.adobe.granite.conf.ui.core))), ("comAdobeGraniteCors", Some(com.adobe.granite.corsQuery.toParamString(com.adobe.granite.cors))), ("comAdobeGraniteCrxExplorer", Some(com.adobe.granite.crx-explorerQuery.toParamString(com.adobe.granite.crx-explorer))), ("comAdobeGraniteCrxdeLite", Some(com.adobe.granite.crxde-liteQuery.toParamString(com.adobe.granite.crxde-lite))), ("comAdobeGraniteCryptoConfig", Some(com.adobe.granite.crypto.configQuery.toParamString(com.adobe.granite.crypto.config))), ("comAdobeGraniteCryptoExtension", Some(com.adobe.granite.crypto.extensionQuery.toParamString(com.adobe.granite.crypto.extension))), ("comAdobeGraniteCryptoFile", Some(com.adobe.granite.crypto.fileQuery.toParamString(com.adobe.granite.crypto.file))), ("comAdobeGraniteCryptoJcr", Some(com.adobe.granite.crypto.jcrQuery.toParamString(com.adobe.granite.crypto.jcr))), ("comAdobeGraniteCsrf", Some(com.adobe.granite.csrfQuery.toParamString(com.adobe.granite.csrf))), ("comAdobeGraniteDistributionCore", Some(com.adobe.granite.distribution.coreQuery.toParamString(com.adobe.granite.distribution.core))), ("comAdobeGraniteDropwizardMetrics", Some(com.adobe.granite.dropwizard.metricsQuery.toParamString(com.adobe.granite.dropwizard.metrics))), ("comAdobeGraniteFragsImpl", Some(com.adobe.granite.frags.implQuery.toParamString(com.adobe.granite.frags.impl))), ("comAdobeGraniteGibson", Some(com.adobe.granite.gibsonQuery.toParamString(com.adobe.granite.gibson))), ("comAdobeGraniteInfocollector", Some(com.adobe.granite.infocollectorQuery.toParamString(com.adobe.granite.infocollector))), ("comAdobeGraniteInstallerFactoryPackages", Some(com.adobe.granite.installer.factory.packagesQuery.toParamString(com.adobe.granite.installer.factory.packages))), ("comAdobeGraniteJettySsl", Some(com.adobe.granite.jetty.sslQuery.toParamString(com.adobe.granite.jetty.ssl))), ("comAdobeGraniteJobsAsync", Some(com.adobe.granite.jobs.asyncQuery.toParamString(com.adobe.granite.jobs.async))), ("comAdobeGraniteMaintenanceOak", Some(com.adobe.granite.maintenance.oakQuery.toParamString(com.adobe.granite.maintenance.oak))), ("comAdobeGraniteMonitoringCore", Some(com.adobe.granite.monitoring.coreQuery.toParamString(com.adobe.granite.monitoring.core))), ("comAdobeGraniteQueries", Some(com.adobe.granite.queriesQuery.toParamString(com.adobe.granite.queries))), ("comAdobeGraniteReplicationHcImpl", Some(com.adobe.granite.replication.hc.implQuery.toParamString(com.adobe.granite.replication.hc.impl))), ("comAdobeGraniteRepositoryChecker", Some(com.adobe.granite.repository.checkerQuery.toParamString(com.adobe.granite.repository.checker))), ("comAdobeGraniteRepositoryHcImpl", Some(com.adobe.granite.repository.hc.implQuery.toParamString(com.adobe.granite.repository.hc.impl))), ("comAdobeGraniteRestAssets", Some(com.adobe.granite.rest.assetsQuery.toParamString(com.adobe.granite.rest.assets))), ("comAdobeGraniteSecurityUi", Some(com.adobe.granite.security.uiQuery.toParamString(com.adobe.granite.security.ui))), ("comAdobeGraniteStartup", Some(com.adobe.granite.startupQuery.toParamString(com.adobe.granite.startup))), ("comAdobeGraniteTagsoup", Some(com.adobe.granite.tagsoupQuery.toParamString(com.adobe.granite.tagsoup))), ("comAdobeGraniteTaskmanagementCore", Some(com.adobe.granite.taskmanagement.coreQuery.toParamString(com.adobe.granite.taskmanagement.core))), ("comAdobeGraniteTaskmanagementWorkflow", Some(com.adobe.granite.taskmanagement.workflowQuery.toParamString(com.adobe.granite.taskmanagement.workflow))), ("comAdobeGraniteUiClientlibsCompilerLess", Some(com.adobe.granite.ui.clientlibs.compiler.lessQuery.toParamString(com.adobe.granite.ui.clientlibs.compiler.less))), ("comAdobeGraniteUiClientlibsProcessorGcc", Some(com.adobe.granite.ui.clientlibs.processor.gccQuery.toParamString(com.adobe.granite.ui.clientlibs.processor.gcc))), ("comAdobeGraniteWebconsolePlugins", Some(com.adobe.granite.webconsole.pluginsQuery.toParamString(com.adobe.granite.webconsole.plugins))), ("comAdobeGraniteWorkflowConsole", Some(com.adobe.granite.workflow.consoleQuery.toParamString(com.adobe.granite.workflow.console))), ("comAdobeXmpWorkerFilesNativeFragmentLinux", Some(com.adobe.xmp.worker.files.native.fragment.linuxQuery.toParamString(com.adobe.xmp.worker.files.native.fragment.linux))), ("comAdobeXmpWorkerFilesNativeFragmentMacosx", Some(com.adobe.xmp.worker.files.native.fragment.macosxQuery.toParamString(com.adobe.xmp.worker.files.native.fragment.macosx))), ("comAdobeXmpWorkerFilesNativeFragmentWin", Some(com.adobe.xmp.worker.files.native.fragment.winQuery.toParamString(com.adobe.xmp.worker.files.native.fragment.win))), ("comDayCommonsOsgiWrapperSimpleJndi", Some(com.day.commons.osgi.wrapper.simple-jndiQuery.toParamString(com.day.commons.osgi.wrapper.simple-jndi))), ("comDayCqCqAuthhandler", Some(com.day.cq.cq-authhandlerQuery.toParamString(com.day.cq.cq-authhandler))), ("comDayCqCqCompatConfigupdate", Some(com.day.cq.cq-compat-configupdateQuery.toParamString(com.day.cq.cq-compat-configupdate))), ("comDayCqCqLicensebranding", Some(com.day.cq.cq-licensebrandingQuery.toParamString(com.day.cq.cq-licensebranding))), ("comDayCqCqNotifcationImpl", Some(com.day.cq.cq-notifcation-implQuery.toParamString(com.day.cq.cq-notifcation-impl))), ("comDayCqCqReplicationAudit", Some(com.day.cq.cq-replication-auditQuery.toParamString(com.day.cq.cq-replication-audit))), ("comDayCqCqSearchExt", Some(com.day.cq.cq-search-extQuery.toParamString(com.day.cq.cq-search-ext))), ("comDayCqDamCqDamAnnotationPrint", Some(com.day.cq.dam.cq-dam-annotation-printQuery.toParamString(com.day.cq.dam.cq-dam-annotation-print))), ("comDayCqDamCqDamAssetUsage", Some(com.day.cq.dam.cq-dam-asset-usageQuery.toParamString(com.day.cq.dam.cq-dam-asset-usage))), ("comDayCqDamCqDamS7dam", Some(com.day.cq.dam.cq-dam-s7damQuery.toParamString(com.day.cq.dam.cq-dam-s7dam))), ("comDayCqDamCqDamSimilaritysearch", Some(com.day.cq.dam.cq-dam-similaritysearchQuery.toParamString(com.day.cq.dam.cq-dam-similaritysearch))), ("comDayCqDamDamWebdavSupport", Some(com.day.cq.dam.dam-webdav-supportQuery.toParamString(com.day.cq.dam.dam-webdav-support))), ("comDayCqPreUpgradeTasks", Some(com.day.cq.pre-upgrade-tasksQuery.toParamString(com.day.cq.pre-upgrade-tasks))), ("comDayCqReplicationExtensions", Some(com.day.cq.replication.extensionsQuery.toParamString(com.day.cq.replication.extensions))), ("comDayCqWcmCqMsmCore", Some(com.day.cq.wcm.cq-msm-coreQuery.toParamString(com.day.cq.wcm.cq-msm-core))), ("comDayCqWcmCqWcmTranslation", Some(com.day.cq.wcm.cq-wcm-translationQuery.toParamString(com.day.cq.wcm.cq-wcm-translation))), ("dayCommonsJrawio", Some(day-commons-jrawioQuery.toParamString(day-commons-jrawio))), ("orgApacheAriesJmxWhiteboard", Some(org.apache.aries.jmx.whiteboardQuery.toParamString(org.apache.aries.jmx.whiteboard))), ("orgApacheFelixHttpSslfilter", Some(org.apache.felix.http.sslfilterQuery.toParamString(org.apache.felix.http.sslfilter))), ("orgApacheFelixOrgApacheFelixThreaddump", Some(org.apache.felix.org.apache.felix.threaddumpQuery.toParamString(org.apache.felix.org.apache.felix.threaddump))), ("orgApacheFelixWebconsolePluginsDs", Some(org.apache.felix.webconsole.plugins.dsQuery.toParamString(org.apache.felix.webconsole.plugins.ds))), ("orgApacheFelixWebconsolePluginsEvent", Some(org.apache.felix.webconsole.plugins.eventQuery.toParamString(org.apache.felix.webconsole.plugins.event))), ("orgApacheFelixWebconsolePluginsMemoryusage", Some(org.apache.felix.webconsole.plugins.memoryusageQuery.toParamString(org.apache.felix.webconsole.plugins.memoryusage))), ("orgApacheFelixWebconsolePluginsPackageadmin", Some(org.apache.felix.webconsole.plugins.packageadminQuery.toParamString(org.apache.felix.webconsole.plugins.packageadmin))), ("orgApacheJackrabbitOakAuthLdap", Some(org.apache.jackrabbit.oak-auth-ldapQuery.toParamString(org.apache.jackrabbit.oak-auth-ldap))), ("orgApacheJackrabbitOakSegmentTar", Some(org.apache.jackrabbit.oak-segment-tarQuery.toParamString(org.apache.jackrabbit.oak-segment-tar))), ("orgApacheJackrabbitOakSolrOsgi", Some(org.apache.jackrabbit.oak-solr-osgiQuery.toParamString(org.apache.jackrabbit.oak-solr-osgi))), ("orgApacheSlingBundleresourceImpl", Some(org.apache.sling.bundleresource.implQuery.toParamString(org.apache.sling.bundleresource.impl))), ("orgApacheSlingCommonsFsclassloader", Some(org.apache.sling.commons.fsclassloaderQuery.toParamString(org.apache.sling.commons.fsclassloader))), ("orgApacheSlingCommonsLogWebconsole", Some(org.apache.sling.commons.log.webconsoleQuery.toParamString(org.apache.sling.commons.log.webconsole))), ("orgApacheSlingDatasource", Some(org.apache.sling.datasourceQuery.toParamString(org.apache.sling.datasource))), ("orgApacheSlingDiscoveryBase", Some(org.apache.sling.discovery.baseQuery.toParamString(org.apache.sling.discovery.base))), ("orgApacheSlingDiscoveryOak", Some(org.apache.sling.discovery.oakQuery.toParamString(org.apache.sling.discovery.oak))), ("orgApacheSlingDiscoverySupport", Some(org.apache.sling.discovery.supportQuery.toParamString(org.apache.sling.discovery.support))), ("orgApacheSlingDistributionApi", Some(org.apache.sling.distribution.apiQuery.toParamString(org.apache.sling.distribution.api))), ("orgApacheSlingDistributionCore", Some(org.apache.sling.distribution.coreQuery.toParamString(org.apache.sling.distribution.core))), ("orgApacheSlingExtensionsWebconsolesecurityprovider", Some(org.apache.sling.extensions.webconsolesecurityproviderQuery.toParamString(org.apache.sling.extensions.webconsolesecurityprovider))), ("orgApacheSlingHcWebconsole", Some(org.apache.sling.hc.webconsoleQuery.toParamString(org.apache.sling.hc.webconsole))), ("orgApacheSlingInstallerConsole", Some(org.apache.sling.installer.consoleQuery.toParamString(org.apache.sling.installer.console))), ("orgApacheSlingInstallerProviderFile", Some(org.apache.sling.installer.provider.fileQuery.toParamString(org.apache.sling.installer.provider.file))), ("orgApacheSlingInstallerProviderJcr", Some(org.apache.sling.installer.provider.jcrQuery.toParamString(org.apache.sling.installer.provider.jcr))), ("orgApacheSlingJcrDavex", Some(org.apache.sling.jcr.davexQuery.toParamString(org.apache.sling.jcr.davex))), ("orgApacheSlingJcrResourcesecurity", Some(org.apache.sling.jcr.resourcesecurityQuery.toParamString(org.apache.sling.jcr.resourcesecurity))), ("orgApacheSlingJmxProvider", Some(org.apache.sling.jmx.providerQuery.toParamString(org.apache.sling.jmx.provider))), ("orgApacheSlingLaunchpadInstaller", Some(org.apache.sling.launchpad.installerQuery.toParamString(org.apache.sling.launchpad.installer))), ("orgApacheSlingModelsImpl", Some(org.apache.sling.models.implQuery.toParamString(org.apache.sling.models.impl))), ("orgApacheSlingRepoinitParser", Some(org.apache.sling.repoinit.parserQuery.toParamString(org.apache.sling.repoinit.parser))), ("orgApacheSlingResourceInventory", Some(org.apache.sling.resource.inventoryQuery.toParamString(org.apache.sling.resource.inventory))), ("orgApacheSlingResourceresolver", Some(org.apache.sling.resourceresolverQuery.toParamString(org.apache.sling.resourceresolver))), ("orgApacheSlingScriptingJavascript", Some(org.apache.sling.scripting.javascriptQuery.toParamString(org.apache.sling.scripting.javascript))), ("orgApacheSlingScriptingJst", Some(org.apache.sling.scripting.jstQuery.toParamString(org.apache.sling.scripting.jst))), ("orgApacheSlingScriptingSightlyJsProvider", Some(org.apache.sling.scripting.sightly.js.providerQuery.toParamString(org.apache.sling.scripting.sightly.js.provider))), ("orgApacheSlingScriptingSightlyModelsProvider", Some(org.apache.sling.scripting.sightly.models.providerQuery.toParamString(org.apache.sling.scripting.sightly.models.provider))), ("orgApacheSlingSecurity", Some(org.apache.sling.securityQuery.toParamString(org.apache.sling.security))), ("orgApacheSlingServletsCompat", Some(org.apache.sling.servlets.compatQuery.toParamString(org.apache.sling.servlets.compat))), ("orgApacheSlingServletsGet", Some(org.apache.sling.servlets.getQuery.toParamString(org.apache.sling.servlets.get))), ("orgApacheSlingStartupfilterDisabler", Some(org.apache.sling.startupfilter.disablerQuery.toParamString(org.apache.sling.startupfilter.disabler))), ("orgApacheSlingTracer", Some(org.apache.sling.tracerQuery.toParamString(org.apache.sling.tracer))), ("weRetailClientAppCore", Some(we.retail.client.app.coreQuery.toParamString(we.retail.client.app.core))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthCertImplClientCertAuthHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], serviceRankingQuery: QueryParam[Integer]): Task[ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo] = jsonOf[ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.cert.impl.ClientCertAuthHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthIms(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], configid: String, scope: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], configidQuery: QueryParam[String], scopeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthImsInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthImsInfo] = jsonOf[ComAdobeGraniteAuthImsInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.ims"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("configid", Some(configidQuery.toParamString(configid))), ("scope", Some(scopeQuery.toParamString(scope))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthImsInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtension(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String]): Task[ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo] = jsonOf[ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.ims.impl.ExternalUserIdMappingProviderExtension"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], authImsClientSecret: String, customizerType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], authImsClientSecretQuery: QueryParam[String], customizerTypeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo] = jsonOf[ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSAccessTokenRequestCustomizerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("authImsClientSecret", Some(auth.ims.client.secretQuery.toParamString(auth.ims.client.secret))), ("customizerType", Some(customizer.typeQuery.toParamString(customizer.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthImsImplIMSInstanceCredentialsValidator(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String]): Task[ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo] = jsonOf[ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSInstanceCredentialsValidator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthImsImplIMSProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String, oauthProviderImsAuthorizationUrl: String, oauthProviderImsTokenUrl: String, oauthProviderImsProfileUrl: String, oauthProviderImsExtendedDetailsUrls: List[String], oauthProviderImsValidateTokenUrl: String, oauthProviderImsSessionProperty: String, oauthProviderImsServiceTokenClientId: String, oauthProviderImsServiceTokenClientSecret: String, oauthProviderImsServiceToken: String, imsOrgRef: String, imsGroupMapping: List[String], oauthProviderImsOnlyLicenseGroup: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String], oauthProviderImsAuthorizationUrlQuery: QueryParam[String], oauthProviderImsTokenUrlQuery: QueryParam[String], oauthProviderImsProfileUrlQuery: QueryParam[String], oauthProviderImsExtendedDetailsUrlsQuery: QueryParam[List[String]], oauthProviderImsValidateTokenUrlQuery: QueryParam[String], oauthProviderImsSessionPropertyQuery: QueryParam[String], oauthProviderImsServiceTokenClientIdQuery: QueryParam[String], oauthProviderImsServiceTokenClientSecretQuery: QueryParam[String], oauthProviderImsServiceTokenQuery: QueryParam[String], imsOrgRefQuery: QueryParam[String], imsGroupMappingQuery: QueryParam[List[String]], oauthProviderImsOnlyLicenseGroupQuery: QueryParam[Boolean]): Task[ComAdobeGraniteAuthImsImplIMSProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthImsImplIMSProviderImplInfo] = jsonOf[ComAdobeGraniteAuthImsImplIMSProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))), ("oauthProviderImsAuthorizationUrl", Some(oauth.provider.ims.authorization.urlQuery.toParamString(oauth.provider.ims.authorization.url))), ("oauthProviderImsTokenUrl", Some(oauth.provider.ims.token.urlQuery.toParamString(oauth.provider.ims.token.url))), ("oauthProviderImsProfileUrl", Some(oauth.provider.ims.profile.urlQuery.toParamString(oauth.provider.ims.profile.url))), ("oauthProviderImsExtendedDetailsUrls", Some(oauth.provider.ims.extended.details.urlsQuery.toParamString(oauth.provider.ims.extended.details.urls))), ("oauthProviderImsValidateTokenUrl", Some(oauth.provider.ims.validate.token.urlQuery.toParamString(oauth.provider.ims.validate.token.url))), ("oauthProviderImsSessionProperty", Some(oauth.provider.ims.session.propertyQuery.toParamString(oauth.provider.ims.session.property))), ("oauthProviderImsServiceTokenClientId", Some(oauth.provider.ims.service.token.client.idQuery.toParamString(oauth.provider.ims.service.token.client.id))), ("oauthProviderImsServiceTokenClientSecret", Some(oauth.provider.ims.service.token.client.secretQuery.toParamString(oauth.provider.ims.service.token.client.secret))), ("oauthProviderImsServiceToken", Some(oauth.provider.ims.service.tokenQuery.toParamString(oauth.provider.ims.service.token))), ("imsOrgRef", Some(ims.org.refQuery.toParamString(ims.org.ref))), ("imsGroupMapping", Some(ims.group.mappingQuery.toParamString(ims.group.mapping))), ("oauthProviderImsOnlyLicenseGroup", Some(oauth.provider.ims.only.license.groupQuery.toParamString(oauth.provider.ims.only.license.group))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthImsImplIMSProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthImsImplImsConfigProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthConfigmanagerImsConfigid: String, imsOwningEntity: String, aemInstanceId: String, imsServiceCode: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthConfigmanagerImsConfigidQuery: QueryParam[String], imsOwningEntityQuery: QueryParam[String], aemInstanceIdQuery: QueryParam[String], imsServiceCodeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo] = jsonOf[ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.ims.impl.ImsConfigProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthConfigmanagerImsConfigid", Some(oauth.configmanager.ims.configidQuery.toParamString(oauth.configmanager.ims.configid))), ("imsOwningEntity", Some(ims.owningEntityQuery.toParamString(ims.owningEntity))), ("aemInstanceId", Some(aem.instanceIdQuery.toParamString(aem.instanceId))), ("imsServiceCode", Some(ims.serviceCodeQuery.toParamString(ims.serviceCode))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthAccesstokenProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, authTokenProviderTitle: String, authTokenProviderDefaultClaims: List[String], authTokenProviderEndpoint: String, authAccessTokenRequest: String, authTokenProviderKeypairAlias: String, authTokenProviderConnTimeout: Integer, authTokenProviderSoTimeout: Integer, authTokenProviderClientId: String, authTokenProviderScope: String, authTokenProviderReuseAccessToken: Boolean, authTokenProviderRelaxedSsl: Boolean, tokenRequestCustomizerType: String, authTokenValidatorType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], authTokenProviderTitleQuery: QueryParam[String], authTokenProviderDefaultClaimsQuery: QueryParam[List[String]], authTokenProviderEndpointQuery: QueryParam[String], authAccessTokenRequestQuery: QueryParam[String], authTokenProviderKeypairAliasQuery: QueryParam[String], authTokenProviderConnTimeoutQuery: QueryParam[Integer], authTokenProviderSoTimeoutQuery: QueryParam[Integer], authTokenProviderClientIdQuery: QueryParam[String], authTokenProviderScopeQuery: QueryParam[String], authTokenProviderReuseAccessTokenQuery: QueryParam[Boolean], authTokenProviderRelaxedSslQuery: QueryParam[Boolean], tokenRequestCustomizerTypeQuery: QueryParam[String], authTokenValidatorTypeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthAccesstokenProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthAccesstokenProviderInfo] = jsonOf[ComAdobeGraniteAuthOauthAccesstokenProviderInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.accesstoken.provider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("authTokenProviderTitle", Some(auth.token.provider.titleQuery.toParamString(auth.token.provider.title))), ("authTokenProviderDefaultClaims", Some(auth.token.provider.default.claimsQuery.toParamString(auth.token.provider.default.claims))), ("authTokenProviderEndpoint", Some(auth.token.provider.endpointQuery.toParamString(auth.token.provider.endpoint))), ("authAccessTokenRequest", Some(auth.access.token.requestQuery.toParamString(auth.access.token.request))), ("authTokenProviderKeypairAlias", Some(auth.token.provider.keypair.aliasQuery.toParamString(auth.token.provider.keypair.alias))), ("authTokenProviderConnTimeout", Some(auth.token.provider.conn.timeoutQuery.toParamString(auth.token.provider.conn.timeout))), ("authTokenProviderSoTimeout", Some(auth.token.provider.so.timeoutQuery.toParamString(auth.token.provider.so.timeout))), ("authTokenProviderClientId", Some(auth.token.provider.client.idQuery.toParamString(auth.token.provider.client.id))), ("authTokenProviderScope", Some(auth.token.provider.scopeQuery.toParamString(auth.token.provider.scope))), ("authTokenProviderReuseAccessToken", Some(auth.token.provider.reuse.access.tokenQuery.toParamString(auth.token.provider.reuse.access.token))), ("authTokenProviderRelaxedSsl", Some(auth.token.provider.relaxed.sslQuery.toParamString(auth.token.provider.relaxed.ssl))), ("tokenRequestCustomizerType", Some(token.request.customizer.typeQuery.toParamString(token.request.customizer.type))), ("authTokenValidatorType", Some(auth.token.validator.typeQuery.toParamString(auth.token.validator.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthAccesstokenProviderInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplBearerAuthenticationHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, oauthClientIdsAllowed: List[String], authBearerSyncIms: Boolean, authTokenRequestParameter: String, oauthBearerConfigid: String, oauthJwtSupport: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], oauthClientIdsAllowedQuery: QueryParam[List[String]], authBearerSyncImsQuery: QueryParam[Boolean], authTokenRequestParameterQuery: QueryParam[String], oauthBearerConfigidQuery: QueryParam[String], oauthJwtSupportQuery: QueryParam[Boolean]): Task[ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo] = jsonOf[ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.BearerAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("oauthClientIdsAllowed", Some(oauth.clientIds.allowedQuery.toParamString(oauth.clientIds.allowed))), ("authBearerSyncIms", Some(auth.bearer.sync.imsQuery.toParamString(auth.bearer.sync.ims))), ("authTokenRequestParameter", Some(auth.tokenRequestParameterQuery.toParamString(auth.tokenRequestParameter))), ("oauthBearerConfigid", Some(oauth.bearer.configidQuery.toParamString(oauth.bearer.configid))), ("oauthJwtSupport", Some(oauth.jwt.supportQuery.toParamString(oauth.jwt.support))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplDefaultTokenValidatorImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], authTokenValidatorType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], authTokenValidatorTypeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo] = jsonOf[ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.DefaultTokenValidatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("authTokenValidatorType", Some(auth.token.validator.typeQuery.toParamString(auth.token.validator.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplFacebookProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo] = jsonOf[ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.FacebookProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplGithubProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String, oauthProviderGithubAuthorizationUrl: String, oauthProviderGithubTokenUrl: String, oauthProviderGithubProfileUrl: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String], oauthProviderGithubAuthorizationUrlQuery: QueryParam[String], oauthProviderGithubTokenUrlQuery: QueryParam[String], oauthProviderGithubProfileUrlQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplGithubProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplGithubProviderImplInfo] = jsonOf[ComAdobeGraniteAuthOauthImplGithubProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.GithubProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))), ("oauthProviderGithubAuthorizationUrl", Some(oauth.provider.github.authorization.urlQuery.toParamString(oauth.provider.github.authorization.url))), ("oauthProviderGithubTokenUrl", Some(oauth.provider.github.token.urlQuery.toParamString(oauth.provider.github.token.url))), ("oauthProviderGithubProfileUrl", Some(oauth.provider.github.profile.urlQuery.toParamString(oauth.provider.github.profile.url))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplGithubProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplGraniteProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String, oauthProviderGraniteAuthorizationUrl: String, oauthProviderGraniteTokenUrl: String, oauthProviderGraniteProfileUrl: String, oauthProviderGraniteExtendedDetailsUrls: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String], oauthProviderGraniteAuthorizationUrlQuery: QueryParam[String], oauthProviderGraniteTokenUrlQuery: QueryParam[String], oauthProviderGraniteProfileUrlQuery: QueryParam[String], oauthProviderGraniteExtendedDetailsUrlsQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplGraniteProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplGraniteProviderInfo] = jsonOf[ComAdobeGraniteAuthOauthImplGraniteProviderInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.GraniteProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))), ("oauthProviderGraniteAuthorizationUrl", Some(oauth.provider.granite.authorization.urlQuery.toParamString(oauth.provider.granite.authorization.url))), ("oauthProviderGraniteTokenUrl", Some(oauth.provider.granite.token.urlQuery.toParamString(oauth.provider.granite.token.url))), ("oauthProviderGraniteProfileUrl", Some(oauth.provider.granite.profile.urlQuery.toParamString(oauth.provider.granite.profile.url))), ("oauthProviderGraniteExtendedDetailsUrls", Some(oauth.provider.granite.extended.details.urlsQuery.toParamString(oauth.provider.granite.extended.details.urls))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplGraniteProviderInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplHelperProviderConfigManager(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthCookieLoginTimeout: String, oauthCookieMaxAge: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthCookieLoginTimeoutQuery: QueryParam[String], oauthCookieMaxAgeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo] = jsonOf[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.helper.ProviderConfigManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthCookieLoginTimeout", Some(oauth.cookie.login.timeoutQuery.toParamString(oauth.cookie.login.timeout))), ("oauthCookieMaxAge", Some(oauth.cookie.max.ageQuery.toParamString(oauth.cookie.max.age))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternal(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthCookieLoginTimeout: String, oauthCookieMaxAge: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthCookieLoginTimeoutQuery: QueryParam[String], oauthCookieMaxAgeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo] = jsonOf[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.helper.ProviderConfigManagerInternal"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthCookieLoginTimeout", Some(oauth.cookie.login.timeoutQuery.toParamString(oauth.cookie.login.timeout))), ("oauthCookieMaxAge", Some(oauth.cookie.max.ageQuery.toParamString(oauth.cookie.max.age))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplOAuthAuthenticationHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo] = jsonOf[ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.OAuthAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplTwitterProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo] = jsonOf[ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.TwitterProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthConfigId: String, oauthClientId: String, oauthClientSecret: String, oauthScope: List[String], oauthConfigProviderId: String, oauthCreateUsers: Boolean, oauthUseridProperty: String, forceStrictUsernameMatching: Boolean, oauthEncodeUserids: Boolean, oauthHashUserids: Boolean, oauthCallBackUrl: String, oauthAccessTokenPersist: Boolean, oauthAccessTokenPersistCookie: Boolean, oauthCsrfStateProtection: Boolean, oauthRedirectRequestParams: Boolean, oauthConfigSiblingsAllow: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthConfigIdQuery: QueryParam[String], oauthClientIdQuery: QueryParam[String], oauthClientSecretQuery: QueryParam[String], oauthScopeQuery: QueryParam[List[String]], oauthConfigProviderIdQuery: QueryParam[String], oauthCreateUsersQuery: QueryParam[Boolean], oauthUseridPropertyQuery: QueryParam[String], forceStrictUsernameMatchingQuery: QueryParam[Boolean], oauthEncodeUseridsQuery: QueryParam[Boolean], oauthHashUseridsQuery: QueryParam[Boolean], oauthCallBackUrlQuery: QueryParam[String], oauthAccessTokenPersistQuery: QueryParam[Boolean], oauthAccessTokenPersistCookieQuery: QueryParam[Boolean], oauthCsrfStateProtectionQuery: QueryParam[Boolean], oauthRedirectRequestParamsQuery: QueryParam[Boolean], oauthConfigSiblingsAllowQuery: QueryParam[Boolean]): Task[ComAdobeGraniteAuthOauthProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthProviderInfo] = jsonOf[ComAdobeGraniteAuthOauthProviderInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.provider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthConfigId", Some(oauth.config.idQuery.toParamString(oauth.config.id))), ("oauthClientId", Some(oauth.client.idQuery.toParamString(oauth.client.id))), ("oauthClientSecret", Some(oauth.client.secretQuery.toParamString(oauth.client.secret))), ("oauthScope", Some(oauth.scopeQuery.toParamString(oauth.scope))), ("oauthConfigProviderId", Some(oauth.config.provider.idQuery.toParamString(oauth.config.provider.id))), ("oauthCreateUsers", Some(oauth.create.usersQuery.toParamString(oauth.create.users))), ("oauthUseridProperty", Some(oauth.userid.propertyQuery.toParamString(oauth.userid.property))), ("forceStrictUsernameMatching", Some(force.strict.username.matchingQuery.toParamString(force.strict.username.matching))), ("oauthEncodeUserids", Some(oauth.encode.useridsQuery.toParamString(oauth.encode.userids))), ("oauthHashUserids", Some(oauth.hash.useridsQuery.toParamString(oauth.hash.userids))), ("oauthCallBackUrl", Some(oauth.callBackUrlQuery.toParamString(oauth.callBackUrl))), ("oauthAccessTokenPersist", Some(oauth.access.token.persistQuery.toParamString(oauth.access.token.persist))), ("oauthAccessTokenPersistCookie", Some(oauth.access.token.persist.cookieQuery.toParamString(oauth.access.token.persist.cookie))), ("oauthCsrfStateProtection", Some(oauth.csrf.state.protectionQuery.toParamString(oauth.csrf.state.protection))), ("oauthRedirectRequestParams", Some(oauth.redirect.request.paramsQuery.toParamString(oauth.redirect.request.params))), ("oauthConfigSiblingsAllow", Some(oauth.config.siblings.allowQuery.toParamString(oauth.config.siblings.allow))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthProviderInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthRequirementImplDefaultRequirementHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], supportedPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], supportedPathsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo] = jsonOf[ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.requirement.impl.DefaultRequirementHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("supportedPaths", Some(supportedPathsQuery.toParamString(supportedPaths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthSamlSamlAuthenticationHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: List[String], serviceRanking: Integer, idpUrl: String, idpCertAlias: String, idpHttpRedirect: Boolean, serviceProviderEntityId: String, assertionConsumerServiceURL: String, spPrivateKeyAlias: String, keyStorePassword: String, defaultRedirectUrl: String, userIDAttribute: String, useEncryption: Boolean, createUser: Boolean, userIntermediatePath: String, addGroupMemberships: Boolean, groupMembershipAttribute: String, defaultGroups: List[String], nameIdFormat: String, synchronizeAttributes: List[String], handleLogout: Boolean, logoutUrl: String, clockTolerance: Integer, digestMethod: String, signatureMethod: String, identitySyncType: String, idpIdentifier: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], idpUrlQuery: QueryParam[String], idpCertAliasQuery: QueryParam[String], idpHttpRedirectQuery: QueryParam[Boolean], serviceProviderEntityIdQuery: QueryParam[String], assertionConsumerServiceURLQuery: QueryParam[String], spPrivateKeyAliasQuery: QueryParam[String], keyStorePasswordQuery: QueryParam[String], defaultRedirectUrlQuery: QueryParam[String], userIDAttributeQuery: QueryParam[String], useEncryptionQuery: QueryParam[Boolean], createUserQuery: QueryParam[Boolean], userIntermediatePathQuery: QueryParam[String], addGroupMembershipsQuery: QueryParam[Boolean], groupMembershipAttributeQuery: QueryParam[String], defaultGroupsQuery: QueryParam[List[String]], nameIdFormatQuery: QueryParam[String], synchronizeAttributesQuery: QueryParam[List[String]], handleLogoutQuery: QueryParam[Boolean], logoutUrlQuery: QueryParam[String], clockToleranceQuery: QueryParam[Integer], digestMethodQuery: QueryParam[String], signatureMethodQuery: QueryParam[String], identitySyncTypeQuery: QueryParam[String], idpIdentifierQuery: QueryParam[String]): Task[ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo] = jsonOf[ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("idpUrl", Some(idpUrlQuery.toParamString(idpUrl))), ("idpCertAlias", Some(idpCertAliasQuery.toParamString(idpCertAlias))), ("idpHttpRedirect", Some(idpHttpRedirectQuery.toParamString(idpHttpRedirect))), ("serviceProviderEntityId", Some(serviceProviderEntityIdQuery.toParamString(serviceProviderEntityId))), ("assertionConsumerServiceURL", Some(assertionConsumerServiceURLQuery.toParamString(assertionConsumerServiceURL))), ("spPrivateKeyAlias", Some(spPrivateKeyAliasQuery.toParamString(spPrivateKeyAlias))), ("keyStorePassword", Some(keyStorePasswordQuery.toParamString(keyStorePassword))), ("defaultRedirectUrl", Some(defaultRedirectUrlQuery.toParamString(defaultRedirectUrl))), ("userIDAttribute", Some(userIDAttributeQuery.toParamString(userIDAttribute))), ("useEncryption", Some(useEncryptionQuery.toParamString(useEncryption))), ("createUser", Some(createUserQuery.toParamString(createUser))), ("userIntermediatePath", Some(userIntermediatePathQuery.toParamString(userIntermediatePath))), ("addGroupMemberships", Some(addGroupMembershipsQuery.toParamString(addGroupMemberships))), ("groupMembershipAttribute", Some(groupMembershipAttributeQuery.toParamString(groupMembershipAttribute))), ("defaultGroups", Some(defaultGroupsQuery.toParamString(defaultGroups))), ("nameIdFormat", Some(nameIdFormatQuery.toParamString(nameIdFormat))), ("synchronizeAttributes", Some(synchronizeAttributesQuery.toParamString(synchronizeAttributes))), ("handleLogout", Some(handleLogoutQuery.toParamString(handleLogout))), ("logoutUrl", Some(logoutUrlQuery.toParamString(logoutUrl))), ("clockTolerance", Some(clockToleranceQuery.toParamString(clockTolerance))), ("digestMethod", Some(digestMethodQuery.toParamString(digestMethod))), ("signatureMethod", Some(signatureMethodQuery.toParamString(signatureMethod))), ("identitySyncType", Some(identitySyncTypeQuery.toParamString(identitySyncType))), ("idpIdentifier", Some(idpIdentifierQuery.toParamString(idpIdentifier))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthSsoImplSsoAuthenticationHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, serviceRanking: Integer, jaasControlFlag: String, jaasRealmName: String, jaasRanking: Integer, headers: List[String], cookies: List[String], parameters: List[String], usermap: List[String], format: String, trustedCredentialsAttribute: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], serviceRankingQuery: QueryParam[Integer], jaasControlFlagQuery: QueryParam[String], jaasRealmNameQuery: QueryParam[String], jaasRankingQuery: QueryParam[Integer], headersQuery: QueryParam[List[String]], cookiesQuery: QueryParam[List[String]], parametersQuery: QueryParam[List[String]], usermapQuery: QueryParam[List[String]], formatQuery: QueryParam[String], trustedCredentialsAttributeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo] = jsonOf[ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.sso.impl.SsoAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("jaasControlFlag", Some(jaas.controlFlagQuery.toParamString(jaas.controlFlag))), ("jaasRealmName", Some(jaas.realmNameQuery.toParamString(jaas.realmName))), ("jaasRanking", Some(jaas.rankingQuery.toParamString(jaas.ranking))), ("headers", Some(headersQuery.toParamString(headers))), ("cookies", Some(cookiesQuery.toParamString(cookies))), ("parameters", Some(parametersQuery.toParamString(parameters))), ("usermap", Some(usermapQuery.toParamString(usermap))), ("format", Some(formatQuery.toParamString(format))), ("trustedCredentialsAttribute", Some(trustedCredentialsAttributeQuery.toParamString(trustedCredentialsAttribute))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplCodeCacheHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], minimumCodeCacheSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], minimumCodeCacheSizeQuery: QueryParam[Integer]): Task[ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.CodeCacheHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("minimumCodeCacheSize", Some(minimum.code.cache.sizeQuery.toParamString(minimum.code.cache.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.CrxdeSupportBundleHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplDavExBundleHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.DavExBundleHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplInactiveBundlesHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], ignoredBundles: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], ignoredBundlesQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.InactiveBundlesHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("ignoredBundles", Some(ignored.bundlesQuery.toParamString(ignored.bundles))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplJobsHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], maxQueuedJobs: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], maxQueuedJobsQuery: QueryParam[Integer]): Task[ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.JobsHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("maxQueuedJobs", Some(max.queued.jobsQuery.toParamString(max.queued.jobs))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplSlingGetServletHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingGetServletHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingJavaScriptHandlerHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingJspScriptHandlerHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingReferrerFilterHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplWebDavBundleHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.WebDavBundleHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCommentsInternalCommentReplicationContentFilterFac(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], replicateCommentResourceTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], replicateCommentResourceTypesQuery: QueryParam[List[String]]): Task[ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo] = jsonOf[ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo]

    val path = "/system/console/configMgr/com.adobe.granite.comments.internal.CommentReplicationContentFilterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("replicateCommentResourceTypes", Some(replicate.comment.resourceTypesQuery.toParamString(replicate.comment.resourceTypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCompatrouterImplCompatSwitchingServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], compatgroups: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], compatgroupsQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo] = jsonOf[ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.compatrouter.impl.CompatSwitchingServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("compatgroups", Some(compatgroupsQuery.toParamString(compatgroups))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCompatrouterImplRoutingConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], id: String, compatPath: String, newPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], idQuery: QueryParam[String], compatPathQuery: QueryParam[String], newPathQuery: QueryParam[String]): Task[ComAdobeGraniteCompatrouterImplRoutingConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCompatrouterImplRoutingConfigInfo] = jsonOf[ComAdobeGraniteCompatrouterImplRoutingConfigInfo]

    val path = "/system/console/configMgr/com.adobe.granite.compatrouter.impl.RoutingConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("id", Some(idQuery.toParamString(id))), ("compatPath", Some(compatPathQuery.toParamString(compatPath))), ("newPath", Some(newPathQuery.toParamString(newPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCompatrouterImplRoutingConfigInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCompatrouterImplSwitchMappingConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], group: String, ids: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], groupQuery: QueryParam[String], idsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo] = jsonOf[ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo]

    val path = "/system/console/configMgr/com.adobe.granite.compatrouter.impl.SwitchMappingConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("group", Some(groupQuery.toParamString(group))), ("ids", Some(idsQuery.toParamString(ids))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolving(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, fallbackPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], fallbackPathsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo] = jsonOf[ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo]

    val path = "/system/console/configMgr/com.adobe.granite.conf.impl.RuntimeAwareConfigurationResourceResolvingStrategy"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("fallbackPaths", Some(fallbackPathsQuery.toParamString(fallbackPaths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteContexthubImplContextHubImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeGraniteContexthubSilentMode: Boolean, comAdobeGraniteContexthubShowUi: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeGraniteContexthubSilentModeQuery: QueryParam[Boolean], comAdobeGraniteContexthubShowUiQuery: QueryParam[Boolean]): Task[ComAdobeGraniteContexthubImplContextHubImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteContexthubImplContextHubImplInfo] = jsonOf[ComAdobeGraniteContexthubImplContextHubImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.contexthub.impl.ContextHubImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeGraniteContexthubSilentMode", Some(com.adobe.granite.contexthub.silent_modeQuery.toParamString(com.adobe.granite.contexthub.silent_mode))), ("comAdobeGraniteContexthubShowUi", Some(com.adobe.granite.contexthub.show_uiQuery.toParamString(com.adobe.granite.contexthub.show_ui))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteContexthubImplContextHubImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCorsImplCORSPolicyImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], alloworigin: List[String], alloworiginregexp: List[String], allowedpaths: List[String], exposedheaders: List[String], maxage: Integer, supportedheaders: List[String], supportedmethods: List[String], supportscredentials: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], alloworiginQuery: QueryParam[List[String]], alloworiginregexpQuery: QueryParam[List[String]], allowedpathsQuery: QueryParam[List[String]], exposedheadersQuery: QueryParam[List[String]], maxageQuery: QueryParam[Integer], supportedheadersQuery: QueryParam[List[String]], supportedmethodsQuery: QueryParam[List[String]], supportscredentialsQuery: QueryParam[Boolean]): Task[ComAdobeGraniteCorsImplCORSPolicyImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCorsImplCORSPolicyImplInfo] = jsonOf[ComAdobeGraniteCorsImplCORSPolicyImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.cors.impl.CORSPolicyImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("alloworigin", Some(alloworiginQuery.toParamString(alloworigin))), ("alloworiginregexp", Some(alloworiginregexpQuery.toParamString(alloworiginregexp))), ("allowedpaths", Some(allowedpathsQuery.toParamString(allowedpaths))), ("exposedheaders", Some(exposedheadersQuery.toParamString(exposedheaders))), ("maxage", Some(maxageQuery.toParamString(maxage))), ("supportedheaders", Some(supportedheadersQuery.toParamString(supportedheaders))), ("supportedmethods", Some(supportedmethodsQuery.toParamString(supportedmethods))), ("supportscredentials", Some(supportscredentialsQuery.toParamString(supportscredentials))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCorsImplCORSPolicyImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCsrfImplCSRFFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], filterMethods: List[String], filterEnableSafeUserAgents: Boolean, filterSafeUserAgents: List[String], filterExcludedPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], filterMethodsQuery: QueryParam[List[String]], filterEnableSafeUserAgentsQuery: QueryParam[Boolean], filterSafeUserAgentsQuery: QueryParam[List[String]], filterExcludedPathsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteCsrfImplCSRFFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCsrfImplCSRFFilterInfo] = jsonOf[ComAdobeGraniteCsrfImplCSRFFilterInfo]

    val path = "/system/console/configMgr/com.adobe.granite.csrf.impl.CSRFFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("filterMethods", Some(filter.methodsQuery.toParamString(filter.methods))), ("filterEnableSafeUserAgents", Some(filter.enable.safe.user.agentsQuery.toParamString(filter.enable.safe.user.agents))), ("filterSafeUserAgents", Some(filter.safe.user.agentsQuery.toParamString(filter.safe.user.agents))), ("filterExcludedPaths", Some(filter.excluded.pathsQuery.toParamString(filter.excluded.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCsrfImplCSRFFilterInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCsrfImplCSRFServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], csrfTokenExpiresIn: Integer, slingAuthRequirements: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], csrfTokenExpiresInQuery: QueryParam[Integer], slingAuthRequirementsQuery: QueryParam[String]): Task[ComAdobeGraniteCsrfImplCSRFServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCsrfImplCSRFServletInfo] = jsonOf[ComAdobeGraniteCsrfImplCSRFServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.csrf.impl.CSRFServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("csrfTokenExpiresIn", Some(csrf.token.expires.inQuery.toParamString(csrf.token.expires.in))), ("slingAuthRequirements", Some(sling.auth.requirementsQuery.toParamString(sling.auth.requirements))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCsrfImplCSRFServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplCryptoDistributionTransportSe(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, username: String, encryptedPassword: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], usernameQuery: QueryParam[String], encryptedPasswordQuery: QueryParam[String]): Task[ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.CryptoDistributionTransportSecretProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("username", Some(usernameQuery.toParamString(username))), ("encryptedPassword", Some(encryptedPasswordQuery.toParamString(encryptedPassword))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplDiffDiffChangesObserver(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, agentName: String, diffPath: String, observedPath: String, serviceName: String, propertyNames: String, distributionDelay: Integer, serviceUserTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], agentNameQuery: QueryParam[String], diffPathQuery: QueryParam[String], observedPathQuery: QueryParam[String], serviceNameQuery: QueryParam[String], propertyNamesQuery: QueryParam[String], distributionDelayQuery: QueryParam[Integer], serviceUserTargetQuery: QueryParam[String]): Task[ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.diff.DiffChangesObserver"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("agentName", Some(agentNameQuery.toParamString(agentName))), ("diffPath", Some(diffPathQuery.toParamString(diffPath))), ("observedPath", Some(observedPathQuery.toParamString(observedPath))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("propertyNames", Some(propertyNamesQuery.toParamString(propertyNames))), ("distributionDelay", Some(distributionDelayQuery.toParamString(distributionDelay))), ("serviceUserTarget", Some(serviceUser.targetQuery.toParamString(serviceUser.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplDiffDiffEventListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], diffPath: String, serviceName: String, serviceUserTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], diffPathQuery: QueryParam[String], serviceNameQuery: QueryParam[String], serviceUserTargetQuery: QueryParam[String]): Task[ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.diff.DiffEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("diffPath", Some(diffPathQuery.toParamString(diffPath))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("serviceUserTarget", Some(serviceUser.targetQuery.toParamString(serviceUser.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplDistributionToReplicationEven(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], importerName: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], importerNameQuery: QueryParam[List[String]]): Task[ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.DistributionToReplicationEventTransformer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("importerName", Some(importer.nameQuery.toParamString(importer.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplReplicationAdaptersReplicat(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerName: String, forwardRequests: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerNameQuery: QueryParam[String], forwardRequestsQuery: QueryParam[Boolean]): Task[ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.replication.adapters.ReplicationAgentProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerName", Some(providerNameQuery.toParamString(providerName))), ("forwardRequests", Some(forward.requestsQuery.toParamString(forward.requests))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplReplicationDistributionTrans(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], forwardRequests: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], forwardRequestsQuery: QueryParam[Boolean]): Task[ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.replication.DistributionTransportHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("forwardRequests", Some(forward.requestsQuery.toParamString(forward.requests))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplTransportAccessTokenDistribu(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, serviceName: String, userId: String, accessTokenProviderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], serviceNameQuery: QueryParam[String], userIdQuery: QueryParam[String], accessTokenProviderTargetQuery: QueryParam[String]): Task[ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.transport.AccessTokenDistributionTransportSecretProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("userId", Some(userIdQuery.toParamString(userId))), ("accessTokenProviderTarget", Some(accessTokenProvider.targetQuery.toParamString(accessTokenProvider.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteFragsImplCheckHttpHeaderFlag(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], featureName: String, featureDescription: String, httpHeaderName: String, httpHeaderValuepattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], featureNameQuery: QueryParam[String], featureDescriptionQuery: QueryParam[String], httpHeaderNameQuery: QueryParam[String], httpHeaderValuepatternQuery: QueryParam[String]): Task[ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo] = jsonOf[ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo]

    val path = "/system/console/configMgr/com.adobe.granite.frags.impl.CheckHttpHeaderFlag"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("featureName", Some(feature.nameQuery.toParamString(feature.name))), ("featureDescription", Some(feature.descriptionQuery.toParamString(feature.description))), ("httpHeaderName", Some(http.header.nameQuery.toParamString(http.header.name))), ("httpHeaderValuepattern", Some(http.header.valuepatternQuery.toParamString(http.header.valuepattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteFragsImplRandomFeature(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], featureName: String, featureDescription: String, activePercentage: String, cookieName: String, cookieMaxAge: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], featureNameQuery: QueryParam[String], featureDescriptionQuery: QueryParam[String], activePercentageQuery: QueryParam[String], cookieNameQuery: QueryParam[String], cookieMaxAgeQuery: QueryParam[Integer]): Task[ComAdobeGraniteFragsImplRandomFeatureInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteFragsImplRandomFeatureInfo] = jsonOf[ComAdobeGraniteFragsImplRandomFeatureInfo]

    val path = "/system/console/configMgr/com.adobe.granite.frags.impl.RandomFeature"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("featureName", Some(feature.nameQuery.toParamString(feature.name))), ("featureDescription", Some(feature.descriptionQuery.toParamString(feature.description))), ("activePercentage", Some(active.percentageQuery.toParamString(active.percentage))), ("cookieName", Some(cookie.nameQuery.toParamString(cookie.name))), ("cookieMaxAge", Some(cookie.maxAgeQuery.toParamString(cookie.maxAge))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteFragsImplRandomFeatureInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteHttpcacheFileFileCacheStore(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeGraniteHttpcacheFileDocumentRoot: String, comAdobeGraniteHttpcacheFileIncludeHost: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeGraniteHttpcacheFileDocumentRootQuery: QueryParam[String], comAdobeGraniteHttpcacheFileIncludeHostQuery: QueryParam[String]): Task[ComAdobeGraniteHttpcacheFileFileCacheStoreInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteHttpcacheFileFileCacheStoreInfo] = jsonOf[ComAdobeGraniteHttpcacheFileFileCacheStoreInfo]

    val path = "/system/console/configMgr/com.adobe.granite.httpcache.file.FileCacheStore"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeGraniteHttpcacheFileDocumentRoot", Some(com.adobe.granite.httpcache.file.documentRootQuery.toParamString(com.adobe.granite.httpcache.file.documentRoot))), ("comAdobeGraniteHttpcacheFileIncludeHost", Some(com.adobe.granite.httpcache.file.includeHostQuery.toParamString(com.adobe.granite.httpcache.file.includeHost))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteHttpcacheFileFileCacheStoreInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteHttpcacheImplOuterCacheFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeGraniteHttpcacheUrlPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeGraniteHttpcacheUrlPathsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo] = jsonOf[ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo]

    val path = "/system/console/configMgr/com.adobe.granite.httpcache.impl.OuterCacheFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeGraniteHttpcacheUrlPaths", Some(com.adobe.granite.httpcache.url.pathsQuery.toParamString(com.adobe.granite.httpcache.url.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteI18nImplBundlePseudoTranslations(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pseudoPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pseudoPatternsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo] = jsonOf[ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo]

    val path = "/system/console/configMgr/com.adobe.granite.i18n.impl.bundle.PseudoTranslations"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pseudoPatterns", Some(pseudo.patternsQuery.toParamString(pseudo.patterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteI18nImplPreferencesLocaleResolverService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], securityPreferencesName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], securityPreferencesNameQuery: QueryParam[String]): Task[ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo] = jsonOf[ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo]

    val path = "/system/console/configMgr/com.adobe.granite.i18n.impl.PreferencesLocaleResolverService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("securityPreferencesName", Some(security.preferences.nameQuery.toParamString(security.preferences.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteInfocollectorInfoCollector(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], graniteInfocollectorIncludeThreadDumps: Boolean, graniteInfocollectorIncludeHeapDump: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], graniteInfocollectorIncludeThreadDumpsQuery: QueryParam[Boolean], graniteInfocollectorIncludeHeapDumpQuery: QueryParam[Boolean]): Task[ComAdobeGraniteInfocollectorInfoCollectorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteInfocollectorInfoCollectorInfo] = jsonOf[ComAdobeGraniteInfocollectorInfoCollectorInfo]

    val path = "/system/console/configMgr/com.adobe.granite.infocollector.InfoCollector"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("graniteInfocollectorIncludeThreadDumps", Some(granite.infocollector.includeThreadDumpsQuery.toParamString(granite.infocollector.includeThreadDumps))), ("graniteInfocollectorIncludeHeapDump", Some(granite.infocollector.includeHeapDumpQuery.toParamString(granite.infocollector.includeHeapDump))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteInfocollectorInfoCollectorInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteJettySslInternalGraniteSslConnectorFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeGraniteJettySslPort: Integer, comAdobeGraniteJettySslKeystoreUser: String, comAdobeGraniteJettySslKeystorePassword: String, comAdobeGraniteJettySslCiphersuitesExcluded: List[String], comAdobeGraniteJettySslCiphersuitesIncluded: List[String], comAdobeGraniteJettySslClientCertificate: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeGraniteJettySslPortQuery: QueryParam[Integer], comAdobeGraniteJettySslKeystoreUserQuery: QueryParam[String], comAdobeGraniteJettySslKeystorePasswordQuery: QueryParam[String], comAdobeGraniteJettySslCiphersuitesExcludedQuery: QueryParam[List[String]], comAdobeGraniteJettySslCiphersuitesIncludedQuery: QueryParam[List[String]], comAdobeGraniteJettySslClientCertificateQuery: QueryParam[String]): Task[ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo] = jsonOf[ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo]

    val path = "/system/console/configMgr/com.adobe.granite.jetty.ssl.internal.GraniteSslConnectorFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeGraniteJettySslPort", Some(com.adobe.granite.jetty.ssl.portQuery.toParamString(com.adobe.granite.jetty.ssl.port))), ("comAdobeGraniteJettySslKeystoreUser", Some(com.adobe.granite.jetty.ssl.keystore.userQuery.toParamString(com.adobe.granite.jetty.ssl.keystore.user))), ("comAdobeGraniteJettySslKeystorePassword", Some(com.adobe.granite.jetty.ssl.keystore.passwordQuery.toParamString(com.adobe.granite.jetty.ssl.keystore.password))), ("comAdobeGraniteJettySslCiphersuitesExcluded", Some(com.adobe.granite.jetty.ssl.ciphersuites.excludedQuery.toParamString(com.adobe.granite.jetty.ssl.ciphersuites.excluded))), ("comAdobeGraniteJettySslCiphersuitesIncluded", Some(com.adobe.granite.jetty.ssl.ciphersuites.includedQuery.toParamString(com.adobe.granite.jetty.ssl.ciphersuites.included))), ("comAdobeGraniteJettySslClientCertificate", Some(com.adobe.granite.jetty.ssl.client.certificateQuery.toParamString(com.adobe.granite.jetty.ssl.client.certificate))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteLicenseImplLicenseCheckFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], checkInternval: Integer, excludeIds: List[String], encryptPing: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], checkInternvalQuery: QueryParam[Integer], excludeIdsQuery: QueryParam[List[String]], encryptPingQuery: QueryParam[Boolean]): Task[ComAdobeGraniteLicenseImplLicenseCheckFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteLicenseImplLicenseCheckFilterInfo] = jsonOf[ComAdobeGraniteLicenseImplLicenseCheckFilterInfo]

    val path = "/system/console/configMgr/com.adobe.granite.license.impl.LicenseCheckFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("checkInternval", Some(checkInternvalQuery.toParamString(checkInternval))), ("excludeIds", Some(excludeIdsQuery.toParamString(excludeIds))), ("encryptPing", Some(encryptPingQuery.toParamString(encryptPing))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteLicenseImplLicenseCheckFilterInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteLoggingImplLogAnalyserImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], messagesQueueSize: Integer, loggerConfig: List[String], messagesSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], messagesQueueSizeQuery: QueryParam[Integer], loggerConfigQuery: QueryParam[List[String]], messagesSizeQuery: QueryParam[Integer]): Task[ComAdobeGraniteLoggingImplLogAnalyserImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteLoggingImplLogAnalyserImplInfo] = jsonOf[ComAdobeGraniteLoggingImplLogAnalyserImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.logging.impl.LogAnalyserImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("messagesQueueSize", Some(messages.queue.sizeQuery.toParamString(messages.queue.size))), ("loggerConfig", Some(logger.configQuery.toParamString(logger.config))), ("messagesSize", Some(messages.sizeQuery.toParamString(messages.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteLoggingImplLogAnalyserImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteLoggingImplLogErrorHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo] = jsonOf[ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.logging.impl.LogErrorHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTask(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], graniteMaintenanceMandatory: Boolean, jobTopics: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], graniteMaintenanceMandatoryQuery: QueryParam[Boolean], jobTopicsQuery: QueryParam[String]): Task[ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo] = jsonOf[ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo]

    val path = "/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.DataStoreGarbageCollectionTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("graniteMaintenanceMandatory", Some(granite.maintenance.mandatoryQuery.toParamString(granite.maintenance.mandatory))), ("jobTopics", Some(job.topicsQuery.toParamString(job.topics))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTask(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jobTopics: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jobTopicsQuery: QueryParam[String]): Task[ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo] = jsonOf[ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo]

    val path = "/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.LuceneBinariesCleanupTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jobTopics", Some(job.topicsQuery.toParamString(job.topics))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteMaintenanceCrxImplRevisionCleanupTask(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fullGcDays: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fullGcDaysQuery: QueryParam[List[String]]): Task[ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo] = jsonOf[ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo]

    val path = "/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.RevisionCleanupTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fullGcDays", Some(full.gc.daysQuery.toParamString(full.gc.days))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteMonitoringImplScriptConfigImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], scriptFilename: String, scriptDisplay: String, scriptPath: String, scriptPlatform: List[String], interval: Integer, jmxdomain: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], scriptFilenameQuery: QueryParam[String], scriptDisplayQuery: QueryParam[String], scriptPathQuery: QueryParam[String], scriptPlatformQuery: QueryParam[List[String]], intervalQuery: QueryParam[Integer], jmxdomainQuery: QueryParam[String]): Task[ComAdobeGraniteMonitoringImplScriptConfigImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteMonitoringImplScriptConfigImplInfo] = jsonOf[ComAdobeGraniteMonitoringImplScriptConfigImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.monitoring.impl.ScriptConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("scriptFilename", Some(script.filenameQuery.toParamString(script.filename))), ("scriptDisplay", Some(script.displayQuery.toParamString(script.display))), ("scriptPath", Some(script.pathQuery.toParamString(script.path))), ("scriptPlatform", Some(script.platformQuery.toParamString(script.platform))), ("interval", Some(intervalQuery.toParamString(interval))), ("jmxdomain", Some(jmxdomainQuery.toParamString(jmxdomain))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteMonitoringImplScriptConfigImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHan(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, jaasControlFlag: String, jaasRealmName: String, jaasRanking: Integer, oauthOfflineValidation: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], jaasControlFlagQuery: QueryParam[String], jaasRealmNameQuery: QueryParam[String], jaasRankingQuery: QueryParam[Integer], oauthOfflineValidationQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo] = jsonOf[ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo]

    val path = "/system/console/configMgr/com.adobe.granite.oauth.server.auth.impl.OAuth2ServerAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("jaasControlFlag", Some(jaas.controlFlagQuery.toParamString(jaas.controlFlag))), ("jaasRealmName", Some(jaas.realmNameQuery.toParamString(jaas.realmName))), ("jaasRanking", Some(jaas.rankingQuery.toParamString(jaas.ranking))), ("oauthOfflineValidation", Some(oauth.offline.validationQuery.toParamString(oauth.offline.validation))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOauthServerImplAccessTokenCleanupTask(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String]): Task[ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo] = jsonOf[ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo]

    val path = "/system/console/configMgr/com.adobe.granite.oauth.server.impl.AccessTokenCleanupTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOauthServerImplOAuth2ClientRevocationServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthClientRevocationActive: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthClientRevocationActiveQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo] = jsonOf[ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2ClientRevocationServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthClientRevocationActive", Some(oauth.client.revocation.activeQuery.toParamString(oauth.client.revocation.active))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOauthServerImplOAuth2RevocationEndpointServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletPaths: String, oauthRevocationActive: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletPathsQuery: QueryParam[String], oauthRevocationActiveQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo] = jsonOf[ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2RevocationEndpointServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletPaths", Some(sling.servlet.pathsQuery.toParamString(sling.servlet.paths))), ("oauthRevocationActive", Some(oauth.revocation.activeQuery.toParamString(oauth.revocation.active))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOauthServerImplOAuth2TokenEndpointServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthIssuer: String, oauthAccessTokenExpiresIn: String, osgiHttpWhiteboardServletPattern: String, osgiHttpWhiteboardContextSelect: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthIssuerQuery: QueryParam[String], oauthAccessTokenExpiresInQuery: QueryParam[String], osgiHttpWhiteboardServletPatternQuery: QueryParam[String], osgiHttpWhiteboardContextSelectQuery: QueryParam[String]): Task[ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo] = jsonOf[ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2TokenEndpointServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthIssuer", Some(oauth.issuerQuery.toParamString(oauth.issuer))), ("oauthAccessTokenExpiresIn", Some(oauth.access.token.expires.inQuery.toParamString(oauth.access.token.expires.in))), ("osgiHttpWhiteboardServletPattern", Some(osgi.http.whiteboard.servlet.patternQuery.toParamString(osgi.http.whiteboard.servlet.pattern))), ("osgiHttpWhiteboardContextSelect", Some(osgi.http.whiteboard.context.selectQuery.toParamString(osgi.http.whiteboard.context.select))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOauthServerImplOAuth2TokenRevocationServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthTokenRevocationActive: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthTokenRevocationActiveQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo] = jsonOf[ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2TokenRevocationServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthTokenRevocationActive", Some(oauth.token.revocation.activeQuery.toParamString(oauth.token.revocation.active))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOffloadingImplOffloadingConfigurator(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], offloadingTransporter: String, offloadingCleanupPayload: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], offloadingTransporterQuery: QueryParam[String], offloadingCleanupPayloadQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo] = jsonOf[ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo]

    val path = "/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingConfigurator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("offloadingTransporter", Some(offloading.transporterQuery.toParamString(offloading.transporter))), ("offloadingCleanupPayload", Some(offloading.cleanup.payloadQuery.toParamString(offloading.cleanup.payload))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOffloadingImplOffloadingJobCloner(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], offloadingJobclonerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], offloadingJobclonerEnabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo] = jsonOf[ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingJobCloner"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("offloadingJobclonerEnabled", Some(offloading.jobcloner.enabledQuery.toParamString(offloading.jobcloner.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOffloadingImplOffloadingJobOffloader(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], offloadingOffloaderEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], offloadingOffloaderEnabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo] = jsonOf[ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo]

    val path = "/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingJobOffloader"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("offloadingOffloaderEnabled", Some(offloading.offloader.enabledQuery.toParamString(offloading.offloader.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOffloadingImplTransporterOffloadingAgentManager(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], offloadingAgentmanagerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], offloadingAgentmanagerEnabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo] = jsonOf[ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.offloading.impl.transporter.OffloadingAgentManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("offloadingAgentmanagerEnabled", Some(offloading.agentmanager.enabledQuery.toParamString(offloading.agentmanager.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspo(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultTransportAgentToWorkerPrefix: String, defaultTransportAgentToMasterPrefix: String, defaultTransportInputPackage: String, defaultTransportOutputPackage: String, defaultTransportReplicationSynchronous: Boolean, defaultTransportContentpackage: Boolean, offloadingTransporterDefaultEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultTransportAgentToWorkerPrefixQuery: QueryParam[String], defaultTransportAgentToMasterPrefixQuery: QueryParam[String], defaultTransportInputPackageQuery: QueryParam[String], defaultTransportOutputPackageQuery: QueryParam[String], defaultTransportReplicationSynchronousQuery: QueryParam[Boolean], defaultTransportContentpackageQuery: QueryParam[Boolean], offloadingTransporterDefaultEnabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo] = jsonOf[ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo]

    val path = "/system/console/configMgr/com.adobe.granite.offloading.impl.transporter.OffloadingDefaultTransporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultTransportAgentToWorkerPrefix", Some(default.transport.agent-to-worker.prefixQuery.toParamString(default.transport.agent-to-worker.prefix))), ("defaultTransportAgentToMasterPrefix", Some(default.transport.agent-to-master.prefixQuery.toParamString(default.transport.agent-to-master.prefix))), ("defaultTransportInputPackage", Some(default.transport.input.packageQuery.toParamString(default.transport.input.package))), ("defaultTransportOutputPackage", Some(default.transport.output.packageQuery.toParamString(default.transport.output.package))), ("defaultTransportReplicationSynchronous", Some(default.transport.replication.synchronousQuery.toParamString(default.transport.replication.synchronous))), ("defaultTransportContentpackage", Some(default.transport.contentpackageQuery.toParamString(default.transport.contentpackage))), ("offloadingTransporterDefaultEnabled", Some(offloading.transporter.default.enabledQuery.toParamString(offloading.transporter.default.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOmnisearchImplCoreOmniSearchServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], omnisearchSuggestionRequiretextMin: Integer, omnisearchSuggestionSpellcheckRequire: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], omnisearchSuggestionRequiretextMinQuery: QueryParam[Integer], omnisearchSuggestionSpellcheckRequireQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo] = jsonOf[ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.omnisearch.impl.core.OmniSearchServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("omnisearchSuggestionRequiretextMin", Some(omnisearch.suggestion.requiretext.minQuery.toParamString(omnisearch.suggestion.requiretext.min))), ("omnisearchSuggestionSpellcheckRequire", Some(omnisearch.suggestion.spellcheck.requireQuery.toParamString(omnisearch.suggestion.spellcheck.require))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOptoutImplOptOutServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], optoutCookies: List[String], optoutHeaders: List[String], optoutWhitelistCookies: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], optoutCookiesQuery: QueryParam[List[String]], optoutHeadersQuery: QueryParam[List[String]], optoutWhitelistCookiesQuery: QueryParam[List[String]]): Task[ComAdobeGraniteOptoutImplOptOutServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOptoutImplOptOutServiceImplInfo] = jsonOf[ComAdobeGraniteOptoutImplOptOutServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.optout.impl.OptOutServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("optoutCookies", Some(optout.cookiesQuery.toParamString(optout.cookies))), ("optoutHeaders", Some(optout.headersQuery.toParamString(optout.headers))), ("optoutWhitelistCookies", Some(optout.whitelist.cookiesQuery.toParamString(optout.whitelist.cookies))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOptoutImplOptOutServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteQueriesImplHcAsyncIndexHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], indexingCriticalThreshold: Integer, indexingWarnThreshold: Integer, hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], indexingCriticalThresholdQuery: QueryParam[Integer], indexingWarnThresholdQuery: QueryParam[Integer], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo] = jsonOf[ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.queries.impl.hc.AsyncIndexHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("indexingCriticalThreshold", Some(indexing.critical.thresholdQuery.toParamString(indexing.critical.threshold))), ("indexingWarnThreshold", Some(indexing.warn.thresholdQuery.toParamString(indexing.warn.threshold))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteQueriesImplHcLargeIndexHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], largeIndexCriticalThreshold: Integer, largeIndexWarnThreshold: Integer, hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], largeIndexCriticalThresholdQuery: QueryParam[Integer], largeIndexWarnThresholdQuery: QueryParam[Integer], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo] = jsonOf[ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.queries.impl.hc.LargeIndexHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("largeIndexCriticalThreshold", Some(large.index.critical.thresholdQuery.toParamString(large.index.critical.threshold))), ("largeIndexWarnThreshold", Some(large.index.warn.thresholdQuery.toParamString(large.index.warn.threshold))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteQueriesImplHcQueriesStatusHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo] = jsonOf[ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueriesStatusHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteQueriesImplHcQueryHealthCheckMetrics(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], getPeriod: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], getPeriodQuery: QueryParam[Integer]): Task[ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo] = jsonOf[ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo]

    val path = "/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueryHealthCheckMetrics"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("getPeriod", Some(getPeriodQuery.toParamString(getPeriod))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteQueriesImplHcQueryLimitsHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo] = jsonOf[ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueryLimitsHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteReplicationHcImplReplicationQueueHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], numberOfRetriesAllowed: Integer, hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], numberOfRetriesAllowedQuery: QueryParam[Integer], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo] = jsonOf[ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.replication.hc.impl.ReplicationQueueHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("numberOfRetriesAllowed", Some(number.of.retries.allowedQuery.toParamString(number.of.retries.allowed))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteReplicationHcImplReplicationTransportUsersHealthC(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo] = jsonOf[ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo]

    val path = "/system/console/configMgr/com.adobe.granite.replication.hc.impl.ReplicationTransportUsersHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.AuthorizableNodeNameHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthC(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], excludeSearchPath: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], excludeSearchPathQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.content.sling.SlingContentHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("excludeSearchPath", Some(exclude.search.pathQuery.toParamString(exclude.search.path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplContinuousRGCHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.ContinuousRGCHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthChe(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.DefaultAccessUserProfileHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], accountLogins: List[String], consoleLogins: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], accountLoginsQuery: QueryParam[List[String]], consoleLoginsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.DefaultLoginsHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("accountLogins", Some(account.loginsQuery.toParamString(account.logins))), ("consoleLogins", Some(console.loginsQuery.toParamString(console.logins))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplDiskSpaceHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], diskSpaceWarnThreshold: Integer, diskSpaceErrorThreshold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], diskSpaceWarnThresholdQuery: QueryParam[Integer], diskSpaceErrorThresholdQuery: QueryParam[Integer]): Task[ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.DiskSpaceHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("diskSpaceWarnThreshold", Some(disk.space.warn.thresholdQuery.toParamString(disk.space.warn.threshold))), ("diskSpaceErrorThreshold", Some(disk.space.error.thresholdQuery.toParamString(disk.space.error.threshold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.ObservationQueueLengthHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryImplCommitStatsConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, intervalSeconds: Integer, commitsPerIntervalThreshold: Integer, maxLocationLength: Integer, maxDetailsShown: Integer, minDetailsPercentage: Integer, threadMatchers: List[String], maxGreedyDepth: Integer, greedyStackMatchers: String, stackFilters: List[String], stackMatchers: List[String], stackCategorizers: List[String], stackShorteners: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], intervalSecondsQuery: QueryParam[Integer], commitsPerIntervalThresholdQuery: QueryParam[Integer], maxLocationLengthQuery: QueryParam[Integer], maxDetailsShownQuery: QueryParam[Integer], minDetailsPercentageQuery: QueryParam[Integer], threadMatchersQuery: QueryParam[List[String]], maxGreedyDepthQuery: QueryParam[Integer], greedyStackMatchersQuery: QueryParam[String], stackFiltersQuery: QueryParam[List[String]], stackMatchersQuery: QueryParam[List[String]], stackCategorizersQuery: QueryParam[List[String]], stackShortenersQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryImplCommitStatsConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryImplCommitStatsConfigInfo] = jsonOf[ComAdobeGraniteRepositoryImplCommitStatsConfigInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.impl.CommitStatsConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("intervalSeconds", Some(intervalSecondsQuery.toParamString(intervalSeconds))), ("commitsPerIntervalThreshold", Some(commitsPerIntervalThresholdQuery.toParamString(commitsPerIntervalThreshold))), ("maxLocationLength", Some(maxLocationLengthQuery.toParamString(maxLocationLength))), ("maxDetailsShown", Some(maxDetailsShownQuery.toParamString(maxDetailsShown))), ("minDetailsPercentage", Some(minDetailsPercentageQuery.toParamString(minDetailsPercentage))), ("threadMatchers", Some(threadMatchersQuery.toParamString(threadMatchers))), ("maxGreedyDepth", Some(maxGreedyDepthQuery.toParamString(maxGreedyDepth))), ("greedyStackMatchers", Some(greedyStackMatchersQuery.toParamString(greedyStackMatchers))), ("stackFilters", Some(stackFiltersQuery.toParamString(stackFilters))), ("stackMatchers", Some(stackMatchersQuery.toParamString(stackMatchers))), ("stackCategorizers", Some(stackCategorizersQuery.toParamString(stackCategorizers))), ("stackShorteners", Some(stackShortenersQuery.toParamString(stackShorteners))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryImplCommitStatsConfigInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryServiceUserConfiguration(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, serviceusersSimpleSubjectPopulation: Boolean, serviceusersList: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], serviceusersSimpleSubjectPopulationQuery: QueryParam[Boolean], serviceusersListQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryServiceUserConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryServiceUserConfigurationInfo] = jsonOf[ComAdobeGraniteRepositoryServiceUserConfigurationInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.ServiceUserConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("serviceusersSimpleSubjectPopulation", Some(serviceusers.simpleSubjectPopulationQuery.toParamString(serviceusers.simpleSubjectPopulation))), ("serviceusersList", Some(serviceusers.listQuery.toParamString(serviceusers.list))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryServiceUserConfigurationInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckIm(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo] = jsonOf[ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo]

    val path = "/system/console/configMgr/com.adobe.granite.requests.logging.impl.hc.RequestsStatusHealthCheckImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteResourcestatusImplCompositeStatusType(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, types: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], typesQuery: QueryParam[List[String]]): Task[ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo] = jsonOf[ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo]

    val path = "/system/console/configMgr/com.adobe.granite.resourcestatus.impl.CompositeStatusType"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("types", Some(typesQuery.toParamString(types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteResourcestatusImplStatusResourceProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerRoot: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerRootQuery: QueryParam[String]): Task[ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo] = jsonOf[ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.resourcestatus.impl.StatusResourceProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerRoot", Some(provider.rootQuery.toParamString(provider.root))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRestAssetsImplAssetContentDispositionFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mimeAllowEmpty: Boolean, mimeAllowed: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mimeAllowEmptyQuery: QueryParam[Boolean], mimeAllowedQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo] = jsonOf[ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo]

    val path = "/system/console/configMgr/com.adobe.granite.rest.assets.impl.AssetContentDispositionFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mimeAllowEmpty", Some(mime.allowEmptyQuery.toParamString(mime.allowEmpty))), ("mimeAllowed", Some(mime.allowedQuery.toParamString(mime.allowed))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRestImplApiEndpointResourceProviderFactoryImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerRoots: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerRootsQuery: QueryParam[String]): Task[ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo] = jsonOf[ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.rest.impl.ApiEndpointResourceProviderFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerRoots", Some(provider.rootsQuery.toParamString(provider.roots))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRestImplServletDefaultGETServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultLimit: Integer, useAbsoluteUri: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultLimitQuery: QueryParam[Integer], useAbsoluteUriQuery: QueryParam[Boolean]): Task[ComAdobeGraniteRestImplServletDefaultGETServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRestImplServletDefaultGETServletInfo] = jsonOf[ComAdobeGraniteRestImplServletDefaultGETServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.rest.impl.servlet.DefaultGETServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultLimit", Some(default.limitQuery.toParamString(default.limit))), ("useAbsoluteUri", Some(use.absolute.uriQuery.toParamString(use.absolute.uri))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRestImplServletDefaultGETServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationS(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo] = jsonOf[ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo]

    val path = "/system/console/configMgr/com.adobe.granite.security.user.ui.internal.servlets.SSLConfigurationServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteSecurityUserUserPropertiesService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], adapterCondition: String, graniteUserpropertiesNodetypes: List[String], graniteUserpropertiesResourcetypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], adapterConditionQuery: QueryParam[String], graniteUserpropertiesNodetypesQuery: QueryParam[List[String]], graniteUserpropertiesResourcetypesQuery: QueryParam[List[String]]): Task[ComAdobeGraniteSecurityUserUserPropertiesServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteSecurityUserUserPropertiesServiceInfo] = jsonOf[ComAdobeGraniteSecurityUserUserPropertiesServiceInfo]

    val path = "/system/console/configMgr/com.adobe.granite.security.user.UserPropertiesService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("adapterCondition", Some(adapter.conditionQuery.toParamString(adapter.condition))), ("graniteUserpropertiesNodetypes", Some(granite.userproperties.nodetypesQuery.toParamString(granite.userproperties.nodetypes))), ("graniteUserpropertiesResourcetypes", Some(granite.userproperties.resourcetypesQuery.toParamString(granite.userproperties.resourcetypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteSecurityUserUserPropertiesServiceInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteSocialgraphImplSocialGraphFactoryImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], group2memberRelationshipOutgoing: String, group2memberExcludedOutgoing: List[String], group2memberRelationshipIncoming: String, group2memberExcludedIncoming: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], group2memberRelationshipOutgoingQuery: QueryParam[String], group2memberExcludedOutgoingQuery: QueryParam[List[String]], group2memberRelationshipIncomingQuery: QueryParam[String], group2memberExcludedIncomingQuery: QueryParam[List[String]]): Task[ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo] = jsonOf[ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.socialgraph.impl.SocialGraphFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("group2memberRelationshipOutgoing", Some(group2member.relationship.outgoingQuery.toParamString(group2member.relationship.outgoing))), ("group2memberExcludedOutgoing", Some(group2member.excluded.outgoingQuery.toParamString(group2member.excluded.outgoing))), ("group2memberRelationshipIncoming", Some(group2member.relationship.incomingQuery.toParamString(group2member.relationship.incoming))), ("group2memberExcludedIncoming", Some(group2member.excluded.incomingQuery.toParamString(group2member.excluded.incoming))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteSystemMonitoringImplSystemStatsMBeanImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, jmxObjectname: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], jmxObjectnameQuery: QueryParam[String]): Task[ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo] = jsonOf[ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.system.monitoring.impl.SystemStatsMBeanImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("jmxObjectname", Some(jmx.objectnameQuery.toParamString(jmx.objectname))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteTaskmanagementImplJcrTaskAdapterFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], adapterCondition: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], adapterConditionQuery: QueryParam[String]): Task[ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo] = jsonOf[ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo]

    val path = "/system/console/configMgr/com.adobe.granite.taskmanagement.impl.jcr.TaskAdapterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("adapterCondition", Some(adapter.conditionQuery.toParamString(adapter.condition))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteTaskmanagementImplJcrTaskArchiveService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], archivingEnabled: Boolean, schedulerExpression: String, archiveSinceDaysCompleted: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], archivingEnabledQuery: QueryParam[Boolean], schedulerExpressionQuery: QueryParam[String], archiveSinceDaysCompletedQuery: QueryParam[Integer]): Task[ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo] = jsonOf[ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo]

    val path = "/system/console/configMgr/com.adobe.granite.taskmanagement.impl.jcr.TaskArchiveService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("archivingEnabled", Some(archiving.enabledQuery.toParamString(archiving.enabled))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("archiveSinceDaysCompleted", Some(archive.since.days.completedQuery.toParamString(archive.since.days.completed))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTask(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], purgeCompleted: Boolean, completedAge: Integer, purgeActive: Boolean, activeAge: Integer, saveThreshold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], purgeCompletedQuery: QueryParam[Boolean], completedAgeQuery: QueryParam[Integer], purgeActiveQuery: QueryParam[Boolean], activeAgeQuery: QueryParam[Integer], saveThresholdQuery: QueryParam[Integer]): Task[ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo] = jsonOf[ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo]

    val path = "/system/console/configMgr/com.adobe.granite.taskmanagement.impl.purge.TaskPurgeMaintenanceTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("purgeCompleted", Some(purgeCompletedQuery.toParamString(purgeCompleted))), ("completedAge", Some(completedAgeQuery.toParamString(completedAge))), ("purgeActive", Some(purgeActiveQuery.toParamString(purgeActive))), ("activeAge", Some(activeAgeQuery.toParamString(activeAge))), ("saveThreshold", Some(saveThresholdQuery.toParamString(saveThreshold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], adapterCondition: String, taskmanagerAdmingroups: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], adapterConditionQuery: QueryParam[String], taskmanagerAdmingroupsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo] = jsonOf[ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo]

    val path = "/system/console/configMgr/com.adobe.granite.taskmanagement.impl.service.TaskManagerAdapterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("adapterCondition", Some(adapter.conditionQuery.toParamString(adapter.condition))), ("taskmanagerAdmingroups", Some(taskmanager.admingroupsQuery.toParamString(taskmanager.admingroups))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteThreaddumpThreadDumpCollector(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerPeriod: Integer, schedulerRunOn: String, graniteThreaddumpEnabled: Boolean, graniteThreaddumpDumpsPerFile: Integer, graniteThreaddumpEnableGzipCompression: Boolean, graniteThreaddumpEnableDirectoriesCompression: Boolean, graniteThreaddumpEnableJStack: Boolean, graniteThreaddumpMaxBackupDays: Integer, graniteThreaddumpBackupCleanTrigger: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerPeriodQuery: QueryParam[Integer], schedulerRunOnQuery: QueryParam[String], graniteThreaddumpEnabledQuery: QueryParam[Boolean], graniteThreaddumpDumpsPerFileQuery: QueryParam[Integer], graniteThreaddumpEnableGzipCompressionQuery: QueryParam[Boolean], graniteThreaddumpEnableDirectoriesCompressionQuery: QueryParam[Boolean], graniteThreaddumpEnableJStackQuery: QueryParam[Boolean], graniteThreaddumpMaxBackupDaysQuery: QueryParam[Integer], graniteThreaddumpBackupCleanTriggerQuery: QueryParam[String]): Task[ComAdobeGraniteThreaddumpThreadDumpCollectorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteThreaddumpThreadDumpCollectorInfo] = jsonOf[ComAdobeGraniteThreaddumpThreadDumpCollectorInfo]

    val path = "/system/console/configMgr/com.adobe.granite.threaddump.ThreadDumpCollector"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerPeriod", Some(scheduler.periodQuery.toParamString(scheduler.period))), ("schedulerRunOn", Some(scheduler.runOnQuery.toParamString(scheduler.runOn))), ("graniteThreaddumpEnabled", Some(granite.threaddump.enabledQuery.toParamString(granite.threaddump.enabled))), ("graniteThreaddumpDumpsPerFile", Some(granite.threaddump.dumpsPerFileQuery.toParamString(granite.threaddump.dumpsPerFile))), ("graniteThreaddumpEnableGzipCompression", Some(granite.threaddump.enableGzipCompressionQuery.toParamString(granite.threaddump.enableGzipCompression))), ("graniteThreaddumpEnableDirectoriesCompression", Some(granite.threaddump.enableDirectoriesCompressionQuery.toParamString(granite.threaddump.enableDirectoriesCompression))), ("graniteThreaddumpEnableJStack", Some(granite.threaddump.enableJStackQuery.toParamString(granite.threaddump.enableJStack))), ("graniteThreaddumpMaxBackupDays", Some(granite.threaddump.maxBackupDaysQuery.toParamString(granite.threaddump.maxBackupDays))), ("graniteThreaddumpBackupCleanTrigger", Some(granite.threaddump.backupCleanTriggerQuery.toParamString(granite.threaddump.backupCleanTrigger))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteThreaddumpThreadDumpCollectorInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTransl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], translationFactory: String, defaultConnectorLabel: String, defaultConnectorAttribution: String, defaultConnectorWorkspaceId: String, defaultConnectorSubscriptionKey: String, languageMapLocation: String, categoryMapLocation: String, retryAttempts: Integer, timeoutCount: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], translationFactoryQuery: QueryParam[String], defaultConnectorLabelQuery: QueryParam[String], defaultConnectorAttributionQuery: QueryParam[String], defaultConnectorWorkspaceIdQuery: QueryParam[String], defaultConnectorSubscriptionKeyQuery: QueryParam[String], languageMapLocationQuery: QueryParam[String], categoryMapLocationQuery: QueryParam[String], retryAttemptsQuery: QueryParam[Integer], timeoutCountQuery: QueryParam[Integer]): Task[ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo] = jsonOf[ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo]

    val path = "/system/console/configMgr/com.adobe.granite.translation.connector.msft.core.impl.MicrosoftTranslationServiceFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("translationFactory", Some(translationFactoryQuery.toParamString(translationFactory))), ("defaultConnectorLabel", Some(defaultConnectorLabelQuery.toParamString(defaultConnectorLabel))), ("defaultConnectorAttribution", Some(defaultConnectorAttributionQuery.toParamString(defaultConnectorAttribution))), ("defaultConnectorWorkspaceId", Some(defaultConnectorWorkspaceIdQuery.toParamString(defaultConnectorWorkspaceId))), ("defaultConnectorSubscriptionKey", Some(defaultConnectorSubscriptionKeyQuery.toParamString(defaultConnectorSubscriptionKey))), ("languageMapLocation", Some(languageMapLocationQuery.toParamString(languageMapLocation))), ("categoryMapLocation", Some(categoryMapLocationQuery.toParamString(categoryMapLocation))), ("retryAttempts", Some(retryAttemptsQuery.toParamString(retryAttempts))), ("timeoutCount", Some(timeoutCountQuery.toParamString(timeoutCount))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteTranslationCoreImplTranslationManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultConnectorName: String, defaultCategory: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultConnectorNameQuery: QueryParam[String], defaultCategoryQuery: QueryParam[String]): Task[ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo] = jsonOf[ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.translation.core.impl.TranslationManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultConnectorName", Some(defaultConnectorNameQuery.toParamString(defaultConnectorName))), ("defaultCategory", Some(defaultCategoryQuery.toParamString(defaultCategory))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteUiClientlibsImplHtmlLibraryManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], htmllibmanagerTiming: Boolean, htmllibmanagerDebugInitJs: String, htmllibmanagerMinify: Boolean, htmllibmanagerDebug: Boolean, htmllibmanagerGzip: Boolean, htmllibmanagerMaxDataUriSize: Integer, htmllibmanagerMaxage: Integer, htmllibmanagerForceCQUrlInfo: Boolean, htmllibmanagerDefaultthemename: String, htmllibmanagerDefaultuserthemename: String, htmllibmanagerClientmanager: String, htmllibmanagerPathList: List[String], htmllibmanagerExcludedPathList: List[String], htmllibmanagerProcessorJs: List[String], htmllibmanagerProcessorCss: List[String], htmllibmanagerLongcachePatterns: List[String], htmllibmanagerLongcacheFormat: String, htmllibmanagerUseFileSystemOutputCache: Boolean, htmllibmanagerFileSystemOutputCacheLocation: String, htmllibmanagerDisableReplacement: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], htmllibmanagerTimingQuery: QueryParam[Boolean], htmllibmanagerDebugInitJsQuery: QueryParam[String], htmllibmanagerMinifyQuery: QueryParam[Boolean], htmllibmanagerDebugQuery: QueryParam[Boolean], htmllibmanagerGzipQuery: QueryParam[Boolean], htmllibmanagerMaxDataUriSizeQuery: QueryParam[Integer], htmllibmanagerMaxageQuery: QueryParam[Integer], htmllibmanagerForceCQUrlInfoQuery: QueryParam[Boolean], htmllibmanagerDefaultthemenameQuery: QueryParam[String], htmllibmanagerDefaultuserthemenameQuery: QueryParam[String], htmllibmanagerClientmanagerQuery: QueryParam[String], htmllibmanagerPathListQuery: QueryParam[List[String]], htmllibmanagerExcludedPathListQuery: QueryParam[List[String]], htmllibmanagerProcessorJsQuery: QueryParam[List[String]], htmllibmanagerProcessorCssQuery: QueryParam[List[String]], htmllibmanagerLongcachePatternsQuery: QueryParam[List[String]], htmllibmanagerLongcacheFormatQuery: QueryParam[String], htmllibmanagerUseFileSystemOutputCacheQuery: QueryParam[Boolean], htmllibmanagerFileSystemOutputCacheLocationQuery: QueryParam[String], htmllibmanagerDisableReplacementQuery: QueryParam[List[String]]): Task[ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo] = jsonOf[ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.ui.clientlibs.impl.HtmlLibraryManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("htmllibmanagerTiming", Some(htmllibmanager.timingQuery.toParamString(htmllibmanager.timing))), ("htmllibmanagerDebugInitJs", Some(htmllibmanager.debug.init.jsQuery.toParamString(htmllibmanager.debug.init.js))), ("htmllibmanagerMinify", Some(htmllibmanager.minifyQuery.toParamString(htmllibmanager.minify))), ("htmllibmanagerDebug", Some(htmllibmanager.debugQuery.toParamString(htmllibmanager.debug))), ("htmllibmanagerGzip", Some(htmllibmanager.gzipQuery.toParamString(htmllibmanager.gzip))), ("htmllibmanagerMaxDataUriSize", Some(htmllibmanager.maxDataUriSizeQuery.toParamString(htmllibmanager.maxDataUriSize))), ("htmllibmanagerMaxage", Some(htmllibmanager.maxageQuery.toParamString(htmllibmanager.maxage))), ("htmllibmanagerForceCQUrlInfo", Some(htmllibmanager.forceCQUrlInfoQuery.toParamString(htmllibmanager.forceCQUrlInfo))), ("htmllibmanagerDefaultthemename", Some(htmllibmanager.defaultthemenameQuery.toParamString(htmllibmanager.defaultthemename))), ("htmllibmanagerDefaultuserthemename", Some(htmllibmanager.defaultuserthemenameQuery.toParamString(htmllibmanager.defaultuserthemename))), ("htmllibmanagerClientmanager", Some(htmllibmanager.clientmanagerQuery.toParamString(htmllibmanager.clientmanager))), ("htmllibmanagerPathList", Some(htmllibmanager.path.listQuery.toParamString(htmllibmanager.path.list))), ("htmllibmanagerExcludedPathList", Some(htmllibmanager.excluded.path.listQuery.toParamString(htmllibmanager.excluded.path.list))), ("htmllibmanagerProcessorJs", Some(htmllibmanager.processor.jsQuery.toParamString(htmllibmanager.processor.js))), ("htmllibmanagerProcessorCss", Some(htmllibmanager.processor.cssQuery.toParamString(htmllibmanager.processor.css))), ("htmllibmanagerLongcachePatterns", Some(htmllibmanager.longcache.patternsQuery.toParamString(htmllibmanager.longcache.patterns))), ("htmllibmanagerLongcacheFormat", Some(htmllibmanager.longcache.formatQuery.toParamString(htmllibmanager.longcache.format))), ("htmllibmanagerUseFileSystemOutputCache", Some(htmllibmanager.useFileSystemOutputCacheQuery.toParamString(htmllibmanager.useFileSystemOutputCache))), ("htmllibmanagerFileSystemOutputCacheLocation", Some(htmllibmanager.fileSystemOutputCacheLocationQuery.toParamString(htmllibmanager.fileSystemOutputCacheLocation))), ("htmllibmanagerDisableReplacement", Some(htmllibmanager.disable.replacementQuery.toParamString(htmllibmanager.disable.replacement))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeature(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo] = jsonOf[ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.console.frags.WorkflowWithdrawFeature"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowConsolePublishWorkflowPublishEventService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], graniteWorkflowWorkflowPublishEventServiceEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], graniteWorkflowWorkflowPublishEventServiceEnabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo] = jsonOf[ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.console.publish.WorkflowPublishEventService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("graniteWorkflowWorkflowPublishEventServiceEnabled", Some(granite.workflow.WorkflowPublishEventService.enabledQuery.toParamString(granite.workflow.WorkflowPublishEventService.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCoreJcrWorkflowBucketManager(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], bucketSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], bucketSizeQuery: QueryParam[Integer]): Task[ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo] = jsonOf[ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.jcr.WorkflowBucketManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("bucketSize", Some(bucketSizeQuery.toParamString(bucketSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCoreJobExternalProcessJobHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultTimeout: Integer, maxTimeout: Integer, defaultPeriod: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultTimeoutQuery: QueryParam[Integer], maxTimeoutQuery: QueryParam[Integer], defaultPeriodQuery: QueryParam[Integer]): Task[ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo] = jsonOf[ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.job.ExternalProcessJobHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultTimeout", Some(default.timeoutQuery.toParamString(default.timeout))), ("maxTimeout", Some(max.timeoutQuery.toParamString(max.timeout))), ("defaultPeriod", Some(default.periodQuery.toParamString(default.period))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCoreJobJobHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jobTopics: List[String], allowSelfProcessTermination: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jobTopicsQuery: QueryParam[List[String]], allowSelfProcessTerminationQuery: QueryParam[Boolean]): Task[ComAdobeGraniteWorkflowCoreJobJobHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCoreJobJobHandlerInfo] = jsonOf[ComAdobeGraniteWorkflowCoreJobJobHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.job.JobHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jobTopics", Some(job.topicsQuery.toParamString(job.topics))), ("allowSelfProcessTermination", Some(allow.self.process.terminationQuery.toParamString(allow.self.process.termination))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCoreJobJobHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsum(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jobTopics: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jobTopicsQuery: QueryParam[String]): Task[ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo] = jsonOf[ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.offloading.WorkflowOffloadingJobConsumer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jobTopics", Some(job.topicsQuery.toParamString(job.topics))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCorePayloadMapCache(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], getSystemWorkflowModels: List[String], getPackageRootPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], getSystemWorkflowModelsQuery: QueryParam[List[String]], getPackageRootPathQuery: QueryParam[String]): Task[ComAdobeGraniteWorkflowCorePayloadMapCacheInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCorePayloadMapCacheInfo] = jsonOf[ComAdobeGraniteWorkflowCorePayloadMapCacheInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.PayloadMapCache"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("getSystemWorkflowModels", Some(getSystemWorkflowModelsQuery.toParamString(getSystemWorkflowModels))), ("getPackageRootPath", Some(getPackageRootPathQuery.toParamString(getPackageRootPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCorePayloadMapCacheInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCorePayloadmapPayloadMoveListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], payloadMoveWhiteList: List[String], payloadMoveHandleFromWorkflowProcess: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], payloadMoveWhiteListQuery: QueryParam[List[String]], payloadMoveHandleFromWorkflowProcessQuery: QueryParam[Boolean]): Task[ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo] = jsonOf[ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.payloadmap.PayloadMoveListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("payloadMoveWhiteList", Some(payload.move.white.listQuery.toParamString(payload.move.white.list))), ("payloadMoveHandleFromWorkflowProcess", Some(payload.move.handle.from.workflow.processQuery.toParamString(payload.move.handle.from.workflow.process))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCoreWorkflowConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWorkflowConfigWorkflowPackagesRootPath: List[String], cqWorkflowConfigWorkflowProcessLegacyMode: Boolean, cqWorkflowConfigAllowLocking: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWorkflowConfigWorkflowPackagesRootPathQuery: QueryParam[List[String]], cqWorkflowConfigWorkflowProcessLegacyModeQuery: QueryParam[Boolean], cqWorkflowConfigAllowLockingQuery: QueryParam[Boolean]): Task[ComAdobeGraniteWorkflowCoreWorkflowConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCoreWorkflowConfigInfo] = jsonOf[ComAdobeGraniteWorkflowCoreWorkflowConfigInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.WorkflowConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWorkflowConfigWorkflowPackagesRootPath", Some(cq.workflow.config.workflow.packages.root.pathQuery.toParamString(cq.workflow.config.workflow.packages.root.path))), ("cqWorkflowConfigWorkflowProcessLegacyMode", Some(cq.workflow.config.workflow.process.legacy.modeQuery.toParamString(cq.workflow.config.workflow.process.legacy.mode))), ("cqWorkflowConfigAllowLocking", Some(cq.workflow.config.allow.lockingQuery.toParamString(cq.workflow.config.allow.locking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCoreWorkflowConfigInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCoreWorkflowSessionFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], graniteWorkflowinboxSortPropertyName: String, graniteWorkflowinboxSortOrder: String, cqWorkflowJobRetry: Integer, cqWorkflowSuperuser: List[String], graniteWorkflowInboxQuerySize: Integer, graniteWorkflowAdminUserGroupFilter: Boolean, graniteWorkflowEnforceWorkitemAssigneePermissions: Boolean, graniteWorkflowEnforceWorkflowInitiatorPermissions: Boolean, graniteWorkflowInjectTenantIdInJobTopics: Boolean, graniteWorkflowMaxPurgeSaveThreshold: Integer, graniteWorkflowMaxPurgeQueryCount: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], graniteWorkflowinboxSortPropertyNameQuery: QueryParam[String], graniteWorkflowinboxSortOrderQuery: QueryParam[String], cqWorkflowJobRetryQuery: QueryParam[Integer], cqWorkflowSuperuserQuery: QueryParam[List[String]], graniteWorkflowInboxQuerySizeQuery: QueryParam[Integer], graniteWorkflowAdminUserGroupFilterQuery: QueryParam[Boolean], graniteWorkflowEnforceWorkitemAssigneePermissionsQuery: QueryParam[Boolean], graniteWorkflowEnforceWorkflowInitiatorPermissionsQuery: QueryParam[Boolean], graniteWorkflowInjectTenantIdInJobTopicsQuery: QueryParam[Boolean], graniteWorkflowMaxPurgeSaveThresholdQuery: QueryParam[Integer], graniteWorkflowMaxPurgeQueryCountQuery: QueryParam[Integer]): Task[ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo] = jsonOf[ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.WorkflowSessionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("graniteWorkflowinboxSortPropertyName", Some(granite.workflowinbox.sort.propertyNameQuery.toParamString(granite.workflowinbox.sort.propertyName))), ("graniteWorkflowinboxSortOrder", Some(granite.workflowinbox.sort.orderQuery.toParamString(granite.workflowinbox.sort.order))), ("cqWorkflowJobRetry", Some(cq.workflow.job.retryQuery.toParamString(cq.workflow.job.retry))), ("cqWorkflowSuperuser", Some(cq.workflow.superuserQuery.toParamString(cq.workflow.superuser))), ("graniteWorkflowInboxQuerySize", Some(granite.workflow.inboxQuerySizeQuery.toParamString(granite.workflow.inboxQuerySize))), ("graniteWorkflowAdminUserGroupFilter", Some(granite.workflow.adminUserGroupFilterQuery.toParamString(granite.workflow.adminUserGroupFilter))), ("graniteWorkflowEnforceWorkitemAssigneePermissions", Some(granite.workflow.enforceWorkitemAssigneePermissionsQuery.toParamString(granite.workflow.enforceWorkitemAssigneePermissions))), ("graniteWorkflowEnforceWorkflowInitiatorPermissions", Some(granite.workflow.enforceWorkflowInitiatorPermissionsQuery.toParamString(granite.workflow.enforceWorkflowInitiatorPermissions))), ("graniteWorkflowInjectTenantIdInJobTopics", Some(granite.workflow.injectTenantIdInJobTopicsQuery.toParamString(granite.workflow.injectTenantIdInJobTopics))), ("graniteWorkflowMaxPurgeSaveThreshold", Some(granite.workflow.maxPurgeSaveThresholdQuery.toParamString(granite.workflow.maxPurgeSaveThreshold))), ("graniteWorkflowMaxPurgeQueryCount", Some(granite.workflow.maxPurgeQueryCountQuery.toParamString(granite.workflow.maxPurgeQueryCount))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowPurgeScheduler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], scheduledpurgeName: String, scheduledpurgeWorkflowStatus: String, scheduledpurgeModelIds: List[String], scheduledpurgeDaysold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], scheduledpurgeNameQuery: QueryParam[String], scheduledpurgeWorkflowStatusQuery: QueryParam[String], scheduledpurgeModelIdsQuery: QueryParam[List[String]], scheduledpurgeDaysoldQuery: QueryParam[Integer]): Task[ComAdobeGraniteWorkflowPurgeSchedulerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowPurgeSchedulerInfo] = jsonOf[ComAdobeGraniteWorkflowPurgeSchedulerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.purge.Scheduler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("scheduledpurgeName", Some(scheduledpurge.nameQuery.toParamString(scheduledpurge.name))), ("scheduledpurgeWorkflowStatus", Some(scheduledpurge.workflowStatusQuery.toParamString(scheduledpurge.workflowStatus))), ("scheduledpurgeModelIds", Some(scheduledpurge.modelIdsQuery.toParamString(scheduledpurge.modelIds))), ("scheduledpurgeDaysold", Some(scheduledpurge.daysoldQuery.toParamString(scheduledpurge.daysold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowPurgeSchedulerInfo](req)

    } yield resp
  }
  
  def comAdobeOctopusNcommBootstrap(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxConnections: Integer, maxRequests: Integer, requestTimeout: Integer, requestRetries: Integer, launchTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxConnectionsQuery: QueryParam[Integer], maxRequestsQuery: QueryParam[Integer], requestTimeoutQuery: QueryParam[Integer], requestRetriesQuery: QueryParam[Integer], launchTimeoutQuery: QueryParam[Integer]): Task[ComAdobeOctopusNcommBootstrapInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeOctopusNcommBootstrapInfo] = jsonOf[ComAdobeOctopusNcommBootstrapInfo]

    val path = "/system/console/configMgr/com.adobe.octopus.ncomm.bootstrap"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxConnections", Some(maxConnectionsQuery.toParamString(maxConnections))), ("maxRequests", Some(maxRequestsQuery.toParamString(maxRequests))), ("requestTimeout", Some(requestTimeoutQuery.toParamString(requestTimeout))), ("requestRetries", Some(requestRetriesQuery.toParamString(requestRetries))), ("launchTimeout", Some(launchTimeoutQuery.toParamString(launchTimeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeOctopusNcommBootstrapInfo](req)

    } yield resp
  }
  
  def comAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullS(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], communitiesIntegrationLivefyreSlingEventFilter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], communitiesIntegrationLivefyreSlingEventFilterQuery: QueryParam[String]): Task[ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo] = jsonOf[ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo]

    val path = "/system/console/configMgr/com.adobe.social.integrations.livefyre.user.pingforpull.impl.PingPullServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("communitiesIntegrationLivefyreSlingEventFilter", Some(communities.integration.livefyre.sling.event.filterQuery.toParamString(communities.integration.livefyre.sling.event.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo](req)

    } yield resp
  }
  
  def comAdobeXmpWorkerFilesNcommXMPFilesNComm(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxConnections: String, maxRequests: String, requestTimeout: String, logDir: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxConnectionsQuery: QueryParam[String], maxRequestsQuery: QueryParam[String], requestTimeoutQuery: QueryParam[String], logDirQuery: QueryParam[String]): Task[ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo] = jsonOf[ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo]

    val path = "/system/console/configMgr/com.adobe.xmp.worker.files.ncomm.XMPFilesNComm"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxConnections", Some(maxConnectionsQuery.toParamString(maxConnections))), ("maxRequests", Some(maxRequestsQuery.toParamString(maxRequests))), ("requestTimeout", Some(requestTimeoutQuery.toParamString(requestTimeout))), ("logDir", Some(logDirQuery.toParamString(logDir))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo](req)

    } yield resp
  }
  
  def comDayCommonsDatasourceJdbcpoolJdbcPoolService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jdbcDriverClass: String, jdbcConnectionUri: String, jdbcUsername: String, jdbcPassword: String, jdbcValidationQuery: String, defaultReadonly: Boolean, defaultAutocommit: Boolean, poolSize: Integer, poolMaxWaitMsec: Integer, datasourceName: String, datasourceSvcProperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jdbcDriverClassQuery: QueryParam[String], jdbcConnectionUriQuery: QueryParam[String], jdbcUsernameQuery: QueryParam[String], jdbcPasswordQuery: QueryParam[String], jdbcValidationQueryQuery: QueryParam[String], defaultReadonlyQuery: QueryParam[Boolean], defaultAutocommitQuery: QueryParam[Boolean], poolSizeQuery: QueryParam[Integer], poolMaxWaitMsecQuery: QueryParam[Integer], datasourceNameQuery: QueryParam[String], datasourceSvcPropertiesQuery: QueryParam[List[String]]): Task[ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo] = jsonOf[ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo]

    val path = "/system/console/configMgr/com.day.commons.datasource.jdbcpool.JdbcPoolService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jdbcDriverClass", Some(jdbc.driver.classQuery.toParamString(jdbc.driver.class))), ("jdbcConnectionUri", Some(jdbc.connection.uriQuery.toParamString(jdbc.connection.uri))), ("jdbcUsername", Some(jdbc.usernameQuery.toParamString(jdbc.username))), ("jdbcPassword", Some(jdbc.passwordQuery.toParamString(jdbc.password))), ("jdbcValidationQuery", Some(jdbc.validation.queryQuery.toParamString(jdbc.validation.query))), ("defaultReadonly", Some(default.readonlyQuery.toParamString(default.readonly))), ("defaultAutocommit", Some(default.autocommitQuery.toParamString(default.autocommit))), ("poolSize", Some(pool.sizeQuery.toParamString(pool.size))), ("poolMaxWaitMsec", Some(pool.max.wait.msecQuery.toParamString(pool.max.wait.msec))), ("datasourceName", Some(datasource.nameQuery.toParamString(datasource.name))), ("datasourceSvcProperties", Some(datasource.svc.propertiesQuery.toParamString(datasource.svc.properties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo](req)

    } yield resp
  }
  
  def comDayCommonsHttpclient(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], proxyEnabled: Boolean, proxyHost: String, proxyUser: String, proxyPassword: String, proxyNtlmHost: String, proxyNtlmDomain: String, proxyExceptions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], proxyEnabledQuery: QueryParam[Boolean], proxyHostQuery: QueryParam[String], proxyUserQuery: QueryParam[String], proxyPasswordQuery: QueryParam[String], proxyNtlmHostQuery: QueryParam[String], proxyNtlmDomainQuery: QueryParam[String], proxyExceptionsQuery: QueryParam[List[String]]): Task[ComDayCommonsHttpclientInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCommonsHttpclientInfo] = jsonOf[ComDayCommonsHttpclientInfo]

    val path = "/system/console/configMgr/com.day.commons.httpclient"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("proxyEnabled", Some(proxy.enabledQuery.toParamString(proxy.enabled))), ("proxyHost", Some(proxy.hostQuery.toParamString(proxy.host))), ("proxyUser", Some(proxy.userQuery.toParamString(proxy.user))), ("proxyPassword", Some(proxy.passwordQuery.toParamString(proxy.password))), ("proxyNtlmHost", Some(proxy.ntlm.hostQuery.toParamString(proxy.ntlm.host))), ("proxyNtlmDomain", Some(proxy.ntlm.domainQuery.toParamString(proxy.ntlm.domain))), ("proxyExceptions", Some(proxy.exceptionsQuery.toParamString(proxy.exceptions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCommonsHttpclientInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsImplStorePropertiesChangeListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqStoreListenerAdditionalStorePaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqStoreListenerAdditionalStorePathsQuery: QueryParam[List[String]]): Task[ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo] = jsonOf[ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.impl.StorePropertiesChangeListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqStoreListenerAdditionalStorePaths", Some(cq.store.listener.additionalStorePathsQuery.toParamString(cq.store.listener.additionalStorePaths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsSitecatalystImplExporterClassificationsExporte(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], allowedPaths: List[String], cqAnalyticsSaintExporterPagesize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], allowedPathsQuery: QueryParam[List[String]], cqAnalyticsSaintExporterPagesizeQuery: QueryParam[Integer]): Task[ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo] = jsonOf[ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.exporter.ClassificationsExporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("allowedPaths", Some(allowed.pathsQuery.toParamString(allowed.paths))), ("cqAnalyticsSaintExporterPagesize", Some(cq.analytics.saint.exporter.pagesizeQuery.toParamString(cq.analytics.saint.exporter.pagesize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsSitecatalystImplImporterReportImporter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], reportFetchAttempts: Integer, reportFetchDelay: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], reportFetchAttemptsQuery: QueryParam[Integer], reportFetchDelayQuery: QueryParam[Integer]): Task[ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo] = jsonOf[ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.importer.ReportImporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("reportFetchAttempts", Some(report.fetch.attemptsQuery.toParamString(report.fetch.attempts))), ("reportFetchDelay", Some(report.fetch.delayQuery.toParamString(report.fetch.delay))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsAdapterfactoryContextstores: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsAdapterfactoryContextstoresQuery: QueryParam[List[String]]): Task[ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo] = jsonOf[ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.SitecatalystAdapterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsAdapterfactoryContextstores", Some(cq.analytics.adapterfactory.contextstoresQuery.toParamString(cq.analytics.adapterfactory.contextstores))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsSitecatalystServiceDatacenterUrl: List[String], devhostnamepatterns: List[String], connectionTimeout: Integer, socketTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsSitecatalystServiceDatacenterUrlQuery: QueryParam[List[String]], devhostnamepatternsQuery: QueryParam[List[String]], connectionTimeoutQuery: QueryParam[Integer], socketTimeoutQuery: QueryParam[Integer]): Task[ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo] = jsonOf[ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.SitecatalystHttpClientImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsSitecatalystServiceDatacenterUrl", Some(cq.analytics.sitecatalyst.service.datacenter.urlQuery.toParamString(cq.analytics.sitecatalyst.service.datacenter.url))), ("devhostnamepatterns", Some(devhostnamepatternsQuery.toParamString(devhostnamepatterns))), ("connectionTimeout", Some(connection.timeoutQuery.toParamString(connection.timeout))), ("socketTimeout", Some(socket.timeoutQuery.toParamString(socket.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplAccountOptionsUpdater(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsTestandtargetAccountoptionsupdaterEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsTestandtargetAccountoptionsupdaterEnabledQuery: QueryParam[Boolean]): Task[ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.AccountOptionsUpdater"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsTestandtargetAccountoptionsupdaterEnabled", Some(cq.analytics.testandtarget.accountoptionsupdater.enabledQuery.toParamString(cq.analytics.testandtarget.accountoptionsupdater.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabledQuery: QueryParam[Boolean]): Task[ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.DeleteAuthorActivityListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabled", Some(cq.analytics.testandtarget.deleteauthoractivitylistener.enabledQuery.toParamString(cq.analytics.testandtarget.deleteauthoractivitylistener.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabledQuery: QueryParam[Boolean]): Task[ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.PushAuthorCampaignPageListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabled", Some(cq.analytics.testandtarget.pushauthorcampaignpagelistener.enabledQuery.toParamString(cq.analytics.testandtarget.pushauthorcampaignpagelistener.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplSegmentImporter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsTestandtargetSegmentimporterEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsTestandtargetSegmentimporterEnabledQuery: QueryParam[Boolean]): Task[ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.SegmentImporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsTestandtargetSegmentimporterEnabled", Some(cq.analytics.testandtarget.segmentimporter.enabledQuery.toParamString(cq.analytics.testandtarget.segmentimporter.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplServiceWebServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], endpointUri: String, connectionTimeout: Integer, socketTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], endpointUriQuery: QueryParam[String], connectionTimeoutQuery: QueryParam[Integer], socketTimeoutQuery: QueryParam[Integer]): Task[ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.service.WebServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("endpointUri", Some(endpointUriQuery.toParamString(endpointUri))), ("connectionTimeout", Some(connectionTimeoutQuery.toParamString(connectionTimeout))), ("socketTimeout", Some(socketTimeoutQuery.toParamString(socketTimeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplServletsAdminServerServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], testandtargetEndpointUrl: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], testandtargetEndpointUrlQuery: QueryParam[String]): Task[ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.servlets.AdminServerServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("testandtargetEndpointUrl", Some(testandtarget.endpoint.urlQuery.toParamString(testandtarget.endpoint.url))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsTestandtargetApiUrl: String, cqAnalyticsTestandtargetTimeout: Integer, cqAnalyticsTestandtargetSockettimeout: Integer, cqAnalyticsTestandtargetRecommendationsUrlReplace: String, cqAnalyticsTestandtargetRecommendationsUrlReplacewith: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsTestandtargetApiUrlQuery: QueryParam[String], cqAnalyticsTestandtargetTimeoutQuery: QueryParam[Integer], cqAnalyticsTestandtargetSockettimeoutQuery: QueryParam[Integer], cqAnalyticsTestandtargetRecommendationsUrlReplaceQuery: QueryParam[String], cqAnalyticsTestandtargetRecommendationsUrlReplacewithQuery: QueryParam[String]): Task[ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.TestandtargetHttpClientImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsTestandtargetApiUrl", Some(cq.analytics.testandtarget.api.urlQuery.toParamString(cq.analytics.testandtarget.api.url))), ("cqAnalyticsTestandtargetTimeout", Some(cq.analytics.testandtarget.timeoutQuery.toParamString(cq.analytics.testandtarget.timeout))), ("cqAnalyticsTestandtargetSockettimeout", Some(cq.analytics.testandtarget.sockettimeoutQuery.toParamString(cq.analytics.testandtarget.sockettimeout))), ("cqAnalyticsTestandtargetRecommendationsUrlReplace", Some(cq.analytics.testandtarget.recommendations.url.replaceQuery.toParamString(cq.analytics.testandtarget.recommendations.url.replace))), ("cqAnalyticsTestandtargetRecommendationsUrlReplacewith", Some(cq.analytics.testandtarget.recommendations.url.replacewithQuery.toParamString(cq.analytics.testandtarget.recommendations.url.replacewith))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo](req)

    } yield resp
  }
  
  def comDayCqAuthImplCugCugSupportImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cugExemptedPrincipals: List[String], cugEnabled: Boolean, cugPrincipalsRegex: String, cugPrincipalsReplacement: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cugExemptedPrincipalsQuery: QueryParam[List[String]], cugEnabledQuery: QueryParam[Boolean], cugPrincipalsRegexQuery: QueryParam[String], cugPrincipalsReplacementQuery: QueryParam[String]): Task[ComDayCqAuthImplCugCugSupportImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAuthImplCugCugSupportImplInfo] = jsonOf[ComDayCqAuthImplCugCugSupportImplInfo]

    val path = "/system/console/configMgr/com.day.cq.auth.impl.cug.CugSupportImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cugExemptedPrincipals", Some(cug.exempted.principalsQuery.toParamString(cug.exempted.principals))), ("cugEnabled", Some(cug.enabledQuery.toParamString(cug.enabled))), ("cugPrincipalsRegex", Some(cug.principals.regexQuery.toParamString(cug.principals.regex))), ("cugPrincipalsReplacement", Some(cug.principals.replacementQuery.toParamString(cug.principals.replacement))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAuthImplCugCugSupportImplInfo](req)

    } yield resp
  }
  
  def comDayCqAuthImplLoginSelectorHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, serviceRanking: Integer, authLoginselectorMappings: List[String], authLoginselectorChangepwMappings: List[String], authLoginselectorDefaultloginpage: String, authLoginselectorDefaultchangepwpage: String, authLoginselectorHandle: List[String], authLoginselectorHandleAllExtensions: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], serviceRankingQuery: QueryParam[Integer], authLoginselectorMappingsQuery: QueryParam[List[String]], authLoginselectorChangepwMappingsQuery: QueryParam[List[String]], authLoginselectorDefaultloginpageQuery: QueryParam[String], authLoginselectorDefaultchangepwpageQuery: QueryParam[String], authLoginselectorHandleQuery: QueryParam[List[String]], authLoginselectorHandleAllExtensionsQuery: QueryParam[Boolean]): Task[ComDayCqAuthImplLoginSelectorHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAuthImplLoginSelectorHandlerInfo] = jsonOf[ComDayCqAuthImplLoginSelectorHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.auth.impl.LoginSelectorHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("authLoginselectorMappings", Some(auth.loginselector.mappingsQuery.toParamString(auth.loginselector.mappings))), ("authLoginselectorChangepwMappings", Some(auth.loginselector.changepw.mappingsQuery.toParamString(auth.loginselector.changepw.mappings))), ("authLoginselectorDefaultloginpage", Some(auth.loginselector.defaultloginpageQuery.toParamString(auth.loginselector.defaultloginpage))), ("authLoginselectorDefaultchangepwpage", Some(auth.loginselector.defaultchangepwpageQuery.toParamString(auth.loginselector.defaultchangepwpage))), ("authLoginselectorHandle", Some(auth.loginselector.handleQuery.toParamString(auth.loginselector.handle))), ("authLoginselectorHandleAllExtensions", Some(auth.loginselector.handle.all.extensionsQuery.toParamString(auth.loginselector.handle.all.extensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAuthImplLoginSelectorHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqCommonsImplExternalizerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], externalizerDomains: List[String], externalizerHost: String, externalizerContextpath: String, externalizerEncodedpath: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], externalizerDomainsQuery: QueryParam[List[String]], externalizerHostQuery: QueryParam[String], externalizerContextpathQuery: QueryParam[String], externalizerEncodedpathQuery: QueryParam[Boolean]): Task[ComDayCqCommonsImplExternalizerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqCommonsImplExternalizerImplInfo] = jsonOf[ComDayCqCommonsImplExternalizerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.commons.impl.ExternalizerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("externalizerDomains", Some(externalizer.domainsQuery.toParamString(externalizer.domains))), ("externalizerHost", Some(externalizer.hostQuery.toParamString(externalizer.host))), ("externalizerContextpath", Some(externalizer.contextpathQuery.toParamString(externalizer.contextpath))), ("externalizerEncodedpath", Some(externalizer.encodedpathQuery.toParamString(externalizer.encodedpath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqCommonsImplExternalizerImplInfo](req)

    } yield resp
  }
  
  def comDayCqCommonsServletsRootMappingServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], rootmappingTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], rootmappingTargetQuery: QueryParam[String]): Task[ComDayCqCommonsServletsRootMappingServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqCommonsServletsRootMappingServletInfo] = jsonOf[ComDayCqCommonsServletsRootMappingServletInfo]

    val path = "/system/console/configMgr/com.day.cq.commons.servlets.RootMappingServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("rootmappingTarget", Some(rootmapping.targetQuery.toParamString(rootmapping.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqCommonsServletsRootMappingServletInfo](req)

    } yield resp
  }
  
  def comDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionChecke(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], codeupgradetasks: List[String], codeupgradetaskfilters: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], codeupgradetasksQuery: QueryParam[List[String]], codeupgradetaskfiltersQuery: QueryParam[List[String]]): Task[ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo] = jsonOf[ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo]

    val path = "/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.CodeUpgradeExecutionConditionChecker"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("codeupgradetasks", Some(codeupgradetasksQuery.toParamString(codeupgradetasks))), ("codeupgradetaskfilters", Some(codeupgradetaskfiltersQuery.toParamString(codeupgradetaskfilters))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo](req)

    } yield resp
  }
  
  def comDayCqCompatCodeupgradeImplUpgradeTaskIgnoreList(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], upgradeTaskIgnoreList: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], upgradeTaskIgnoreListQuery: QueryParam[List[String]]): Task[ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo] = jsonOf[ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo]

    val path = "/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.UpgradeTaskIgnoreList"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("upgradeTaskIgnoreList", Some(upgradeTaskIgnoreListQuery.toParamString(upgradeTaskIgnoreList))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo](req)

    } yield resp
  }
  
  def comDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelist(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], effectiveBundleListPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], effectiveBundleListPathQuery: QueryParam[String]): Task[ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo] = jsonOf[ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo]

    val path = "/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.VersionRangeTaskIgnorelist"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("effectiveBundleListPath", Some(effectiveBundleListPathQuery.toParamString(effectiveBundleListPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo](req)

    } yield resp
  }
  
  def comDayCqContentsyncImplContentSyncManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], contentsyncFallbackAuthorizable: String, contentsyncFallbackUpdateuser: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], contentsyncFallbackAuthorizableQuery: QueryParam[String], contentsyncFallbackUpdateuserQuery: QueryParam[String]): Task[ComDayCqContentsyncImplContentSyncManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqContentsyncImplContentSyncManagerImplInfo] = jsonOf[ComDayCqContentsyncImplContentSyncManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.contentsync.impl.ContentSyncManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("contentsyncFallbackAuthorizable", Some(contentsync.fallback.authorizableQuery.toParamString(contentsync.fallback.authorizable))), ("contentsyncFallbackUpdateuser", Some(contentsync.fallback.updateuserQuery.toParamString(contentsync.fallback.updateuser))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqContentsyncImplContentSyncManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCommonsHandlerStandardImageHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], largeFileThreshold: Integer, largeCommentThreshold: Integer, cqDamEnableExtMetaExtraction: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], largeFileThresholdQuery: QueryParam[Integer], largeCommentThresholdQuery: QueryParam[Integer], cqDamEnableExtMetaExtractionQuery: QueryParam[Boolean]): Task[ComDayCqDamCommonsHandlerStandardImageHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCommonsHandlerStandardImageHandlerInfo] = jsonOf[ComDayCqDamCommonsHandlerStandardImageHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.commons.handler.StandardImageHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("largeFileThreshold", Some(large_file_thresholdQuery.toParamString(large_file_threshold))), ("largeCommentThreshold", Some(large_comment_thresholdQuery.toParamString(large_comment_threshold))), ("cqDamEnableExtMetaExtraction", Some(cq.dam.enable.ext.meta.extractionQuery.toParamString(cq.dam.enable.ext.meta.extraction))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCommonsHandlerStandardImageHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCommonsMetadataXmpFilterBlackWhite(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], xmpFilterApplyWhitelist: Boolean, xmpFilterWhitelist: List[String], xmpFilterApplyBlacklist: Boolean, xmpFilterBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], xmpFilterApplyWhitelistQuery: QueryParam[Boolean], xmpFilterWhitelistQuery: QueryParam[List[String]], xmpFilterApplyBlacklistQuery: QueryParam[Boolean], xmpFilterBlacklistQuery: QueryParam[List[String]]): Task[ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo] = jsonOf[ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.commons.metadata.XmpFilterBlackWhite"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("xmpFilterApplyWhitelist", Some(xmp.filter.apply_whitelistQuery.toParamString(xmp.filter.apply_whitelist))), ("xmpFilterWhitelist", Some(xmp.filter.whitelistQuery.toParamString(xmp.filter.whitelist))), ("xmpFilterApplyBlacklist", Some(xmp.filter.apply_blacklistQuery.toParamString(xmp.filter.apply_blacklist))), ("xmpFilterBlacklist", Some(xmp.filter.blacklistQuery.toParamString(xmp.filter.blacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo](req)

    } yield resp
  }
  
  def comDayCqDamCommonsUtilImplAssetCacheImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], largeFileMin: Integer, cacheApply: Boolean, mimeTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], largeFileMinQuery: QueryParam[Integer], cacheApplyQuery: QueryParam[Boolean], mimeTypesQuery: QueryParam[List[String]]): Task[ComDayCqDamCommonsUtilImplAssetCacheImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCommonsUtilImplAssetCacheImplInfo] = jsonOf[ComDayCqDamCommonsUtilImplAssetCacheImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.commons.util.impl.AssetCacheImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("largeFileMin", Some(large.file.minQuery.toParamString(large.file.min))), ("cacheApply", Some(cache.applyQuery.toParamString(cache.apply))), ("mimeTypes", Some(mime.typesQuery.toParamString(mime.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCommonsUtilImplAssetCacheImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplAnnotationPdfAnnotationPdfConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamConfigAnnotationPdfDocumentWidth: Integer, cqDamConfigAnnotationPdfDocumentHeight: Integer, cqDamConfigAnnotationPdfDocumentPaddingHorizontal: Integer, cqDamConfigAnnotationPdfDocumentPaddingVertical: Integer, cqDamConfigAnnotationPdfFontSize: Integer, cqDamConfigAnnotationPdfFontColor: String, cqDamConfigAnnotationPdfFontFamily: String, cqDamConfigAnnotationPdfFontLight: String, cqDamConfigAnnotationPdfMarginTextImage: Integer, cqDamConfigAnnotationPdfMinImageHeight: Integer, cqDamConfigAnnotationPdfReviewStatusWidth: Integer, cqDamConfigAnnotationPdfReviewStatusColorApproved: String, cqDamConfigAnnotationPdfReviewStatusColorRejected: String, cqDamConfigAnnotationPdfReviewStatusColorChangesRequested: String, cqDamConfigAnnotationPdfAnnotationMarkerWidth: Integer, cqDamConfigAnnotationPdfAssetMinheight: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamConfigAnnotationPdfDocumentWidthQuery: QueryParam[Integer], cqDamConfigAnnotationPdfDocumentHeightQuery: QueryParam[Integer], cqDamConfigAnnotationPdfDocumentPaddingHorizontalQuery: QueryParam[Integer], cqDamConfigAnnotationPdfDocumentPaddingVerticalQuery: QueryParam[Integer], cqDamConfigAnnotationPdfFontSizeQuery: QueryParam[Integer], cqDamConfigAnnotationPdfFontColorQuery: QueryParam[String], cqDamConfigAnnotationPdfFontFamilyQuery: QueryParam[String], cqDamConfigAnnotationPdfFontLightQuery: QueryParam[String], cqDamConfigAnnotationPdfMarginTextImageQuery: QueryParam[Integer], cqDamConfigAnnotationPdfMinImageHeightQuery: QueryParam[Integer], cqDamConfigAnnotationPdfReviewStatusWidthQuery: QueryParam[Integer], cqDamConfigAnnotationPdfReviewStatusColorApprovedQuery: QueryParam[String], cqDamConfigAnnotationPdfReviewStatusColorRejectedQuery: QueryParam[String], cqDamConfigAnnotationPdfReviewStatusColorChangesRequestedQuery: QueryParam[String], cqDamConfigAnnotationPdfAnnotationMarkerWidthQuery: QueryParam[Integer], cqDamConfigAnnotationPdfAssetMinheightQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo] = jsonOf[ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.annotation.pdf.AnnotationPdfConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamConfigAnnotationPdfDocumentWidth", Some(cq.dam.config.annotation.pdf.document.widthQuery.toParamString(cq.dam.config.annotation.pdf.document.width))), ("cqDamConfigAnnotationPdfDocumentHeight", Some(cq.dam.config.annotation.pdf.document.heightQuery.toParamString(cq.dam.config.annotation.pdf.document.height))), ("cqDamConfigAnnotationPdfDocumentPaddingHorizontal", Some(cq.dam.config.annotation.pdf.document.padding.horizontalQuery.toParamString(cq.dam.config.annotation.pdf.document.padding.horizontal))), ("cqDamConfigAnnotationPdfDocumentPaddingVertical", Some(cq.dam.config.annotation.pdf.document.padding.verticalQuery.toParamString(cq.dam.config.annotation.pdf.document.padding.vertical))), ("cqDamConfigAnnotationPdfFontSize", Some(cq.dam.config.annotation.pdf.font.sizeQuery.toParamString(cq.dam.config.annotation.pdf.font.size))), ("cqDamConfigAnnotationPdfFontColor", Some(cq.dam.config.annotation.pdf.font.colorQuery.toParamString(cq.dam.config.annotation.pdf.font.color))), ("cqDamConfigAnnotationPdfFontFamily", Some(cq.dam.config.annotation.pdf.font.familyQuery.toParamString(cq.dam.config.annotation.pdf.font.family))), ("cqDamConfigAnnotationPdfFontLight", Some(cq.dam.config.annotation.pdf.font.lightQuery.toParamString(cq.dam.config.annotation.pdf.font.light))), ("cqDamConfigAnnotationPdfMarginTextImage", Some(cq.dam.config.annotation.pdf.marginTextImageQuery.toParamString(cq.dam.config.annotation.pdf.marginTextImage))), ("cqDamConfigAnnotationPdfMinImageHeight", Some(cq.dam.config.annotation.pdf.minImageHeightQuery.toParamString(cq.dam.config.annotation.pdf.minImageHeight))), ("cqDamConfigAnnotationPdfReviewStatusWidth", Some(cq.dam.config.annotation.pdf.reviewStatus.widthQuery.toParamString(cq.dam.config.annotation.pdf.reviewStatus.width))), ("cqDamConfigAnnotationPdfReviewStatusColorApproved", Some(cq.dam.config.annotation.pdf.reviewStatus.color.approvedQuery.toParamString(cq.dam.config.annotation.pdf.reviewStatus.color.approved))), ("cqDamConfigAnnotationPdfReviewStatusColorRejected", Some(cq.dam.config.annotation.pdf.reviewStatus.color.rejectedQuery.toParamString(cq.dam.config.annotation.pdf.reviewStatus.color.rejected))), ("cqDamConfigAnnotationPdfReviewStatusColorChangesRequested", Some(cq.dam.config.annotation.pdf.reviewStatus.color.changesRequestedQuery.toParamString(cq.dam.config.annotation.pdf.reviewStatus.color.changesRequested))), ("cqDamConfigAnnotationPdfAnnotationMarkerWidth", Some(cq.dam.config.annotation.pdf.annotationMarker.widthQuery.toParamString(cq.dam.config.annotation.pdf.annotationMarker.width))), ("cqDamConfigAnnotationPdfAssetMinheight", Some(cq.dam.config.annotation.pdf.asset.minheightQuery.toParamString(cq.dam.config.annotation.pdf.asset.minheight))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplAssetMoveListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplAssetMoveListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplAssetMoveListenerInfo] = jsonOf[ComDayCqDamCoreImplAssetMoveListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.AssetMoveListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplAssetMoveListenerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplAssethomeAssetHomePageConfiguration(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], isEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], isEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo] = jsonOf[ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.assethome.AssetHomePageConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("isEnabled", Some(isEnabledQuery.toParamString(isEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamAdhocAssetSharePrezipMaxcontentsize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamAdhocAssetSharePrezipMaxcontentsizeQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo] = jsonOf[ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.assetlinkshare.AdhocAssetShareProxyServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamAdhocAssetSharePrezipMaxcontentsize", Some(cq.dam.adhoc.asset.share.prezip.maxcontentsizeQuery.toParamString(cq.dam.adhoc.asset.share.prezip.maxcontentsize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplCacheCQBufferedImageCache(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamImageCacheMaxMemory: Integer, cqDamImageCacheMaxAge: Integer, cqDamImageCacheMaxDimension: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamImageCacheMaxMemoryQuery: QueryParam[Integer], cqDamImageCacheMaxAgeQuery: QueryParam[Integer], cqDamImageCacheMaxDimensionQuery: QueryParam[String]): Task[ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo] = jsonOf[ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.cache.CQBufferedImageCache"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamImageCacheMaxMemory", Some(cq.dam.image.cache.max.memoryQuery.toParamString(cq.dam.image.cache.max.memory))), ("cqDamImageCacheMaxAge", Some(cq.dam.image.cache.max.ageQuery.toParamString(cq.dam.image.cache.max.age))), ("cqDamImageCacheMaxDimension", Some(cq.dam.image.cache.max.dimensionQuery.toParamString(cq.dam.image.cache.max.dimension))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplDamChangeEventListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], changeeventlistenerObservedPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], changeeventlistenerObservedPathsQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplDamChangeEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplDamChangeEventListenerInfo] = jsonOf[ComDayCqDamCoreImplDamChangeEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.DamChangeEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("changeeventlistenerObservedPaths", Some(changeeventlistener.observed.pathsQuery.toParamString(changeeventlistener.observed.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplDamChangeEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplDamEventPurgeService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, maxSavedActivities: Integer, saveInterval: Integer, enableActivityPurge: Boolean, eventTypes: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], maxSavedActivitiesQuery: QueryParam[Integer], saveIntervalQuery: QueryParam[Integer], enableActivityPurgeQuery: QueryParam[Boolean], eventTypesQuery: QueryParam[String]): Task[ComDayCqDamCoreImplDamEventPurgeServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplDamEventPurgeServiceInfo] = jsonOf[ComDayCqDamCoreImplDamEventPurgeServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.DamEventPurgeService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("maxSavedActivities", Some(maxSavedActivitiesQuery.toParamString(maxSavedActivities))), ("saveInterval", Some(saveIntervalQuery.toParamString(saveInterval))), ("enableActivityPurge", Some(enableActivityPurgeQuery.toParamString(enableActivityPurge))), ("eventTypes", Some(eventTypesQuery.toParamString(eventTypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplDamEventPurgeServiceInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplDamEventRecorderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String, eventQueueLength: Integer, eventrecorderEnabled: Boolean, eventrecorderBlacklist: List[String], eventrecorderEventtypes: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String], eventQueueLengthQuery: QueryParam[Integer], eventrecorderEnabledQuery: QueryParam[Boolean], eventrecorderBlacklistQuery: QueryParam[List[String]], eventrecorderEventtypesQuery: QueryParam[String]): Task[ComDayCqDamCoreImplDamEventRecorderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplDamEventRecorderImplInfo] = jsonOf[ComDayCqDamCoreImplDamEventRecorderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.DamEventRecorderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("eventQueueLength", Some(event.queue.lengthQuery.toParamString(event.queue.length))), ("eventrecorderEnabled", Some(eventrecorder.enabledQuery.toParamString(eventrecorder.enabled))), ("eventrecorderBlacklist", Some(eventrecorder.blacklistQuery.toParamString(eventrecorder.blacklist))), ("eventrecorderEventtypes", Some(eventrecorder.eventtypesQuery.toParamString(eventrecorder.eventtypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplDamEventRecorderImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplEventDamEventAuditListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String, enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String], enabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplEventDamEventAuditListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplEventDamEventAuditListenerInfo] = jsonOf[ComDayCqDamCoreImplEventDamEventAuditListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.event.DamEventAuditListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplEventDamEventAuditListenerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplExpiryNotificationJobImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamExpiryNotificationSchedulerIstimebased: Boolean, cqDamExpiryNotificationSchedulerTimebasedRule: String, cqDamExpiryNotificationSchedulerPeriodRule: Integer, sendEmail: Boolean, assetExpiredLimit: Integer, priorNotificationSeconds: Integer, cqDamExpiryNotificationUrlProtocol: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamExpiryNotificationSchedulerIstimebasedQuery: QueryParam[Boolean], cqDamExpiryNotificationSchedulerTimebasedRuleQuery: QueryParam[String], cqDamExpiryNotificationSchedulerPeriodRuleQuery: QueryParam[Integer], sendEmailQuery: QueryParam[Boolean], assetExpiredLimitQuery: QueryParam[Integer], priorNotificationSecondsQuery: QueryParam[Integer], cqDamExpiryNotificationUrlProtocolQuery: QueryParam[String]): Task[ComDayCqDamCoreImplExpiryNotificationJobImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplExpiryNotificationJobImplInfo] = jsonOf[ComDayCqDamCoreImplExpiryNotificationJobImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.ExpiryNotificationJobImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamExpiryNotificationSchedulerIstimebased", Some(cq.dam.expiry.notification.scheduler.istimebasedQuery.toParamString(cq.dam.expiry.notification.scheduler.istimebased))), ("cqDamExpiryNotificationSchedulerTimebasedRule", Some(cq.dam.expiry.notification.scheduler.timebased.ruleQuery.toParamString(cq.dam.expiry.notification.scheduler.timebased.rule))), ("cqDamExpiryNotificationSchedulerPeriodRule", Some(cq.dam.expiry.notification.scheduler.period.ruleQuery.toParamString(cq.dam.expiry.notification.scheduler.period.rule))), ("sendEmail", Some(send_emailQuery.toParamString(send_email))), ("assetExpiredLimit", Some(asset_expired_limitQuery.toParamString(asset_expired_limit))), ("priorNotificationSeconds", Some(prior_notification_secondsQuery.toParamString(prior_notification_seconds))), ("cqDamExpiryNotificationUrlProtocol", Some(cq.dam.expiry.notification.url.protocolQuery.toParamString(cq.dam.expiry.notification.url.protocol))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplExpiryNotificationJobImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeat(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], isEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], isEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo] = jsonOf[ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.foldermetadataschema.FolderMetadataSchemaFeatureFlag"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("isEnabled", Some(isEnabledQuery.toParamString(isEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplGfxCommonsGfxRenderer(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], skipBufferedcache: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], skipBufferedcacheQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplGfxCommonsGfxRendererInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplGfxCommonsGfxRendererInfo] = jsonOf[ComDayCqDamCoreImplGfxCommonsGfxRendererInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.gfx.CommonsGfxRenderer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("skipBufferedcache", Some(skip.bufferedcacheQuery.toParamString(skip.bufferedcache))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplGfxCommonsGfxRendererInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplHandlerEPSFormatHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mimetype: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mimetypeQuery: QueryParam[String]): Task[ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo] = jsonOf[ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.handler.EPSFormatHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mimetype", Some(mimetypeQuery.toParamString(mimetype))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplHandlerIndesignFormatHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mimetype: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mimetypeQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo] = jsonOf[ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.handler.IndesignFormatHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mimetype", Some(mimetypeQuery.toParamString(mimetype))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplHandlerJpegHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamEnableExtMetaExtraction: Boolean, largeFileThreshold: Integer, largeCommentThreshold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamEnableExtMetaExtractionQuery: QueryParam[Boolean], largeFileThresholdQuery: QueryParam[Integer], largeCommentThresholdQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplHandlerJpegHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplHandlerJpegHandlerInfo] = jsonOf[ComDayCqDamCoreImplHandlerJpegHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.handler.JpegHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamEnableExtMetaExtraction", Some(cq.dam.enable.ext.meta.extractionQuery.toParamString(cq.dam.enable.ext.meta.extraction))), ("largeFileThreshold", Some(large_file_thresholdQuery.toParamString(large_file_threshold))), ("largeCommentThreshold", Some(large_comment_thresholdQuery.toParamString(large_comment_threshold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplHandlerJpegHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplHandlerXmpNCommXMPHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], xmphandlerCqFormats: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], xmphandlerCqFormatsQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo] = jsonOf[ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.handler.xmp.NCommXMPHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("xmphandlerCqFormats", Some(xmphandler.cq.formatsQuery.toParamString(xmphandler.cq.formats))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplJmxAssetIndexUpdateMonitor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jmxObjectname: String, propertyMeasureEnabled: Boolean, propertyName: String, propertyMaxWaitMs: Integer, propertyMaxRate: BigDecimal, fulltextMeasureEnabled: Boolean, fulltextName: String, fulltextMaxWaitMs: Integer, fulltextMaxRate: BigDecimal)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jmxObjectnameQuery: QueryParam[String], propertyMeasureEnabledQuery: QueryParam[Boolean], propertyNameQuery: QueryParam[String], propertyMaxWaitMsQuery: QueryParam[Integer], propertyMaxRateQuery: QueryParam[BigDecimal], fulltextMeasureEnabledQuery: QueryParam[Boolean], fulltextNameQuery: QueryParam[String], fulltextMaxWaitMsQuery: QueryParam[Integer], fulltextMaxRateQuery: QueryParam[BigDecimal]): Task[ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo] = jsonOf[ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetIndexUpdateMonitor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jmxObjectname", Some(jmx.objectnameQuery.toParamString(jmx.objectname))), ("propertyMeasureEnabled", Some(property.measure.enabledQuery.toParamString(property.measure.enabled))), ("propertyName", Some(property.nameQuery.toParamString(property.name))), ("propertyMaxWaitMs", Some(property.max.wait.msQuery.toParamString(property.max.wait.ms))), ("propertyMaxRate", Some(property.max.rateQuery.toParamString(property.max.rate))), ("fulltextMeasureEnabled", Some(fulltext.measure.enabledQuery.toParamString(fulltext.measure.enabled))), ("fulltextName", Some(fulltext.nameQuery.toParamString(fulltext.name))), ("fulltextMaxWaitMs", Some(fulltext.max.wait.msQuery.toParamString(fulltext.max.wait.ms))), ("fulltextMaxRate", Some(fulltext.max.rateQuery.toParamString(fulltext.max.rate))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplJmxAssetMigrationMBeanImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jmxObjectname: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jmxObjectnameQuery: QueryParam[String]): Task[ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo] = jsonOf[ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetMigrationMBeanImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jmxObjectname", Some(jmx.objectnameQuery.toParamString(jmx.objectname))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplJmxAssetUpdateMonitorImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jmxObjectname: String, active: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jmxObjectnameQuery: QueryParam[String], activeQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo] = jsonOf[ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetUpdateMonitorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jmxObjectname", Some(jmx.objectnameQuery.toParamString(jmx.objectname))), ("active", Some(activeQuery.toParamString(active))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], operation: String, emailEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], operationQuery: QueryParam[String], emailEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo] = jsonOf[ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.jobs.metadataexport.AsyncMetadataExportConfigProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("operation", Some(operationQuery.toParamString(operation))), ("emailEnabled", Some(emailEnabledQuery.toParamString(emailEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], operation: String, operationIcon: String, topicName: String, emailEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], operationQuery: QueryParam[String], operationIconQuery: QueryParam[String], topicNameQuery: QueryParam[String], emailEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo] = jsonOf[ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.jobs.metadataimport.AsyncMetadataImportConfigProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("operation", Some(operationQuery.toParamString(operation))), ("operationIcon", Some(operationIconQuery.toParamString(operationIcon))), ("topicName", Some(topicNameQuery.toParamString(topicName))), ("emailEnabled", Some(emailEnabledQuery.toParamString(emailEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplLightboxLightboxServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletPaths: String, slingServletMethods: List[String], cqDamEnableAnonymous: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletPathsQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[List[String]], cqDamEnableAnonymousQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplLightboxLightboxServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplLightboxLightboxServletInfo] = jsonOf[ComDayCqDamCoreImplLightboxLightboxServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.lightbox.LightboxServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletPaths", Some(sling.servlet.pathsQuery.toParamString(sling.servlet.paths))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))), ("cqDamEnableAnonymous", Some(cq.dam.enable.anonymousQuery.toParamString(cq.dam.enable.anonymous))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplLightboxLightboxServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplMetadataEditorSelectComponentHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], granitedata: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], granitedataQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo] = jsonOf[ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.metadata.editor.SelectComponentHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("granitedata", Some(granite:dataQuery.toParamString(granite:data))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelper(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamAllowAllMime: Boolean, cqDamAllowedAssetMimes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamAllowAllMimeQuery: QueryParam[Boolean], cqDamAllowedAssetMimesQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo] = jsonOf[ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.mimeType.AssetUploadRestrictionHelper"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamAllowAllMime", Some(cq.dam.allow.all.mimeQuery.toParamString(cq.dam.allow.all.mime))), ("cqDamAllowedAssetMimes", Some(cq.dam.allowed.asset.mimesQuery.toParamString(cq.dam.allowed.asset.mimes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplMimeTypeDamMimeTypeServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamDetectAssetMimeFromContent: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamDetectAssetMimeFromContentQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo] = jsonOf[ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.mimeType.DamMimeTypeServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamDetectAssetMimeFromContent", Some(cq.dam.detect.asset.mime.from.contentQuery.toParamString(cq.dam.detect.asset.mime.from.content))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplMissingMetadataNotificationJob(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamMissingmetadataNotificationSchedulerIstimebased: Boolean, cqDamMissingmetadataNotificationSchedulerTimebasedRule: String, cqDamMissingmetadataNotificationSchedulerPeriodRule: Integer, cqDamMissingmetadataNotificationRecipient: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamMissingmetadataNotificationSchedulerIstimebasedQuery: QueryParam[Boolean], cqDamMissingmetadataNotificationSchedulerTimebasedRuleQuery: QueryParam[String], cqDamMissingmetadataNotificationSchedulerPeriodRuleQuery: QueryParam[Integer], cqDamMissingmetadataNotificationRecipientQuery: QueryParam[String]): Task[ComDayCqDamCoreImplMissingMetadataNotificationJobInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplMissingMetadataNotificationJobInfo] = jsonOf[ComDayCqDamCoreImplMissingMetadataNotificationJobInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.MissingMetadataNotificationJob"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamMissingmetadataNotificationSchedulerIstimebased", Some(cq.dam.missingmetadata.notification.scheduler.istimebasedQuery.toParamString(cq.dam.missingmetadata.notification.scheduler.istimebased))), ("cqDamMissingmetadataNotificationSchedulerTimebasedRule", Some(cq.dam.missingmetadata.notification.scheduler.timebased.ruleQuery.toParamString(cq.dam.missingmetadata.notification.scheduler.timebased.rule))), ("cqDamMissingmetadataNotificationSchedulerPeriodRule", Some(cq.dam.missingmetadata.notification.scheduler.period.ruleQuery.toParamString(cq.dam.missingmetadata.notification.scheduler.period.rule))), ("cqDamMissingmetadataNotificationRecipient", Some(cq.dam.missingmetadata.notification.recipientQuery.toParamString(cq.dam.missingmetadata.notification.recipient))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplMissingMetadataNotificationJobInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPr(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String, notifyOnComplete: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String], notifyOnCompleteQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo] = jsonOf[ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.process.SendTransientWorkflowCompletedEmailProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("notifyOnComplete", Some(Notify on CompleteQuery.toParamString(Notify on Complete))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplProcessTextExtractionProcess(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mimeTypes: List[String], maxExtract: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mimeTypesQuery: QueryParam[List[String]], maxExtractQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplProcessTextExtractionProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplProcessTextExtractionProcessInfo] = jsonOf[ComDayCqDamCoreImplProcessTextExtractionProcessInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.process.TextExtractionProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mimeTypes", Some(mimeTypesQuery.toParamString(mimeTypes))), ("maxExtract", Some(maxExtractQuery.toParamString(maxExtract))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplProcessTextExtractionProcessInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplRenditionMakerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], xmpPropagate: Boolean, xmpExcludes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], xmpPropagateQuery: QueryParam[Boolean], xmpExcludesQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplRenditionMakerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplRenditionMakerImplInfo] = jsonOf[ComDayCqDamCoreImplRenditionMakerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.RenditionMakerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("xmpPropagate", Some(xmp.propagateQuery.toParamString(xmp.propagate))), ("xmpExcludes", Some(xmp.excludesQuery.toParamString(xmp.excludes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplRenditionMakerImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplReportsReportExportService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], queryBatchSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], queryBatchSizeQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplReportsReportExportServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplReportsReportExportServiceInfo] = jsonOf[ComDayCqDamCoreImplReportsReportExportServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.reports.ReportExportService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("queryBatchSize", Some(queryBatchSizeQuery.toParamString(queryBatchSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplReportsReportExportServiceInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplReportsReportPurgeService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, maxSavedReports: Integer, timeDuration: Integer, enableReportPurge: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], maxSavedReportsQuery: QueryParam[Integer], timeDurationQuery: QueryParam[Integer], enableReportPurgeQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplReportsReportPurgeServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplReportsReportPurgeServiceInfo] = jsonOf[ComDayCqDamCoreImplReportsReportPurgeServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.reports.ReportPurgeService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("maxSavedReports", Some(maxSavedReportsQuery.toParamString(maxSavedReports))), ("timeDuration", Some(timeDurationQuery.toParamString(timeDuration))), ("enableReportPurge", Some(enableReportPurgeQuery.toParamString(enableReportPurge))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplReportsReportPurgeServiceInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletAssetDownloadServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletAssetDownloadServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletAssetDownloadServletInfo] = jsonOf[ComDayCqDamCoreImplServletAssetDownloadServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetDownloadServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletAssetDownloadServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletAssetStatusServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamBatchStatusMaxassets: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamBatchStatusMaxassetsQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplServletAssetStatusServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletAssetStatusServletInfo] = jsonOf[ComDayCqDamCoreImplServletAssetStatusServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetStatusServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamBatchStatusMaxassets", Some(cq.dam.batch.status.maxassetsQuery.toParamString(cq.dam.batch.status.maxassets))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletAssetStatusServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletAssetXMPSearchServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamBatchIndesignMaxassets: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamBatchIndesignMaxassetsQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplServletAssetXMPSearchServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletAssetXMPSearchServletInfo] = jsonOf[ComDayCqDamCoreImplServletAssetXMPSearchServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetXMPSearchServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamBatchIndesignMaxassets", Some(cq.dam.batch.indesign.maxassetsQuery.toParamString(cq.dam.batch.indesign.maxassets))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletAssetXMPSearchServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletBatchMetadataServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamBatchMetadataAssetDefault: List[String], cqDamBatchMetadataCollectionDefault: List[String], cqDamBatchMetadataMaxresources: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamBatchMetadataAssetDefaultQuery: QueryParam[List[String]], cqDamBatchMetadataCollectionDefaultQuery: QueryParam[List[String]], cqDamBatchMetadataMaxresourcesQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplServletBatchMetadataServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletBatchMetadataServletInfo] = jsonOf[ComDayCqDamCoreImplServletBatchMetadataServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.BatchMetadataServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamBatchMetadataAssetDefault", Some(cq.dam.batch.metadata.asset.defaultQuery.toParamString(cq.dam.batch.metadata.asset.default))), ("cqDamBatchMetadataCollectionDefault", Some(cq.dam.batch.metadata.collection.defaultQuery.toParamString(cq.dam.batch.metadata.collection.default))), ("cqDamBatchMetadataMaxresources", Some(cq.dam.batch.metadata.maxresourcesQuery.toParamString(cq.dam.batch.metadata.maxresources))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletBatchMetadataServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletBinaryProviderServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletResourceTypes: List[String], slingServletMethods: List[String], cqDamDrmEnable: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletResourceTypesQuery: QueryParam[List[String]], slingServletMethodsQuery: QueryParam[List[String]], cqDamDrmEnableQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletBinaryProviderServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletBinaryProviderServletInfo] = jsonOf[ComDayCqDamCoreImplServletBinaryProviderServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.BinaryProviderServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletResourceTypes", Some(sling.servlet.resourceTypesQuery.toParamString(sling.servlet.resourceTypes))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))), ("cqDamDrmEnable", Some(cq.dam.drm.enableQuery.toParamString(cq.dam.drm.enable))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletBinaryProviderServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletCollectionServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamBatchCollectionProperties: List[String], cqDamBatchCollectionMaxcollections: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamBatchCollectionPropertiesQuery: QueryParam[List[String]], cqDamBatchCollectionMaxcollectionsQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplServletCollectionServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletCollectionServletInfo] = jsonOf[ComDayCqDamCoreImplServletCollectionServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CollectionServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamBatchCollectionProperties", Some(cq.dam.batch.collection.propertiesQuery.toParamString(cq.dam.batch.collection.properties))), ("cqDamBatchCollectionMaxcollections", Some(cq.dam.batch.collection.maxcollectionsQuery.toParamString(cq.dam.batch.collection.maxcollections))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletCollectionServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletCollectionsServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamBatchCollectionsProperties: List[String], cqDamBatchCollectionsLimit: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamBatchCollectionsPropertiesQuery: QueryParam[List[String]], cqDamBatchCollectionsLimitQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplServletCollectionsServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletCollectionsServletInfo] = jsonOf[ComDayCqDamCoreImplServletCollectionsServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CollectionsServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamBatchCollectionsProperties", Some(cq.dam.batch.collections.propertiesQuery.toParamString(cq.dam.batch.collections.properties))), ("cqDamBatchCollectionsLimit", Some(cq.dam.batch.collections.limitQuery.toParamString(cq.dam.batch.collections.limit))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletCollectionsServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletCompanionServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], moreInfo: String, mntoverlaydamguicontentassetsmoreinfoHtmlpath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], moreInfoQuery: QueryParam[String], mntoverlaydamguicontentassetsmoreinfoHtmlpathQuery: QueryParam[String]): Task[ComDayCqDamCoreImplServletCompanionServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletCompanionServletInfo] = jsonOf[ComDayCqDamCoreImplServletCompanionServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CompanionServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("moreInfo", Some(More InfoQuery.toParamString(More Info))), ("mntoverlaydamguicontentassetsmoreinfoHtmlpath", Some(/mnt/overlay/dam/gui/content/assets/moreinfo.html/${path}Query.toParamString(/mnt/overlay/dam/gui/content/assets/moreinfo.html/${path}))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletCompanionServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletCreateAssetServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], detectDuplicate: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], detectDuplicateQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletCreateAssetServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletCreateAssetServletInfo] = jsonOf[ComDayCqDamCoreImplServletCreateAssetServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CreateAssetServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("detectDuplicate", Some(detect_duplicateQuery.toParamString(detect_duplicate))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletCreateAssetServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletDamContentDispositionFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqMimeTypeBlacklist: List[String], cqDamEmptyMime: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqMimeTypeBlacklistQuery: QueryParam[List[String]], cqDamEmptyMimeQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletDamContentDispositionFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletDamContentDispositionFilterInfo] = jsonOf[ComDayCqDamCoreImplServletDamContentDispositionFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.DamContentDispositionFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqMimeTypeBlacklist", Some(cq.mime.type.blacklistQuery.toParamString(cq.mime.type.blacklist))), ("cqDamEmptyMime", Some(cq.dam.empty.mimeQuery.toParamString(cq.dam.empty.mime))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletDamContentDispositionFilterInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletGuidLookupFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamCoreGuidlookupfilterEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamCoreGuidlookupfilterEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletGuidLookupFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletGuidLookupFilterInfo] = jsonOf[ComDayCqDamCoreImplServletGuidLookupFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.GuidLookupFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamCoreGuidlookupfilterEnabled", Some(cq.dam.core.guidlookupfilter.enabledQuery.toParamString(cq.dam.core.guidlookupfilter.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletGuidLookupFilterInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletHealthCheckServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamSyncWorkflowId: String, cqDamSyncFolderTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamSyncWorkflowIdQuery: QueryParam[String], cqDamSyncFolderTypesQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplServletHealthCheckServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletHealthCheckServletInfo] = jsonOf[ComDayCqDamCoreImplServletHealthCheckServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.HealthCheckServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamSyncWorkflowId", Some(cq.dam.sync.workflow.idQuery.toParamString(cq.dam.sync.workflow.id))), ("cqDamSyncFolderTypes", Some(cq.dam.sync.folder.typesQuery.toParamString(cq.dam.sync.folder.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletHealthCheckServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletMetadataGetServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletResourceTypes: String, slingServletMethods: String, slingServletExtensions: String, slingServletSelectors: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletResourceTypesQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[String], slingServletExtensionsQuery: QueryParam[String], slingServletSelectorsQuery: QueryParam[String]): Task[ComDayCqDamCoreImplServletMetadataGetServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletMetadataGetServletInfo] = jsonOf[ComDayCqDamCoreImplServletMetadataGetServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.MetadataGetServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletResourceTypes", Some(sling.servlet.resourceTypesQuery.toParamString(sling.servlet.resourceTypes))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))), ("slingServletExtensions", Some(sling.servlet.extensionsQuery.toParamString(sling.servlet.extensions))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletMetadataGetServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletMultipleLicenseAcceptServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamDrmEnable: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamDrmEnableQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo] = jsonOf[ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.MultipleLicenseAcceptServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamDrmEnable", Some(cq.dam.drm.enableQuery.toParamString(cq.dam.drm.enable))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletResourceCollectionServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletResourceTypes: List[String], slingServletMethods: String, slingServletSelectors: String, downloadConfig: String, viewSelector: String, sendEmail: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletResourceTypesQuery: QueryParam[List[String]], slingServletMethodsQuery: QueryParam[String], slingServletSelectorsQuery: QueryParam[String], downloadConfigQuery: QueryParam[String], viewSelectorQuery: QueryParam[String], sendEmailQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletResourceCollectionServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletResourceCollectionServletInfo] = jsonOf[ComDayCqDamCoreImplServletResourceCollectionServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.ResourceCollectionServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletResourceTypes", Some(sling.servlet.resourceTypesQuery.toParamString(sling.servlet.resourceTypes))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("downloadConfig", Some(download.configQuery.toParamString(download.config))), ("viewSelector", Some(view.selectorQuery.toParamString(view.selector))), ("sendEmail", Some(send_emailQuery.toParamString(send_email))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletResourceCollectionServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], createPreviewEnabled: Boolean, updatePreviewEnabled: Boolean, queueSize: Integer, folderPreviewRenditionRegex: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], createPreviewEnabledQuery: QueryParam[Boolean], updatePreviewEnabledQuery: QueryParam[Boolean], queueSizeQuery: QueryParam[Integer], folderPreviewRenditionRegexQuery: QueryParam[String]): Task[ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo] = jsonOf[ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.ui.preview.FolderPreviewUpdaterImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("createPreviewEnabled", Some(createPreviewEnabledQuery.toParamString(createPreviewEnabled))), ("updatePreviewEnabled", Some(updatePreviewEnabledQuery.toParamString(updatePreviewEnabled))), ("queueSize", Some(queueSizeQuery.toParamString(queueSize))), ("folderPreviewRenditionRegex", Some(folderPreviewRenditionRegexQuery.toParamString(folderPreviewRenditionRegex))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplUnzipUnzipConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamConfigUnzipMaxuncompressedsize: Integer, cqDamConfigUnzipEncoding: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamConfigUnzipMaxuncompressedsizeQuery: QueryParam[Integer], cqDamConfigUnzipEncodingQuery: QueryParam[String]): Task[ComDayCqDamCoreImplUnzipUnzipConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplUnzipUnzipConfigInfo] = jsonOf[ComDayCqDamCoreImplUnzipUnzipConfigInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.unzip.UnzipConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamConfigUnzipMaxuncompressedsize", Some(cq.dam.config.unzip.maxuncompressedsizeQuery.toParamString(cq.dam.config.unzip.maxuncompressedsize))), ("cqDamConfigUnzipEncoding", Some(cq.dam.config.unzip.encodingQuery.toParamString(cq.dam.config.unzip.encoding))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplUnzipUnzipConfigInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreProcessExifToolExtractMetadataProcess(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String, cqDamEnableSha1: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String], cqDamEnableSha1Query: QueryParam[Boolean]): Task[ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo] = jsonOf[ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.process.ExifToolExtractMetadataProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("cqDamEnableSha1", Some(cq.dam.enable.sha1Query.toParamString(cq.dam.enable.sha1))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreProcessExtractMetadataProcess(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String, cqDamEnableSha1: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String], cqDamEnableSha1Query: QueryParam[Boolean]): Task[ComDayCqDamCoreProcessExtractMetadataProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreProcessExtractMetadataProcessInfo] = jsonOf[ComDayCqDamCoreProcessExtractMetadataProcessInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.process.ExtractMetadataProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("cqDamEnableSha1", Some(cq.dam.enable.sha1Query.toParamString(cq.dam.enable.sha1))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreProcessExtractMetadataProcessInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreProcessMetadataProcessorProcess(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String, cqDamEnableSha1: Boolean, cqDamMetadataXssprotectedProperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String], cqDamEnableSha1Query: QueryParam[Boolean], cqDamMetadataXssprotectedPropertiesQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreProcessMetadataProcessorProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreProcessMetadataProcessorProcessInfo] = jsonOf[ComDayCqDamCoreProcessMetadataProcessorProcessInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.process.MetadataProcessorProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("cqDamEnableSha1", Some(cq.dam.enable.sha1Query.toParamString(cq.dam.enable.sha1))), ("cqDamMetadataXssprotectedProperties", Some(cq.dam.metadata.xssprotected.propertiesQuery.toParamString(cq.dam.metadata.xssprotected.properties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreProcessMetadataProcessorProcessInfo](req)

    } yield resp
  }
  
  def comDayCqDamHandlerFfmpegLocatorImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], executableSearchpath: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], executableSearchpathQuery: QueryParam[List[String]]): Task[ComDayCqDamHandlerFfmpegLocatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamHandlerFfmpegLocatorImplInfo] = jsonOf[ComDayCqDamHandlerFfmpegLocatorImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.handler.ffmpeg.LocatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("executableSearchpath", Some(executable.searchpathQuery.toParamString(executable.searchpath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamHandlerFfmpegLocatorImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String, fontmgrSystemFontDir: List[String], fontmgrAdobeFontDir: String, fontmgrCustomerFontDir: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String], fontmgrSystemFontDirQuery: QueryParam[List[String]], fontmgrAdobeFontDirQuery: QueryParam[String], fontmgrCustomerFontDirQuery: QueryParam[String]): Task[ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo] = jsonOf[ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.handler.gibson.fontmanager.impl.FontManagerServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("fontmgrSystemFontDir", Some(fontmgr.system.font.dirQuery.toParamString(fontmgr.system.font.dir))), ("fontmgrAdobeFontDir", Some(fontmgr.adobe.font.dirQuery.toParamString(fontmgr.adobe.font.dir))), ("fontmgrCustomerFontDir", Some(fontmgr.customer.font.dirQuery.toParamString(fontmgr.customer.font.dir))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamHandlerStandardPdfPdfHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], rasterAnnotation: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], rasterAnnotationQuery: QueryParam[Boolean]): Task[ComDayCqDamHandlerStandardPdfPdfHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamHandlerStandardPdfPdfHandlerInfo] = jsonOf[ComDayCqDamHandlerStandardPdfPdfHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.handler.standard.pdf.PdfHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("rasterAnnotation", Some(raster.annotationQuery.toParamString(raster.annotation))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamHandlerStandardPdfPdfHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamHandlerStandardPsPostScriptHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], rasterAnnotation: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], rasterAnnotationQuery: QueryParam[Boolean]): Task[ComDayCqDamHandlerStandardPsPostScriptHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamHandlerStandardPsPostScriptHandlerInfo] = jsonOf[ComDayCqDamHandlerStandardPsPostScriptHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.handler.standard.ps.PostScriptHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("rasterAnnotation", Some(raster.annotationQuery.toParamString(raster.annotation))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamHandlerStandardPsPostScriptHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamHandlerStandardPsdPsdHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], largeFileThreshold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], largeFileThresholdQuery: QueryParam[Integer]): Task[ComDayCqDamHandlerStandardPsdPsdHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamHandlerStandardPsdPsdHandlerInfo] = jsonOf[ComDayCqDamHandlerStandardPsdPsdHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.handler.standard.psd.PsdHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("largeFileThreshold", Some(large_file_thresholdQuery.toParamString(large_file_threshold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamHandlerStandardPsdPsdHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamIdsImplIDSJobProcessor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enableMultisession: Boolean, idsCcEnable: Boolean, enableRetry: Boolean, enableRetryScripterror: Boolean, externalizerDomainCqhost: String, externalizerDomainHttp: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableMultisessionQuery: QueryParam[Boolean], idsCcEnableQuery: QueryParam[Boolean], enableRetryQuery: QueryParam[Boolean], enableRetryScripterrorQuery: QueryParam[Boolean], externalizerDomainCqhostQuery: QueryParam[String], externalizerDomainHttpQuery: QueryParam[String]): Task[ComDayCqDamIdsImplIDSJobProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamIdsImplIDSJobProcessorInfo] = jsonOf[ComDayCqDamIdsImplIDSJobProcessorInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.ids.impl.IDSJobProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enableMultisession", Some(enable.multisessionQuery.toParamString(enable.multisession))), ("idsCcEnable", Some(ids.cc.enableQuery.toParamString(ids.cc.enable))), ("enableRetry", Some(enable.retryQuery.toParamString(enable.retry))), ("enableRetryScripterror", Some(enable.retry.scripterrorQuery.toParamString(enable.retry.scripterror))), ("externalizerDomainCqhost", Some(externalizer.domain.cqhostQuery.toParamString(externalizer.domain.cqhost))), ("externalizerDomainHttp", Some(externalizer.domain.httpQuery.toParamString(externalizer.domain.http))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamIdsImplIDSJobProcessorInfo](req)

    } yield resp
  }
  
  def comDayCqDamIdsImplIDSPoolManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxErrorsToBlacklist: Integer, retryIntervalToWhitelist: Integer, connectTimeout: Integer, socketTimeout: Integer, processLabel: String, connectionUseMax: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxErrorsToBlacklistQuery: QueryParam[Integer], retryIntervalToWhitelistQuery: QueryParam[Integer], connectTimeoutQuery: QueryParam[Integer], socketTimeoutQuery: QueryParam[Integer], processLabelQuery: QueryParam[String], connectionUseMaxQuery: QueryParam[Integer]): Task[ComDayCqDamIdsImplIDSPoolManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamIdsImplIDSPoolManagerImplInfo] = jsonOf[ComDayCqDamIdsImplIDSPoolManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.ids.impl.IDSPoolManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxErrorsToBlacklist", Some(max.errors.to.blacklistQuery.toParamString(max.errors.to.blacklist))), ("retryIntervalToWhitelist", Some(retry.interval.to.whitelistQuery.toParamString(retry.interval.to.whitelist))), ("connectTimeout", Some(connect.timeoutQuery.toParamString(connect.timeout))), ("socketTimeout", Some(socket.timeoutQuery.toParamString(socket.timeout))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("connectionUseMax", Some(connection.use.maxQuery.toParamString(connection.use.max))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamIdsImplIDSPoolManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamInddImplHandlerIndesignXMPHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String, extractPages: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String], extractPagesQuery: QueryParam[Boolean]): Task[ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo] = jsonOf[ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.indd.impl.handler.IndesignXMPHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("extractPages", Some(extract.pagesQuery.toParamString(extract.pages))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamInddImplServletSnippetCreationServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], snippetcreationMaxcollections: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], snippetcreationMaxcollectionsQuery: QueryParam[Integer]): Task[ComDayCqDamInddImplServletSnippetCreationServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamInddImplServletSnippetCreationServletInfo] = jsonOf[ComDayCqDamInddImplServletSnippetCreationServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.indd.impl.servlet.SnippetCreationServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("snippetcreationMaxcollections", Some(snippetcreation.maxcollectionsQuery.toParamString(snippetcreation.maxcollections))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamInddImplServletSnippetCreationServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamInddProcessINDDMediaExtractProcess(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String, cqDamInddPagesRegex: String, idsJobDecoupled: Boolean, idsJobWorkflowModel: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String], cqDamInddPagesRegexQuery: QueryParam[String], idsJobDecoupledQuery: QueryParam[Boolean], idsJobWorkflowModelQuery: QueryParam[String]): Task[ComDayCqDamInddProcessINDDMediaExtractProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamInddProcessINDDMediaExtractProcessInfo] = jsonOf[ComDayCqDamInddProcessINDDMediaExtractProcessInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.indd.process.INDDMediaExtractProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("cqDamInddPagesRegex", Some(cq.dam.indd.pages.regexQuery.toParamString(cq.dam.indd.pages.regex))), ("idsJobDecoupled", Some(ids.job.decoupledQuery.toParamString(ids.job.decoupled))), ("idsJobWorkflowModel", Some(ids.job.workflow.modelQuery.toParamString(ids.job.workflow.model))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamInddProcessINDDMediaExtractProcessInfo](req)

    } yield resp
  }
  
  def comDayCqDamPerformanceInternalAssetPerformanceDataHandlerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], batchCommitSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], batchCommitSizeQuery: QueryParam[Integer]): Task[ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo] = jsonOf[ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.performance.internal.AssetPerformanceDataHandlerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("batchCommitSize", Some(batch.commit.sizeQuery.toParamString(batch.commit.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamPerformanceInternalAssetPerformanceReportSyncJob(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String]): Task[ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo] = jsonOf[ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.performance.internal.AssetPerformanceReportSyncJob"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo](req)

    } yield resp
  }
  
  def comDayCqDamPimImplSourcingUploadProcessProductAssetsUploadPro(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], deleteZipFile: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], deleteZipFileQuery: QueryParam[Boolean]): Task[ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo] = jsonOf[ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.pim.impl.sourcing.upload.process.ProductAssetsUploadProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("deleteZipFile", Some(delete.zip.fileQuery.toParamString(delete.zip.file))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEven(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamS7damDynamicmediaconfigeventlistenerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamS7damDynamicmediaconfigeventlistenerEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo] = jsonOf[ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.analytics.impl.S7damDynamicMediaConfigEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamS7damDynamicmediaconfigeventlistenerEnabled", Some(cq.dam.s7dam.dynamicmediaconfigeventlistener.enabledQuery.toParamString(cq.dam.s7dam.dynamicmediaconfigeventlistener.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunner(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, schedulerConcurrent: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], schedulerConcurrentQuery: QueryParam[Boolean]): Task[ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo] = jsonOf[ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.analytics.impl.SiteCatalystReportRunner"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("schedulerConcurrent", Some(scheduler.concurrentQuery.toParamString(scheduler.concurrent))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonPostServletsSetCreateHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingPostOperation: String, slingServletMethods: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingPostOperationQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[String]): Task[ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo] = jsonOf[ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.post.servlets.SetCreateHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingPostOperation", Some(sling.post.operationQuery.toParamString(sling.post.operation))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonPostServletsSetModifyHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingPostOperation: String, slingServletMethods: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingPostOperationQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[String]): Task[ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo] = jsonOf[ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.post.servlets.SetModifyHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingPostOperation", Some(sling.post.operationQuery.toParamString(sling.post.operation))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonProcessVideoThumbnailDownloadProcess(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String]): Task[ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo] = jsonOf[ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.process.VideoThumbnailDownloadProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonS7damDamChangeEventListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamS7damDamchangeeventlistenerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamS7damDamchangeeventlistenerEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo] = jsonOf[ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.S7damDamChangeEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamS7damDamchangeeventlistenerEnabled", Some(cq.dam.s7dam.damchangeeventlistener.enabledQuery.toParamString(cq.dam.s7dam.damchangeeventlistener.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonServletsS7damProductInfoServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletPaths: String, slingServletMethods: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletPathsQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[String]): Task[ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo] = jsonOf[ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.servlets.S7damProductInfoServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletPaths", Some(sling.servlet.pathsQuery.toParamString(sling.servlet.paths))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonVideoImplVideoProxyClientServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeName: Integer, cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeName: Integer, cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadName: Integer, cqDamS7damVideoproxyclientserviceHttpReadtimeoutName: Integer, cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutName: Integer, cqDamS7damVideoproxyclientserviceHttpMaxretrycountName: Integer, cqDamS7damVideoproxyclientserviceUploadprogressIntervalName: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeNameQuery: QueryParam[Integer], cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeNameQuery: QueryParam[Integer], cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadNameQuery: QueryParam[Integer], cqDamS7damVideoproxyclientserviceHttpReadtimeoutNameQuery: QueryParam[Integer], cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutNameQuery: QueryParam[Integer], cqDamS7damVideoproxyclientserviceHttpMaxretrycountNameQuery: QueryParam[Integer], cqDamS7damVideoproxyclientserviceUploadprogressIntervalNameQuery: QueryParam[Integer]): Task[ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo] = jsonOf[ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.video.impl.VideoProxyClientServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeName", Some(cq.dam.s7dam.videoproxyclientservice.multipartupload.minsize.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.multipartupload.minsize.name))), ("cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeName", Some(cq.dam.s7dam.videoproxyclientservice.multipartupload.partsize.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.multipartupload.partsize.name))), ("cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadName", Some(cq.dam.s7dam.videoproxyclientservice.multipartupload.numthread.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.multipartupload.numthread.name))), ("cqDamS7damVideoproxyclientserviceHttpReadtimeoutName", Some(cq.dam.s7dam.videoproxyclientservice.http.readtimeout.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.http.readtimeout.name))), ("cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutName", Some(cq.dam.s7dam.videoproxyclientservice.http.connectiontimeout.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.http.connectiontimeout.name))), ("cqDamS7damVideoproxyclientserviceHttpMaxretrycountName", Some(cq.dam.s7dam.videoproxyclientservice.http.maxretrycount.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.http.maxretrycount.name))), ("cqDamS7damVideoproxyclientserviceUploadprogressIntervalName", Some(cq.dam.s7dam.videoproxyclientservice.uploadprogress.interval.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.uploadprogress.interval.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamScene7ImplScene7APIClientImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamScene7ApiclientRecordsperpageNofilterName: Integer, cqDamScene7ApiclientRecordsperpageWithfilterName: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamScene7ApiclientRecordsperpageNofilterNameQuery: QueryParam[Integer], cqDamScene7ApiclientRecordsperpageWithfilterNameQuery: QueryParam[Integer]): Task[ComDayCqDamScene7ImplScene7APIClientImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamScene7ImplScene7APIClientImplInfo] = jsonOf[ComDayCqDamScene7ImplScene7APIClientImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7APIClientImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamScene7ApiclientRecordsperpageNofilterName", Some(cq.dam.scene7.apiclient.recordsperpage.nofilter.nameQuery.toParamString(cq.dam.scene7.apiclient.recordsperpage.nofilter.name))), ("cqDamScene7ApiclientRecordsperpageWithfilterName", Some(cq.dam.scene7.apiclient.recordsperpage.withfilter.nameQuery.toParamString(cq.dam.scene7.apiclient.recordsperpage.withfilter.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamScene7ImplScene7APIClientImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamScene7ImplScene7AssetMimeTypeServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamScene7AssetmimetypeserviceMapping: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamScene7AssetmimetypeserviceMappingQuery: QueryParam[List[String]]): Task[ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo] = jsonOf[ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7AssetMimeTypeServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamScene7AssetmimetypeserviceMapping", Some(cq.dam.scene7.assetmimetypeservice.mappingQuery.toParamString(cq.dam.scene7.assetmimetypeservice.mapping))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamScene7ImplScene7ConfigurationEventListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamScene7ConfigurationeventlistenerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamScene7ConfigurationeventlistenerEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo] = jsonOf[ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7ConfigurationEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamScene7ConfigurationeventlistenerEnabled", Some(cq.dam.scene7.configurationeventlistener.enabledQuery.toParamString(cq.dam.scene7.configurationeventlistener.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqDamScene7ImplScene7DamChangeEventListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamScene7DamchangeeventlistenerEnabled: Boolean, cqDamScene7DamchangeeventlistenerObservedPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamScene7DamchangeeventlistenerEnabledQuery: QueryParam[Boolean], cqDamScene7DamchangeeventlistenerObservedPathsQuery: QueryParam[List[String]]): Task[ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo] = jsonOf[ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7DamChangeEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamScene7DamchangeeventlistenerEnabled", Some(cq.dam.scene7.damchangeeventlistener.enabledQuery.toParamString(cq.dam.scene7.damchangeeventlistener.enabled))), ("cqDamScene7DamchangeeventlistenerObservedPaths", Some(cq.dam.scene7.damchangeeventlistener.observed.pathsQuery.toParamString(cq.dam.scene7.damchangeeventlistener.observed.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqDamScene7ImplScene7FlashTemplatesServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], scene7FlashTemplatesRti: String, scene7FlashTemplatesRsi: String, scene7FlashTemplatesRb: String, scene7FlashTemplatesRurl: String, scene7FlashTemplateUrlFormatParameter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], scene7FlashTemplatesRtiQuery: QueryParam[String], scene7FlashTemplatesRsiQuery: QueryParam[String], scene7FlashTemplatesRbQuery: QueryParam[String], scene7FlashTemplatesRurlQuery: QueryParam[String], scene7FlashTemplateUrlFormatParameterQuery: QueryParam[String]): Task[ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo] = jsonOf[ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7FlashTemplatesServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("scene7FlashTemplatesRti", Some(scene7FlashTemplates.rtiQuery.toParamString(scene7FlashTemplates.rti))), ("scene7FlashTemplatesRsi", Some(scene7FlashTemplates.rsiQuery.toParamString(scene7FlashTemplates.rsi))), ("scene7FlashTemplatesRb", Some(scene7FlashTemplates.rbQuery.toParamString(scene7FlashTemplates.rb))), ("scene7FlashTemplatesRurl", Some(scene7FlashTemplates.rurlQuery.toParamString(scene7FlashTemplates.rurl))), ("scene7FlashTemplateUrlFormatParameter", Some(scene7FlashTemplate.urlFormatParameterQuery.toParamString(scene7FlashTemplate.urlFormatParameter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamScene7ImplScene7UploadServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamScene7UploadserviceActivejobtimeoutLabel: Integer, cqDamScene7UploadserviceConnectionmaxperrouteLabel: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamScene7UploadserviceActivejobtimeoutLabelQuery: QueryParam[Integer], cqDamScene7UploadserviceConnectionmaxperrouteLabelQuery: QueryParam[Integer]): Task[ComDayCqDamScene7ImplScene7UploadServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamScene7ImplScene7UploadServiceImplInfo] = jsonOf[ComDayCqDamScene7ImplScene7UploadServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7UploadServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamScene7UploadserviceActivejobtimeoutLabel", Some(cq.dam.scene7.uploadservice.activejobtimeout.labelQuery.toParamString(cq.dam.scene7.uploadservice.activejobtimeout.label))), ("cqDamScene7UploadserviceConnectionmaxperrouteLabel", Some(cq.dam.scene7.uploadservice.connectionmaxperroute.labelQuery.toParamString(cq.dam.scene7.uploadservice.connectionmaxperroute.label))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamScene7ImplScene7UploadServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamStockIntegrationImplCacheStockCacheConfigurationSer(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], getCacheExpirationUnit: String, getCacheExpirationValue: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], getCacheExpirationUnitQuery: QueryParam[String], getCacheExpirationValueQuery: QueryParam[Integer]): Task[ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo] = jsonOf[ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.stock.integration.impl.cache.StockCacheConfigurationServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("getCacheExpirationUnit", Some(getCacheExpirationUnitQuery.toParamString(getCacheExpirationUnit))), ("getCacheExpirationValue", Some(getCacheExpirationValueQuery.toParamString(getCacheExpirationValue))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo](req)

    } yield resp
  }
  
  def comDayCqDamStockIntegrationImplConfigurationStockConfiguration(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, locale: String, imsConfig: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], localeQuery: QueryParam[String], imsConfigQuery: QueryParam[String]): Task[ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo] = jsonOf[ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.stock.integration.impl.configuration.StockConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("locale", Some(localeQuery.toParamString(locale))), ("imsConfig", Some(imsConfigQuery.toParamString(imsConfig))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo](req)

    } yield resp
  }
  
  def comDayCqDamVideoImplServletVideoTestServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[ComDayCqDamVideoImplServletVideoTestServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamVideoImplServletVideoTestServletInfo] = jsonOf[ComDayCqDamVideoImplServletVideoTestServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.video.impl.servlet.VideoTestServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamVideoImplServletVideoTestServletInfo](req)

    } yield resp
  }
  
  def comDayCqExtwidgetServletsImageSpriteServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxWidth: Integer, maxHeight: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxWidthQuery: QueryParam[Integer], maxHeightQuery: QueryParam[Integer]): Task[ComDayCqExtwidgetServletsImageSpriteServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqExtwidgetServletsImageSpriteServletInfo] = jsonOf[ComDayCqExtwidgetServletsImageSpriteServletInfo]

    val path = "/system/console/configMgr/com.day.cq.extwidget.servlets.ImageSpriteServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxWidth", Some(maxWidthQuery.toParamString(maxWidth))), ("maxHeight", Some(maxHeightQuery.toParamString(maxHeight))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqExtwidgetServletsImageSpriteServletInfo](req)

    } yield resp
  }
  
  def comDayCqImageInternalFontFontHelper(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fontpath: List[String], oversamplingFactor: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fontpathQuery: QueryParam[List[String]], oversamplingFactorQuery: QueryParam[Integer]): Task[ComDayCqImageInternalFontFontHelperInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqImageInternalFontFontHelperInfo] = jsonOf[ComDayCqImageInternalFontFontHelperInfo]

    val path = "/system/console/configMgr/com.day.cq.image.internal.font.FontHelper"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fontpath", Some(fontpathQuery.toParamString(fontpath))), ("oversamplingFactor", Some(oversamplingFactorQuery.toParamString(oversamplingFactor))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqImageInternalFontFontHelperInfo](req)

    } yield resp
  }
  
  def comDayCqJcrclustersupportClusterStartLevelController(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], clusterLevelEnable: Boolean, clusterMasterLevel: Integer, clusterSlaveLevel: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], clusterLevelEnableQuery: QueryParam[Boolean], clusterMasterLevelQuery: QueryParam[Integer], clusterSlaveLevelQuery: QueryParam[Integer]): Task[ComDayCqJcrclustersupportClusterStartLevelControllerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqJcrclustersupportClusterStartLevelControllerInfo] = jsonOf[ComDayCqJcrclustersupportClusterStartLevelControllerInfo]

    val path = "/system/console/configMgr/com.day.cq.jcrclustersupport.ClusterStartLevelController"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("clusterLevelEnable", Some(cluster.level.enableQuery.toParamString(cluster.level.enable))), ("clusterMasterLevel", Some(cluster.master.levelQuery.toParamString(cluster.master.level))), ("clusterSlaveLevel", Some(cluster.slave.levelQuery.toParamString(cluster.slave.level))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqJcrclustersupportClusterStartLevelControllerInfo](req)

    } yield resp
  }
  
  def comDayCqMailerDefaultMailService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], smtpHost: String, smtpPort: Integer, smtpUser: String, smtpPassword: String, fromAddress: String, smtpSsl: Boolean, smtpStarttls: Boolean, debugEmail: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], smtpHostQuery: QueryParam[String], smtpPortQuery: QueryParam[Integer], smtpUserQuery: QueryParam[String], smtpPasswordQuery: QueryParam[String], fromAddressQuery: QueryParam[String], smtpSslQuery: QueryParam[Boolean], smtpStarttlsQuery: QueryParam[Boolean], debugEmailQuery: QueryParam[Boolean]): Task[ComDayCqMailerDefaultMailServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMailerDefaultMailServiceInfo] = jsonOf[ComDayCqMailerDefaultMailServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.mailer.DefaultMailService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("smtpHost", Some(smtp.hostQuery.toParamString(smtp.host))), ("smtpPort", Some(smtp.portQuery.toParamString(smtp.port))), ("smtpUser", Some(smtp.userQuery.toParamString(smtp.user))), ("smtpPassword", Some(smtp.passwordQuery.toParamString(smtp.password))), ("fromAddress", Some(from.addressQuery.toParamString(from.address))), ("smtpSsl", Some(smtp.sslQuery.toParamString(smtp.ssl))), ("smtpStarttls", Some(smtp.starttlsQuery.toParamString(smtp.starttls))), ("debugEmail", Some(debug.emailQuery.toParamString(debug.email))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMailerDefaultMailServiceInfo](req)

    } yield resp
  }
  
  def comDayCqMailerImplCqMailingService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxRecipientCount: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxRecipientCountQuery: QueryParam[String]): Task[ComDayCqMailerImplCqMailingServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMailerImplCqMailingServiceInfo] = jsonOf[ComDayCqMailerImplCqMailingServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.mailer.impl.CqMailingService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxRecipientCount", Some(max.recipient.countQuery.toParamString(max.recipient.count))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMailerImplCqMailingServiceInfo](req)

    } yield resp
  }
  
  def comDayCqMailerImplEmailCqEmailTemplateFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mailerEmailCharset: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mailerEmailCharsetQuery: QueryParam[String]): Task[ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo] = jsonOf[ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.mailer.impl.email.CqEmailTemplateFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mailerEmailCharset", Some(mailer.email.charsetQuery.toParamString(mailer.email.charset))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqMailerImplEmailCqRetrieverTemplateFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mailerEmailEmbed: Boolean, mailerEmailCharset: String, mailerEmailRetrieverUserID: String, mailerEmailRetrieverUserPWD: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mailerEmailEmbedQuery: QueryParam[Boolean], mailerEmailCharsetQuery: QueryParam[String], mailerEmailRetrieverUserIDQuery: QueryParam[String], mailerEmailRetrieverUserPWDQuery: QueryParam[String]): Task[ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo] = jsonOf[ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.mailer.impl.email.CqRetrieverTemplateFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mailerEmailEmbed", Some(mailer.email.embedQuery.toParamString(mailer.email.embed))), ("mailerEmailCharset", Some(mailer.email.charsetQuery.toParamString(mailer.email.charset))), ("mailerEmailRetrieverUserID", Some(mailer.email.retrieverUserIDQuery.toParamString(mailer.email.retrieverUserID))), ("mailerEmailRetrieverUserPWD", Some(mailer.email.retrieverUserPWDQuery.toParamString(mailer.email.retrieverUserPWD))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqMcmCampaignImplIntegrationConfigImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], aemMcmCampaignFormConstraints: List[String], aemMcmCampaignPublicUrl: String, aemMcmCampaignRelaxedSSL: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], aemMcmCampaignFormConstraintsQuery: QueryParam[List[String]], aemMcmCampaignPublicUrlQuery: QueryParam[String], aemMcmCampaignRelaxedSSLQuery: QueryParam[Boolean]): Task[ComDayCqMcmCampaignImplIntegrationConfigImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmCampaignImplIntegrationConfigImplInfo] = jsonOf[ComDayCqMcmCampaignImplIntegrationConfigImplInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.campaign.impl.IntegrationConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("aemMcmCampaignFormConstraints", Some(aem.mcm.campaign.formConstraintsQuery.toParamString(aem.mcm.campaign.formConstraints))), ("aemMcmCampaignPublicUrl", Some(aem.mcm.campaign.publicUrlQuery.toParamString(aem.mcm.campaign.publicUrl))), ("aemMcmCampaignRelaxedSSL", Some(aem.mcm.campaign.relaxedSSLQuery.toParamString(aem.mcm.campaign.relaxedSSL))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmCampaignImplIntegrationConfigImplInfo](req)

    } yield resp
  }
  
  def comDayCqMcmCampaignImporterPersonalizedTextHandlerFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo] = jsonOf[ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.campaign.importer.PersonalizedTextHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqMcmCoreNewsletterNewsletterEmailServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fromAddress: String, senderHost: String, maxBounceCount: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fromAddressQuery: QueryParam[String], senderHostQuery: QueryParam[String], maxBounceCountQuery: QueryParam[String]): Task[ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo] = jsonOf[ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.core.newsletter.NewsletterEmailServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fromAddress", Some(from.addressQuery.toParamString(from.address))), ("senderHost", Some(sender.hostQuery.toParamString(sender.host))), ("maxBounceCount", Some(max.bounce.countQuery.toParamString(max.bounce.count))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqMcmImplMCMConfiguration(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], experienceIndirection: List[String], touchpointIndirection: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], experienceIndirectionQuery: QueryParam[List[String]], touchpointIndirectionQuery: QueryParam[List[String]]): Task[ComDayCqMcmImplMCMConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmImplMCMConfigurationInfo] = jsonOf[ComDayCqMcmImplMCMConfigurationInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.impl.MCMConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("experienceIndirection", Some(experience.indirectionQuery.toParamString(experience.indirection))), ("touchpointIndirection", Some(touchpoint.indirectionQuery.toParamString(touchpoint.indirection))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmImplMCMConfigurationInfo](req)

    } yield resp
  }
  
  def comDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponen(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo] = jsonOf[ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.ClickThroughComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo](req)

    } yield resp
  }
  
  def comDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThroug(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo] = jsonOf[ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.GraphicalClickThroughComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo](req)

    } yield resp
  }
  
  def comDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponent(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo] = jsonOf[ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.LeadFormCTAComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo](req)

    } yield resp
  }
  
  def comDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHa(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo] = jsonOf[ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.mbox.MBoxExperienceTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo](req)

    } yield resp
  }
  
  def comDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagH(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo] = jsonOf[ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.mbox.TargetComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo](req)

    } yield resp
  }
  
  def comDayCqNotificationImplNotificationServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String]): Task[ComDayCqNotificationImplNotificationServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqNotificationImplNotificationServiceImplInfo] = jsonOf[ComDayCqNotificationImplNotificationServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.notification.impl.NotificationServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqNotificationImplNotificationServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqPersonalizationImplServletsTargetingConfigurationServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], forcelocation: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], forcelocationQuery: QueryParam[Boolean]): Task[ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo] = jsonOf[ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo]

    val path = "/system/console/configMgr/com.day.cq.personalization.impl.servlets.TargetingConfigurationServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("forcelocation", Some(forcelocationQuery.toParamString(forcelocation))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo](req)

    } yield resp
  }
  
  def comDayCqPollingImporterImplManagedPollConfigImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], id: String, enabled: Boolean, reference: Boolean, interval: Integer, expression: String, source: String, target: String, login: String, password: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], idQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], referenceQuery: QueryParam[Boolean], intervalQuery: QueryParam[Integer], expressionQuery: QueryParam[String], sourceQuery: QueryParam[String], targetQuery: QueryParam[String], loginQuery: QueryParam[String], passwordQuery: QueryParam[String]): Task[ComDayCqPollingImporterImplManagedPollConfigImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqPollingImporterImplManagedPollConfigImplInfo] = jsonOf[ComDayCqPollingImporterImplManagedPollConfigImplInfo]

    val path = "/system/console/configMgr/com.day.cq.polling.importer.impl.ManagedPollConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("id", Some(idQuery.toParamString(id))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("reference", Some(referenceQuery.toParamString(reference))), ("interval", Some(intervalQuery.toParamString(interval))), ("expression", Some(expressionQuery.toParamString(expression))), ("source", Some(sourceQuery.toParamString(source))), ("target", Some(targetQuery.toParamString(target))), ("login", Some(loginQuery.toParamString(login))), ("password", Some(passwordQuery.toParamString(password))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqPollingImporterImplManagedPollConfigImplInfo](req)

    } yield resp
  }
  
  def comDayCqPollingImporterImplManagedPollingImporterImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], importerUser: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], importerUserQuery: QueryParam[String]): Task[ComDayCqPollingImporterImplManagedPollingImporterImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqPollingImporterImplManagedPollingImporterImplInfo] = jsonOf[ComDayCqPollingImporterImplManagedPollingImporterImplInfo]

    val path = "/system/console/configMgr/com.day.cq.polling.importer.impl.ManagedPollingImporterImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("importerUser", Some(importer.userQuery.toParamString(importer.user))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqPollingImporterImplManagedPollingImporterImplInfo](req)

    } yield resp
  }
  
  def comDayCqPollingImporterImplPollingImporterImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], importerMinInterval: Integer, importerUser: String, excludePaths: List[String], includePaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], importerMinIntervalQuery: QueryParam[Integer], importerUserQuery: QueryParam[String], excludePathsQuery: QueryParam[List[String]], includePathsQuery: QueryParam[List[String]]): Task[ComDayCqPollingImporterImplPollingImporterImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqPollingImporterImplPollingImporterImplInfo] = jsonOf[ComDayCqPollingImporterImplPollingImporterImplInfo]

    val path = "/system/console/configMgr/com.day.cq.polling.importer.impl.PollingImporterImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("importerMinInterval", Some(importer.min.intervalQuery.toParamString(importer.min.interval))), ("importerUser", Some(importer.userQuery.toParamString(importer.user))), ("excludePaths", Some(exclude.pathsQuery.toParamString(exclude.paths))), ("includePaths", Some(include.pathsQuery.toParamString(include.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqPollingImporterImplPollingImporterImplInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationAuditReplicationEventListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer]): Task[ComDayCqReplicationAuditReplicationEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationAuditReplicationEventListenerInfo] = jsonOf[ComDayCqReplicationAuditReplicationEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.audit.ReplicationEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationAuditReplicationEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationContentStaticContentBuilder(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], host: String, port: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hostQuery: QueryParam[String], portQuery: QueryParam[Integer]): Task[ComDayCqReplicationContentStaticContentBuilderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationContentStaticContentBuilderInfo] = jsonOf[ComDayCqReplicationContentStaticContentBuilderInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.content.StaticContentBuilder"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("host", Some(hostQuery.toParamString(host))), ("port", Some(portQuery.toParamString(port))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationContentStaticContentBuilderInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplAgentManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jobTopics: String, serviceUserTarget: String, agentProviderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jobTopicsQuery: QueryParam[String], serviceUserTargetQuery: QueryParam[String], agentProviderTargetQuery: QueryParam[String]): Task[ComDayCqReplicationImplAgentManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplAgentManagerImplInfo] = jsonOf[ComDayCqReplicationImplAgentManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.AgentManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jobTopics", Some(job.topicsQuery.toParamString(job.topics))), ("serviceUserTarget", Some(serviceUser.targetQuery.toParamString(serviceUser.target))), ("agentProviderTarget", Some(agentProvider.targetQuery.toParamString(agentProvider.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplAgentManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplContentDurboBinaryLessContentBuilder(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], binaryThreshold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], binaryThresholdQuery: QueryParam[Integer]): Task[ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo] = jsonOf[ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.content.durbo.BinaryLessContentBuilder"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("binaryThreshold", Some(binary.thresholdQuery.toParamString(binary.threshold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplContentDurboDurboImportConfigurationProv(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], preserveHierarchyNodes: Boolean, ignoreVersioning: Boolean, importAcl: Boolean, saveThreshold: Integer, preserveUserPaths: Boolean, preserveUuid: Boolean, preserveUuidNodetypes: List[String], preserveUuidSubtrees: List[String], autoCommit: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], preserveHierarchyNodesQuery: QueryParam[Boolean], ignoreVersioningQuery: QueryParam[Boolean], importAclQuery: QueryParam[Boolean], saveThresholdQuery: QueryParam[Integer], preserveUserPathsQuery: QueryParam[Boolean], preserveUuidQuery: QueryParam[Boolean], preserveUuidNodetypesQuery: QueryParam[List[String]], preserveUuidSubtreesQuery: QueryParam[List[String]], autoCommitQuery: QueryParam[Boolean]): Task[ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo] = jsonOf[ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.content.durbo.DurboImportConfigurationProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("preserveHierarchyNodes", Some(preserve.hierarchy.nodesQuery.toParamString(preserve.hierarchy.nodes))), ("ignoreVersioning", Some(ignore.versioningQuery.toParamString(ignore.versioning))), ("importAcl", Some(import.aclQuery.toParamString(import.acl))), ("saveThreshold", Some(save.thresholdQuery.toParamString(save.threshold))), ("preserveUserPaths", Some(preserve.user.pathsQuery.toParamString(preserve.user.paths))), ("preserveUuid", Some(preserve.uuidQuery.toParamString(preserve.uuid))), ("preserveUuidNodetypes", Some(preserve.uuid.nodetypesQuery.toParamString(preserve.uuid.nodetypes))), ("preserveUuidSubtrees", Some(preserve.uuid.subtreesQuery.toParamString(preserve.uuid.subtrees))), ("autoCommit", Some(auto.commitQuery.toParamString(auto.commit))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplReplicationContentFactoryProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], replicationContentUseFileStorage: Boolean, replicationContentMaxCommitAttempts: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], replicationContentUseFileStorageQuery: QueryParam[Boolean], replicationContentMaxCommitAttemptsQuery: QueryParam[Integer]): Task[ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo] = jsonOf[ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.ReplicationContentFactoryProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("replicationContentUseFileStorage", Some(replication.content.useFileStorageQuery.toParamString(replication.content.useFileStorage))), ("replicationContentMaxCommitAttempts", Some(replication.content.maxCommitAttemptsQuery.toParamString(replication.content.maxCommitAttempts))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplReplicationReceiverImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], receiverTmpfileThreshold: Integer, receiverPackagesUseInstall: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], receiverTmpfileThresholdQuery: QueryParam[Integer], receiverPackagesUseInstallQuery: QueryParam[Boolean]): Task[ComDayCqReplicationImplReplicationReceiverImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplReplicationReceiverImplInfo] = jsonOf[ComDayCqReplicationImplReplicationReceiverImplInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.ReplicationReceiverImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("receiverTmpfileThreshold", Some(receiver.tmpfile.thresholdQuery.toParamString(receiver.tmpfile.threshold))), ("receiverPackagesUseInstall", Some(receiver.packages.use.installQuery.toParamString(receiver.packages.use.install))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplReplicationReceiverImplInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplReplicatorImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], distributeEvents: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], distributeEventsQuery: QueryParam[Boolean]): Task[ComDayCqReplicationImplReplicatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplReplicatorImplInfo] = jsonOf[ComDayCqReplicationImplReplicatorImplInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.ReplicatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("distributeEvents", Some(distribute_eventsQuery.toParamString(distribute_events))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplReplicatorImplInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplReverseReplicator(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerPeriod: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerPeriodQuery: QueryParam[Integer]): Task[ComDayCqReplicationImplReverseReplicatorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplReverseReplicatorInfo] = jsonOf[ComDayCqReplicationImplReverseReplicatorInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.ReverseReplicator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerPeriod", Some(scheduler.periodQuery.toParamString(scheduler.period))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplReverseReplicatorInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplTransportBinaryLessTransportHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], disabledCipherSuites: List[String], enabledCipherSuites: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], disabledCipherSuitesQuery: QueryParam[List[String]], enabledCipherSuitesQuery: QueryParam[List[String]]): Task[ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo] = jsonOf[ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.transport.BinaryLessTransportHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("disabledCipherSuites", Some(disabled.cipher.suitesQuery.toParamString(disabled.cipher.suites))), ("enabledCipherSuites", Some(enabled.cipher.suitesQuery.toParamString(enabled.cipher.suites))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplTransportHttp(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], disabledCipherSuites: List[String], enabledCipherSuites: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], disabledCipherSuitesQuery: QueryParam[List[String]], enabledCipherSuitesQuery: QueryParam[List[String]]): Task[ComDayCqReplicationImplTransportHttpInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplTransportHttpInfo] = jsonOf[ComDayCqReplicationImplTransportHttpInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.transport.Http"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("disabledCipherSuites", Some(disabled.cipher.suitesQuery.toParamString(disabled.cipher.suites))), ("enabledCipherSuites", Some(enabled.cipher.suitesQuery.toParamString(enabled.cipher.suites))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplTransportHttpInfo](req)

    } yield resp
  }
  
  def comDayCqReportingImplCacheCacheImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], repcacheEnable: Boolean, repcacheTtl: Integer, repcacheMax: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], repcacheEnableQuery: QueryParam[Boolean], repcacheTtlQuery: QueryParam[Integer], repcacheMaxQuery: QueryParam[Integer]): Task[ComDayCqReportingImplCacheCacheImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReportingImplCacheCacheImplInfo] = jsonOf[ComDayCqReportingImplCacheCacheImplInfo]

    val path = "/system/console/configMgr/com.day.cq.reporting.impl.cache.CacheImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("repcacheEnable", Some(repcache.enableQuery.toParamString(repcache.enable))), ("repcacheTtl", Some(repcache.ttlQuery.toParamString(repcache.ttl))), ("repcacheMax", Some(repcache.maxQuery.toParamString(repcache.max))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReportingImplCacheCacheImplInfo](req)

    } yield resp
  }
  
  def comDayCqReportingImplConfigServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], repconfTimezone: String, repconfLocale: String, repconfSnapshots: String, repconfRepdir: String, repconfHourofday: Integer, repconfMinofhour: Integer, repconfMaxrows: Integer, repconfFakedata: Boolean, repconfSnapshotuser: String, repconfEnforcesnapshotuser: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], repconfTimezoneQuery: QueryParam[String], repconfLocaleQuery: QueryParam[String], repconfSnapshotsQuery: QueryParam[String], repconfRepdirQuery: QueryParam[String], repconfHourofdayQuery: QueryParam[Integer], repconfMinofhourQuery: QueryParam[Integer], repconfMaxrowsQuery: QueryParam[Integer], repconfFakedataQuery: QueryParam[Boolean], repconfSnapshotuserQuery: QueryParam[String], repconfEnforcesnapshotuserQuery: QueryParam[Boolean]): Task[ComDayCqReportingImplConfigServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReportingImplConfigServiceImplInfo] = jsonOf[ComDayCqReportingImplConfigServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.reporting.impl.ConfigServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("repconfTimezone", Some(repconf.timezoneQuery.toParamString(repconf.timezone))), ("repconfLocale", Some(repconf.localeQuery.toParamString(repconf.locale))), ("repconfSnapshots", Some(repconf.snapshotsQuery.toParamString(repconf.snapshots))), ("repconfRepdir", Some(repconf.repdirQuery.toParamString(repconf.repdir))), ("repconfHourofday", Some(repconf.hourofdayQuery.toParamString(repconf.hourofday))), ("repconfMinofhour", Some(repconf.minofhourQuery.toParamString(repconf.minofhour))), ("repconfMaxrows", Some(repconf.maxrowsQuery.toParamString(repconf.maxrows))), ("repconfFakedata", Some(repconf.fakedataQuery.toParamString(repconf.fakedata))), ("repconfSnapshotuser", Some(repconf.snapshotuserQuery.toParamString(repconf.snapshotuser))), ("repconfEnforcesnapshotuser", Some(repconf.enforcesnapshotuserQuery.toParamString(repconf.enforcesnapshotuser))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReportingImplConfigServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqReportingImplRLogAnalyzer(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], requestLogOutput: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], requestLogOutputQuery: QueryParam[String]): Task[ComDayCqReportingImplRLogAnalyzerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReportingImplRLogAnalyzerInfo] = jsonOf[ComDayCqReportingImplRLogAnalyzerInfo]

    val path = "/system/console/configMgr/com.day.cq.reporting.impl.RLogAnalyzer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("requestLogOutput", Some(request.log.outputQuery.toParamString(request.log.output))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReportingImplRLogAnalyzerInfo](req)

    } yield resp
  }
  
  def comDayCqRewriterLinkcheckerImplLinkCheckerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerPeriod: Integer, schedulerConcurrent: Boolean, serviceBadLinkToleranceInterval: Integer, serviceCheckOverridePatterns: List[String], serviceCacheBrokenInternalLinks: Boolean, serviceSpecialLinkPrefix: List[String], serviceSpecialLinkPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerPeriodQuery: QueryParam[Integer], schedulerConcurrentQuery: QueryParam[Boolean], serviceBadLinkToleranceIntervalQuery: QueryParam[Integer], serviceCheckOverridePatternsQuery: QueryParam[List[String]], serviceCacheBrokenInternalLinksQuery: QueryParam[Boolean], serviceSpecialLinkPrefixQuery: QueryParam[List[String]], serviceSpecialLinkPatternsQuery: QueryParam[List[String]]): Task[ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo] = jsonOf[ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerPeriod", Some(scheduler.periodQuery.toParamString(scheduler.period))), ("schedulerConcurrent", Some(scheduler.concurrentQuery.toParamString(scheduler.concurrent))), ("serviceBadLinkToleranceInterval", Some(service.bad_link_tolerance_intervalQuery.toParamString(service.bad_link_tolerance_interval))), ("serviceCheckOverridePatterns", Some(service.check_override_patternsQuery.toParamString(service.check_override_patterns))), ("serviceCacheBrokenInternalLinks", Some(service.cache_broken_internal_linksQuery.toParamString(service.cache_broken_internal_links))), ("serviceSpecialLinkPrefix", Some(service.special_link_prefixQuery.toParamString(service.special_link_prefix))), ("serviceSpecialLinkPatterns", Some(service.special_link_patternsQuery.toParamString(service.special_link_patterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo](req)

    } yield resp
  }
  
  def comDayCqRewriterLinkcheckerImplLinkCheckerTask(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerPeriod: Integer, schedulerConcurrent: Boolean, goodLinkTestInterval: Integer, badLinkTestInterval: Integer, linkUnusedInterval: Integer, connectionTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerPeriodQuery: QueryParam[Integer], schedulerConcurrentQuery: QueryParam[Boolean], goodLinkTestIntervalQuery: QueryParam[Integer], badLinkTestIntervalQuery: QueryParam[Integer], linkUnusedIntervalQuery: QueryParam[Integer], connectionTimeoutQuery: QueryParam[Integer]): Task[ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo] = jsonOf[ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo]

    val path = "/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerPeriod", Some(scheduler.periodQuery.toParamString(scheduler.period))), ("schedulerConcurrent", Some(scheduler.concurrentQuery.toParamString(scheduler.concurrent))), ("goodLinkTestInterval", Some(good_link_test_intervalQuery.toParamString(good_link_test_interval))), ("badLinkTestInterval", Some(bad_link_test_intervalQuery.toParamString(bad_link_test_interval))), ("linkUnusedInterval", Some(link_unused_intervalQuery.toParamString(link_unused_interval))), ("connectionTimeout", Some(connection.timeoutQuery.toParamString(connection.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo](req)

    } yield resp
  }
  
  def comDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], linkcheckertransformerDisableRewriting: Boolean, linkcheckertransformerDisableChecking: Boolean, linkcheckertransformerMapCacheSize: Integer, linkcheckertransformerStrictExtensionCheck: Boolean, linkcheckertransformerStripHtmltExtension: Boolean, linkcheckertransformerRewriteElements: List[String], linkcheckertransformerStripExtensionPathBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], linkcheckertransformerDisableRewritingQuery: QueryParam[Boolean], linkcheckertransformerDisableCheckingQuery: QueryParam[Boolean], linkcheckertransformerMapCacheSizeQuery: QueryParam[Integer], linkcheckertransformerStrictExtensionCheckQuery: QueryParam[Boolean], linkcheckertransformerStripHtmltExtensionQuery: QueryParam[Boolean], linkcheckertransformerRewriteElementsQuery: QueryParam[List[String]], linkcheckertransformerStripExtensionPathBlacklistQuery: QueryParam[List[String]]): Task[ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo] = jsonOf[ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerTransformerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("linkcheckertransformerDisableRewriting", Some(linkcheckertransformer.disableRewritingQuery.toParamString(linkcheckertransformer.disableRewriting))), ("linkcheckertransformerDisableChecking", Some(linkcheckertransformer.disableCheckingQuery.toParamString(linkcheckertransformer.disableChecking))), ("linkcheckertransformerMapCacheSize", Some(linkcheckertransformer.mapCacheSizeQuery.toParamString(linkcheckertransformer.mapCacheSize))), ("linkcheckertransformerStrictExtensionCheck", Some(linkcheckertransformer.strictExtensionCheckQuery.toParamString(linkcheckertransformer.strictExtensionCheck))), ("linkcheckertransformerStripHtmltExtension", Some(linkcheckertransformer.stripHtmltExtensionQuery.toParamString(linkcheckertransformer.stripHtmltExtension))), ("linkcheckertransformerRewriteElements", Some(linkcheckertransformer.rewriteElementsQuery.toParamString(linkcheckertransformer.rewriteElements))), ("linkcheckertransformerStripExtensionPathBlacklist", Some(linkcheckertransformer.stripExtensionPathBlacklistQuery.toParamString(linkcheckertransformer.stripExtensionPathBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqRewriterLinkcheckerImplLinkInfoStorageImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceMaxLinksPerHost: Integer, serviceSaveExternalLinkReferences: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceMaxLinksPerHostQuery: QueryParam[Integer], serviceSaveExternalLinkReferencesQuery: QueryParam[Boolean]): Task[ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo] = jsonOf[ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo]

    val path = "/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkInfoStorageImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceMaxLinksPerHost", Some(service.max_links_per_hostQuery.toParamString(service.max_links_per_host))), ("serviceSaveExternalLinkReferences", Some(service.save_external_link_referencesQuery.toParamString(service.save_external_link_references))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo](req)

    } yield resp
  }
  
  def comDayCqRewriterProcessorImplHtmlParserFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], htmlparserProcessTags: List[String], htmlparserPreserveCamelCase: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], htmlparserProcessTagsQuery: QueryParam[List[String]], htmlparserPreserveCamelCaseQuery: QueryParam[Boolean]): Task[ComDayCqRewriterProcessorImplHtmlParserFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqRewriterProcessorImplHtmlParserFactoryInfo] = jsonOf[ComDayCqRewriterProcessorImplHtmlParserFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.rewriter.processor.impl.HtmlParserFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("htmlparserProcessTags", Some(htmlparser.processTagsQuery.toParamString(htmlparser.processTags))), ("htmlparserPreserveCamelCase", Some(htmlparser.preserveCamelCaseQuery.toParamString(htmlparser.preserveCamelCase))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqRewriterProcessorImplHtmlParserFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqSearchImplBuilderQueryBuilderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], excerptProperties: List[String], cacheMaxEntries: Integer, cacheEntryLifetime: Integer, xpathUnion: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], excerptPropertiesQuery: QueryParam[List[String]], cacheMaxEntriesQuery: QueryParam[Integer], cacheEntryLifetimeQuery: QueryParam[Integer], xpathUnionQuery: QueryParam[Boolean]): Task[ComDayCqSearchImplBuilderQueryBuilderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqSearchImplBuilderQueryBuilderImplInfo] = jsonOf[ComDayCqSearchImplBuilderQueryBuilderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.search.impl.builder.QueryBuilderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("excerptProperties", Some(excerpt.propertiesQuery.toParamString(excerpt.properties))), ("cacheMaxEntries", Some(cache.max.entriesQuery.toParamString(cache.max.entries))), ("cacheEntryLifetime", Some(cache.entry.lifetimeQuery.toParamString(cache.entry.lifetime))), ("xpathUnion", Some(xpath.unionQuery.toParamString(xpath.union))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqSearchImplBuilderQueryBuilderImplInfo](req)

    } yield resp
  }
  
  def comDayCqSearchSuggestImplSuggestionIndexManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pathBuilderTarget: String, suggestBasepath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pathBuilderTargetQuery: QueryParam[String], suggestBasepathQuery: QueryParam[String]): Task[ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo] = jsonOf[ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.search.suggest.impl.SuggestionIndexManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pathBuilderTarget", Some(pathBuilder.targetQuery.toParamString(pathBuilder.target))), ("suggestBasepath", Some(suggest.basepathQuery.toParamString(suggest.basepath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqSearchpromoteImplPublishSearchPromoteConfigHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqSearchpromoteConfighandlerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqSearchpromoteConfighandlerEnabledQuery: QueryParam[Boolean]): Task[ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo] = jsonOf[ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.searchpromote.impl.PublishSearchPromoteConfigHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqSearchpromoteConfighandlerEnabled", Some(cq.searchpromote.confighandler.enabledQuery.toParamString(cq.searchpromote.confighandler.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqSearchpromoteImplSearchPromoteServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqSearchpromoteConfigurationServerUri: String, cqSearchpromoteConfigurationEnvironment: String, connectionTimeout: Integer, socketTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqSearchpromoteConfigurationServerUriQuery: QueryParam[String], cqSearchpromoteConfigurationEnvironmentQuery: QueryParam[String], connectionTimeoutQuery: QueryParam[Integer], socketTimeoutQuery: QueryParam[Integer]): Task[ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo] = jsonOf[ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.searchpromote.impl.SearchPromoteServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqSearchpromoteConfigurationServerUri", Some(cq.searchpromote.configuration.server.uriQuery.toParamString(cq.searchpromote.configuration.server.uri))), ("cqSearchpromoteConfigurationEnvironment", Some(cq.searchpromote.configuration.environmentQuery.toParamString(cq.searchpromote.configuration.environment))), ("connectionTimeout", Some(connection.timeoutQuery.toParamString(connection.timeout))), ("socketTimeout", Some(socket.timeoutQuery.toParamString(socket.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqSecurityACLSetup(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAclsetupRules: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAclsetupRulesQuery: QueryParam[List[String]]): Task[ComDayCqSecurityACLSetupInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqSecurityACLSetupInfo] = jsonOf[ComDayCqSecurityACLSetupInfo]

    val path = "/system/console/configMgr/com.day.cq.security.ACLSetup"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAclsetupRules", Some(cq.aclsetup.rulesQuery.toParamString(cq.aclsetup.rules))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqSecurityACLSetupInfo](req)

    } yield resp
  }
  
  def comDayCqStatisticsImplStatisticsServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerPeriod: Integer, schedulerConcurrent: Boolean, `path`: String, workspace: String, keywordsPath: String, asyncEntries: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerPeriodQuery: QueryParam[Integer], schedulerConcurrentQuery: QueryParam[Boolean], `path`Query: QueryParam[String], workspaceQuery: QueryParam[String], keywordsPathQuery: QueryParam[String], asyncEntriesQuery: QueryParam[Boolean]): Task[ComDayCqStatisticsImplStatisticsServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqStatisticsImplStatisticsServiceImplInfo] = jsonOf[ComDayCqStatisticsImplStatisticsServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.statistics.impl.StatisticsServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerPeriod", Some(scheduler.periodQuery.toParamString(scheduler.period))), ("schedulerConcurrent", Some(scheduler.concurrentQuery.toParamString(scheduler.concurrent))), ("`path`", Some(pathQuery.toParamString(path))), ("workspace", Some(workspaceQuery.toParamString(workspace))), ("keywordsPath", Some(keywordsPathQuery.toParamString(keywordsPath))), ("asyncEntries", Some(asyncEntriesQuery.toParamString(asyncEntries))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqStatisticsImplStatisticsServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqTaggingImplJcrTagManagerFactoryImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], validationEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], validationEnabledQuery: QueryParam[Boolean]): Task[ComDayCqTaggingImplJcrTagManagerFactoryImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqTaggingImplJcrTagManagerFactoryImplInfo] = jsonOf[ComDayCqTaggingImplJcrTagManagerFactoryImplInfo]

    val path = "/system/console/configMgr/com.day.cq.tagging.impl.JcrTagManagerFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("validationEnabled", Some(validation.enabledQuery.toParamString(validation.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqTaggingImplJcrTagManagerFactoryImplInfo](req)

    } yield resp
  }
  
  def comDayCqTaggingImplSearchTagPredicateEvaluator(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], ignorePath: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], ignorePathQuery: QueryParam[Boolean]): Task[ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo] = jsonOf[ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo]

    val path = "/system/console/configMgr/com.day.cq.tagging.impl.search.TagPredicateEvaluator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("ignorePath", Some(ignore_pathQuery.toParamString(ignore_path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo](req)

    } yield resp
  }
  
  def comDayCqTaggingImplTagGarbageCollector(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String]): Task[ComDayCqTaggingImplTagGarbageCollectorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqTaggingImplTagGarbageCollectorInfo] = jsonOf[ComDayCqTaggingImplTagGarbageCollectorInfo]

    val path = "/system/console/configMgr/com.day.cq.tagging.impl.TagGarbageCollector"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqTaggingImplTagGarbageCollectorInfo](req)

    } yield resp
  }
  
  def comDayCqWcmContentsyncImplHandlerPagesUpdateHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqPagesupdatehandlerImageresourcetypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqPagesupdatehandlerImageresourcetypesQuery: QueryParam[List[String]]): Task[ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo] = jsonOf[ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.contentsync.impl.handler.PagesUpdateHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqPagesupdatehandlerImageresourcetypes", Some(cq.pagesupdatehandler.imageresourcetypesQuery.toParamString(cq.pagesupdatehandler.imageresourcetypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqContentsyncPathrewritertransformerMappingLinks: List[String], cqContentsyncPathrewritertransformerMappingClientlibs: List[String], cqContentsyncPathrewritertransformerMappingImages: List[String], cqContentsyncPathrewritertransformerAttributePattern: String, cqContentsyncPathrewritertransformerClientlibraryPattern: String, cqContentsyncPathrewritertransformerClientlibraryReplace: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqContentsyncPathrewritertransformerMappingLinksQuery: QueryParam[List[String]], cqContentsyncPathrewritertransformerMappingClientlibsQuery: QueryParam[List[String]], cqContentsyncPathrewritertransformerMappingImagesQuery: QueryParam[List[String]], cqContentsyncPathrewritertransformerAttributePatternQuery: QueryParam[String], cqContentsyncPathrewritertransformerClientlibraryPatternQuery: QueryParam[String], cqContentsyncPathrewritertransformerClientlibraryReplaceQuery: QueryParam[String]): Task[ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo] = jsonOf[ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.contentsync.impl.rewriter.PathRewriterTransformerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqContentsyncPathrewritertransformerMappingLinks", Some(cq.contentsync.pathrewritertransformer.mapping.linksQuery.toParamString(cq.contentsync.pathrewritertransformer.mapping.links))), ("cqContentsyncPathrewritertransformerMappingClientlibs", Some(cq.contentsync.pathrewritertransformer.mapping.clientlibsQuery.toParamString(cq.contentsync.pathrewritertransformer.mapping.clientlibs))), ("cqContentsyncPathrewritertransformerMappingImages", Some(cq.contentsync.pathrewritertransformer.mapping.imagesQuery.toParamString(cq.contentsync.pathrewritertransformer.mapping.images))), ("cqContentsyncPathrewritertransformerAttributePattern", Some(cq.contentsync.pathrewritertransformer.attribute.patternQuery.toParamString(cq.contentsync.pathrewritertransformer.attribute.pattern))), ("cqContentsyncPathrewritertransformerClientlibraryPattern", Some(cq.contentsync.pathrewritertransformer.clientlibrary.patternQuery.toParamString(cq.contentsync.pathrewritertransformer.clientlibrary.pattern))), ("cqContentsyncPathrewritertransformerClientlibraryReplace", Some(cq.contentsync.pathrewritertransformer.clientlibrary.replaceQuery.toParamString(cq.contentsync.pathrewritertransformer.clientlibrary.replace))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplAuthoringUIModeServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], authoringUIModeServiceDefault: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], authoringUIModeServiceDefaultQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo] = jsonOf[ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.AuthoringUIModeServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("authoringUIModeServiceDefault", Some(authoringUIModeService.defaultQuery.toParamString(authoringUIModeService.default))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplCommandsWCMCommandServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], wcmcommandservletDeleteWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], wcmcommandservletDeleteWhitelistQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplCommandsWCMCommandServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplCommandsWCMCommandServletInfo] = jsonOf[ComDayCqWcmCoreImplCommandsWCMCommandServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.commands.WCMCommandServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("wcmcommandservletDeleteWhitelist", Some(wcmcommandservlet.delete_whitelistQuery.toParamString(wcmcommandservlet.delete_whitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplCommandsWCMCommandServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], dimDefaultMode: String, dimAppcacheEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], dimDefaultModeQuery: QueryParam[String], dimAppcacheEnabledQuery: QueryParam[Boolean]): Task[ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo] = jsonOf[ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.devicedetection.DeviceIdentificationModeImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("dimDefaultMode", Some(dim.default.modeQuery.toParamString(dim.default.mode))), ("dimAppcacheEnabled", Some(dim.appcache.enabledQuery.toParamString(dim.appcache.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplEventPageEventAuditListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], configured: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], configuredQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplEventPageEventAuditListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplEventPageEventAuditListenerInfo] = jsonOf[ComDayCqWcmCoreImplEventPageEventAuditListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.event.PageEventAuditListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("configured", Some(configuredQuery.toParamString(configured))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplEventPageEventAuditListenerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplEventPagePostProcessor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], paths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pathsQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplEventPagePostProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplEventPagePostProcessorInfo] = jsonOf[ComDayCqWcmCoreImplEventPagePostProcessorInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.event.PagePostProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("paths", Some(pathsQuery.toParamString(paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplEventPagePostProcessorInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplEventRepositoryChangeEventListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], paths: List[String], excludedPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pathsQuery: QueryParam[List[String]], excludedPathsQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo] = jsonOf[ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.event.RepositoryChangeEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("paths", Some(pathsQuery.toParamString(paths))), ("excludedPaths", Some(excludedPathsQuery.toParamString(excludedPaths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplEventTemplatePostProcessor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], paths: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pathsQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplEventTemplatePostProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplEventTemplatePostProcessorInfo] = jsonOf[ComDayCqWcmCoreImplEventTemplatePostProcessorInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.event.TemplatePostProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("paths", Some(pathsQuery.toParamString(paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplEventTemplatePostProcessorInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplLanguageManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], langmgrListPath: String, langmgrCountryDefault: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], langmgrListPathQuery: QueryParam[String], langmgrCountryDefaultQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplLanguageManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplLanguageManagerImplInfo] = jsonOf[ComDayCqWcmCoreImplLanguageManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.LanguageManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("langmgrListPath", Some(langmgr.list.pathQuery.toParamString(langmgr.list.path))), ("langmgrCountryDefault", Some(langmgr.country.defaultQuery.toParamString(langmgr.country.default))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplLanguageManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplLinkCheckerConfigurationFactoryImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], linkExpiredPrefix: String, linkExpiredRemove: Boolean, linkExpiredSuffix: String, linkInvalidPrefix: String, linkInvalidRemove: Boolean, linkInvalidSuffix: String, linkPredatedPrefix: String, linkPredatedRemove: Boolean, linkPredatedSuffix: String, linkWcmmodes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], linkExpiredPrefixQuery: QueryParam[String], linkExpiredRemoveQuery: QueryParam[Boolean], linkExpiredSuffixQuery: QueryParam[String], linkInvalidPrefixQuery: QueryParam[String], linkInvalidRemoveQuery: QueryParam[Boolean], linkInvalidSuffixQuery: QueryParam[String], linkPredatedPrefixQuery: QueryParam[String], linkPredatedRemoveQuery: QueryParam[Boolean], linkPredatedSuffixQuery: QueryParam[String], linkWcmmodesQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo] = jsonOf[ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.LinkCheckerConfigurationFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("linkExpiredPrefix", Some(link.expired.prefixQuery.toParamString(link.expired.prefix))), ("linkExpiredRemove", Some(link.expired.removeQuery.toParamString(link.expired.remove))), ("linkExpiredSuffix", Some(link.expired.suffixQuery.toParamString(link.expired.suffix))), ("linkInvalidPrefix", Some(link.invalid.prefixQuery.toParamString(link.invalid.prefix))), ("linkInvalidRemove", Some(link.invalid.removeQuery.toParamString(link.invalid.remove))), ("linkInvalidSuffix", Some(link.invalid.suffixQuery.toParamString(link.invalid.suffix))), ("linkPredatedPrefix", Some(link.predated.prefixQuery.toParamString(link.predated.prefix))), ("linkPredatedRemove", Some(link.predated.removeQuery.toParamString(link.predated.remove))), ("linkPredatedSuffix", Some(link.predated.suffixQuery.toParamString(link.predated.suffix))), ("linkWcmmodes", Some(link.wcmmodesQuery.toParamString(link.wcmmodes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplPagePageInfoAggregatorImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pageInfoProviderPropertyRegexDefault: String, pageInfoProviderPropertyName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pageInfoProviderPropertyRegexDefaultQuery: QueryParam[String], pageInfoProviderPropertyNameQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo] = jsonOf[ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.page.PageInfoAggregatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pageInfoProviderPropertyRegexDefault", Some(page.info.provider.property.regex.defaultQuery.toParamString(page.info.provider.property.regex.default))), ("pageInfoProviderPropertyName", Some(page.info.provider.property.nameQuery.toParamString(page.info.provider.property.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplPagePageManagerFactoryImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], illegalCharMapping: String, pageSubTreeActivationCheck: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], illegalCharMappingQuery: QueryParam[String], pageSubTreeActivationCheckQuery: QueryParam[Boolean]): Task[ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo] = jsonOf[ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.page.PageManagerFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("illegalCharMapping", Some(illegalCharMappingQuery.toParamString(illegalCharMapping))), ("pageSubTreeActivationCheck", Some(pageSubTreeActivationCheckQuery.toParamString(pageSubTreeActivationCheck))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplReferencesContentContentReferenceConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], contentReferenceConfigResourceTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], contentReferenceConfigResourceTypesQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo] = jsonOf[ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.references.content.ContentReferenceConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("contentReferenceConfigResourceTypes", Some(contentReferenceConfig.resourceTypesQuery.toParamString(contentReferenceConfig.resourceTypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplServletsContentfinderAssetViewHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], damShowexpired: Boolean, damShowhidden: Boolean, tagTitleSearch: Boolean, guessTotal: String, damExpiryProperty: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], damShowexpiredQuery: QueryParam[Boolean], damShowhiddenQuery: QueryParam[Boolean], tagTitleSearchQuery: QueryParam[Boolean], guessTotalQuery: QueryParam[String], damExpiryPropertyQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo] = jsonOf[ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.AssetViewHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("damShowexpired", Some(dam.showexpiredQuery.toParamString(dam.showexpired))), ("damShowhidden", Some(dam.showhiddenQuery.toParamString(dam.showhidden))), ("tagTitleSearch", Some(tagTitleSearchQuery.toParamString(tagTitleSearch))), ("guessTotal", Some(guessTotalQuery.toParamString(guessTotal))), ("damExpiryProperty", Some(dam.expiryPropertyQuery.toParamString(dam.expiryProperty))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplServletsContentfinderConnectorConnectorVie(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], itemResourceTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], itemResourceTypesQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo] = jsonOf[ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.connector.ConnectorViewHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("itemResourceTypes", Some(item.resource.typesQuery.toParamString(item.resource.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplServletsContentfinderPageViewHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], guessTotal: String, tagTitleSearch: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], guessTotalQuery: QueryParam[String], tagTitleSearchQuery: QueryParam[Boolean]): Task[ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo] = jsonOf[ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.PageViewHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("guessTotal", Some(guessTotalQuery.toParamString(guessTotal))), ("tagTitleSearch", Some(tagTitleSearchQuery.toParamString(tagTitleSearch))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplServletsFindReplaceServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], scope: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], scopeQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplServletsFindReplaceServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplServletsFindReplaceServletInfo] = jsonOf[ComDayCqWcmCoreImplServletsFindReplaceServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.FindReplaceServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("scope", Some(scopeQuery.toParamString(scope))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplServletsFindReplaceServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplServletsReferenceSearchServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], referencesearchservletMaxReferencesPerPage: Integer, referencesearchservletMaxPages: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], referencesearchservletMaxReferencesPerPageQuery: QueryParam[Integer], referencesearchservletMaxPagesQuery: QueryParam[Integer]): Task[ComDayCqWcmCoreImplServletsReferenceSearchServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplServletsReferenceSearchServletInfo] = jsonOf[ComDayCqWcmCoreImplServletsReferenceSearchServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.ReferenceSearchServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("referencesearchservletMaxReferencesPerPage", Some(referencesearchservlet.maxReferencesPerPageQuery.toParamString(referencesearchservlet.maxReferencesPerPage))), ("referencesearchservletMaxPages", Some(referencesearchservlet.maxPagesQuery.toParamString(referencesearchservlet.maxPages))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplServletsReferenceSearchServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplServletsThumbnailServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], workspace: String, dimensions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], workspaceQuery: QueryParam[String], dimensionsQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplServletsThumbnailServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplServletsThumbnailServletInfo] = jsonOf[ComDayCqWcmCoreImplServletsThumbnailServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.ThumbnailServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("workspace", Some(workspaceQuery.toParamString(workspace))), ("dimensions", Some(dimensionsQuery.toParamString(dimensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplServletsThumbnailServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplUtilsDefaultPageNameValidator(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], nonValidChars: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nonValidCharsQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo] = jsonOf[ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.utils.DefaultPageNameValidator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("nonValidChars", Some(nonValidCharsQuery.toParamString(nonValidChars))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplVariantsPageVariantsProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultExternalizerDomain: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultExternalizerDomainQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo] = jsonOf[ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.variants.PageVariantsProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultExternalizerDomain", Some(default.externalizer.domainQuery.toParamString(default.externalizer.domain))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplVersionManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], versionmanagerCreateVersionOnActivation: Boolean, versionmanagerPurgingEnabled: Boolean, versionmanagerPurgePaths: List[String], versionmanagerIvPaths: List[String], versionmanagerMaxAgeDays: Integer, versionmanagerMaxNumberVersions: Integer, versionmanagerMinNumberVersions: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], versionmanagerCreateVersionOnActivationQuery: QueryParam[Boolean], versionmanagerPurgingEnabledQuery: QueryParam[Boolean], versionmanagerPurgePathsQuery: QueryParam[List[String]], versionmanagerIvPathsQuery: QueryParam[List[String]], versionmanagerMaxAgeDaysQuery: QueryParam[Integer], versionmanagerMaxNumberVersionsQuery: QueryParam[Integer], versionmanagerMinNumberVersionsQuery: QueryParam[Integer]): Task[ComDayCqWcmCoreImplVersionManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplVersionManagerImplInfo] = jsonOf[ComDayCqWcmCoreImplVersionManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.VersionManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("versionmanagerCreateVersionOnActivation", Some(versionmanager.createVersionOnActivationQuery.toParamString(versionmanager.createVersionOnActivation))), ("versionmanagerPurgingEnabled", Some(versionmanager.purgingEnabledQuery.toParamString(versionmanager.purgingEnabled))), ("versionmanagerPurgePaths", Some(versionmanager.purgePathsQuery.toParamString(versionmanager.purgePaths))), ("versionmanagerIvPaths", Some(versionmanager.ivPathsQuery.toParamString(versionmanager.ivPaths))), ("versionmanagerMaxAgeDays", Some(versionmanager.maxAgeDaysQuery.toParamString(versionmanager.maxAgeDays))), ("versionmanagerMaxNumberVersions", Some(versionmanager.maxNumberVersionsQuery.toParamString(versionmanager.maxNumberVersions))), ("versionmanagerMinNumberVersions", Some(versionmanager.minNumberVersionsQuery.toParamString(versionmanager.minNumberVersions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplVersionManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplVersionPurgeTask(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], versionpurgePaths: List[String], versionpurgeRecursive: Boolean, versionpurgeMaxVersions: Integer, versionpurgeMinVersions: Integer, versionpurgeMaxAgeDays: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], versionpurgePathsQuery: QueryParam[List[String]], versionpurgeRecursiveQuery: QueryParam[Boolean], versionpurgeMaxVersionsQuery: QueryParam[Integer], versionpurgeMinVersionsQuery: QueryParam[Integer], versionpurgeMaxAgeDaysQuery: QueryParam[Integer]): Task[ComDayCqWcmCoreImplVersionPurgeTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplVersionPurgeTaskInfo] = jsonOf[ComDayCqWcmCoreImplVersionPurgeTaskInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.VersionPurgeTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("versionpurgePaths", Some(versionpurge.pathsQuery.toParamString(versionpurge.paths))), ("versionpurgeRecursive", Some(versionpurge.recursiveQuery.toParamString(versionpurge.recursive))), ("versionpurgeMaxVersions", Some(versionpurge.maxVersionsQuery.toParamString(versionpurge.maxVersions))), ("versionpurgeMinVersions", Some(versionpurge.minVersionsQuery.toParamString(versionpurge.minVersions))), ("versionpurgeMaxAgeDays", Some(versionpurge.maxAgeDaysQuery.toParamString(versionpurge.maxAgeDays))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplVersionPurgeTaskInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplWCMDebugFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], wcmdbgfilterEnabled: Boolean, wcmdbgfilterJspDebug: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], wcmdbgfilterEnabledQuery: QueryParam[Boolean], wcmdbgfilterJspDebugQuery: QueryParam[Boolean]): Task[ComDayCqWcmCoreImplWCMDebugFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplWCMDebugFilterInfo] = jsonOf[ComDayCqWcmCoreImplWCMDebugFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.WCMDebugFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("wcmdbgfilterEnabled", Some(wcmdbgfilter.enabledQuery.toParamString(wcmdbgfilter.enabled))), ("wcmdbgfilterJspDebug", Some(wcmdbgfilter.jspDebugQuery.toParamString(wcmdbgfilter.jspDebug))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplWCMDebugFilterInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplWCMDeveloperModeFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], wcmdevmodefilterEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], wcmdevmodefilterEnabledQuery: QueryParam[Boolean]): Task[ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo] = jsonOf[ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.WCMDeveloperModeFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("wcmdevmodefilterEnabled", Some(wcmdevmodefilter.enabledQuery.toParamString(wcmdevmodefilter.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplWarpTimeWarpFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], filterOrder: String, filterScope: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], filterOrderQuery: QueryParam[String], filterScopeQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplWarpTimeWarpFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplWarpTimeWarpFilterInfo] = jsonOf[ComDayCqWcmCoreImplWarpTimeWarpFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.warp.TimeWarpFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("filterOrder", Some(filter.orderQuery.toParamString(filter.order))), ("filterScope", Some(filter.scopeQuery.toParamString(filter.scope))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplWarpTimeWarpFilterInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreMvtMVTStatisticsImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mvtstatisticsTrackingurl: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mvtstatisticsTrackingurlQuery: QueryParam[String]): Task[ComDayCqWcmCoreMvtMVTStatisticsImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreMvtMVTStatisticsImplInfo] = jsonOf[ComDayCqWcmCoreMvtMVTStatisticsImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.mvt.MVTStatisticsImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mvtstatisticsTrackingurl", Some(mvtstatistics.trackingurlQuery.toParamString(mvtstatistics.trackingurl))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreMvtMVTStatisticsImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreStatsPageViewStatisticsImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pageviewstatisticsTrackingurl: String, pageviewstatisticsTrackingscriptEnabled: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pageviewstatisticsTrackingurlQuery: QueryParam[String], pageviewstatisticsTrackingscriptEnabledQuery: QueryParam[String]): Task[ComDayCqWcmCoreStatsPageViewStatisticsImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreStatsPageViewStatisticsImplInfo] = jsonOf[ComDayCqWcmCoreStatsPageViewStatisticsImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.stats.PageViewStatisticsImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pageviewstatisticsTrackingurl", Some(pageviewstatistics.trackingurlQuery.toParamString(pageviewstatistics.trackingurl))), ("pageviewstatisticsTrackingscriptEnabled", Some(pageviewstatistics.trackingscript.enabledQuery.toParamString(pageviewstatistics.trackingscript.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreStatsPageViewStatisticsImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreWCMRequestFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], wcmfilterMode: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], wcmfilterModeQuery: QueryParam[String]): Task[ComDayCqWcmCoreWCMRequestFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreWCMRequestFilterInfo] = jsonOf[ComDayCqWcmCoreWCMRequestFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.WCMRequestFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("wcmfilterMode", Some(wcmfilter.modeQuery.toParamString(wcmfilter.mode))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreWCMRequestFilterInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterDesignPackageImporter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], extractFilter: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], extractFilterQuery: QueryParam[List[String]]): Task[ComDayCqWcmDesignimporterDesignPackageImporterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterDesignPackageImporterInfo] = jsonOf[ComDayCqWcmDesignimporterDesignPackageImporterInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.DesignPackageImporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("extractFilter", Some(extract.filterQuery.toParamString(extract.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterDesignPackageImporterInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterImplCanvasBuilderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], filepattern: String, buildPageNodes: Boolean, buildClientLibs: Boolean, buildCanvasComponent: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], filepatternQuery: QueryParam[String], buildPageNodesQuery: QueryParam[Boolean], buildClientLibsQuery: QueryParam[Boolean], buildCanvasComponentQuery: QueryParam[Boolean]): Task[ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo] = jsonOf[ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.impl.CanvasBuilderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("filepattern", Some(filepatternQuery.toParamString(filepattern))), ("buildPageNodes", Some(build.page.nodesQuery.toParamString(build.page.nodes))), ("buildClientLibs", Some(build.client.libsQuery.toParamString(build.client.libs))), ("buildCanvasComponent", Some(build.canvas.componentQuery.toParamString(build.canvas.component))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterImplCanvasPageDeleteHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], minThreadPoolSize: Integer, maxThreadPoolSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], minThreadPoolSizeQuery: QueryParam[Integer], maxThreadPoolSizeQuery: QueryParam[Integer]): Task[ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo] = jsonOf[ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.impl.CanvasPageDeleteHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("minThreadPoolSize", Some(minThreadPoolSizeQuery.toParamString(minThreadPoolSize))), ("maxThreadPoolSize", Some(maxThreadPoolSizeQuery.toParamString(maxThreadPoolSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterImplEntryPreprocessorImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], searchPattern: String, replacePattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], searchPatternQuery: QueryParam[String], replacePatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo] = jsonOf[ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.impl.EntryPreprocessorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("searchPattern", Some(search.patternQuery.toParamString(search.pattern))), ("replacePattern", Some(replace.patternQuery.toParamString(replace.pattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterImplMobileCanvasBuilderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], filepattern: String, deviceGroups: List[String], buildPageNodes: Boolean, buildClientLibs: Boolean, buildCanvasComponent: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], filepatternQuery: QueryParam[String], deviceGroupsQuery: QueryParam[List[String]], buildPageNodesQuery: QueryParam[Boolean], buildClientLibsQuery: QueryParam[Boolean], buildCanvasComponentQuery: QueryParam[Boolean]): Task[ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo] = jsonOf[ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.impl.MobileCanvasBuilderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("filepattern", Some(filepatternQuery.toParamString(filepattern))), ("deviceGroups", Some(device.groupsQuery.toParamString(device.groups))), ("buildPageNodes", Some(build.page.nodesQuery.toParamString(build.page.nodes))), ("buildClientLibs", Some(build.client.libsQuery.toParamString(build.client.libs))), ("buildCanvasComponent", Some(build.canvas.componentQuery.toParamString(build.canvas.component))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryCanvasCompone(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.CanvasComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultCompon(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.DefaultComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHan(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.DefaultTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandle(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.HeadTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHand(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.IFrameTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryImageComponen(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ImageComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ImgTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptT(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.InlineScriptTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandle(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.LinkTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandle(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.MetaTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagH(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.NonScriptTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryParsysCompone(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ParsysComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHand(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ScriptTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.StyleTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryTextComponent(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TextComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponen(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TitleComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TitleTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationFormsImplFormChooserServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceName: String, slingServletResourceTypes: String, slingServletSelectors: String, slingServletMethods: List[String], formsFormchooserservletAdvansesearchRequire: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceNameQuery: QueryParam[String], slingServletResourceTypesQuery: QueryParam[String], slingServletSelectorsQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[List[String]], formsFormchooserservletAdvansesearchRequireQuery: QueryParam[Boolean]): Task[ComDayCqWcmFoundationFormsImplFormChooserServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationFormsImplFormChooserServletInfo] = jsonOf[ComDayCqWcmFoundationFormsImplFormChooserServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormChooserServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceName", Some(service.nameQuery.toParamString(service.name))), ("slingServletResourceTypes", Some(sling.servlet.resourceTypesQuery.toParamString(sling.servlet.resourceTypes))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))), ("formsFormchooserservletAdvansesearchRequire", Some(forms.formchooserservlet.advansesearch.requireQuery.toParamString(forms.formchooserservlet.advansesearch.require))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationFormsImplFormChooserServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationFormsImplFormParagraphPostProcessor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], formsFormparagraphpostprocessorEnabled: Boolean, formsFormparagraphpostprocessorFormresourcetypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], formsFormparagraphpostprocessorEnabledQuery: QueryParam[Boolean], formsFormparagraphpostprocessorFormresourcetypesQuery: QueryParam[List[String]]): Task[ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo] = jsonOf[ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormParagraphPostProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("formsFormparagraphpostprocessorEnabled", Some(forms.formparagraphpostprocessor.enabledQuery.toParamString(forms.formparagraphpostprocessor.enabled))), ("formsFormparagraphpostprocessorFormresourcetypes", Some(forms.formparagraphpostprocessor.formresourcetypesQuery.toParamString(forms.formparagraphpostprocessor.formresourcetypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationFormsImplFormsHandlingServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], nameWhitelist: String, allowExpressions: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameWhitelistQuery: QueryParam[String], allowExpressionsQuery: QueryParam[Boolean]): Task[ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo] = jsonOf[ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormsHandlingServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("nameWhitelist", Some(name.whitelistQuery.toParamString(name.whitelist))), ("allowExpressions", Some(allow.expressionsQuery.toParamString(allow.expressions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationFormsImplMailServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletResourceTypes: String, slingServletSelectors: String, resourceWhitelist: List[String], resourceBlacklist: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletResourceTypesQuery: QueryParam[String], slingServletSelectorsQuery: QueryParam[String], resourceWhitelistQuery: QueryParam[List[String]], resourceBlacklistQuery: QueryParam[String]): Task[ComDayCqWcmFoundationFormsImplMailServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationFormsImplMailServletInfo] = jsonOf[ComDayCqWcmFoundationFormsImplMailServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.MailServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletResourceTypes", Some(sling.servlet.resourceTypesQuery.toParamString(sling.servlet.resourceTypes))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("resourceWhitelist", Some(resource.whitelistQuery.toParamString(resource.whitelist))), ("resourceBlacklist", Some(resource.blacklistQuery.toParamString(resource.blacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationFormsImplMailServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationImplAdaptiveImageComponentServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], adaptSupportedWidths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], adaptSupportedWidthsQuery: QueryParam[List[String]]): Task[ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo] = jsonOf[ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.impl.AdaptiveImageComponentServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("adaptSupportedWidths", Some(adapt.supported.widthsQuery.toParamString(adapt.supported.widths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationImplHTTPAuthHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, authHttpNologin: Boolean, authHttpRealm: String, authDefaultLoginpage: String, authCredForm: List[String], authCredUtf8: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], authHttpNologinQuery: QueryParam[Boolean], authHttpRealmQuery: QueryParam[String], authDefaultLoginpageQuery: QueryParam[String], authCredFormQuery: QueryParam[List[String]], authCredUtf8Query: QueryParam[List[String]]): Task[ComDayCqWcmFoundationImplHTTPAuthHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationImplHTTPAuthHandlerInfo] = jsonOf[ComDayCqWcmFoundationImplHTTPAuthHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.impl.HTTPAuthHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("authHttpNologin", Some(auth.http.nologinQuery.toParamString(auth.http.nologin))), ("authHttpRealm", Some(auth.http.realmQuery.toParamString(auth.http.realm))), ("authDefaultLoginpage", Some(auth.default.loginpageQuery.toParamString(auth.default.loginpage))), ("authCredForm", Some(auth.cred.formQuery.toParamString(auth.cred.form))), ("authCredUtf8", Some(auth.cred.utf8Query.toParamString(auth.cred.utf8))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationImplHTTPAuthHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationImplPageImpressionsTracker(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingAuthRequirements: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingAuthRequirementsQuery: QueryParam[String]): Task[ComDayCqWcmFoundationImplPageImpressionsTrackerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationImplPageImpressionsTrackerInfo] = jsonOf[ComDayCqWcmFoundationImplPageImpressionsTrackerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.impl.PageImpressionsTracker"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingAuthRequirements", Some(sling.auth.requirementsQuery.toParamString(sling.auth.requirements))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationImplPageImpressionsTrackerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationImplPageRedirectServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], excludedResourceTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], excludedResourceTypesQuery: QueryParam[List[String]]): Task[ComDayCqWcmFoundationImplPageRedirectServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationImplPageRedirectServletInfo] = jsonOf[ComDayCqWcmFoundationImplPageRedirectServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.impl.PageRedirectServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("excludedResourceTypes", Some(excluded.resource.typesQuery.toParamString(excluded.resource.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationImplPageRedirectServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklist(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultAttachmentTypeBlacklist: List[String], baselineAttachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultAttachmentTypeBlacklistQuery: QueryParam[List[String]], baselineAttachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo] = jsonOf[ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.security.impl.DefaultAttachmentTypeBlacklistService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultAttachmentTypeBlacklist", Some(default.attachment.type.blacklistQuery.toParamString(default.attachment.type.blacklist))), ("baselineAttachmentTypeBlacklist", Some(baseline.attachment.type.blacklistQuery.toParamString(baseline.attachment.type.blacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], parameterWhitelist: List[String], parameterWhitelistPrefixes: List[String], binaryParameterWhitelist: List[String], modifierWhitelist: List[String], operationWhitelist: List[String], operationWhitelistPrefixes: List[String], typehintWhitelist: List[String], resourcetypeWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], parameterWhitelistQuery: QueryParam[List[String]], parameterWhitelistPrefixesQuery: QueryParam[List[String]], binaryParameterWhitelistQuery: QueryParam[List[String]], modifierWhitelistQuery: QueryParam[List[String]], operationWhitelistQuery: QueryParam[List[String]], operationWhitelistPrefixesQuery: QueryParam[List[String]], typehintWhitelistQuery: QueryParam[List[String]], resourcetypeWhitelistQuery: QueryParam[List[String]]): Task[ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo] = jsonOf[ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.security.impl.SaferSlingPostValidatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("parameterWhitelist", Some(parameter.whitelistQuery.toParamString(parameter.whitelist))), ("parameterWhitelistPrefixes", Some(parameter.whitelist.prefixesQuery.toParamString(parameter.whitelist.prefixes))), ("binaryParameterWhitelist", Some(binary.parameter.whitelistQuery.toParamString(binary.parameter.whitelist))), ("modifierWhitelist", Some(modifier.whitelistQuery.toParamString(modifier.whitelist))), ("operationWhitelist", Some(operation.whitelistQuery.toParamString(operation.whitelist))), ("operationWhitelistPrefixes", Some(operation.whitelist.prefixesQuery.toParamString(operation.whitelist.prefixes))), ("typehintWhitelist", Some(typehint.whitelistQuery.toParamString(typehint.whitelist))), ("resourcetypeWhitelist", Some(resourcetype.whitelistQuery.toParamString(resourcetype.whitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], deviceInfoTransformerEnabled: Boolean, deviceInfoTransformerCssStyle: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], deviceInfoTransformerEnabledQuery: QueryParam[Boolean], deviceInfoTransformerCssStyleQuery: QueryParam[String]): Task[ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo] = jsonOf[ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.mobile.core.impl.device.DeviceInfoTransformerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("deviceInfoTransformerEnabled", Some(device.info.transformer.enabledQuery.toParamString(device.info.transformer.enabled))), ("deviceInfoTransformerCssStyle", Some(device.info.transformer.css.styleQuery.toParamString(device.info.transformer.css.style))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMobileCoreImplRedirectRedirectFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], redirectEnabled: Boolean, redirectStatsEnabled: Boolean, redirectExtensions: List[String], redirectPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], redirectEnabledQuery: QueryParam[Boolean], redirectStatsEnabledQuery: QueryParam[Boolean], redirectExtensionsQuery: QueryParam[List[String]], redirectPathsQuery: QueryParam[List[String]]): Task[ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo] = jsonOf[ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.mobile.core.impl.redirect.RedirectFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("redirectEnabled", Some(redirect.enabledQuery.toParamString(redirect.enabled))), ("redirectStatsEnabled", Some(redirect.stats.enabledQuery.toParamString(redirect.stats.enabled))), ("redirectExtensions", Some(redirect.extensionsQuery.toParamString(redirect.extensions))), ("redirectPaths", Some(redirect.pathsQuery.toParamString(redirect.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsContentCopyActionFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String], contentcopyactionOrderStyle: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]], contentcopyactionOrderStyleQuery: QueryParam[String]): Task[ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentCopyActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))), ("contentcopyactionOrderStyle", Some(contentcopyaction.order.styleQuery.toParamString(contentcopyaction.order.style))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsContentDeleteActionFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]]): Task[ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentDeleteActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsContentUpdateActionFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String], cqWcmMsmActionIgnoredMixin: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]], cqWcmMsmActionIgnoredMixinQuery: QueryParam[List[String]]): Task[ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentUpdateActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))), ("cqWcmMsmActionIgnoredMixin", Some(cq.wcm.msm.action.ignoredMixinQuery.toParamString(cq.wcm.msm.action.ignoredMixin))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsOrderChildrenActionFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]]): Task[ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.OrderChildrenActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsPageMoveActionFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String], cqWcmMsmImplActionsPagemovePropReferenceUpdate: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]], cqWcmMsmImplActionsPagemovePropReferenceUpdateQuery: QueryParam[Boolean]): Task[ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.PageMoveActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))), ("cqWcmMsmImplActionsPagemovePropReferenceUpdate", Some(cq.wcm.msm.impl.actions.pagemove.prop_referenceUpdateQuery.toParamString(cq.wcm.msm.impl.actions.pagemove.prop_referenceUpdate))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsReferencesUpdateActionFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String], cqWcmMsmImplActionReferencesupdatePropUpdateNested: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]], cqWcmMsmImplActionReferencesupdatePropUpdateNestedQuery: QueryParam[Boolean]): Task[ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ReferencesUpdateActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))), ("cqWcmMsmImplActionReferencesupdatePropUpdateNested", Some(cq.wcm.msm.impl.action.referencesupdate.prop_updateNestedQuery.toParamString(cq.wcm.msm.impl.action.referencesupdate.prop_updateNested))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsVersionCopyActionFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]]): Task[ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.VersionCopyActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplLiveRelationshipManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], liverelationshipmgrRelationsconfigDefault: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], liverelationshipmgrRelationsconfigDefaultQuery: QueryParam[String]): Task[ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo] = jsonOf[ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.LiveRelationshipManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("liverelationshipmgrRelationsconfigDefault", Some(liverelationshipmgr.relationsconfig.defaultQuery.toParamString(liverelationshipmgr.relationsconfig.default))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplRolloutManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String, rolloutmgrExcludedpropsDefault: List[String], rolloutmgrExcludedparagraphpropsDefault: List[String], rolloutmgrExcludednodetypesDefault: List[String], rolloutmgrThreadpoolMaxsize: Integer, rolloutmgrThreadpoolMaxshutdowntime: Integer, rolloutmgrThreadpoolPriority: String, rolloutmgrCommitSize: Integer, rolloutmgrConflicthandlingEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String], rolloutmgrExcludedpropsDefaultQuery: QueryParam[List[String]], rolloutmgrExcludedparagraphpropsDefaultQuery: QueryParam[List[String]], rolloutmgrExcludednodetypesDefaultQuery: QueryParam[List[String]], rolloutmgrThreadpoolMaxsizeQuery: QueryParam[Integer], rolloutmgrThreadpoolMaxshutdowntimeQuery: QueryParam[Integer], rolloutmgrThreadpoolPriorityQuery: QueryParam[String], rolloutmgrCommitSizeQuery: QueryParam[Integer], rolloutmgrConflicthandlingEnabledQuery: QueryParam[Boolean]): Task[ComDayCqWcmMsmImplRolloutManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplRolloutManagerImplInfo] = jsonOf[ComDayCqWcmMsmImplRolloutManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.RolloutManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("rolloutmgrExcludedpropsDefault", Some(rolloutmgr.excludedprops.defaultQuery.toParamString(rolloutmgr.excludedprops.default))), ("rolloutmgrExcludedparagraphpropsDefault", Some(rolloutmgr.excludedparagraphprops.defaultQuery.toParamString(rolloutmgr.excludedparagraphprops.default))), ("rolloutmgrExcludednodetypesDefault", Some(rolloutmgr.excludednodetypes.defaultQuery.toParamString(rolloutmgr.excludednodetypes.default))), ("rolloutmgrThreadpoolMaxsize", Some(rolloutmgr.threadpool.maxsizeQuery.toParamString(rolloutmgr.threadpool.maxsize))), ("rolloutmgrThreadpoolMaxshutdowntime", Some(rolloutmgr.threadpool.maxshutdowntimeQuery.toParamString(rolloutmgr.threadpool.maxshutdowntime))), ("rolloutmgrThreadpoolPriority", Some(rolloutmgr.threadpool.priorityQuery.toParamString(rolloutmgr.threadpool.priority))), ("rolloutmgrCommitSize", Some(rolloutmgr.commit.sizeQuery.toParamString(rolloutmgr.commit.size))), ("rolloutmgrConflicthandlingEnabled", Some(rolloutmgr.conflicthandling.enabledQuery.toParamString(rolloutmgr.conflicthandling.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplRolloutManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplServletsAuditLogServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], auditlogservletDefaultEventsCount: Integer, auditlogservletDefaultPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], auditlogservletDefaultEventsCountQuery: QueryParam[Integer], auditlogservletDefaultPathQuery: QueryParam[String]): Task[ComDayCqWcmMsmImplServletsAuditLogServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplServletsAuditLogServletInfo] = jsonOf[ComDayCqWcmMsmImplServletsAuditLogServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.servlets.AuditLogServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("auditlogservletDefaultEventsCount", Some(auditlogservlet.default.events.countQuery.toParamString(auditlogservlet.default.events.count))), ("auditlogservletDefaultPath", Some(auditlogservlet.default.pathQuery.toParamString(auditlogservlet.default.path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplServletsAuditLogServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmNotificationEmailImplEmailChannel(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], emailFrom: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], emailFromQuery: QueryParam[String]): Task[ComDayCqWcmNotificationEmailImplEmailChannelInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmNotificationEmailImplEmailChannelInfo] = jsonOf[ComDayCqWcmNotificationEmailImplEmailChannelInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.notification.email.impl.EmailChannel"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("emailFrom", Some(email.fromQuery.toParamString(email.from))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmNotificationEmailImplEmailChannelInfo](req)

    } yield resp
  }
  
  def comDayCqWcmNotificationImplNotificationManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[List[String]]): Task[ComDayCqWcmNotificationImplNotificationManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmNotificationImplNotificationManagerImplInfo] = jsonOf[ComDayCqWcmNotificationImplNotificationManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.notification.impl.NotificationManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmNotificationImplNotificationManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmScriptingImplBVPManager(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comDayCqWcmScriptingBvpScriptEngines: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comDayCqWcmScriptingBvpScriptEnginesQuery: QueryParam[List[String]]): Task[ComDayCqWcmScriptingImplBVPManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmScriptingImplBVPManagerInfo] = jsonOf[ComDayCqWcmScriptingImplBVPManagerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.scripting.impl.BVPManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comDayCqWcmScriptingBvpScriptEngines", Some(com.day.cq.wcm.scripting.bvp.script.enginesQuery.toParamString(com.day.cq.wcm.scripting.bvp.script.engines))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmScriptingImplBVPManagerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmUndoUndoConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmUndoEnabled: Boolean, cqWcmUndoPath: String, cqWcmUndoValidity: Integer, cqWcmUndoSteps: Integer, cqWcmUndoPersistence: String, cqWcmUndoPersistenceMode: Boolean, cqWcmUndoMarkermode: String, cqWcmUndoWhitelist: List[String], cqWcmUndoBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmUndoEnabledQuery: QueryParam[Boolean], cqWcmUndoPathQuery: QueryParam[String], cqWcmUndoValidityQuery: QueryParam[Integer], cqWcmUndoStepsQuery: QueryParam[Integer], cqWcmUndoPersistenceQuery: QueryParam[String], cqWcmUndoPersistenceModeQuery: QueryParam[Boolean], cqWcmUndoMarkermodeQuery: QueryParam[String], cqWcmUndoWhitelistQuery: QueryParam[List[String]], cqWcmUndoBlacklistQuery: QueryParam[List[String]]): Task[ComDayCqWcmUndoUndoConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmUndoUndoConfigInfo] = jsonOf[ComDayCqWcmUndoUndoConfigInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.undo.UndoConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmUndoEnabled", Some(cq.wcm.undo.enabledQuery.toParamString(cq.wcm.undo.enabled))), ("cqWcmUndoPath", Some(cq.wcm.undo.pathQuery.toParamString(cq.wcm.undo.path))), ("cqWcmUndoValidity", Some(cq.wcm.undo.validityQuery.toParamString(cq.wcm.undo.validity))), ("cqWcmUndoSteps", Some(cq.wcm.undo.stepsQuery.toParamString(cq.wcm.undo.steps))), ("cqWcmUndoPersistence", Some(cq.wcm.undo.persistenceQuery.toParamString(cq.wcm.undo.persistence))), ("cqWcmUndoPersistenceMode", Some(cq.wcm.undo.persistence.modeQuery.toParamString(cq.wcm.undo.persistence.mode))), ("cqWcmUndoMarkermode", Some(cq.wcm.undo.markermodeQuery.toParamString(cq.wcm.undo.markermode))), ("cqWcmUndoWhitelist", Some(cq.wcm.undo.whitelistQuery.toParamString(cq.wcm.undo.whitelist))), ("cqWcmUndoBlacklist", Some(cq.wcm.undo.blacklistQuery.toParamString(cq.wcm.undo.blacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmUndoUndoConfigInfo](req)

    } yield resp
  }
  
  def comDayCqWcmWebservicesupportImplReplicationEventListener(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], flushAgents: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], flushAgentsQuery: QueryParam[List[String]]): Task[ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo] = jsonOf[ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.webservicesupport.impl.ReplicationEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("flushAgents", Some(Flush agentsQuery.toParamString(Flush agents))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmWorkflowImplWcmWorkflowServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String, minThreadPoolSize: Integer, maxThreadPoolSize: Integer, cqWcmWorkflowTerminateOnActivate: Boolean, cqWcmWorklfowTerminateExclusionList: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String], minThreadPoolSizeQuery: QueryParam[Integer], maxThreadPoolSizeQuery: QueryParam[Integer], cqWcmWorkflowTerminateOnActivateQuery: QueryParam[Boolean], cqWcmWorklfowTerminateExclusionListQuery: QueryParam[List[String]]): Task[ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo] = jsonOf[ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.workflow.impl.WcmWorkflowServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("minThreadPoolSize", Some(minThreadPoolSizeQuery.toParamString(minThreadPoolSize))), ("maxThreadPoolSize", Some(maxThreadPoolSizeQuery.toParamString(maxThreadPoolSize))), ("cqWcmWorkflowTerminateOnActivate", Some(cq.wcm.workflow.terminate.on.activateQuery.toParamString(cq.wcm.workflow.terminate.on.activate))), ("cqWcmWorklfowTerminateExclusionList", Some(cq.wcm.worklfow.terminate.exclusion.listQuery.toParamString(cq.wcm.worklfow.terminate.exclusion.list))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmWorkflowImplWorkflowPackageInfoProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], workflowpackageinfoproviderFilter: List[String], workflowpackageinfoproviderFilterRootpath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], workflowpackageinfoproviderFilterQuery: QueryParam[List[String]], workflowpackageinfoproviderFilterRootpathQuery: QueryParam[String]): Task[ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo] = jsonOf[ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.workflow.impl.WorkflowPackageInfoProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("workflowpackageinfoproviderFilter", Some(workflowpackageinfoprovider.filterQuery.toParamString(workflowpackageinfoprovider.filter))), ("workflowpackageinfoproviderFilterRootpath", Some(workflowpackageinfoprovider.filter.rootpathQuery.toParamString(workflowpackageinfoprovider.filter.rootpath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo](req)

    } yield resp
  }
  
  def comDayCqWidgetImplHtmlLibraryManagerImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], htmllibmanagerClientmanager: String, htmllibmanagerDebug: Boolean, htmllibmanagerDebugConsole: Boolean, htmllibmanagerDebugInitJs: String, htmllibmanagerDefaultthemename: String, htmllibmanagerDefaultuserthemename: String, htmllibmanagerFirebuglitePath: String, htmllibmanagerForceCQUrlInfo: Boolean, htmllibmanagerGzip: Boolean, htmllibmanagerMaxage: Integer, htmllibmanagerMaxDataUriSize: Integer, htmllibmanagerMinify: Boolean, htmllibmanagerPathList: List[String], htmllibmanagerTiming: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], htmllibmanagerClientmanagerQuery: QueryParam[String], htmllibmanagerDebugQuery: QueryParam[Boolean], htmllibmanagerDebugConsoleQuery: QueryParam[Boolean], htmllibmanagerDebugInitJsQuery: QueryParam[String], htmllibmanagerDefaultthemenameQuery: QueryParam[String], htmllibmanagerDefaultuserthemenameQuery: QueryParam[String], htmllibmanagerFirebuglitePathQuery: QueryParam[String], htmllibmanagerForceCQUrlInfoQuery: QueryParam[Boolean], htmllibmanagerGzipQuery: QueryParam[Boolean], htmllibmanagerMaxageQuery: QueryParam[Integer], htmllibmanagerMaxDataUriSizeQuery: QueryParam[Integer], htmllibmanagerMinifyQuery: QueryParam[Boolean], htmllibmanagerPathListQuery: QueryParam[List[String]], htmllibmanagerTimingQuery: QueryParam[Boolean]): Task[ComDayCqWidgetImplHtmlLibraryManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWidgetImplHtmlLibraryManagerImplInfo] = jsonOf[ComDayCqWidgetImplHtmlLibraryManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.widget.impl.HtmlLibraryManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("htmllibmanagerClientmanager", Some(htmllibmanager.clientmanagerQuery.toParamString(htmllibmanager.clientmanager))), ("htmllibmanagerDebug", Some(htmllibmanager.debugQuery.toParamString(htmllibmanager.debug))), ("htmllibmanagerDebugConsole", Some(htmllibmanager.debug.consoleQuery.toParamString(htmllibmanager.debug.console))), ("htmllibmanagerDebugInitJs", Some(htmllibmanager.debug.init.jsQuery.toParamString(htmllibmanager.debug.init.js))), ("htmllibmanagerDefaultthemename", Some(htmllibmanager.defaultthemenameQuery.toParamString(htmllibmanager.defaultthemename))), ("htmllibmanagerDefaultuserthemename", Some(htmllibmanager.defaultuserthemenameQuery.toParamString(htmllibmanager.defaultuserthemename))), ("htmllibmanagerFirebuglitePath", Some(htmllibmanager.firebuglite.pathQuery.toParamString(htmllibmanager.firebuglite.path))), ("htmllibmanagerForceCQUrlInfo", Some(htmllibmanager.forceCQUrlInfoQuery.toParamString(htmllibmanager.forceCQUrlInfo))), ("htmllibmanagerGzip", Some(htmllibmanager.gzipQuery.toParamString(htmllibmanager.gzip))), ("htmllibmanagerMaxage", Some(htmllibmanager.maxageQuery.toParamString(htmllibmanager.maxage))), ("htmllibmanagerMaxDataUriSize", Some(htmllibmanager.maxDataUriSizeQuery.toParamString(htmllibmanager.maxDataUriSize))), ("htmllibmanagerMinify", Some(htmllibmanager.minifyQuery.toParamString(htmllibmanager.minify))), ("htmllibmanagerPathList", Some(htmllibmanager.path.listQuery.toParamString(htmllibmanager.path.list))), ("htmllibmanagerTiming", Some(htmllibmanager.timingQuery.toParamString(htmllibmanager.timing))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWidgetImplHtmlLibraryManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqWidgetImplWidgetExtensionProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], extendableWidgets: List[String], widgetextensionproviderDebug: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], extendableWidgetsQuery: QueryParam[List[String]], widgetextensionproviderDebugQuery: QueryParam[Boolean]): Task[ComDayCqWidgetImplWidgetExtensionProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWidgetImplWidgetExtensionProviderImplInfo] = jsonOf[ComDayCqWidgetImplWidgetExtensionProviderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.widget.impl.WidgetExtensionProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("extendableWidgets", Some(extendable.widgetsQuery.toParamString(extendable.widgets))), ("widgetextensionproviderDebug", Some(widgetextensionprovider.debugQuery.toParamString(widgetextensionprovider.debug))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWidgetImplWidgetExtensionProviderImplInfo](req)

    } yield resp
  }
  
  def comDayCqWorkflowImplEmailEMailNotificationService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fromAddress: String, hostPrefix: String, notifyOnabort: Boolean, notifyOncomplete: Boolean, notifyOncontainercomplete: Boolean, notifyUseronly: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fromAddressQuery: QueryParam[String], hostPrefixQuery: QueryParam[String], notifyOnabortQuery: QueryParam[Boolean], notifyOncompleteQuery: QueryParam[Boolean], notifyOncontainercompleteQuery: QueryParam[Boolean], notifyUseronlyQuery: QueryParam[Boolean]): Task[ComDayCqWorkflowImplEmailEMailNotificationServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWorkflowImplEmailEMailNotificationServiceInfo] = jsonOf[ComDayCqWorkflowImplEmailEMailNotificationServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.workflow.impl.email.EMailNotificationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fromAddress", Some(from.addressQuery.toParamString(from.address))), ("hostPrefix", Some(host.prefixQuery.toParamString(host.prefix))), ("notifyOnabort", Some(notify.onabortQuery.toParamString(notify.onabort))), ("notifyOncomplete", Some(notify.oncompleteQuery.toParamString(notify.oncomplete))), ("notifyOncontainercomplete", Some(notify.oncontainercompleteQuery.toParamString(notify.oncontainercomplete))), ("notifyUseronly", Some(notify.useronlyQuery.toParamString(notify.useronly))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWorkflowImplEmailEMailNotificationServiceInfo](req)

    } yield resp
  }
  
  def comDayCqWorkflowImplEmailTaskEMailNotificationService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], notifyOnupdate: Boolean, notifyOncomplete: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], notifyOnupdateQuery: QueryParam[Boolean], notifyOncompleteQuery: QueryParam[Boolean]): Task[ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo] = jsonOf[ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.workflow.impl.email.TaskEMailNotificationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("notifyOnupdate", Some(notify.onupdateQuery.toParamString(notify.onupdate))), ("notifyOncomplete", Some(notify.oncompleteQuery.toParamString(notify.oncomplete))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo](req)

    } yield resp
  }
  
  def comDayCrxSecurityTokenImplImplTokenAuthenticationHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, tokenRequiredAttr: String, tokenAlternateUrl: String, tokenEncapsulated: Boolean, skipTokenRefresh: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], tokenRequiredAttrQuery: QueryParam[String], tokenAlternateUrlQuery: QueryParam[String], tokenEncapsulatedQuery: QueryParam[Boolean], skipTokenRefreshQuery: QueryParam[List[String]]): Task[ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo] = jsonOf[ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo]

    val path = "/system/console/configMgr/com.day.crx.security.token.impl.impl.TokenAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("tokenRequiredAttr", Some(token.required.attrQuery.toParamString(token.required.attr))), ("tokenAlternateUrl", Some(token.alternate.urlQuery.toParamString(token.alternate.url))), ("tokenEncapsulated", Some(token.encapsulatedQuery.toParamString(token.encapsulated))), ("skipTokenRefresh", Some(skip.token.refreshQuery.toParamString(skip.token.refresh))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo](req)

    } yield resp
  }
  
  def comDayCrxSecurityTokenImplTokenCleanupTask(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enableTokenCleanupTask: Boolean, schedulerExpression: String, batchSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableTokenCleanupTaskQuery: QueryParam[Boolean], schedulerExpressionQuery: QueryParam[String], batchSizeQuery: QueryParam[Integer]): Task[ComDayCrxSecurityTokenImplTokenCleanupTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCrxSecurityTokenImplTokenCleanupTaskInfo] = jsonOf[ComDayCrxSecurityTokenImplTokenCleanupTaskInfo]

    val path = "/system/console/configMgr/com.day.crx.security.token.impl.TokenCleanupTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enableTokenCleanupTask", Some(enable.token.cleanup.taskQuery.toParamString(enable.token.cleanup.task))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("batchSize", Some(batch.sizeQuery.toParamString(batch.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCrxSecurityTokenImplTokenCleanupTaskInfo](req)

    } yield resp
  }
  
  def guideLocalizationService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], supportedLocales: List[String], localizableProperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], supportedLocalesQuery: QueryParam[List[String]], localizablePropertiesQuery: QueryParam[List[String]]): Task[GuideLocalizationServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[GuideLocalizationServiceInfo] = jsonOf[GuideLocalizationServiceInfo]

    val path = "/system/console/configMgr/Guide Localization Service"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("supportedLocales", Some(supportedLocalesQuery.toParamString(supportedLocales))), ("localizableProperties", Some(Localizable PropertiesQuery.toParamString(Localizable Properties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[GuideLocalizationServiceInfo](req)

    } yield resp
  }
  
  def messagingUserComponentFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[MessagingUserComponentFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[MessagingUserComponentFactoryInfo] = jsonOf[MessagingUserComponentFactoryInfo]

    val path = "/system/console/configMgr/MessagingUserComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[MessagingUserComponentFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheAriesJmxFrameworkStateConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], attributeChangeNotificationEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], attributeChangeNotificationEnabledQuery: QueryParam[Boolean]): Task[OrgApacheAriesJmxFrameworkStateConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheAriesJmxFrameworkStateConfigInfo] = jsonOf[OrgApacheAriesJmxFrameworkStateConfigInfo]

    val path = "/system/console/configMgr/org.apache.aries.jmx.framework.StateConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("attributeChangeNotificationEnabled", Some(attributeChangeNotificationEnabledQuery.toParamString(attributeChangeNotificationEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheAriesJmxFrameworkStateConfigInfo](req)

    } yield resp
  }
  
  def orgApacheFelixEventadminImplEventAdmin(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheFelixEventadminThreadPoolSize: Integer, orgApacheFelixEventadminAsyncToSyncThreadRatio: BigDecimal, orgApacheFelixEventadminTimeout: Integer, orgApacheFelixEventadminRequireTopic: Boolean, orgApacheFelixEventadminIgnoreTimeout: List[String], orgApacheFelixEventadminIgnoreTopic: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheFelixEventadminThreadPoolSizeQuery: QueryParam[Integer], orgApacheFelixEventadminAsyncToSyncThreadRatioQuery: QueryParam[BigDecimal], orgApacheFelixEventadminTimeoutQuery: QueryParam[Integer], orgApacheFelixEventadminRequireTopicQuery: QueryParam[Boolean], orgApacheFelixEventadminIgnoreTimeoutQuery: QueryParam[List[String]], orgApacheFelixEventadminIgnoreTopicQuery: QueryParam[List[String]]): Task[OrgApacheFelixEventadminImplEventAdminInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixEventadminImplEventAdminInfo] = jsonOf[OrgApacheFelixEventadminImplEventAdminInfo]

    val path = "/system/console/configMgr/org.apache.felix.eventadmin.impl.EventAdmin"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheFelixEventadminThreadPoolSize", Some(org.apache.felix.eventadmin.ThreadPoolSizeQuery.toParamString(org.apache.felix.eventadmin.ThreadPoolSize))), ("orgApacheFelixEventadminAsyncToSyncThreadRatio", Some(org.apache.felix.eventadmin.AsyncToSyncThreadRatioQuery.toParamString(org.apache.felix.eventadmin.AsyncToSyncThreadRatio))), ("orgApacheFelixEventadminTimeout", Some(org.apache.felix.eventadmin.TimeoutQuery.toParamString(org.apache.felix.eventadmin.Timeout))), ("orgApacheFelixEventadminRequireTopic", Some(org.apache.felix.eventadmin.RequireTopicQuery.toParamString(org.apache.felix.eventadmin.RequireTopic))), ("orgApacheFelixEventadminIgnoreTimeout", Some(org.apache.felix.eventadmin.IgnoreTimeoutQuery.toParamString(org.apache.felix.eventadmin.IgnoreTimeout))), ("orgApacheFelixEventadminIgnoreTopic", Some(org.apache.felix.eventadmin.IgnoreTopicQuery.toParamString(org.apache.felix.eventadmin.IgnoreTopic))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixEventadminImplEventAdminInfo](req)

    } yield resp
  }
  
  def orgApacheFelixHttp(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheFelixHttpHost: String, orgApacheFelixHttpEnable: Boolean, orgOsgiServiceHttpPort: Integer, orgApacheFelixHttpTimeout: Integer, orgApacheFelixHttpsEnable: Boolean, orgOsgiServiceHttpPortSecure: Integer, orgApacheFelixHttpsKeystore: String, orgApacheFelixHttpsKeystorePassword: String, orgApacheFelixHttpsKeystoreKeyPassword: String, orgApacheFelixHttpsTruststore: String, orgApacheFelixHttpsTruststorePassword: String, orgApacheFelixHttpsClientcertificate: String, orgApacheFelixHttpContextPath: String, orgApacheFelixHttpMbeans: Boolean, orgApacheFelixHttpSessionTimeout: Integer, orgApacheFelixHttpJettyThreadpoolMax: Integer, orgApacheFelixHttpJettyAcceptors: Integer, orgApacheFelixHttpJettySelectors: Integer, orgApacheFelixHttpJettyHeaderBufferSize: Integer, orgApacheFelixHttpJettyRequestBufferSize: Integer, orgApacheFelixHttpJettyResponseBufferSize: Integer, orgApacheFelixHttpJettyMaxFormSize: Integer, orgApacheFelixHttpPathExclusions: List[String], orgApacheFelixHttpsJettyCiphersuitesExcluded: List[String], orgApacheFelixHttpsJettyCiphersuitesIncluded: List[String], orgApacheFelixHttpJettySendServerHeader: Boolean, orgApacheFelixHttpsJettyProtocolsIncluded: List[String], orgApacheFelixHttpsJettyProtocolsExcluded: List[String], orgApacheFelixProxyLoadBalancerConnectionEnable: Boolean, orgApacheFelixHttpsJettyRenegotiateAllowed: Boolean, orgApacheFelixHttpsJettySessionCookieHttpOnly: Boolean, orgApacheFelixHttpsJettySessionCookieSecure: Boolean, orgEclipseJettyServletSessionIdPathParameterName: String, orgEclipseJettyServletCheckingRemoteSessionIdEncoding: Boolean, orgEclipseJettyServletSessionCookie: String, orgEclipseJettyServletSessionDomain: String, orgEclipseJettyServletSessionPath: String, orgEclipseJettyServletMaxAge: Integer, orgApacheFelixHttpName: String, orgApacheFelixJettyGziphandlerEnable: Boolean, orgApacheFelixJettyGzipMinGzipSize: Integer, orgApacheFelixJettyGzipCompressionLevel: Integer, orgApacheFelixJettyGzipInflateBufferSize: Integer, orgApacheFelixJettyGzipSyncFlush: Boolean, orgApacheFelixJettyGzipExcludedUserAgents: List[String], orgApacheFelixJettyGzipIncludedMethods: List[String], orgApacheFelixJettyGzipExcludedMethods: List[String], orgApacheFelixJettyGzipIncludedPaths: List[String], orgApacheFelixJettyGzipExcludedPaths: List[String], orgApacheFelixJettyGzipIncludedMimeTypes: List[String], orgApacheFelixJettyGzipExcludedMimeTypes: List[String], orgApacheFelixHttpSessionInvalidate: Boolean, orgApacheFelixHttpSessionUniqueid: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheFelixHttpHostQuery: QueryParam[String], orgApacheFelixHttpEnableQuery: QueryParam[Boolean], orgOsgiServiceHttpPortQuery: QueryParam[Integer], orgApacheFelixHttpTimeoutQuery: QueryParam[Integer], orgApacheFelixHttpsEnableQuery: QueryParam[Boolean], orgOsgiServiceHttpPortSecureQuery: QueryParam[Integer], orgApacheFelixHttpsKeystoreQuery: QueryParam[String], orgApacheFelixHttpsKeystorePasswordQuery: QueryParam[String], orgApacheFelixHttpsKeystoreKeyPasswordQuery: QueryParam[String], orgApacheFelixHttpsTruststoreQuery: QueryParam[String], orgApacheFelixHttpsTruststorePasswordQuery: QueryParam[String], orgApacheFelixHttpsClientcertificateQuery: QueryParam[String], orgApacheFelixHttpContextPathQuery: QueryParam[String], orgApacheFelixHttpMbeansQuery: QueryParam[Boolean], orgApacheFelixHttpSessionTimeoutQuery: QueryParam[Integer], orgApacheFelixHttpJettyThreadpoolMaxQuery: QueryParam[Integer], orgApacheFelixHttpJettyAcceptorsQuery: QueryParam[Integer], orgApacheFelixHttpJettySelectorsQuery: QueryParam[Integer], orgApacheFelixHttpJettyHeaderBufferSizeQuery: QueryParam[Integer], orgApacheFelixHttpJettyRequestBufferSizeQuery: QueryParam[Integer], orgApacheFelixHttpJettyResponseBufferSizeQuery: QueryParam[Integer], orgApacheFelixHttpJettyMaxFormSizeQuery: QueryParam[Integer], orgApacheFelixHttpPathExclusionsQuery: QueryParam[List[String]], orgApacheFelixHttpsJettyCiphersuitesExcludedQuery: QueryParam[List[String]], orgApacheFelixHttpsJettyCiphersuitesIncludedQuery: QueryParam[List[String]], orgApacheFelixHttpJettySendServerHeaderQuery: QueryParam[Boolean], orgApacheFelixHttpsJettyProtocolsIncludedQuery: QueryParam[List[String]], orgApacheFelixHttpsJettyProtocolsExcludedQuery: QueryParam[List[String]], orgApacheFelixProxyLoadBalancerConnectionEnableQuery: QueryParam[Boolean], orgApacheFelixHttpsJettyRenegotiateAllowedQuery: QueryParam[Boolean], orgApacheFelixHttpsJettySessionCookieHttpOnlyQuery: QueryParam[Boolean], orgApacheFelixHttpsJettySessionCookieSecureQuery: QueryParam[Boolean], orgEclipseJettyServletSessionIdPathParameterNameQuery: QueryParam[String], orgEclipseJettyServletCheckingRemoteSessionIdEncodingQuery: QueryParam[Boolean], orgEclipseJettyServletSessionCookieQuery: QueryParam[String], orgEclipseJettyServletSessionDomainQuery: QueryParam[String], orgEclipseJettyServletSessionPathQuery: QueryParam[String], orgEclipseJettyServletMaxAgeQuery: QueryParam[Integer], orgApacheFelixHttpNameQuery: QueryParam[String], orgApacheFelixJettyGziphandlerEnableQuery: QueryParam[Boolean], orgApacheFelixJettyGzipMinGzipSizeQuery: QueryParam[Integer], orgApacheFelixJettyGzipCompressionLevelQuery: QueryParam[Integer], orgApacheFelixJettyGzipInflateBufferSizeQuery: QueryParam[Integer], orgApacheFelixJettyGzipSyncFlushQuery: QueryParam[Boolean], orgApacheFelixJettyGzipExcludedUserAgentsQuery: QueryParam[List[String]], orgApacheFelixJettyGzipIncludedMethodsQuery: QueryParam[List[String]], orgApacheFelixJettyGzipExcludedMethodsQuery: QueryParam[List[String]], orgApacheFelixJettyGzipIncludedPathsQuery: QueryParam[List[String]], orgApacheFelixJettyGzipExcludedPathsQuery: QueryParam[List[String]], orgApacheFelixJettyGzipIncludedMimeTypesQuery: QueryParam[List[String]], orgApacheFelixJettyGzipExcludedMimeTypesQuery: QueryParam[List[String]], orgApacheFelixHttpSessionInvalidateQuery: QueryParam[Boolean], orgApacheFelixHttpSessionUniqueidQuery: QueryParam[Boolean]): Task[OrgApacheFelixHttpInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixHttpInfo] = jsonOf[OrgApacheFelixHttpInfo]

    val path = "/system/console/configMgr/org.apache.felix.http"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheFelixHttpHost", Some(org.apache.felix.http.hostQuery.toParamString(org.apache.felix.http.host))), ("orgApacheFelixHttpEnable", Some(org.apache.felix.http.enableQuery.toParamString(org.apache.felix.http.enable))), ("orgOsgiServiceHttpPort", Some(org.osgi.service.http.portQuery.toParamString(org.osgi.service.http.port))), ("orgApacheFelixHttpTimeout", Some(org.apache.felix.http.timeoutQuery.toParamString(org.apache.felix.http.timeout))), ("orgApacheFelixHttpsEnable", Some(org.apache.felix.https.enableQuery.toParamString(org.apache.felix.https.enable))), ("orgOsgiServiceHttpPortSecure", Some(org.osgi.service.http.port.secureQuery.toParamString(org.osgi.service.http.port.secure))), ("orgApacheFelixHttpsKeystore", Some(org.apache.felix.https.keystoreQuery.toParamString(org.apache.felix.https.keystore))), ("orgApacheFelixHttpsKeystorePassword", Some(org.apache.felix.https.keystore.passwordQuery.toParamString(org.apache.felix.https.keystore.password))), ("orgApacheFelixHttpsKeystoreKeyPassword", Some(org.apache.felix.https.keystore.key.passwordQuery.toParamString(org.apache.felix.https.keystore.key.password))), ("orgApacheFelixHttpsTruststore", Some(org.apache.felix.https.truststoreQuery.toParamString(org.apache.felix.https.truststore))), ("orgApacheFelixHttpsTruststorePassword", Some(org.apache.felix.https.truststore.passwordQuery.toParamString(org.apache.felix.https.truststore.password))), ("orgApacheFelixHttpsClientcertificate", Some(org.apache.felix.https.clientcertificateQuery.toParamString(org.apache.felix.https.clientcertificate))), ("orgApacheFelixHttpContextPath", Some(org.apache.felix.http.context_pathQuery.toParamString(org.apache.felix.http.context_path))), ("orgApacheFelixHttpMbeans", Some(org.apache.felix.http.mbeansQuery.toParamString(org.apache.felix.http.mbeans))), ("orgApacheFelixHttpSessionTimeout", Some(org.apache.felix.http.session.timeoutQuery.toParamString(org.apache.felix.http.session.timeout))), ("orgApacheFelixHttpJettyThreadpoolMax", Some(org.apache.felix.http.jetty.threadpool.maxQuery.toParamString(org.apache.felix.http.jetty.threadpool.max))), ("orgApacheFelixHttpJettyAcceptors", Some(org.apache.felix.http.jetty.acceptorsQuery.toParamString(org.apache.felix.http.jetty.acceptors))), ("orgApacheFelixHttpJettySelectors", Some(org.apache.felix.http.jetty.selectorsQuery.toParamString(org.apache.felix.http.jetty.selectors))), ("orgApacheFelixHttpJettyHeaderBufferSize", Some(org.apache.felix.http.jetty.headerBufferSizeQuery.toParamString(org.apache.felix.http.jetty.headerBufferSize))), ("orgApacheFelixHttpJettyRequestBufferSize", Some(org.apache.felix.http.jetty.requestBufferSizeQuery.toParamString(org.apache.felix.http.jetty.requestBufferSize))), ("orgApacheFelixHttpJettyResponseBufferSize", Some(org.apache.felix.http.jetty.responseBufferSizeQuery.toParamString(org.apache.felix.http.jetty.responseBufferSize))), ("orgApacheFelixHttpJettyMaxFormSize", Some(org.apache.felix.http.jetty.maxFormSizeQuery.toParamString(org.apache.felix.http.jetty.maxFormSize))), ("orgApacheFelixHttpPathExclusions", Some(org.apache.felix.http.path_exclusionsQuery.toParamString(org.apache.felix.http.path_exclusions))), ("orgApacheFelixHttpsJettyCiphersuitesExcluded", Some(org.apache.felix.https.jetty.ciphersuites.excludedQuery.toParamString(org.apache.felix.https.jetty.ciphersuites.excluded))), ("orgApacheFelixHttpsJettyCiphersuitesIncluded", Some(org.apache.felix.https.jetty.ciphersuites.includedQuery.toParamString(org.apache.felix.https.jetty.ciphersuites.included))), ("orgApacheFelixHttpJettySendServerHeader", Some(org.apache.felix.http.jetty.sendServerHeaderQuery.toParamString(org.apache.felix.http.jetty.sendServerHeader))), ("orgApacheFelixHttpsJettyProtocolsIncluded", Some(org.apache.felix.https.jetty.protocols.includedQuery.toParamString(org.apache.felix.https.jetty.protocols.included))), ("orgApacheFelixHttpsJettyProtocolsExcluded", Some(org.apache.felix.https.jetty.protocols.excludedQuery.toParamString(org.apache.felix.https.jetty.protocols.excluded))), ("orgApacheFelixProxyLoadBalancerConnectionEnable", Some(org.apache.felix.proxy.load.balancer.connection.enableQuery.toParamString(org.apache.felix.proxy.load.balancer.connection.enable))), ("orgApacheFelixHttpsJettyRenegotiateAllowed", Some(org.apache.felix.https.jetty.renegotiateAllowedQuery.toParamString(org.apache.felix.https.jetty.renegotiateAllowed))), ("orgApacheFelixHttpsJettySessionCookieHttpOnly", Some(org.apache.felix.https.jetty.session.cookie.httpOnlyQuery.toParamString(org.apache.felix.https.jetty.session.cookie.httpOnly))), ("orgApacheFelixHttpsJettySessionCookieSecure", Some(org.apache.felix.https.jetty.session.cookie.secureQuery.toParamString(org.apache.felix.https.jetty.session.cookie.secure))), ("orgEclipseJettyServletSessionIdPathParameterName", Some(org.eclipse.jetty.servlet.SessionIdPathParameterNameQuery.toParamString(org.eclipse.jetty.servlet.SessionIdPathParameterName))), ("orgEclipseJettyServletCheckingRemoteSessionIdEncoding", Some(org.eclipse.jetty.servlet.CheckingRemoteSessionIdEncodingQuery.toParamString(org.eclipse.jetty.servlet.CheckingRemoteSessionIdEncoding))), ("orgEclipseJettyServletSessionCookie", Some(org.eclipse.jetty.servlet.SessionCookieQuery.toParamString(org.eclipse.jetty.servlet.SessionCookie))), ("orgEclipseJettyServletSessionDomain", Some(org.eclipse.jetty.servlet.SessionDomainQuery.toParamString(org.eclipse.jetty.servlet.SessionDomain))), ("orgEclipseJettyServletSessionPath", Some(org.eclipse.jetty.servlet.SessionPathQuery.toParamString(org.eclipse.jetty.servlet.SessionPath))), ("orgEclipseJettyServletMaxAge", Some(org.eclipse.jetty.servlet.MaxAgeQuery.toParamString(org.eclipse.jetty.servlet.MaxAge))), ("orgApacheFelixHttpName", Some(org.apache.felix.http.nameQuery.toParamString(org.apache.felix.http.name))), ("orgApacheFelixJettyGziphandlerEnable", Some(org.apache.felix.jetty.gziphandler.enableQuery.toParamString(org.apache.felix.jetty.gziphandler.enable))), ("orgApacheFelixJettyGzipMinGzipSize", Some(org.apache.felix.jetty.gzip.minGzipSizeQuery.toParamString(org.apache.felix.jetty.gzip.minGzipSize))), ("orgApacheFelixJettyGzipCompressionLevel", Some(org.apache.felix.jetty.gzip.compressionLevelQuery.toParamString(org.apache.felix.jetty.gzip.compressionLevel))), ("orgApacheFelixJettyGzipInflateBufferSize", Some(org.apache.felix.jetty.gzip.inflateBufferSizeQuery.toParamString(org.apache.felix.jetty.gzip.inflateBufferSize))), ("orgApacheFelixJettyGzipSyncFlush", Some(org.apache.felix.jetty.gzip.syncFlushQuery.toParamString(org.apache.felix.jetty.gzip.syncFlush))), ("orgApacheFelixJettyGzipExcludedUserAgents", Some(org.apache.felix.jetty.gzip.excludedUserAgentsQuery.toParamString(org.apache.felix.jetty.gzip.excludedUserAgents))), ("orgApacheFelixJettyGzipIncludedMethods", Some(org.apache.felix.jetty.gzip.includedMethodsQuery.toParamString(org.apache.felix.jetty.gzip.includedMethods))), ("orgApacheFelixJettyGzipExcludedMethods", Some(org.apache.felix.jetty.gzip.excludedMethodsQuery.toParamString(org.apache.felix.jetty.gzip.excludedMethods))), ("orgApacheFelixJettyGzipIncludedPaths", Some(org.apache.felix.jetty.gzip.includedPathsQuery.toParamString(org.apache.felix.jetty.gzip.includedPaths))), ("orgApacheFelixJettyGzipExcludedPaths", Some(org.apache.felix.jetty.gzip.excludedPathsQuery.toParamString(org.apache.felix.jetty.gzip.excludedPaths))), ("orgApacheFelixJettyGzipIncludedMimeTypes", Some(org.apache.felix.jetty.gzip.includedMimeTypesQuery.toParamString(org.apache.felix.jetty.gzip.includedMimeTypes))), ("orgApacheFelixJettyGzipExcludedMimeTypes", Some(org.apache.felix.jetty.gzip.excludedMimeTypesQuery.toParamString(org.apache.felix.jetty.gzip.excludedMimeTypes))), ("orgApacheFelixHttpSessionInvalidate", Some(org.apache.felix.http.session.invalidateQuery.toParamString(org.apache.felix.http.session.invalidate))), ("orgApacheFelixHttpSessionUniqueid", Some(org.apache.felix.http.session.uniqueidQuery.toParamString(org.apache.felix.http.session.uniqueid))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixHttpInfo](req)

    } yield resp
  }
  
  def orgApacheFelixHttpSslfilterSslFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], sslForwardHeader: String, sslForwardValue: String, sslForwardCertHeader: String, rewriteAbsoluteUrls: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], sslForwardHeaderQuery: QueryParam[String], sslForwardValueQuery: QueryParam[String], sslForwardCertHeaderQuery: QueryParam[String], rewriteAbsoluteUrlsQuery: QueryParam[Boolean]): Task[OrgApacheFelixHttpSslfilterSslFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixHttpSslfilterSslFilterInfo] = jsonOf[OrgApacheFelixHttpSslfilterSslFilterInfo]

    val path = "/system/console/configMgr/org.apache.felix.http.sslfilter.SslFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("sslForwardHeader", Some(ssl-forward.headerQuery.toParamString(ssl-forward.header))), ("sslForwardValue", Some(ssl-forward.valueQuery.toParamString(ssl-forward.value))), ("sslForwardCertHeader", Some(ssl-forward-cert.headerQuery.toParamString(ssl-forward-cert.header))), ("rewriteAbsoluteUrls", Some(rewrite.absolute.urlsQuery.toParamString(rewrite.absolute.urls))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixHttpSslfilterSslFilterInfo](req)

    } yield resp
  }
  
  def orgApacheFelixJaasConfigurationFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jaasControlFlag: String, jaasRanking: Integer, jaasRealmName: String, jaasClassname: String, jaasOptions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jaasControlFlagQuery: QueryParam[String], jaasRankingQuery: QueryParam[Integer], jaasRealmNameQuery: QueryParam[String], jaasClassnameQuery: QueryParam[String], jaasOptionsQuery: QueryParam[List[String]]): Task[OrgApacheFelixJaasConfigurationFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixJaasConfigurationFactoryInfo] = jsonOf[OrgApacheFelixJaasConfigurationFactoryInfo]

    val path = "/system/console/configMgr/org.apache.felix.jaas.Configuration.factory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jaasControlFlag", Some(jaas.controlFlagQuery.toParamString(jaas.controlFlag))), ("jaasRanking", Some(jaas.rankingQuery.toParamString(jaas.ranking))), ("jaasRealmName", Some(jaas.realmNameQuery.toParamString(jaas.realmName))), ("jaasClassname", Some(jaas.classnameQuery.toParamString(jaas.classname))), ("jaasOptions", Some(jaas.optionsQuery.toParamString(jaas.options))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixJaasConfigurationFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheFelixJaasConfigurationSpi(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jaasDefaultRealmName: String, jaasConfigProviderName: String, jaasGlobalConfigPolicy: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jaasDefaultRealmNameQuery: QueryParam[String], jaasConfigProviderNameQuery: QueryParam[String], jaasGlobalConfigPolicyQuery: QueryParam[String]): Task[OrgApacheFelixJaasConfigurationSpiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixJaasConfigurationSpiInfo] = jsonOf[OrgApacheFelixJaasConfigurationSpiInfo]

    val path = "/system/console/configMgr/org.apache.felix.jaas.ConfigurationSpi"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jaasDefaultRealmName", Some(jaas.defaultRealmNameQuery.toParamString(jaas.defaultRealmName))), ("jaasConfigProviderName", Some(jaas.configProviderNameQuery.toParamString(jaas.configProviderName))), ("jaasGlobalConfigPolicy", Some(jaas.globalConfigPolicyQuery.toParamString(jaas.globalConfigPolicy))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixJaasConfigurationSpiInfo](req)

    } yield resp
  }
  
  def orgApacheFelixScrScrService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], dsLoglevel: Integer, dsFactoryEnabled: Boolean, dsDelayedKeepInstances: Boolean, dsLockTimeoutMilliseconds: Integer, dsStopTimeoutMilliseconds: Integer, dsGlobalExtender: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], dsLoglevelQuery: QueryParam[Integer], dsFactoryEnabledQuery: QueryParam[Boolean], dsDelayedKeepInstancesQuery: QueryParam[Boolean], dsLockTimeoutMillisecondsQuery: QueryParam[Integer], dsStopTimeoutMillisecondsQuery: QueryParam[Integer], dsGlobalExtenderQuery: QueryParam[Boolean]): Task[OrgApacheFelixScrScrServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixScrScrServiceInfo] = jsonOf[OrgApacheFelixScrScrServiceInfo]

    val path = "/system/console/configMgr/org.apache.felix.scr.ScrService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("dsLoglevel", Some(ds.loglevelQuery.toParamString(ds.loglevel))), ("dsFactoryEnabled", Some(ds.factory.enabledQuery.toParamString(ds.factory.enabled))), ("dsDelayedKeepInstances", Some(ds.delayed.keepInstancesQuery.toParamString(ds.delayed.keepInstances))), ("dsLockTimeoutMilliseconds", Some(ds.lock.timeout.millisecondsQuery.toParamString(ds.lock.timeout.milliseconds))), ("dsStopTimeoutMilliseconds", Some(ds.stop.timeout.millisecondsQuery.toParamString(ds.stop.timeout.milliseconds))), ("dsGlobalExtender", Some(ds.global.extenderQuery.toParamString(ds.global.extender))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixScrScrServiceInfo](req)

    } yield resp
  }
  
  def orgApacheFelixSystemreadyImplComponentsCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], componentsList: List[String], `type`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], componentsListQuery: QueryParam[List[String]], `type`Query: QueryParam[String]): Task[OrgApacheFelixSystemreadyImplComponentsCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixSystemreadyImplComponentsCheckInfo] = jsonOf[OrgApacheFelixSystemreadyImplComponentsCheckInfo]

    val path = "/system/console/configMgr/org.apache.felix.systemready.impl.ComponentsCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("componentsList", Some(components.listQuery.toParamString(components.list))), ("`type`", Some(typeQuery.toParamString(type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixSystemreadyImplComponentsCheckInfo](req)

    } yield resp
  }
  
  def orgApacheFelixSystemreadyImplFrameworkStartCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], timeout: Integer, targetStartLevel: Integer, targetStartLevelPropName: String, `type`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], timeoutQuery: QueryParam[Integer], targetStartLevelQuery: QueryParam[Integer], targetStartLevelPropNameQuery: QueryParam[String], `type`Query: QueryParam[String]): Task[OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo] = jsonOf[OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo]

    val path = "/system/console/configMgr/org.apache.felix.systemready.impl.FrameworkStartCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("timeout", Some(timeoutQuery.toParamString(timeout))), ("targetStartLevel", Some(target.start.levelQuery.toParamString(target.start.level))), ("targetStartLevelPropName", Some(target.start.level.prop.nameQuery.toParamString(target.start.level.prop.name))), ("`type`", Some(typeQuery.toParamString(type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo](req)

    } yield resp
  }
  
  def orgApacheFelixSystemreadyImplServicesCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], servicesList: List[String], `type`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], servicesListQuery: QueryParam[List[String]], `type`Query: QueryParam[String]): Task[OrgApacheFelixSystemreadyImplServicesCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixSystemreadyImplServicesCheckInfo] = jsonOf[OrgApacheFelixSystemreadyImplServicesCheckInfo]

    val path = "/system/console/configMgr/org.apache.felix.systemready.impl.ServicesCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("servicesList", Some(services.listQuery.toParamString(services.list))), ("`type`", Some(typeQuery.toParamString(type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixSystemreadyImplServicesCheckInfo](req)

    } yield resp
  }
  
  def orgApacheFelixSystemreadyImplServletSystemAliveServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], osgiHttpWhiteboardServletPattern: String, osgiHttpWhiteboardContextSelect: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], osgiHttpWhiteboardServletPatternQuery: QueryParam[String], osgiHttpWhiteboardContextSelectQuery: QueryParam[String]): Task[OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo] = jsonOf[OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo]

    val path = "/system/console/configMgr/org.apache.felix.systemready.impl.servlet.SystemAliveServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("osgiHttpWhiteboardServletPattern", Some(osgi.http.whiteboard.servlet.patternQuery.toParamString(osgi.http.whiteboard.servlet.pattern))), ("osgiHttpWhiteboardContextSelect", Some(osgi.http.whiteboard.context.selectQuery.toParamString(osgi.http.whiteboard.context.select))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo](req)

    } yield resp
  }
  
  def orgApacheFelixSystemreadyImplServletSystemReadyServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], osgiHttpWhiteboardServletPattern: String, osgiHttpWhiteboardContextSelect: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], osgiHttpWhiteboardServletPatternQuery: QueryParam[String], osgiHttpWhiteboardContextSelectQuery: QueryParam[String]): Task[OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo] = jsonOf[OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo]

    val path = "/system/console/configMgr/org.apache.felix.systemready.impl.servlet.SystemReadyServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("osgiHttpWhiteboardServletPattern", Some(osgi.http.whiteboard.servlet.patternQuery.toParamString(osgi.http.whiteboard.servlet.pattern))), ("osgiHttpWhiteboardContextSelect", Some(osgi.http.whiteboard.context.selectQuery.toParamString(osgi.http.whiteboard.context.select))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo](req)

    } yield resp
  }
  
  def orgApacheFelixSystemreadySystemReadyMonitor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pollInterval: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pollIntervalQuery: QueryParam[Integer]): Task[OrgApacheFelixSystemreadySystemReadyMonitorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixSystemreadySystemReadyMonitorInfo] = jsonOf[OrgApacheFelixSystemreadySystemReadyMonitorInfo]

    val path = "/system/console/configMgr/org.apache.felix.systemready.SystemReadyMonitor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pollInterval", Some(poll.intervalQuery.toParamString(poll.interval))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixSystemreadySystemReadyMonitorInfo](req)

    } yield resp
  }
  
  def orgApacheFelixWebconsoleInternalServletOsgiManager(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], managerRoot: String, httpServiceFilter: String, defaultRender: String, realm: String, username: String, password: String, category: String, locale: String, loglevel: Integer, plugins: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], managerRootQuery: QueryParam[String], httpServiceFilterQuery: QueryParam[String], defaultRenderQuery: QueryParam[String], realmQuery: QueryParam[String], usernameQuery: QueryParam[String], passwordQuery: QueryParam[String], categoryQuery: QueryParam[String], localeQuery: QueryParam[String], loglevelQuery: QueryParam[Integer], pluginsQuery: QueryParam[String]): Task[OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo] = jsonOf[OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo]

    val path = "/system/console/configMgr/org.apache.felix.webconsole.internal.servlet.OsgiManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("managerRoot", Some(manager.rootQuery.toParamString(manager.root))), ("httpServiceFilter", Some(http.service.filterQuery.toParamString(http.service.filter))), ("defaultRender", Some(default.renderQuery.toParamString(default.render))), ("realm", Some(realmQuery.toParamString(realm))), ("username", Some(usernameQuery.toParamString(username))), ("password", Some(passwordQuery.toParamString(password))), ("category", Some(categoryQuery.toParamString(category))), ("locale", Some(localeQuery.toParamString(locale))), ("loglevel", Some(loglevelQuery.toParamString(loglevel))), ("plugins", Some(pluginsQuery.toParamString(plugins))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo](req)

    } yield resp
  }
  
  def orgApacheFelixWebconsolePluginsEventInternalPluginServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxSizeQuery: QueryParam[Integer]): Task[OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo] = jsonOf[OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo]

    val path = "/system/console/configMgr/org.apache.felix.webconsole.plugins.event.internal.PluginServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxSize", Some(max.sizeQuery.toParamString(max.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo](req)

    } yield resp
  }
  
  def orgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCo(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], felixMemoryusageDumpThreshold: Integer, felixMemoryusageDumpInterval: Integer, felixMemoryusageDumpLocation: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], felixMemoryusageDumpThresholdQuery: QueryParam[Integer], felixMemoryusageDumpIntervalQuery: QueryParam[Integer], felixMemoryusageDumpLocationQuery: QueryParam[String]): Task[OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo] = jsonOf[OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo]

    val path = "/system/console/configMgr/org.apache.felix.webconsole.plugins.memoryusage.internal.MemoryUsageConfigurator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("felixMemoryusageDumpThreshold", Some(felix.memoryusage.dump.thresholdQuery.toParamString(felix.memoryusage.dump.threshold))), ("felixMemoryusageDumpInterval", Some(felix.memoryusage.dump.intervalQuery.toParamString(felix.memoryusage.dump.interval))), ("felixMemoryusageDumpLocation", Some(felix.memoryusage.dump.locationQuery.toParamString(felix.memoryusage.dump.location))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo](req)

    } yield resp
  }
  
  def orgApacheHttpProxyconfigurator(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], proxyEnabled: Boolean, proxyHost: String, proxyPort: Integer, proxyUser: String, proxyPassword: String, proxyExceptions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], proxyEnabledQuery: QueryParam[Boolean], proxyHostQuery: QueryParam[String], proxyPortQuery: QueryParam[Integer], proxyUserQuery: QueryParam[String], proxyPasswordQuery: QueryParam[String], proxyExceptionsQuery: QueryParam[List[String]]): Task[OrgApacheHttpProxyconfiguratorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheHttpProxyconfiguratorInfo] = jsonOf[OrgApacheHttpProxyconfiguratorInfo]

    val path = "/system/console/configMgr/org.apache.http.proxyconfigurator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("proxyEnabled", Some(proxy.enabledQuery.toParamString(proxy.enabled))), ("proxyHost", Some(proxy.hostQuery.toParamString(proxy.host))), ("proxyPort", Some(proxy.portQuery.toParamString(proxy.port))), ("proxyUser", Some(proxy.userQuery.toParamString(proxy.user))), ("proxyPassword", Some(proxy.passwordQuery.toParamString(proxy.password))), ("proxyExceptions", Some(proxy.exceptionsQuery.toParamString(proxy.exceptions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheHttpProxyconfiguratorInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], dir: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], dirQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo] = jsonOf[OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.blob.datastore.DataStoreTextProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("dir", Some(dirQuery.toParamString(dir))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsBlobDatastoreFileDataStore(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo] = jsonOf[OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.blob.datastore.FileDataStore"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mongouri: String, db: String, socketKeepAlive: Boolean, cache: Integer, nodeCachePercentage: Integer, prevDocCachePercentage: Integer, childrenCachePercentage: Integer, diffCachePercentage: Integer, cacheSegmentCount: Integer, cacheStackMoveDistance: Integer, blobCacheSize: Integer, persistentCache: String, journalCache: String, customBlobStore: Boolean, journalGCInterval: Integer, journalGCMaxAge: Integer, prefetchExternalChanges: Boolean, role: String, versionGcMaxAgeInSecs: Integer, versionGCExpression: String, versionGCTimeLimitInSecs: Integer, blobGcMaxAgeInSecs: Integer, blobTrackSnapshotIntervalInSecs: Integer, repositoryHome: String, maxReplicationLagInSecs: Integer, documentStoreType: String, bundlingDisabled: Boolean, updateLimit: Integer, persistentCacheIncludes: List[String], leaseCheckMode: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mongouriQuery: QueryParam[String], dbQuery: QueryParam[String], socketKeepAliveQuery: QueryParam[Boolean], cacheQuery: QueryParam[Integer], nodeCachePercentageQuery: QueryParam[Integer], prevDocCachePercentageQuery: QueryParam[Integer], childrenCachePercentageQuery: QueryParam[Integer], diffCachePercentageQuery: QueryParam[Integer], cacheSegmentCountQuery: QueryParam[Integer], cacheStackMoveDistanceQuery: QueryParam[Integer], blobCacheSizeQuery: QueryParam[Integer], persistentCacheQuery: QueryParam[String], journalCacheQuery: QueryParam[String], customBlobStoreQuery: QueryParam[Boolean], journalGCIntervalQuery: QueryParam[Integer], journalGCMaxAgeQuery: QueryParam[Integer], prefetchExternalChangesQuery: QueryParam[Boolean], roleQuery: QueryParam[String], versionGcMaxAgeInSecsQuery: QueryParam[Integer], versionGCExpressionQuery: QueryParam[String], versionGCTimeLimitInSecsQuery: QueryParam[Integer], blobGcMaxAgeInSecsQuery: QueryParam[Integer], blobTrackSnapshotIntervalInSecsQuery: QueryParam[Integer], repositoryHomeQuery: QueryParam[String], maxReplicationLagInSecsQuery: QueryParam[Integer], documentStoreTypeQuery: QueryParam[String], bundlingDisabledQuery: QueryParam[Boolean], updateLimitQuery: QueryParam[Integer], persistentCacheIncludesQuery: QueryParam[List[String]], leaseCheckModeQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo] = jsonOf[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mongouri", Some(mongouriQuery.toParamString(mongouri))), ("db", Some(dbQuery.toParamString(db))), ("socketKeepAlive", Some(socketKeepAliveQuery.toParamString(socketKeepAlive))), ("cache", Some(cacheQuery.toParamString(cache))), ("nodeCachePercentage", Some(nodeCachePercentageQuery.toParamString(nodeCachePercentage))), ("prevDocCachePercentage", Some(prevDocCachePercentageQuery.toParamString(prevDocCachePercentage))), ("childrenCachePercentage", Some(childrenCachePercentageQuery.toParamString(childrenCachePercentage))), ("diffCachePercentage", Some(diffCachePercentageQuery.toParamString(diffCachePercentage))), ("cacheSegmentCount", Some(cacheSegmentCountQuery.toParamString(cacheSegmentCount))), ("cacheStackMoveDistance", Some(cacheStackMoveDistanceQuery.toParamString(cacheStackMoveDistance))), ("blobCacheSize", Some(blobCacheSizeQuery.toParamString(blobCacheSize))), ("persistentCache", Some(persistentCacheQuery.toParamString(persistentCache))), ("journalCache", Some(journalCacheQuery.toParamString(journalCache))), ("customBlobStore", Some(customBlobStoreQuery.toParamString(customBlobStore))), ("journalGCInterval", Some(journalGCIntervalQuery.toParamString(journalGCInterval))), ("journalGCMaxAge", Some(journalGCMaxAgeQuery.toParamString(journalGCMaxAge))), ("prefetchExternalChanges", Some(prefetchExternalChangesQuery.toParamString(prefetchExternalChanges))), ("role", Some(roleQuery.toParamString(role))), ("versionGcMaxAgeInSecs", Some(versionGcMaxAgeInSecsQuery.toParamString(versionGcMaxAgeInSecs))), ("versionGCExpression", Some(versionGCExpressionQuery.toParamString(versionGCExpression))), ("versionGCTimeLimitInSecs", Some(versionGCTimeLimitInSecsQuery.toParamString(versionGCTimeLimitInSecs))), ("blobGcMaxAgeInSecs", Some(blobGcMaxAgeInSecsQuery.toParamString(blobGcMaxAgeInSecs))), ("blobTrackSnapshotIntervalInSecs", Some(blobTrackSnapshotIntervalInSecsQuery.toParamString(blobTrackSnapshotIntervalInSecs))), ("repositoryHome", Some(repository.homeQuery.toParamString(repository.home))), ("maxReplicationLagInSecs", Some(maxReplicationLagInSecsQuery.toParamString(maxReplicationLagInSecs))), ("documentStoreType", Some(documentStoreTypeQuery.toParamString(documentStoreType))), ("bundlingDisabled", Some(bundlingDisabledQuery.toParamString(bundlingDisabled))), ("updateLimit", Some(updateLimitQuery.toParamString(updateLimit))), ("persistentCacheIncludes", Some(persistentCacheIncludesQuery.toParamString(persistentCacheIncludes))), ("leaseCheckMode", Some(leaseCheckModeQuery.toParamString(leaseCheckMode))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePre(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], persistentCacheIncludes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], persistentCacheIncludesQuery: QueryParam[List[String]]): Task[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo] = jsonOf[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreServicePreset"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("persistentCacheIncludes", Some(persistentCacheIncludesQuery.toParamString(persistentCacheIncludes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCac(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], includedPaths: List[String], enableAsyncObserver: Boolean, observerQueueSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], includedPathsQuery: QueryParam[List[String]], enableAsyncObserverQuery: QueryParam[Boolean], observerQueueSizeQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo] = jsonOf[OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.secondary.SecondaryStoreCacheService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("includedPaths", Some(includedPathsQuery.toParamString(includedPaths))), ("enableAsyncObserver", Some(enableAsyncObserverQuery.toParamString(enableAsyncObserver))), ("observerQueueSize", Some(observerQueueSizeQuery.toParamString(observerQueueSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexAsyncIndexerService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], asyncConfigs: List[String], leaseTimeOutMinutes: Integer, failingIndexTimeoutSeconds: Integer, errorWarnIntervalSeconds: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], asyncConfigsQuery: QueryParam[List[String]], leaseTimeOutMinutesQuery: QueryParam[Integer], failingIndexTimeoutSecondsQuery: QueryParam[Integer], errorWarnIntervalSecondsQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.AsyncIndexerService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("asyncConfigs", Some(asyncConfigsQuery.toParamString(asyncConfigs))), ("leaseTimeOutMinutes", Some(leaseTimeOutMinutesQuery.toParamString(leaseTimeOutMinutes))), ("failingIndexTimeoutSeconds", Some(failingIndexTimeoutSecondsQuery.toParamString(failingIndexTimeoutSeconds))), ("errorWarnIntervalSeconds", Some(errorWarnIntervalSecondsQuery.toParamString(errorWarnIntervalSeconds))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServ(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], disabled: Boolean, debug: Boolean, localIndexDir: String, enableOpenIndexAsync: Boolean, threadPoolSize: Integer, prefetchIndexFiles: Boolean, extractedTextCacheSizeInMB: Integer, extractedTextCacheExpiryInSecs: Integer, alwaysUsePreExtractedCache: Boolean, booleanClauseLimit: Integer, enableHybridIndexing: Boolean, hybridQueueSize: Integer, disableStoredIndexDefinition: Boolean, deletedBlobsCollectionEnabled: Boolean, propIndexCleanerIntervalInSecs: Integer, enableSingleBlobIndexFiles: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], disabledQuery: QueryParam[Boolean], debugQuery: QueryParam[Boolean], localIndexDirQuery: QueryParam[String], enableOpenIndexAsyncQuery: QueryParam[Boolean], threadPoolSizeQuery: QueryParam[Integer], prefetchIndexFilesQuery: QueryParam[Boolean], extractedTextCacheSizeInMBQuery: QueryParam[Integer], extractedTextCacheExpiryInSecsQuery: QueryParam[Integer], alwaysUsePreExtractedCacheQuery: QueryParam[Boolean], booleanClauseLimitQuery: QueryParam[Integer], enableHybridIndexingQuery: QueryParam[Boolean], hybridQueueSizeQuery: QueryParam[Integer], disableStoredIndexDefinitionQuery: QueryParam[Boolean], deletedBlobsCollectionEnabledQuery: QueryParam[Boolean], propIndexCleanerIntervalInSecsQuery: QueryParam[Integer], enableSingleBlobIndexFilesQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("disabled", Some(disabledQuery.toParamString(disabled))), ("debug", Some(debugQuery.toParamString(debug))), ("localIndexDir", Some(localIndexDirQuery.toParamString(localIndexDir))), ("enableOpenIndexAsync", Some(enableOpenIndexAsyncQuery.toParamString(enableOpenIndexAsync))), ("threadPoolSize", Some(threadPoolSizeQuery.toParamString(threadPoolSize))), ("prefetchIndexFiles", Some(prefetchIndexFilesQuery.toParamString(prefetchIndexFiles))), ("extractedTextCacheSizeInMB", Some(extractedTextCacheSizeInMBQuery.toParamString(extractedTextCacheSizeInMB))), ("extractedTextCacheExpiryInSecs", Some(extractedTextCacheExpiryInSecsQuery.toParamString(extractedTextCacheExpiryInSecs))), ("alwaysUsePreExtractedCache", Some(alwaysUsePreExtractedCacheQuery.toParamString(alwaysUsePreExtractedCache))), ("booleanClauseLimit", Some(booleanClauseLimitQuery.toParamString(booleanClauseLimit))), ("enableHybridIndexing", Some(enableHybridIndexingQuery.toParamString(enableHybridIndexing))), ("hybridQueueSize", Some(hybridQueueSizeQuery.toParamString(hybridQueueSize))), ("disableStoredIndexDefinition", Some(disableStoredIndexDefinitionQuery.toParamString(disableStoredIndexDefinition))), ("deletedBlobsCollectionEnabled", Some(deletedBlobsCollectionEnabledQuery.toParamString(deletedBlobsCollectionEnabled))), ("propIndexCleanerIntervalInSecs", Some(propIndexCleanerIntervalInSecsQuery.toParamString(propIndexCleanerIntervalInSecs))), ("enableSingleBlobIndexFiles", Some(enableSingleBlobIndexFilesQuery.toParamString(enableSingleBlobIndexFiles))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCo(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], solrHomePath: String, solrCoreName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], solrHomePathQuery: QueryParam[String], solrCoreNameQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.EmbeddedSolrServerConfigurationProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("solrHomePath", Some(solr.home.pathQuery.toParamString(solr.home.path))), ("solrCoreName", Some(solr.core.nameQuery.toParamString(solr.core.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServers(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.NodeStateSolrServersObserverService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfiguration(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pathDescField: String, pathChildField: String, pathParentField: String, pathExactField: String, catchAllField: String, collapsedPathField: String, pathDepthField: String, commitPolicy: String, rows: Integer, pathRestrictions: Boolean, propertyRestrictions: Boolean, primarytypesRestrictions: Boolean, ignoredProperties: List[String], usedProperties: List[String], typeMappings: List[String], propertyMappings: List[String], collapseJcrcontentNodes: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pathDescFieldQuery: QueryParam[String], pathChildFieldQuery: QueryParam[String], pathParentFieldQuery: QueryParam[String], pathExactFieldQuery: QueryParam[String], catchAllFieldQuery: QueryParam[String], collapsedPathFieldQuery: QueryParam[String], pathDepthFieldQuery: QueryParam[String], commitPolicyQuery: QueryParam[String], rowsQuery: QueryParam[Integer], pathRestrictionsQuery: QueryParam[Boolean], propertyRestrictionsQuery: QueryParam[Boolean], primarytypesRestrictionsQuery: QueryParam[Boolean], ignoredPropertiesQuery: QueryParam[List[String]], usedPropertiesQuery: QueryParam[List[String]], typeMappingsQuery: QueryParam[List[String]], propertyMappingsQuery: QueryParam[List[String]], collapseJcrcontentNodesQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.OakSolrConfigurationProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pathDescField", Some(path.desc.fieldQuery.toParamString(path.desc.field))), ("pathChildField", Some(path.child.fieldQuery.toParamString(path.child.field))), ("pathParentField", Some(path.parent.fieldQuery.toParamString(path.parent.field))), ("pathExactField", Some(path.exact.fieldQuery.toParamString(path.exact.field))), ("catchAllField", Some(catch.all.fieldQuery.toParamString(catch.all.field))), ("collapsedPathField", Some(collapsed.path.fieldQuery.toParamString(collapsed.path.field))), ("pathDepthField", Some(path.depth.fieldQuery.toParamString(path.depth.field))), ("commitPolicy", Some(commit.policyQuery.toParamString(commit.policy))), ("rows", Some(rowsQuery.toParamString(rows))), ("pathRestrictions", Some(path.restrictionsQuery.toParamString(path.restrictions))), ("propertyRestrictions", Some(property.restrictionsQuery.toParamString(property.restrictions))), ("primarytypesRestrictions", Some(primarytypes.restrictionsQuery.toParamString(primarytypes.restrictions))), ("ignoredProperties", Some(ignored.propertiesQuery.toParamString(ignored.properties))), ("usedProperties", Some(used.propertiesQuery.toParamString(used.properties))), ("typeMappings", Some(type.mappingsQuery.toParamString(type.mappings))), ("propertyMappings", Some(property.mappingsQuery.toParamString(property.mappings))), ("collapseJcrcontentNodes", Some(collapse.jcrcontent.nodesQuery.toParamString(collapse.jcrcontent.nodes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConf(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], solrHttpUrl: String, solrZkHost: String, solrCollection: String, solrSocketTimeout: Integer, solrConnectionTimeout: Integer, solrShardsNo: Integer, solrReplicationFactor: Integer, solrConfDir: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], solrHttpUrlQuery: QueryParam[String], solrZkHostQuery: QueryParam[String], solrCollectionQuery: QueryParam[String], solrSocketTimeoutQuery: QueryParam[Integer], solrConnectionTimeoutQuery: QueryParam[Integer], solrShardsNoQuery: QueryParam[Integer], solrReplicationFactorQuery: QueryParam[Integer], solrConfDirQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.RemoteSolrServerConfigurationProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("solrHttpUrl", Some(solr.http.urlQuery.toParamString(solr.http.url))), ("solrZkHost", Some(solr.zk.hostQuery.toParamString(solr.zk.host))), ("solrCollection", Some(solr.collectionQuery.toParamString(solr.collection))), ("solrSocketTimeout", Some(solr.socket.timeoutQuery.toParamString(solr.socket.timeout))), ("solrConnectionTimeout", Some(solr.connection.timeoutQuery.toParamString(solr.connection.timeout))), ("solrShardsNo", Some(solr.shards.noQuery.toParamString(solr.shards.no))), ("solrReplicationFactor", Some(solr.replication.factorQuery.toParamString(solr.replication.factor))), ("solrConfDir", Some(solr.conf.dirQuery.toParamString(solr.conf.dir))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvid(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], queryAggregation: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], queryAggregationQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.SolrQueryIndexProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("queryAggregation", Some(query.aggregationQuery.toParamString(query.aggregation))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSe(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serverType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serverTypeQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.SolrServerProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serverType", Some(server.typeQuery.toParamString(server.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsMetricStatisticsProviderFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerTypeQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo] = jsonOf[OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.metric.StatisticsProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerType", Some(providerTypeQuery.toParamString(providerType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsObservationChangeCollectorProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxItems: Integer, maxPathDepth: Integer, enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxItemsQuery: QueryParam[Integer], maxPathDepthQuery: QueryParam[Integer], enabledQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo] = jsonOf[OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.observation.ChangeCollectorProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxItems", Some(maxItemsQuery.toParamString(maxItems))), ("maxPathDepth", Some(maxPathDepthQuery.toParamString(maxPathDepth))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakQueryQueryEngineSettingsService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], queryLimitInMemory: Integer, queryLimitReads: Integer, queryFailTraversal: Boolean, fastQuerySize: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], queryLimitInMemoryQuery: QueryParam[Integer], queryLimitReadsQuery: QueryParam[Integer], queryFailTraversalQuery: QueryParam[Boolean], fastQuerySizeQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo] = jsonOf[OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.query.QueryEngineSettingsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("queryLimitInMemory", Some(queryLimitInMemoryQuery.toParamString(queryLimitInMemory))), ("queryLimitReads", Some(queryLimitReadsQuery.toParamString(queryLimitReads))), ("queryFailTraversal", Some(queryFailTraversalQuery.toParamString(queryFailTraversal))), ("fastQuerySize", Some(fastQuerySizeQuery.toParamString(fastQuerySize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheJackrabbitOakAuthenticationAppName: String, orgApacheJackrabbitOakAuthenticationConfigSpiName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheJackrabbitOakAuthenticationAppNameQuery: QueryParam[String], orgApacheJackrabbitOakAuthenticationConfigSpiNameQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo] = jsonOf[OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.AuthenticationConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheJackrabbitOakAuthenticationAppName", Some(org.apache.jackrabbit.oak.authentication.appNameQuery.toParamString(org.apache.jackrabbit.oak.authentication.appName))), ("orgApacheJackrabbitOakAuthenticationConfigSpiName", Some(org.apache.jackrabbit.oak.authentication.configSpiNameQuery.toParamString(org.apache.jackrabbit.oak.authentication.configSpiName))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdenti(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerName: String, hostName: String, hostPort: Integer, hostSsl: Boolean, hostTls: Boolean, hostNoCertCheck: Boolean, bindDn: String, bindPassword: String, searchTimeout: String, adminPoolMaxActive: Integer, adminPoolLookupOnValidate: Boolean, userPoolMaxActive: Integer, userPoolLookupOnValidate: Boolean, userBaseDN: String, userObjectclass: List[String], userIdAttribute: String, userExtraFilter: String, userMakeDnPath: Boolean, groupBaseDN: String, groupObjectclass: List[String], groupNameAttribute: String, groupExtraFilter: String, groupMakeDnPath: Boolean, groupMemberAttribute: String, useUidForExtId: Boolean, customattributes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerNameQuery: QueryParam[String], hostNameQuery: QueryParam[String], hostPortQuery: QueryParam[Integer], hostSslQuery: QueryParam[Boolean], hostTlsQuery: QueryParam[Boolean], hostNoCertCheckQuery: QueryParam[Boolean], bindDnQuery: QueryParam[String], bindPasswordQuery: QueryParam[String], searchTimeoutQuery: QueryParam[String], adminPoolMaxActiveQuery: QueryParam[Integer], adminPoolLookupOnValidateQuery: QueryParam[Boolean], userPoolMaxActiveQuery: QueryParam[Integer], userPoolLookupOnValidateQuery: QueryParam[Boolean], userBaseDNQuery: QueryParam[String], userObjectclassQuery: QueryParam[List[String]], userIdAttributeQuery: QueryParam[String], userExtraFilterQuery: QueryParam[String], userMakeDnPathQuery: QueryParam[Boolean], groupBaseDNQuery: QueryParam[String], groupObjectclassQuery: QueryParam[List[String]], groupNameAttributeQuery: QueryParam[String], groupExtraFilterQuery: QueryParam[String], groupMakeDnPathQuery: QueryParam[Boolean], groupMemberAttributeQuery: QueryParam[String], useUidForExtIdQuery: QueryParam[Boolean], customattributesQuery: QueryParam[List[String]]): Task[OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo] = jsonOf[OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerName", Some(provider.nameQuery.toParamString(provider.name))), ("hostName", Some(host.nameQuery.toParamString(host.name))), ("hostPort", Some(host.portQuery.toParamString(host.port))), ("hostSsl", Some(host.sslQuery.toParamString(host.ssl))), ("hostTls", Some(host.tlsQuery.toParamString(host.tls))), ("hostNoCertCheck", Some(host.noCertCheckQuery.toParamString(host.noCertCheck))), ("bindDn", Some(bind.dnQuery.toParamString(bind.dn))), ("bindPassword", Some(bind.passwordQuery.toParamString(bind.password))), ("searchTimeout", Some(searchTimeoutQuery.toParamString(searchTimeout))), ("adminPoolMaxActive", Some(adminPool.maxActiveQuery.toParamString(adminPool.maxActive))), ("adminPoolLookupOnValidate", Some(adminPool.lookupOnValidateQuery.toParamString(adminPool.lookupOnValidate))), ("userPoolMaxActive", Some(userPool.maxActiveQuery.toParamString(userPool.maxActive))), ("userPoolLookupOnValidate", Some(userPool.lookupOnValidateQuery.toParamString(userPool.lookupOnValidate))), ("userBaseDN", Some(user.baseDNQuery.toParamString(user.baseDN))), ("userObjectclass", Some(user.objectclassQuery.toParamString(user.objectclass))), ("userIdAttribute", Some(user.idAttributeQuery.toParamString(user.idAttribute))), ("userExtraFilter", Some(user.extraFilterQuery.toParamString(user.extraFilter))), ("userMakeDnPath", Some(user.makeDnPathQuery.toParamString(user.makeDnPath))), ("groupBaseDN", Some(group.baseDNQuery.toParamString(group.baseDN))), ("groupObjectclass", Some(group.objectclassQuery.toParamString(group.objectclass))), ("groupNameAttribute", Some(group.nameAttributeQuery.toParamString(group.nameAttribute))), ("groupExtraFilter", Some(group.extraFilterQuery.toParamString(group.extraFilter))), ("groupMakeDnPath", Some(group.makeDnPathQuery.toParamString(group.makeDnPath))), ("groupMemberAttribute", Some(group.memberAttributeQuery.toParamString(group.memberAttribute))), ("useUidForExtId", Some(useUidForExtIdQuery.toParamString(useUidForExtId))), ("customattributes", Some(customattributesQuery.toParamString(customattributes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfigura(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], tokenExpiration: String, tokenLength: String, tokenRefresh: Boolean, tokenCleanupThreshold: Integer, passwordHashAlgorithm: String, passwordHashIterations: Integer, passwordSaltSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], tokenExpirationQuery: QueryParam[String], tokenLengthQuery: QueryParam[String], tokenRefreshQuery: QueryParam[Boolean], tokenCleanupThresholdQuery: QueryParam[Integer], passwordHashAlgorithmQuery: QueryParam[String], passwordHashIterationsQuery: QueryParam[Integer], passwordSaltSizeQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo] = jsonOf[OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.token.TokenConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("tokenExpiration", Some(tokenExpirationQuery.toParamString(tokenExpiration))), ("tokenLength", Some(tokenLengthQuery.toParamString(tokenLength))), ("tokenRefresh", Some(tokenRefreshQuery.toParamString(tokenRefresh))), ("tokenCleanupThreshold", Some(tokenCleanupThresholdQuery.toParamString(tokenCleanupThreshold))), ("passwordHashAlgorithm", Some(passwordHashAlgorithmQuery.toParamString(passwordHashAlgorithm))), ("passwordHashIterations", Some(passwordHashIterationsQuery.toParamString(passwordHashIterations))), ("passwordSaltSize", Some(passwordSaltSizeQuery.toParamString(passwordSaltSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigur(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], permissionsJr2: String, importBehavior: String, readPaths: List[String], administrativePrincipals: List[String], configurationRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], permissionsJr2Query: QueryParam[String], importBehaviorQuery: QueryParam[String], readPathsQuery: QueryParam[List[String]], administrativePrincipalsQuery: QueryParam[List[String]], configurationRankingQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo] = jsonOf[OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.authorization.AuthorizationConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("permissionsJr2", Some(permissionsJr2Query.toParamString(permissionsJr2))), ("importBehavior", Some(importBehaviorQuery.toParamString(importBehavior))), ("readPaths", Some(readPathsQuery.toParamString(readPaths))), ("administrativePrincipals", Some(administrativePrincipalsQuery.toParamString(administrativePrincipals))), ("configurationRanking", Some(configurationRankingQuery.toParamString(configurationRanking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityInternalSecurityProviderRegistrati(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], requiredServicePids: List[String], authorizationCompositionType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], requiredServicePidsQuery: QueryParam[List[String]], authorizationCompositionTypeQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo] = jsonOf[OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.internal.SecurityProviderRegistration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("requiredServicePids", Some(requiredServicePidsQuery.toParamString(requiredServicePids))), ("authorizationCompositionType", Some(authorizationCompositionTypeQuery.toParamString(authorizationCompositionType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeName(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], length: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], lengthQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo] = jsonOf[OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.user.RandomAuthorizableNodeName"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("length", Some(lengthQuery.toParamString(length))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityUserUserConfigurationImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], usersPath: String, groupsPath: String, systemRelativePath: String, defaultDepth: Integer, importBehavior: String, passwordHashAlgorithm: String, passwordHashIterations: Integer, passwordSaltSize: Integer, omitAdminPw: Boolean, supportAutoSave: Boolean, passwordMaxAge: Integer, initialPasswordChange: Boolean, passwordHistorySize: Integer, passwordExpiryForAdmin: Boolean, cacheExpiration: Integer, enableRFC7613UsercaseMappedProfile: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], usersPathQuery: QueryParam[String], groupsPathQuery: QueryParam[String], systemRelativePathQuery: QueryParam[String], defaultDepthQuery: QueryParam[Integer], importBehaviorQuery: QueryParam[String], passwordHashAlgorithmQuery: QueryParam[String], passwordHashIterationsQuery: QueryParam[Integer], passwordSaltSizeQuery: QueryParam[Integer], omitAdminPwQuery: QueryParam[Boolean], supportAutoSaveQuery: QueryParam[Boolean], passwordMaxAgeQuery: QueryParam[Integer], initialPasswordChangeQuery: QueryParam[Boolean], passwordHistorySizeQuery: QueryParam[Integer], passwordExpiryForAdminQuery: QueryParam[Boolean], cacheExpirationQuery: QueryParam[Integer], enableRFC7613UsercaseMappedProfileQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo] = jsonOf[OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.user.UserConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("usersPath", Some(usersPathQuery.toParamString(usersPath))), ("groupsPath", Some(groupsPathQuery.toParamString(groupsPath))), ("systemRelativePath", Some(systemRelativePathQuery.toParamString(systemRelativePath))), ("defaultDepth", Some(defaultDepthQuery.toParamString(defaultDepth))), ("importBehavior", Some(importBehaviorQuery.toParamString(importBehavior))), ("passwordHashAlgorithm", Some(passwordHashAlgorithmQuery.toParamString(passwordHashAlgorithm))), ("passwordHashIterations", Some(passwordHashIterationsQuery.toParamString(passwordHashIterations))), ("passwordSaltSize", Some(passwordSaltSizeQuery.toParamString(passwordSaltSize))), ("omitAdminPw", Some(omitAdminPwQuery.toParamString(omitAdminPw))), ("supportAutoSave", Some(supportAutoSaveQuery.toParamString(supportAutoSave))), ("passwordMaxAge", Some(passwordMaxAgeQuery.toParamString(passwordMaxAge))), ("initialPasswordChange", Some(initialPasswordChangeQuery.toParamString(initialPasswordChange))), ("passwordHistorySize", Some(passwordHistorySizeQuery.toParamString(passwordHistorySize))), ("passwordExpiryForAdmin", Some(passwordExpiryForAdminQuery.toParamString(passwordExpiryForAdmin))), ("cacheExpiration", Some(cacheExpirationQuery.toParamString(cacheExpiration))), ("enableRFC7613UsercaseMappedProfile", Some(enableRFC7613UsercaseMappedProfileQuery.toParamString(enableRFC7613UsercaseMappedProfile))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSegmentAzureAzureSegmentStoreService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], accountName: String, containerName: String, accessKey: String, rootPath: String, connectionURL: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], accountNameQuery: QueryParam[String], containerNameQuery: QueryParam[String], accessKeyQuery: QueryParam[String], rootPathQuery: QueryParam[String], connectionURLQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo] = jsonOf[OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.segment.azure.AzureSegmentStoreService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("accountName", Some(accountNameQuery.toParamString(accountName))), ("containerName", Some(containerNameQuery.toParamString(containerName))), ("accessKey", Some(accessKeyQuery.toParamString(accessKey))), ("rootPath", Some(rootPathQuery.toParamString(rootPath))), ("connectionURL", Some(connectionURLQuery.toParamString(connectionURL))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSegmentSegmentNodeStoreFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], repositoryHome: String, tarmkMode: String, tarmkSize: Integer, segmentCacheSize: Integer, stringCacheSize: Integer, templateCacheSize: Integer, stringDeduplicationCacheSize: Integer, templateDeduplicationCacheSize: Integer, nodeDeduplicationCacheSize: Integer, pauseCompaction: Boolean, compactionRetryCount: Integer, compactionForceTimeout: Integer, compactionSizeDeltaEstimation: Integer, compactionDisableEstimation: Boolean, compactionRetainedGenerations: Integer, compactionMemoryThreshold: Integer, compactionProgressLog: Integer, standby: Boolean, customBlobStore: Boolean, customSegmentStore: Boolean, splitPersistence: Boolean, repositoryBackupDir: String, blobGcMaxAgeInSecs: Integer, blobTrackSnapshotIntervalInSecs: Integer, role: String, registerDescriptors: Boolean, dispatchChanges: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], repositoryHomeQuery: QueryParam[String], tarmkModeQuery: QueryParam[String], tarmkSizeQuery: QueryParam[Integer], segmentCacheSizeQuery: QueryParam[Integer], stringCacheSizeQuery: QueryParam[Integer], templateCacheSizeQuery: QueryParam[Integer], stringDeduplicationCacheSizeQuery: QueryParam[Integer], templateDeduplicationCacheSizeQuery: QueryParam[Integer], nodeDeduplicationCacheSizeQuery: QueryParam[Integer], pauseCompactionQuery: QueryParam[Boolean], compactionRetryCountQuery: QueryParam[Integer], compactionForceTimeoutQuery: QueryParam[Integer], compactionSizeDeltaEstimationQuery: QueryParam[Integer], compactionDisableEstimationQuery: QueryParam[Boolean], compactionRetainedGenerationsQuery: QueryParam[Integer], compactionMemoryThresholdQuery: QueryParam[Integer], compactionProgressLogQuery: QueryParam[Integer], standbyQuery: QueryParam[Boolean], customBlobStoreQuery: QueryParam[Boolean], customSegmentStoreQuery: QueryParam[Boolean], splitPersistenceQuery: QueryParam[Boolean], repositoryBackupDirQuery: QueryParam[String], blobGcMaxAgeInSecsQuery: QueryParam[Integer], blobTrackSnapshotIntervalInSecsQuery: QueryParam[Integer], roleQuery: QueryParam[String], registerDescriptorsQuery: QueryParam[Boolean], dispatchChangesQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo] = jsonOf[OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("repositoryHome", Some(repository.homeQuery.toParamString(repository.home))), ("tarmkMode", Some(tarmk.modeQuery.toParamString(tarmk.mode))), ("tarmkSize", Some(tarmk.sizeQuery.toParamString(tarmk.size))), ("segmentCacheSize", Some(segmentCache.sizeQuery.toParamString(segmentCache.size))), ("stringCacheSize", Some(stringCache.sizeQuery.toParamString(stringCache.size))), ("templateCacheSize", Some(templateCache.sizeQuery.toParamString(templateCache.size))), ("stringDeduplicationCacheSize", Some(stringDeduplicationCache.sizeQuery.toParamString(stringDeduplicationCache.size))), ("templateDeduplicationCacheSize", Some(templateDeduplicationCache.sizeQuery.toParamString(templateDeduplicationCache.size))), ("nodeDeduplicationCacheSize", Some(nodeDeduplicationCache.sizeQuery.toParamString(nodeDeduplicationCache.size))), ("pauseCompaction", Some(pauseCompactionQuery.toParamString(pauseCompaction))), ("compactionRetryCount", Some(compaction.retryCountQuery.toParamString(compaction.retryCount))), ("compactionForceTimeout", Some(compaction.force.timeoutQuery.toParamString(compaction.force.timeout))), ("compactionSizeDeltaEstimation", Some(compaction.sizeDeltaEstimationQuery.toParamString(compaction.sizeDeltaEstimation))), ("compactionDisableEstimation", Some(compaction.disableEstimationQuery.toParamString(compaction.disableEstimation))), ("compactionRetainedGenerations", Some(compaction.retainedGenerationsQuery.toParamString(compaction.retainedGenerations))), ("compactionMemoryThreshold", Some(compaction.memoryThresholdQuery.toParamString(compaction.memoryThreshold))), ("compactionProgressLog", Some(compaction.progressLogQuery.toParamString(compaction.progressLog))), ("standby", Some(standbyQuery.toParamString(standby))), ("customBlobStore", Some(customBlobStoreQuery.toParamString(customBlobStore))), ("customSegmentStore", Some(customSegmentStoreQuery.toParamString(customSegmentStore))), ("splitPersistence", Some(splitPersistenceQuery.toParamString(splitPersistence))), ("repositoryBackupDir", Some(repository.backup.dirQuery.toParamString(repository.backup.dir))), ("blobGcMaxAgeInSecs", Some(blobGcMaxAgeInSecsQuery.toParamString(blobGcMaxAgeInSecs))), ("blobTrackSnapshotIntervalInSecs", Some(blobTrackSnapshotIntervalInSecsQuery.toParamString(blobTrackSnapshotIntervalInSecs))), ("role", Some(roleQuery.toParamString(role))), ("registerDescriptors", Some(registerDescriptorsQuery.toParamString(registerDescriptors))), ("dispatchChanges", Some(dispatchChangesQuery.toParamString(dispatchChanges))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], commitsTrackerWriterGroups: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], commitsTrackerWriterGroupsQuery: QueryParam[List[String]]): Task[OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo] = jsonOf[OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreMonitorService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("commitsTrackerWriterGroups", Some(commitsTrackerWriterGroupsQuery.toParamString(commitsTrackerWriterGroups))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSegmentSegmentNodeStoreService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], repositoryHome: String, tarmkMode: String, tarmkSize: Integer, segmentCacheSize: Integer, stringCacheSize: Integer, templateCacheSize: Integer, stringDeduplicationCacheSize: Integer, templateDeduplicationCacheSize: Integer, nodeDeduplicationCacheSize: Integer, pauseCompaction: Boolean, compactionRetryCount: Integer, compactionForceTimeout: Integer, compactionSizeDeltaEstimation: Integer, compactionDisableEstimation: Boolean, compactionRetainedGenerations: Integer, compactionMemoryThreshold: Integer, compactionProgressLog: Integer, standby: Boolean, customBlobStore: Boolean, customSegmentStore: Boolean, splitPersistence: Boolean, repositoryBackupDir: String, blobGcMaxAgeInSecs: Integer, blobTrackSnapshotIntervalInSecs: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], repositoryHomeQuery: QueryParam[String], tarmkModeQuery: QueryParam[String], tarmkSizeQuery: QueryParam[Integer], segmentCacheSizeQuery: QueryParam[Integer], stringCacheSizeQuery: QueryParam[Integer], templateCacheSizeQuery: QueryParam[Integer], stringDeduplicationCacheSizeQuery: QueryParam[Integer], templateDeduplicationCacheSizeQuery: QueryParam[Integer], nodeDeduplicationCacheSizeQuery: QueryParam[Integer], pauseCompactionQuery: QueryParam[Boolean], compactionRetryCountQuery: QueryParam[Integer], compactionForceTimeoutQuery: QueryParam[Integer], compactionSizeDeltaEstimationQuery: QueryParam[Integer], compactionDisableEstimationQuery: QueryParam[Boolean], compactionRetainedGenerationsQuery: QueryParam[Integer], compactionMemoryThresholdQuery: QueryParam[Integer], compactionProgressLogQuery: QueryParam[Integer], standbyQuery: QueryParam[Boolean], customBlobStoreQuery: QueryParam[Boolean], customSegmentStoreQuery: QueryParam[Boolean], splitPersistenceQuery: QueryParam[Boolean], repositoryBackupDirQuery: QueryParam[String], blobGcMaxAgeInSecsQuery: QueryParam[Integer], blobTrackSnapshotIntervalInSecsQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo] = jsonOf[OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("repositoryHome", Some(repository.homeQuery.toParamString(repository.home))), ("tarmkMode", Some(tarmk.modeQuery.toParamString(tarmk.mode))), ("tarmkSize", Some(tarmk.sizeQuery.toParamString(tarmk.size))), ("segmentCacheSize", Some(segmentCache.sizeQuery.toParamString(segmentCache.size))), ("stringCacheSize", Some(stringCache.sizeQuery.toParamString(stringCache.size))), ("templateCacheSize", Some(templateCache.sizeQuery.toParamString(templateCache.size))), ("stringDeduplicationCacheSize", Some(stringDeduplicationCache.sizeQuery.toParamString(stringDeduplicationCache.size))), ("templateDeduplicationCacheSize", Some(templateDeduplicationCache.sizeQuery.toParamString(templateDeduplicationCache.size))), ("nodeDeduplicationCacheSize", Some(nodeDeduplicationCache.sizeQuery.toParamString(nodeDeduplicationCache.size))), ("pauseCompaction", Some(pauseCompactionQuery.toParamString(pauseCompaction))), ("compactionRetryCount", Some(compaction.retryCountQuery.toParamString(compaction.retryCount))), ("compactionForceTimeout", Some(compaction.force.timeoutQuery.toParamString(compaction.force.timeout))), ("compactionSizeDeltaEstimation", Some(compaction.sizeDeltaEstimationQuery.toParamString(compaction.sizeDeltaEstimation))), ("compactionDisableEstimation", Some(compaction.disableEstimationQuery.toParamString(compaction.disableEstimation))), ("compactionRetainedGenerations", Some(compaction.retainedGenerationsQuery.toParamString(compaction.retainedGenerations))), ("compactionMemoryThreshold", Some(compaction.memoryThresholdQuery.toParamString(compaction.memoryThreshold))), ("compactionProgressLog", Some(compaction.progressLogQuery.toParamString(compaction.progressLog))), ("standby", Some(standbyQuery.toParamString(standby))), ("customBlobStore", Some(customBlobStoreQuery.toParamString(customBlobStore))), ("customSegmentStore", Some(customSegmentStoreQuery.toParamString(customSegmentStore))), ("splitPersistence", Some(splitPersistenceQuery.toParamString(splitPersistence))), ("repositoryBackupDir", Some(repository.backup.dirQuery.toParamString(repository.backup.dir))), ("blobGcMaxAgeInSecs", Some(blobGcMaxAgeInSecsQuery.toParamString(blobGcMaxAgeInSecs))), ("blobTrackSnapshotIntervalInSecs", Some(blobTrackSnapshotIntervalInSecsQuery.toParamString(blobTrackSnapshotIntervalInSecs))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingInstallerConfigurationPersist: Boolean, mode: String, port: Integer, primaryHost: String, interval: Integer, primaryAllowedClientIpRanges: List[String], secure: Boolean, standbyReadtimeout: Integer, standbyAutoclean: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingInstallerConfigurationPersistQuery: QueryParam[Boolean], modeQuery: QueryParam[String], portQuery: QueryParam[Integer], primaryHostQuery: QueryParam[String], intervalQuery: QueryParam[Integer], primaryAllowedClientIpRangesQuery: QueryParam[List[String]], secureQuery: QueryParam[Boolean], standbyReadtimeoutQuery: QueryParam[Integer], standbyAutocleanQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo] = jsonOf[OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.segment.standby.store.StandbyStoreService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingInstallerConfigurationPersist", Some(org.apache.sling.installer.configuration.persistQuery.toParamString(org.apache.sling.installer.configuration.persist))), ("mode", Some(modeQuery.toParamString(mode))), ("port", Some(portQuery.toParamString(port))), ("primaryHost", Some(primary.hostQuery.toParamString(primary.host))), ("interval", Some(intervalQuery.toParamString(interval))), ("primaryAllowedClientIpRanges", Some(primary.allowed-client-ip-rangesQuery.toParamString(primary.allowed-client-ip-ranges))), ("secure", Some(secureQuery.toParamString(secure))), ("standbyReadtimeout", Some(standby.readtimeoutQuery.toParamString(standby.readtimeout))), ("standbyAutoclean", Some(standby.autocleanQuery.toParamString(standby.autoclean))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDe(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], handlerName: String, userExpirationTime: String, userAutoMembership: List[String], userPropertyMapping: List[String], userPathPrefix: String, userMembershipExpTime: String, userMembershipNestingDepth: Integer, userDynamicMembership: Boolean, userDisableMissing: Boolean, groupExpirationTime: String, groupAutoMembership: List[String], groupPropertyMapping: List[String], groupPathPrefix: String, enableRFC7613UsercaseMappedProfile: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], handlerNameQuery: QueryParam[String], userExpirationTimeQuery: QueryParam[String], userAutoMembershipQuery: QueryParam[List[String]], userPropertyMappingQuery: QueryParam[List[String]], userPathPrefixQuery: QueryParam[String], userMembershipExpTimeQuery: QueryParam[String], userMembershipNestingDepthQuery: QueryParam[Integer], userDynamicMembershipQuery: QueryParam[Boolean], userDisableMissingQuery: QueryParam[Boolean], groupExpirationTimeQuery: QueryParam[String], groupAutoMembershipQuery: QueryParam[List[String]], groupPropertyMappingQuery: QueryParam[List[String]], groupPathPrefixQuery: QueryParam[String], enableRFC7613UsercaseMappedProfileQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo] = jsonOf[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.DefaultSyncHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("handlerName", Some(handler.nameQuery.toParamString(handler.name))), ("userExpirationTime", Some(user.expirationTimeQuery.toParamString(user.expirationTime))), ("userAutoMembership", Some(user.autoMembershipQuery.toParamString(user.autoMembership))), ("userPropertyMapping", Some(user.propertyMappingQuery.toParamString(user.propertyMapping))), ("userPathPrefix", Some(user.pathPrefixQuery.toParamString(user.pathPrefix))), ("userMembershipExpTime", Some(user.membershipExpTimeQuery.toParamString(user.membershipExpTime))), ("userMembershipNestingDepth", Some(user.membershipNestingDepthQuery.toParamString(user.membershipNestingDepth))), ("userDynamicMembership", Some(user.dynamicMembershipQuery.toParamString(user.dynamicMembership))), ("userDisableMissing", Some(user.disableMissingQuery.toParamString(user.disableMissing))), ("groupExpirationTime", Some(group.expirationTimeQuery.toParamString(group.expirationTime))), ("groupAutoMembership", Some(group.autoMembershipQuery.toParamString(group.autoMembership))), ("groupPropertyMapping", Some(group.propertyMappingQuery.toParamString(group.propertyMapping))), ("groupPathPrefix", Some(group.pathPrefixQuery.toParamString(group.pathPrefix))), ("enableRFC7613UsercaseMappedProfile", Some(enableRFC7613UsercaseMappedProfileQuery.toParamString(enableRFC7613UsercaseMappedProfile))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplEx(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jaasRanking: Integer, jaasControlFlag: String, jaasRealmName: String, idpName: String, syncHandlerName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jaasRankingQuery: QueryParam[Integer], jaasControlFlagQuery: QueryParam[String], jaasRealmNameQuery: QueryParam[String], idpNameQuery: QueryParam[String], syncHandlerNameQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo] = jsonOf[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.ExternalLoginModuleFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jaasRanking", Some(jaas.rankingQuery.toParamString(jaas.ranking))), ("jaasControlFlag", Some(jaas.controlFlagQuery.toParamString(jaas.controlFlag))), ("jaasRealmName", Some(jaas.realmNameQuery.toParamString(jaas.realmName))), ("idpName", Some(idp.nameQuery.toParamString(idp.name))), ("syncHandlerName", Some(sync.handlerNameQuery.toParamString(sync.handlerName))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPr(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], protectExternalId: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], protectExternalIdQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo] = jsonOf[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.principal.ExternalPrincipalConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("protectExternalId", Some(protectExternalIdQuery.toParamString(protectExternalId))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfi(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cugSupportedPaths: List[String], cugEnabled: Boolean, configurationRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cugSupportedPathsQuery: QueryParam[List[String]], cugEnabledQuery: QueryParam[Boolean], configurationRankingQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo] = jsonOf[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authorization.cug.impl.CugConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cugSupportedPaths", Some(cugSupportedPathsQuery.toParamString(cugSupportedPaths))), ("cugEnabled", Some(cugEnabledQuery.toParamString(cugEnabled))), ("configurationRanking", Some(configurationRankingQuery.toParamString(configurationRanking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExclu(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], principalNames: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], principalNamesQuery: QueryParam[List[String]]): Task[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo] = jsonOf[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authorization.cug.impl.CugExcludeImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("principalNames", Some(principalNamesQuery.toParamString(principalNames))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizable(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabledActions: String, userPrivilegeNames: List[String], groupPrivilegeNames: List[String], constraint: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledActionsQuery: QueryParam[String], userPrivilegeNamesQuery: QueryParam[List[String]], groupPrivilegeNamesQuery: QueryParam[List[String]], constraintQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo] = jsonOf[OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.user.action.DefaultAuthorizableActionProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabledActions", Some(enabledActionsQuery.toParamString(enabledActions))), ("userPrivilegeNames", Some(userPrivilegeNamesQuery.toParamString(userPrivilegeNames))), ("groupPrivilegeNames", Some(groupPrivilegeNamesQuery.toParamString(groupPrivilegeNames))), ("constraint", Some(constraintQuery.toParamString(constraint))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitVaultPackagingImplPackagingImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], packageRoots: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], packageRootsQuery: QueryParam[List[String]]): Task[OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo] = jsonOf[OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.vault.packaging.impl.PackagingImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("packageRoots", Some(packageRootsQuery.toParamString(packageRoots))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistry(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], homePath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], homePathQuery: QueryParam[String]): Task[OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo] = jsonOf[OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.vault.packaging.registry.impl.FSPackageRegistry"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("homePath", Some(homePathQuery.toParamString(homePath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingAuthCoreImplLogoutServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletMethods: List[String], slingServletPaths: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletMethodsQuery: QueryParam[List[String]], slingServletPathsQuery: QueryParam[String]): Task[OrgApacheSlingAuthCoreImplLogoutServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingAuthCoreImplLogoutServletInfo] = jsonOf[OrgApacheSlingAuthCoreImplLogoutServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.auth.core.impl.LogoutServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))), ("slingServletPaths", Some(sling.servlet.pathsQuery.toParamString(sling.servlet.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingAuthCoreImplLogoutServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigImplConfigurationBindingsValueProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo] = jsonOf[OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.impl.ConfigurationBindingsValueProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigImplConfigurationResolverImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], configBucketNames: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], configBucketNamesQuery: QueryParam[List[String]]): Task[OrgApacheSlingCaconfigImplConfigurationResolverImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigImplConfigurationResolverImplInfo] = jsonOf[OrgApacheSlingCaconfigImplConfigurationResolverImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.impl.ConfigurationResolverImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("configBucketNames", Some(configBucketNamesQuery.toParamString(configBucketNames))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigImplConfigurationResolverImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStra(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, configPropertyInheritancePropertyNames: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], configPropertyInheritancePropertyNamesQuery: QueryParam[List[String]]): Task[OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo] = jsonOf[OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.impl.def.DefaultConfigurationInheritanceStrategy"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("configPropertyInheritancePropertyNames", Some(configPropertyInheritancePropertyNamesQuery.toParamString(configPropertyInheritancePropertyNames))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStra(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo] = jsonOf[OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.impl.def.DefaultConfigurationPersistenceStrategy"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProvi(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], description: String, overrides: List[String], enabled: Boolean, serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], descriptionQuery: QueryParam[String], overridesQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], serviceRankingQuery: QueryParam[Integer]): Task[OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo] = jsonOf[OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.impl.override.OsgiConfigurationOverrideProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("description", Some(descriptionQuery.toParamString(description))), ("overrides", Some(overridesQuery.toParamString(overrides))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOve(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], serviceRankingQuery: QueryParam[Integer]): Task[OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo] = jsonOf[OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.impl.override.SystemPropertyConfigurationOverrideProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigManagementImplConfigurationManagementSetti(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], ignorePropertyNameRegex: List[String], configCollectionPropertiesResourceNames: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], ignorePropertyNameRegexQuery: QueryParam[List[String]], configCollectionPropertiesResourceNamesQuery: QueryParam[List[String]]): Task[OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo] = jsonOf[OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.management.impl.ConfigurationManagementSettingsImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("ignorePropertyNameRegex", Some(ignorePropertyNameRegexQuery.toParamString(ignorePropertyNameRegex))), ("configCollectionPropertiesResourceNames", Some(configCollectionPropertiesResourceNamesQuery.toParamString(configCollectionPropertiesResourceNames))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigResourceImplDefDefaultConfigurationResour(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, configPath: String, fallbackPaths: List[String], configCollectionInheritancePropertyNames: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], configPathQuery: QueryParam[String], fallbackPathsQuery: QueryParam[List[String]], configCollectionInheritancePropertyNamesQuery: QueryParam[List[String]]): Task[OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo] = jsonOf[OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.resource.impl.def.DefaultConfigurationResourceResolvingStrategy"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("configPath", Some(configPathQuery.toParamString(configPath))), ("fallbackPaths", Some(fallbackPathsQuery.toParamString(fallbackPaths))), ("configCollectionInheritancePropertyNames", Some(configCollectionInheritancePropertyNamesQuery.toParamString(configCollectionInheritancePropertyNames))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategy(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, configRefResourceNames: List[String], configRefPropertyNames: List[String], serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], configRefResourceNamesQuery: QueryParam[List[String]], configRefPropertyNamesQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer]): Task[OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo] = jsonOf[OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.resource.impl.def.DefaultContextPathStrategy"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("configRefResourceNames", Some(configRefResourceNamesQuery.toParamString(configRefResourceNames))), ("configRefPropertyNames", Some(configRefPropertyNamesQuery.toParamString(configRefPropertyNames))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsHtmlInternalTagsoupHtmlParser(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], parserFeatures: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], parserFeaturesQuery: QueryParam[List[String]]): Task[OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo] = jsonOf[OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.html.internal.TagsoupHtmlParser"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("parserFeatures", Some(parser.featuresQuery.toParamString(parser.features))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsLogLogManager(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingCommonsLogLevel: String, orgApacheSlingCommonsLogFile: String, orgApacheSlingCommonsLogFileNumber: Integer, orgApacheSlingCommonsLogFileSize: String, orgApacheSlingCommonsLogPattern: String, orgApacheSlingCommonsLogConfigurationFile: String, orgApacheSlingCommonsLogPackagingDataEnabled: Boolean, orgApacheSlingCommonsLogMaxCallerDataDepth: Integer, orgApacheSlingCommonsLogMaxOldFileCountInDump: Integer, orgApacheSlingCommonsLogNumOfLines: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingCommonsLogLevelQuery: QueryParam[String], orgApacheSlingCommonsLogFileQuery: QueryParam[String], orgApacheSlingCommonsLogFileNumberQuery: QueryParam[Integer], orgApacheSlingCommonsLogFileSizeQuery: QueryParam[String], orgApacheSlingCommonsLogPatternQuery: QueryParam[String], orgApacheSlingCommonsLogConfigurationFileQuery: QueryParam[String], orgApacheSlingCommonsLogPackagingDataEnabledQuery: QueryParam[Boolean], orgApacheSlingCommonsLogMaxCallerDataDepthQuery: QueryParam[Integer], orgApacheSlingCommonsLogMaxOldFileCountInDumpQuery: QueryParam[Integer], orgApacheSlingCommonsLogNumOfLinesQuery: QueryParam[Integer]): Task[OrgApacheSlingCommonsLogLogManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsLogLogManagerInfo] = jsonOf[OrgApacheSlingCommonsLogLogManagerInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.log.LogManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingCommonsLogLevel", Some(org.apache.sling.commons.log.levelQuery.toParamString(org.apache.sling.commons.log.level))), ("orgApacheSlingCommonsLogFile", Some(org.apache.sling.commons.log.fileQuery.toParamString(org.apache.sling.commons.log.file))), ("orgApacheSlingCommonsLogFileNumber", Some(org.apache.sling.commons.log.file.numberQuery.toParamString(org.apache.sling.commons.log.file.number))), ("orgApacheSlingCommonsLogFileSize", Some(org.apache.sling.commons.log.file.sizeQuery.toParamString(org.apache.sling.commons.log.file.size))), ("orgApacheSlingCommonsLogPattern", Some(org.apache.sling.commons.log.patternQuery.toParamString(org.apache.sling.commons.log.pattern))), ("orgApacheSlingCommonsLogConfigurationFile", Some(org.apache.sling.commons.log.configurationFileQuery.toParamString(org.apache.sling.commons.log.configurationFile))), ("orgApacheSlingCommonsLogPackagingDataEnabled", Some(org.apache.sling.commons.log.packagingDataEnabledQuery.toParamString(org.apache.sling.commons.log.packagingDataEnabled))), ("orgApacheSlingCommonsLogMaxCallerDataDepth", Some(org.apache.sling.commons.log.maxCallerDataDepthQuery.toParamString(org.apache.sling.commons.log.maxCallerDataDepth))), ("orgApacheSlingCommonsLogMaxOldFileCountInDump", Some(org.apache.sling.commons.log.maxOldFileCountInDumpQuery.toParamString(org.apache.sling.commons.log.maxOldFileCountInDump))), ("orgApacheSlingCommonsLogNumOfLines", Some(org.apache.sling.commons.log.numOfLinesQuery.toParamString(org.apache.sling.commons.log.numOfLines))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsLogLogManagerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsLogLogManagerFactoryConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingCommonsLogLevel: String, orgApacheSlingCommonsLogFile: String, orgApacheSlingCommonsLogPattern: String, orgApacheSlingCommonsLogNames: List[String], orgApacheSlingCommonsLogAdditiv: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingCommonsLogLevelQuery: QueryParam[String], orgApacheSlingCommonsLogFileQuery: QueryParam[String], orgApacheSlingCommonsLogPatternQuery: QueryParam[String], orgApacheSlingCommonsLogNamesQuery: QueryParam[List[String]], orgApacheSlingCommonsLogAdditivQuery: QueryParam[Boolean]): Task[OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo] = jsonOf[OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.log.LogManager.factory.config"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingCommonsLogLevel", Some(org.apache.sling.commons.log.levelQuery.toParamString(org.apache.sling.commons.log.level))), ("orgApacheSlingCommonsLogFile", Some(org.apache.sling.commons.log.fileQuery.toParamString(org.apache.sling.commons.log.file))), ("orgApacheSlingCommonsLogPattern", Some(org.apache.sling.commons.log.patternQuery.toParamString(org.apache.sling.commons.log.pattern))), ("orgApacheSlingCommonsLogNames", Some(org.apache.sling.commons.log.namesQuery.toParamString(org.apache.sling.commons.log.names))), ("orgApacheSlingCommonsLogAdditiv", Some(org.apache.sling.commons.log.additivQuery.toParamString(org.apache.sling.commons.log.additiv))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsLogLogManagerFactoryWriter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingCommonsLogFile: String, orgApacheSlingCommonsLogFileNumber: Integer, orgApacheSlingCommonsLogFileSize: String, orgApacheSlingCommonsLogFileBuffered: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingCommonsLogFileQuery: QueryParam[String], orgApacheSlingCommonsLogFileNumberQuery: QueryParam[Integer], orgApacheSlingCommonsLogFileSizeQuery: QueryParam[String], orgApacheSlingCommonsLogFileBufferedQuery: QueryParam[Boolean]): Task[OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo] = jsonOf[OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.log.LogManager.factory.writer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingCommonsLogFile", Some(org.apache.sling.commons.log.fileQuery.toParamString(org.apache.sling.commons.log.file))), ("orgApacheSlingCommonsLogFileNumber", Some(org.apache.sling.commons.log.file.numberQuery.toParamString(org.apache.sling.commons.log.file.number))), ("orgApacheSlingCommonsLogFileSize", Some(org.apache.sling.commons.log.file.sizeQuery.toParamString(org.apache.sling.commons.log.file.size))), ("orgApacheSlingCommonsLogFileBuffered", Some(org.apache.sling.commons.log.file.bufferedQuery.toParamString(org.apache.sling.commons.log.file.buffered))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsMetricsInternalLogReporter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], period: Integer, timeUnit: String, level: String, loggerName: String, prefix: String, pattern: String, registryName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], periodQuery: QueryParam[Integer], timeUnitQuery: QueryParam[String], levelQuery: QueryParam[String], loggerNameQuery: QueryParam[String], prefixQuery: QueryParam[String], patternQuery: QueryParam[String], registryNameQuery: QueryParam[String]): Task[OrgApacheSlingCommonsMetricsInternalLogReporterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsMetricsInternalLogReporterInfo] = jsonOf[OrgApacheSlingCommonsMetricsInternalLogReporterInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.metrics.internal.LogReporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("period", Some(periodQuery.toParamString(period))), ("timeUnit", Some(timeUnitQuery.toParamString(timeUnit))), ("level", Some(levelQuery.toParamString(level))), ("loggerName", Some(loggerNameQuery.toParamString(loggerName))), ("prefix", Some(prefixQuery.toParamString(prefix))), ("pattern", Some(patternQuery.toParamString(pattern))), ("registryName", Some(registryNameQuery.toParamString(registryName))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsMetricsInternalLogReporterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], datasources: List[String], step: Integer, archives: List[String], `path`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], datasourcesQuery: QueryParam[List[String]], stepQuery: QueryParam[Integer], archivesQuery: QueryParam[List[String]], `path`Query: QueryParam[String]): Task[OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo] = jsonOf[OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.metrics.rrd4j.impl.CodahaleMetricsReporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("datasources", Some(datasourcesQuery.toParamString(datasources))), ("step", Some(stepQuery.toParamString(step))), ("archives", Some(archivesQuery.toParamString(archives))), ("`path`", Some(pathQuery.toParamString(path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsMimeInternalMimeTypeServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mimeTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mimeTypesQuery: QueryParam[List[String]]): Task[OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo] = jsonOf[OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.mime.internal.MimeTypeServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mimeTypes", Some(mime.typesQuery.toParamString(mime.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsSchedulerImplQuartzScheduler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], poolName: String, allowedPoolNames: List[String], schedulerUseleaderforsingle: Boolean, metricsFilters: List[String], slowThresholdMillis: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], poolNameQuery: QueryParam[String], allowedPoolNamesQuery: QueryParam[List[String]], schedulerUseleaderforsingleQuery: QueryParam[Boolean], metricsFiltersQuery: QueryParam[List[String]], slowThresholdMillisQuery: QueryParam[Integer]): Task[OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo] = jsonOf[OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.scheduler.impl.QuartzScheduler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("poolName", Some(poolNameQuery.toParamString(poolName))), ("allowedPoolNames", Some(allowedPoolNamesQuery.toParamString(allowedPoolNames))), ("schedulerUseleaderforsingle", Some(scheduler.useleaderforsingleQuery.toParamString(scheduler.useleaderforsingle))), ("metricsFilters", Some(metrics.filtersQuery.toParamString(metrics.filters))), ("slowThresholdMillis", Some(slowThresholdMillisQuery.toParamString(slowThresholdMillis))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsSchedulerImplSchedulerHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxQuartzJobDurationAcceptable: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxQuartzJobDurationAcceptableQuery: QueryParam[Integer]): Task[OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo] = jsonOf[OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.scheduler.impl.SchedulerHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxQuartzJobDurationAcceptable", Some(max.quartzJob.duration.acceptableQuery.toParamString(max.quartzJob.duration.acceptable))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsThreadsImplDefaultThreadPoolFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, minPoolSize: Integer, maxPoolSize: Integer, queueSize: Integer, maxThreadAge: Integer, keepAliveTime: Integer, blockPolicy: String, shutdownGraceful: Boolean, daemon: Boolean, shutdownWaitTime: Integer, priority: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], minPoolSizeQuery: QueryParam[Integer], maxPoolSizeQuery: QueryParam[Integer], queueSizeQuery: QueryParam[Integer], maxThreadAgeQuery: QueryParam[Integer], keepAliveTimeQuery: QueryParam[Integer], blockPolicyQuery: QueryParam[String], shutdownGracefulQuery: QueryParam[Boolean], daemonQuery: QueryParam[Boolean], shutdownWaitTimeQuery: QueryParam[Integer], priorityQuery: QueryParam[String]): Task[OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo] = jsonOf[OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.threads.impl.DefaultThreadPool.factory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("minPoolSize", Some(minPoolSizeQuery.toParamString(minPoolSize))), ("maxPoolSize", Some(maxPoolSizeQuery.toParamString(maxPoolSize))), ("queueSize", Some(queueSizeQuery.toParamString(queueSize))), ("maxThreadAge", Some(maxThreadAgeQuery.toParamString(maxThreadAge))), ("keepAliveTime", Some(keepAliveTimeQuery.toParamString(keepAliveTime))), ("blockPolicy", Some(blockPolicyQuery.toParamString(blockPolicy))), ("shutdownGraceful", Some(shutdownGracefulQuery.toParamString(shutdownGraceful))), ("daemon", Some(daemonQuery.toParamString(daemon))), ("shutdownWaitTime", Some(shutdownWaitTimeQuery.toParamString(shutdownWaitTime))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDatasourceDataSourceFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], datasourceName: String, datasourceSvcPropName: String, driverClassName: String, url: String, username: String, password: String, defaultAutoCommit: String, defaultReadOnly: String, defaultTransactionIsolation: String, defaultCatalog: String, maxActive: Integer, maxIdle: Integer, minIdle: Integer, initialSize: Integer, maxWait: Integer, maxAge: Integer, testOnBorrow: Boolean, testOnReturn: Boolean, testWhileIdle: Boolean, validationQuery: String, validationQueryTimeout: Integer, timeBetweenEvictionRunsMillis: Integer, minEvictableIdleTimeMillis: Integer, connectionProperties: String, initSQL: String, jdbcInterceptors: String, validationInterval: Integer, logValidationErrors: Boolean, datasourceSvcProperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], datasourceNameQuery: QueryParam[String], datasourceSvcPropNameQuery: QueryParam[String], driverClassNameQuery: QueryParam[String], urlQuery: QueryParam[String], usernameQuery: QueryParam[String], passwordQuery: QueryParam[String], defaultAutoCommitQuery: QueryParam[String], defaultReadOnlyQuery: QueryParam[String], defaultTransactionIsolationQuery: QueryParam[String], defaultCatalogQuery: QueryParam[String], maxActiveQuery: QueryParam[Integer], maxIdleQuery: QueryParam[Integer], minIdleQuery: QueryParam[Integer], initialSizeQuery: QueryParam[Integer], maxWaitQuery: QueryParam[Integer], maxAgeQuery: QueryParam[Integer], testOnBorrowQuery: QueryParam[Boolean], testOnReturnQuery: QueryParam[Boolean], testWhileIdleQuery: QueryParam[Boolean], validationQueryQuery: QueryParam[String], validationQueryTimeoutQuery: QueryParam[Integer], timeBetweenEvictionRunsMillisQuery: QueryParam[Integer], minEvictableIdleTimeMillisQuery: QueryParam[Integer], connectionPropertiesQuery: QueryParam[String], initSQLQuery: QueryParam[String], jdbcInterceptorsQuery: QueryParam[String], validationIntervalQuery: QueryParam[Integer], logValidationErrorsQuery: QueryParam[Boolean], datasourceSvcPropertiesQuery: QueryParam[List[String]]): Task[OrgApacheSlingDatasourceDataSourceFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDatasourceDataSourceFactoryInfo] = jsonOf[OrgApacheSlingDatasourceDataSourceFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.datasource.DataSourceFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("datasourceName", Some(datasource.nameQuery.toParamString(datasource.name))), ("datasourceSvcPropName", Some(datasource.svc.prop.nameQuery.toParamString(datasource.svc.prop.name))), ("driverClassName", Some(driverClassNameQuery.toParamString(driverClassName))), ("url", Some(urlQuery.toParamString(url))), ("username", Some(usernameQuery.toParamString(username))), ("password", Some(passwordQuery.toParamString(password))), ("defaultAutoCommit", Some(defaultAutoCommitQuery.toParamString(defaultAutoCommit))), ("defaultReadOnly", Some(defaultReadOnlyQuery.toParamString(defaultReadOnly))), ("defaultTransactionIsolation", Some(defaultTransactionIsolationQuery.toParamString(defaultTransactionIsolation))), ("defaultCatalog", Some(defaultCatalogQuery.toParamString(defaultCatalog))), ("maxActive", Some(maxActiveQuery.toParamString(maxActive))), ("maxIdle", Some(maxIdleQuery.toParamString(maxIdle))), ("minIdle", Some(minIdleQuery.toParamString(minIdle))), ("initialSize", Some(initialSizeQuery.toParamString(initialSize))), ("maxWait", Some(maxWaitQuery.toParamString(maxWait))), ("maxAge", Some(maxAgeQuery.toParamString(maxAge))), ("testOnBorrow", Some(testOnBorrowQuery.toParamString(testOnBorrow))), ("testOnReturn", Some(testOnReturnQuery.toParamString(testOnReturn))), ("testWhileIdle", Some(testWhileIdleQuery.toParamString(testWhileIdle))), ("validationQuery", Some(validationQueryQuery.toParamString(validationQuery))), ("validationQueryTimeout", Some(validationQueryTimeoutQuery.toParamString(validationQueryTimeout))), ("timeBetweenEvictionRunsMillis", Some(timeBetweenEvictionRunsMillisQuery.toParamString(timeBetweenEvictionRunsMillis))), ("minEvictableIdleTimeMillis", Some(minEvictableIdleTimeMillisQuery.toParamString(minEvictableIdleTimeMillis))), ("connectionProperties", Some(connectionPropertiesQuery.toParamString(connectionProperties))), ("initSQL", Some(initSQLQuery.toParamString(initSQL))), ("jdbcInterceptors", Some(jdbcInterceptorsQuery.toParamString(jdbcInterceptors))), ("validationInterval", Some(validationIntervalQuery.toParamString(validationInterval))), ("logValidationErrors", Some(logValidationErrorsQuery.toParamString(logValidationErrors))), ("datasourceSvcProperties", Some(datasource.svc.propertiesQuery.toParamString(datasource.svc.properties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDatasourceDataSourceFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDatasourceJNDIDataSourceFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], datasourceName: String, datasourceSvcPropName: String, datasourceJndiName: String, jndiProperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], datasourceNameQuery: QueryParam[String], datasourceSvcPropNameQuery: QueryParam[String], datasourceJndiNameQuery: QueryParam[String], jndiPropertiesQuery: QueryParam[List[String]]): Task[OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo] = jsonOf[OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.datasource.JNDIDataSourceFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("datasourceName", Some(datasource.nameQuery.toParamString(datasource.name))), ("datasourceSvcPropName", Some(datasource.svc.prop.nameQuery.toParamString(datasource.svc.prop.name))), ("datasourceJndiName", Some(datasource.jndi.nameQuery.toParamString(datasource.jndi.name))), ("jndiProperties", Some(jndi.propertiesQuery.toParamString(jndi.properties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDiscoveryOakConfig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], connectorPingTimeout: Integer, connectorPingInterval: Integer, discoveryLiteCheckInterval: Integer, clusterSyncServiceTimeout: Integer, clusterSyncServiceInterval: Integer, enableSyncToken: Boolean, minEventDelay: Integer, socketConnectTimeout: Integer, soTimeout: Integer, topologyConnectorUrls: List[String], topologyConnectorWhitelist: List[String], autoStopLocalLoopEnabled: Boolean, gzipConnectorRequestsEnabled: Boolean, hmacEnabled: Boolean, enableEncryption: Boolean, sharedKey: String, hmacSharedKeyTTL: Integer, backoffStandbyFactor: String, backoffStableFactor: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], connectorPingTimeoutQuery: QueryParam[Integer], connectorPingIntervalQuery: QueryParam[Integer], discoveryLiteCheckIntervalQuery: QueryParam[Integer], clusterSyncServiceTimeoutQuery: QueryParam[Integer], clusterSyncServiceIntervalQuery: QueryParam[Integer], enableSyncTokenQuery: QueryParam[Boolean], minEventDelayQuery: QueryParam[Integer], socketConnectTimeoutQuery: QueryParam[Integer], soTimeoutQuery: QueryParam[Integer], topologyConnectorUrlsQuery: QueryParam[List[String]], topologyConnectorWhitelistQuery: QueryParam[List[String]], autoStopLocalLoopEnabledQuery: QueryParam[Boolean], gzipConnectorRequestsEnabledQuery: QueryParam[Boolean], hmacEnabledQuery: QueryParam[Boolean], enableEncryptionQuery: QueryParam[Boolean], sharedKeyQuery: QueryParam[String], hmacSharedKeyTTLQuery: QueryParam[Integer], backoffStandbyFactorQuery: QueryParam[String], backoffStableFactorQuery: QueryParam[String]): Task[OrgApacheSlingDiscoveryOakConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDiscoveryOakConfigInfo] = jsonOf[OrgApacheSlingDiscoveryOakConfigInfo]

    val path = "/system/console/configMgr/org.apache.sling.discovery.oak.Config"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("connectorPingTimeout", Some(connectorPingTimeoutQuery.toParamString(connectorPingTimeout))), ("connectorPingInterval", Some(connectorPingIntervalQuery.toParamString(connectorPingInterval))), ("discoveryLiteCheckInterval", Some(discoveryLiteCheckIntervalQuery.toParamString(discoveryLiteCheckInterval))), ("clusterSyncServiceTimeout", Some(clusterSyncServiceTimeoutQuery.toParamString(clusterSyncServiceTimeout))), ("clusterSyncServiceInterval", Some(clusterSyncServiceIntervalQuery.toParamString(clusterSyncServiceInterval))), ("enableSyncToken", Some(enableSyncTokenQuery.toParamString(enableSyncToken))), ("minEventDelay", Some(minEventDelayQuery.toParamString(minEventDelay))), ("socketConnectTimeout", Some(socketConnectTimeoutQuery.toParamString(socketConnectTimeout))), ("soTimeout", Some(soTimeoutQuery.toParamString(soTimeout))), ("topologyConnectorUrls", Some(topologyConnectorUrlsQuery.toParamString(topologyConnectorUrls))), ("topologyConnectorWhitelist", Some(topologyConnectorWhitelistQuery.toParamString(topologyConnectorWhitelist))), ("autoStopLocalLoopEnabled", Some(autoStopLocalLoopEnabledQuery.toParamString(autoStopLocalLoopEnabled))), ("gzipConnectorRequestsEnabled", Some(gzipConnectorRequestsEnabledQuery.toParamString(gzipConnectorRequestsEnabled))), ("hmacEnabled", Some(hmacEnabledQuery.toParamString(hmacEnabled))), ("enableEncryption", Some(enableEncryptionQuery.toParamString(enableEncryption))), ("sharedKey", Some(sharedKeyQuery.toParamString(sharedKey))), ("hmacSharedKeyTTL", Some(hmacSharedKeyTTLQuery.toParamString(hmacSharedKeyTTL))), ("backoffStandbyFactor", Some(backoffStandbyFactorQuery.toParamString(backoffStandbyFactor))), ("backoffStableFactor", Some(backoffStableFactorQuery.toParamString(backoffStableFactor))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDiscoveryOakConfigInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDiscoveryOakSynchronizedClocksHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String]): Task[OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo] = jsonOf[OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo]

    val path = "/system/console/configMgr/org.apache.sling.discovery.oak.SynchronizedClocksHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionAgentImplForwardDistributionAgentFacto(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, title: String, details: String, enabled: Boolean, serviceName: String, logLevel: String, allowedRoots: List[String], queueProcessingEnabled: Boolean, packageImporterEndpoints: List[String], passiveQueues: List[String], priorityQueues: List[String], retryStrategy: String, retryAttempts: Integer, requestAuthorizationStrategyTarget: String, transportSecretProviderTarget: String, packageBuilderTarget: String, triggersTarget: String, queueProvider: String, asyncDelivery: Boolean, httpConnTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], titleQuery: QueryParam[String], detailsQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], serviceNameQuery: QueryParam[String], logLevelQuery: QueryParam[String], allowedRootsQuery: QueryParam[List[String]], queueProcessingEnabledQuery: QueryParam[Boolean], packageImporterEndpointsQuery: QueryParam[List[String]], passiveQueuesQuery: QueryParam[List[String]], priorityQueuesQuery: QueryParam[List[String]], retryStrategyQuery: QueryParam[String], retryAttemptsQuery: QueryParam[Integer], requestAuthorizationStrategyTargetQuery: QueryParam[String], transportSecretProviderTargetQuery: QueryParam[String], packageBuilderTargetQuery: QueryParam[String], triggersTargetQuery: QueryParam[String], queueProviderQuery: QueryParam[String], asyncDeliveryQuery: QueryParam[Boolean], httpConnTimeoutQuery: QueryParam[Integer]): Task[OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo] = jsonOf[OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.agent.impl.ForwardDistributionAgentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("title", Some(titleQuery.toParamString(title))), ("details", Some(detailsQuery.toParamString(details))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("logLevel", Some(log.levelQuery.toParamString(log.level))), ("allowedRoots", Some(allowed.rootsQuery.toParamString(allowed.roots))), ("queueProcessingEnabled", Some(queue.processing.enabledQuery.toParamString(queue.processing.enabled))), ("packageImporterEndpoints", Some(packageImporter.endpointsQuery.toParamString(packageImporter.endpoints))), ("passiveQueues", Some(passiveQueuesQuery.toParamString(passiveQueues))), ("priorityQueues", Some(priorityQueuesQuery.toParamString(priorityQueues))), ("retryStrategy", Some(retry.strategyQuery.toParamString(retry.strategy))), ("retryAttempts", Some(retry.attemptsQuery.toParamString(retry.attempts))), ("requestAuthorizationStrategyTarget", Some(requestAuthorizationStrategy.targetQuery.toParamString(requestAuthorizationStrategy.target))), ("transportSecretProviderTarget", Some(transportSecretProvider.targetQuery.toParamString(transportSecretProvider.target))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))), ("triggersTarget", Some(triggers.targetQuery.toParamString(triggers.target))), ("queueProvider", Some(queue.providerQuery.toParamString(queue.provider))), ("asyncDelivery", Some(async.deliveryQuery.toParamString(async.delivery))), ("httpConnTimeout", Some(http.conn.timeoutQuery.toParamString(http.conn.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionAgentImplPrivilegeDistributionRequestA(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, jcrPrivilege: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], jcrPrivilegeQuery: QueryParam[String]): Task[OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo] = jsonOf[OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.agent.impl.PrivilegeDistributionRequestAuthorizationStrategyFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("jcrPrivilege", Some(jcrPrivilegeQuery.toParamString(jcrPrivilege))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionAgentImplQueueDistributionAgentFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, title: String, details: String, enabled: Boolean, serviceName: String, logLevel: String, allowedRoots: List[String], requestAuthorizationStrategyTarget: String, queueProviderFactoryTarget: String, packageBuilderTarget: String, triggersTarget: String, priorityQueues: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], titleQuery: QueryParam[String], detailsQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], serviceNameQuery: QueryParam[String], logLevelQuery: QueryParam[String], allowedRootsQuery: QueryParam[List[String]], requestAuthorizationStrategyTargetQuery: QueryParam[String], queueProviderFactoryTargetQuery: QueryParam[String], packageBuilderTargetQuery: QueryParam[String], triggersTargetQuery: QueryParam[String], priorityQueuesQuery: QueryParam[List[String]]): Task[OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo] = jsonOf[OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.agent.impl.QueueDistributionAgentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("title", Some(titleQuery.toParamString(title))), ("details", Some(detailsQuery.toParamString(details))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("logLevel", Some(log.levelQuery.toParamString(log.level))), ("allowedRoots", Some(allowed.rootsQuery.toParamString(allowed.roots))), ("requestAuthorizationStrategyTarget", Some(requestAuthorizationStrategy.targetQuery.toParamString(requestAuthorizationStrategy.target))), ("queueProviderFactoryTarget", Some(queueProviderFactory.targetQuery.toParamString(queueProviderFactory.target))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))), ("triggersTarget", Some(triggers.targetQuery.toParamString(triggers.target))), ("priorityQueues", Some(priorityQueuesQuery.toParamString(priorityQueues))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionAgentImplReverseDistributionAgentFacto(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, title: String, details: String, enabled: Boolean, serviceName: String, logLevel: String, queueProcessingEnabled: Boolean, packageExporterEndpoints: List[String], pullItems: Integer, httpConnTimeout: Integer, requestAuthorizationStrategyTarget: String, transportSecretProviderTarget: String, packageBuilderTarget: String, triggersTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], titleQuery: QueryParam[String], detailsQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], serviceNameQuery: QueryParam[String], logLevelQuery: QueryParam[String], queueProcessingEnabledQuery: QueryParam[Boolean], packageExporterEndpointsQuery: QueryParam[List[String]], pullItemsQuery: QueryParam[Integer], httpConnTimeoutQuery: QueryParam[Integer], requestAuthorizationStrategyTargetQuery: QueryParam[String], transportSecretProviderTargetQuery: QueryParam[String], packageBuilderTargetQuery: QueryParam[String], triggersTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo] = jsonOf[OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.agent.impl.ReverseDistributionAgentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("title", Some(titleQuery.toParamString(title))), ("details", Some(detailsQuery.toParamString(details))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("logLevel", Some(log.levelQuery.toParamString(log.level))), ("queueProcessingEnabled", Some(queue.processing.enabledQuery.toParamString(queue.processing.enabled))), ("packageExporterEndpoints", Some(packageExporter.endpointsQuery.toParamString(packageExporter.endpoints))), ("pullItems", Some(pull.itemsQuery.toParamString(pull.items))), ("httpConnTimeout", Some(http.conn.timeoutQuery.toParamString(http.conn.timeout))), ("requestAuthorizationStrategyTarget", Some(requestAuthorizationStrategy.targetQuery.toParamString(requestAuthorizationStrategy.target))), ("transportSecretProviderTarget", Some(transportSecretProvider.targetQuery.toParamString(transportSecretProvider.target))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))), ("triggersTarget", Some(triggers.targetQuery.toParamString(triggers.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionAgentImplSimpleDistributionAgentFactor(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, title: String, details: String, enabled: Boolean, serviceName: String, logLevel: String, queueProcessingEnabled: Boolean, packageExporterTarget: String, packageImporterTarget: String, requestAuthorizationStrategyTarget: String, triggersTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], titleQuery: QueryParam[String], detailsQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], serviceNameQuery: QueryParam[String], logLevelQuery: QueryParam[String], queueProcessingEnabledQuery: QueryParam[Boolean], packageExporterTargetQuery: QueryParam[String], packageImporterTargetQuery: QueryParam[String], requestAuthorizationStrategyTargetQuery: QueryParam[String], triggersTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo] = jsonOf[OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.agent.impl.SimpleDistributionAgentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("title", Some(titleQuery.toParamString(title))), ("details", Some(detailsQuery.toParamString(details))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("logLevel", Some(log.levelQuery.toParamString(log.level))), ("queueProcessingEnabled", Some(queue.processing.enabledQuery.toParamString(queue.processing.enabled))), ("packageExporterTarget", Some(packageExporter.targetQuery.toParamString(packageExporter.target))), ("packageImporterTarget", Some(packageImporter.targetQuery.toParamString(packageImporter.target))), ("requestAuthorizationStrategyTarget", Some(requestAuthorizationStrategy.targetQuery.toParamString(requestAuthorizationStrategy.target))), ("triggersTarget", Some(triggers.targetQuery.toParamString(triggers.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionAgentImplSyncDistributionAgentFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, title: String, details: String, enabled: Boolean, serviceName: String, logLevel: String, queueProcessingEnabled: Boolean, passiveQueues: List[String], packageExporterEndpoints: List[String], packageImporterEndpoints: List[String], retryStrategy: String, retryAttempts: Integer, pullItems: Integer, httpConnTimeout: Integer, requestAuthorizationStrategyTarget: String, transportSecretProviderTarget: String, packageBuilderTarget: String, triggersTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], titleQuery: QueryParam[String], detailsQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], serviceNameQuery: QueryParam[String], logLevelQuery: QueryParam[String], queueProcessingEnabledQuery: QueryParam[Boolean], passiveQueuesQuery: QueryParam[List[String]], packageExporterEndpointsQuery: QueryParam[List[String]], packageImporterEndpointsQuery: QueryParam[List[String]], retryStrategyQuery: QueryParam[String], retryAttemptsQuery: QueryParam[Integer], pullItemsQuery: QueryParam[Integer], httpConnTimeoutQuery: QueryParam[Integer], requestAuthorizationStrategyTargetQuery: QueryParam[String], transportSecretProviderTargetQuery: QueryParam[String], packageBuilderTargetQuery: QueryParam[String], triggersTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo] = jsonOf[OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.agent.impl.SyncDistributionAgentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("title", Some(titleQuery.toParamString(title))), ("details", Some(detailsQuery.toParamString(details))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("logLevel", Some(log.levelQuery.toParamString(log.level))), ("queueProcessingEnabled", Some(queue.processing.enabledQuery.toParamString(queue.processing.enabled))), ("passiveQueues", Some(passiveQueuesQuery.toParamString(passiveQueues))), ("packageExporterEndpoints", Some(packageExporter.endpointsQuery.toParamString(packageExporter.endpoints))), ("packageImporterEndpoints", Some(packageImporter.endpointsQuery.toParamString(packageImporter.endpoints))), ("retryStrategy", Some(retry.strategyQuery.toParamString(retry.strategy))), ("retryAttempts", Some(retry.attemptsQuery.toParamString(retry.attempts))), ("pullItems", Some(pull.itemsQuery.toParamString(pull.items))), ("httpConnTimeout", Some(http.conn.timeoutQuery.toParamString(http.conn.timeout))), ("requestAuthorizationStrategyTarget", Some(requestAuthorizationStrategy.targetQuery.toParamString(requestAuthorizationStrategy.target))), ("transportSecretProviderTarget", Some(transportSecretProvider.targetQuery.toParamString(transportSecretProvider.target))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))), ("triggersTarget", Some(triggers.targetQuery.toParamString(triggers.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionMonitorDistributionQueueHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String, numberOfRetriesAllowed: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String], numberOfRetriesAllowedQuery: QueryParam[Integer]): Task[OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo] = jsonOf[OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.monitor.DistributionQueueHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))), ("numberOfRetriesAllowed", Some(numberOfRetriesAllowedQuery.toParamString(numberOfRetriesAllowed))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionPackagingImplExporterAgentDistributio(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, queue: String, dropInvalidItems: Boolean, agentTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], queueQuery: QueryParam[String], dropInvalidItemsQuery: QueryParam[Boolean], agentTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo] = jsonOf[OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.AgentDistributionPackageExporterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("queue", Some(queueQuery.toParamString(queue))), ("dropInvalidItems", Some(drop.invalid.itemsQuery.toParamString(drop.invalid.items))), ("agentTarget", Some(agent.targetQuery.toParamString(agent.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionPackagingImplExporterLocalDistributio(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, packageBuilderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], packageBuilderTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo] = jsonOf[OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.LocalDistributionPackageExporterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionPackagingImplExporterRemoteDistributi(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, endpoints: List[String], pullItems: Integer, packageBuilderTarget: String, transportSecretProviderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], endpointsQuery: QueryParam[List[String]], pullItemsQuery: QueryParam[Integer], packageBuilderTargetQuery: QueryParam[String], transportSecretProviderTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo] = jsonOf[OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.RemoteDistributionPackageExporterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("endpoints", Some(endpointsQuery.toParamString(endpoints))), ("pullItems", Some(pull.itemsQuery.toParamString(pull.items))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))), ("transportSecretProviderTarget", Some(transportSecretProvider.targetQuery.toParamString(transportSecretProvider.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionPackagingImplImporterLocalDistributio(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, packageBuilderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], packageBuilderTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo] = jsonOf[OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.LocalDistributionPackageImporterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionPackagingImplImporterRemoteDistributi(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, endpoints: List[String], transportSecretProviderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], endpointsQuery: QueryParam[List[String]], transportSecretProviderTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo] = jsonOf[OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.RemoteDistributionPackageImporterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("endpoints", Some(endpointsQuery.toParamString(endpoints))), ("transportSecretProviderTarget", Some(transportSecretProvider.targetQuery.toParamString(transportSecretProvider.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionPackagingImplImporterRepositoryDistri(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, serviceName: String, `path`: String, privilegeName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], serviceNameQuery: QueryParam[String], `path`Query: QueryParam[String], privilegeNameQuery: QueryParam[String]): Task[OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo] = jsonOf[OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.RepositoryDistributionPackageImporterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("serviceName", Some(service.nameQuery.toParamString(service.name))), ("`path`", Some(pathQuery.toParamString(path))), ("privilegeName", Some(privilege.nameQuery.toParamString(privilege.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionResourcesImplDistributionConfiguration(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerRoots: String, kind: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerRootsQuery: QueryParam[String], kindQuery: QueryParam[String]): Task[OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo] = jsonOf[OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.resources.impl.DistributionConfigurationResourceProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerRoots", Some(provider.rootsQuery.toParamString(provider.roots))), ("kind", Some(kindQuery.toParamString(kind))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionResourcesImplDistributionServiceResour(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerRoots: String, kind: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerRootsQuery: QueryParam[String], kindQuery: QueryParam[String]): Task[OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo] = jsonOf[OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.resources.impl.DistributionServiceResourceProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerRoots", Some(provider.rootsQuery.toParamString(provider.roots))), ("kind", Some(kindQuery.toParamString(kind))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionSerializationImplDistributionPackageBu(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `type`: String, formatTarget: String, tempFsFolder: String, fileThreshold: Integer, memoryUnit: String, useOffHeapMemory: Boolean, digestAlgorithm: String, monitoringQueueSize: Integer, cleanupDelay: Integer, packageFilters: List[String], propertyFilters: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `type`Query: QueryParam[String], formatTargetQuery: QueryParam[String], tempFsFolderQuery: QueryParam[String], fileThresholdQuery: QueryParam[Integer], memoryUnitQuery: QueryParam[String], useOffHeapMemoryQuery: QueryParam[Boolean], digestAlgorithmQuery: QueryParam[String], monitoringQueueSizeQuery: QueryParam[Integer], cleanupDelayQuery: QueryParam[Integer], packageFiltersQuery: QueryParam[List[String]], propertyFiltersQuery: QueryParam[List[String]]): Task[OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo] = jsonOf[OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.serialization.impl.DistributionPackageBuilderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`type`", Some(typeQuery.toParamString(type))), ("formatTarget", Some(format.targetQuery.toParamString(format.target))), ("tempFsFolder", Some(tempFsFolderQuery.toParamString(tempFsFolder))), ("fileThreshold", Some(fileThresholdQuery.toParamString(fileThreshold))), ("memoryUnit", Some(memoryUnitQuery.toParamString(memoryUnit))), ("useOffHeapMemory", Some(useOffHeapMemoryQuery.toParamString(useOffHeapMemory))), ("digestAlgorithm", Some(digestAlgorithmQuery.toParamString(digestAlgorithm))), ("monitoringQueueSize", Some(monitoringQueueSizeQuery.toParamString(monitoringQueueSize))), ("cleanupDelay", Some(cleanupDelayQuery.toParamString(cleanupDelay))), ("packageFilters", Some(package.filtersQuery.toParamString(package.filters))), ("propertyFilters", Some(property.filtersQuery.toParamString(property.filters))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionSerializationImplVltVaultDistribution(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `type`: String, importMode: String, aclHandling: String, packageRoots: String, packageFilters: List[String], propertyFilters: List[String], tempFsFolder: String, useBinaryReferences: Boolean, autoSaveThreshold: Integer, cleanupDelay: Integer, fileThreshold: Integer, MEGA_BYTES: String, useOffHeapMemory: Boolean, digestAlgorithm: String, monitoringQueueSize: Integer, pathsMapping: List[String], strictImport: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `type`Query: QueryParam[String], importModeQuery: QueryParam[String], aclHandlingQuery: QueryParam[String], packageRootsQuery: QueryParam[String], packageFiltersQuery: QueryParam[List[String]], propertyFiltersQuery: QueryParam[List[String]], tempFsFolderQuery: QueryParam[String], useBinaryReferencesQuery: QueryParam[Boolean], autoSaveThresholdQuery: QueryParam[Integer], cleanupDelayQuery: QueryParam[Integer], fileThresholdQuery: QueryParam[Integer], MEGA_BYTESQuery: QueryParam[String], useOffHeapMemoryQuery: QueryParam[Boolean], digestAlgorithmQuery: QueryParam[String], monitoringQueueSizeQuery: QueryParam[Integer], pathsMappingQuery: QueryParam[List[String]], strictImportQuery: QueryParam[Boolean]): Task[OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo] = jsonOf[OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.serialization.impl.vlt.VaultDistributionPackageBuilderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`type`", Some(typeQuery.toParamString(type))), ("importMode", Some(importModeQuery.toParamString(importMode))), ("aclHandling", Some(aclHandlingQuery.toParamString(aclHandling))), ("packageRoots", Some(package.rootsQuery.toParamString(package.roots))), ("packageFilters", Some(package.filtersQuery.toParamString(package.filters))), ("propertyFilters", Some(property.filtersQuery.toParamString(property.filters))), ("tempFsFolder", Some(tempFsFolderQuery.toParamString(tempFsFolder))), ("useBinaryReferences", Some(useBinaryReferencesQuery.toParamString(useBinaryReferences))), ("autoSaveThreshold", Some(autoSaveThresholdQuery.toParamString(autoSaveThreshold))), ("cleanupDelay", Some(cleanupDelayQuery.toParamString(cleanupDelay))), ("fileThreshold", Some(fileThresholdQuery.toParamString(fileThreshold))), ("MEGA_BYTES", Some(MEGA_BYTESQuery.toParamString(MEGA_BYTES))), ("useOffHeapMemory", Some(useOffHeapMemoryQuery.toParamString(useOffHeapMemory))), ("digestAlgorithm", Some(digestAlgorithmQuery.toParamString(digestAlgorithm))), ("monitoringQueueSize", Some(monitoringQueueSizeQuery.toParamString(monitoringQueueSize))), ("pathsMapping", Some(pathsMappingQuery.toParamString(pathsMapping))), ("strictImport", Some(strictImportQuery.toParamString(strictImport))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTransportImplUserCredentialsDistributi(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, username: String, password: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], usernameQuery: QueryParam[String], passwordQuery: QueryParam[String]): Task[OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo] = jsonOf[OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.transport.impl.UserCredentialsDistributionTransportSecretProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("username", Some(usernameQuery.toParamString(username))), ("password", Some(passwordQuery.toParamString(password))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTriggerImplDistributionEventDistribute(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `path`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `path`Query: QueryParam[String]): Task[OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo] = jsonOf[OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.DistributionEventDistributeDistributionTriggerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`path`", Some(pathQuery.toParamString(path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTriggerImplJcrEventDistributionTrigger(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `path`: String, ignoredPathsPatterns: List[String], serviceName: String, deep: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `path`Query: QueryParam[String], ignoredPathsPatternsQuery: QueryParam[List[String]], serviceNameQuery: QueryParam[String], deepQuery: QueryParam[Boolean]): Task[OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo] = jsonOf[OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.JcrEventDistributionTriggerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`path`", Some(pathQuery.toParamString(path))), ("ignoredPathsPatterns", Some(ignoredPathsPatternsQuery.toParamString(ignoredPathsPatterns))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("deep", Some(deepQuery.toParamString(deep))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTriggerImplPersistedJcrEventDistributi(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `path`: String, serviceName: String, nuggetsPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `path`Query: QueryParam[String], serviceNameQuery: QueryParam[String], nuggetsPathQuery: QueryParam[String]): Task[OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo] = jsonOf[OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.PersistedJcrEventDistributionTriggerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`path`", Some(pathQuery.toParamString(path))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("nuggetsPath", Some(nuggetsPathQuery.toParamString(nuggetsPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTriggerImplRemoteEventDistributionTrig(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, endpoint: String, transportSecretProviderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], endpointQuery: QueryParam[String], transportSecretProviderTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo] = jsonOf[OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.RemoteEventDistributionTriggerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("endpoint", Some(endpointQuery.toParamString(endpoint))), ("transportSecretProviderTarget", Some(transportSecretProvider.targetQuery.toParamString(transportSecretProvider.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTriggerImplResourceEventDistributionTr(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `path`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `path`Query: QueryParam[String]): Task[OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo] = jsonOf[OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.ResourceEventDistributionTriggerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`path`", Some(pathQuery.toParamString(path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTriggerImplScheduledDistributionTrigge(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `path`: String, seconds: String, serviceName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `path`Query: QueryParam[String], secondsQuery: QueryParam[String], serviceNameQuery: QueryParam[String]): Task[OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo] = jsonOf[OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.ScheduledDistributionTriggerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`path`", Some(pathQuery.toParamString(path))), ("seconds", Some(secondsQuery.toParamString(seconds))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEngineImplAuthSlingAuthenticator(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], osgiHttpWhiteboardContextSelect: String, osgiHttpWhiteboardListener: String, authSudoCookie: String, authSudoParameter: String, authAnnonymous: Boolean, slingAuthRequirements: List[String], slingAuthAnonymousUser: String, slingAuthAnonymousPassword: String, authHttp: String, authHttpRealm: String, authUriSuffix: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], osgiHttpWhiteboardContextSelectQuery: QueryParam[String], osgiHttpWhiteboardListenerQuery: QueryParam[String], authSudoCookieQuery: QueryParam[String], authSudoParameterQuery: QueryParam[String], authAnnonymousQuery: QueryParam[Boolean], slingAuthRequirementsQuery: QueryParam[List[String]], slingAuthAnonymousUserQuery: QueryParam[String], slingAuthAnonymousPasswordQuery: QueryParam[String], authHttpQuery: QueryParam[String], authHttpRealmQuery: QueryParam[String], authUriSuffixQuery: QueryParam[List[String]]): Task[OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo] = jsonOf[OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo]

    val path = "/system/console/configMgr/org.apache.sling.engine.impl.auth.SlingAuthenticator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("osgiHttpWhiteboardContextSelect", Some(osgi.http.whiteboard.context.selectQuery.toParamString(osgi.http.whiteboard.context.select))), ("osgiHttpWhiteboardListener", Some(osgi.http.whiteboard.listenerQuery.toParamString(osgi.http.whiteboard.listener))), ("authSudoCookie", Some(auth.sudo.cookieQuery.toParamString(auth.sudo.cookie))), ("authSudoParameter", Some(auth.sudo.parameterQuery.toParamString(auth.sudo.parameter))), ("authAnnonymous", Some(auth.annonymousQuery.toParamString(auth.annonymous))), ("slingAuthRequirements", Some(sling.auth.requirementsQuery.toParamString(sling.auth.requirements))), ("slingAuthAnonymousUser", Some(sling.auth.anonymous.userQuery.toParamString(sling.auth.anonymous.user))), ("slingAuthAnonymousPassword", Some(sling.auth.anonymous.passwordQuery.toParamString(sling.auth.anonymous.password))), ("authHttp", Some(auth.httpQuery.toParamString(auth.http))), ("authHttpRealm", Some(auth.http.realmQuery.toParamString(auth.http.realm))), ("authUriSuffix", Some(auth.uri.suffixQuery.toParamString(auth.uri.suffix))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEngineImplDebugRequestProgressTrackerLogFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], extensions: List[String], minDurationMs: Integer, maxDurationMs: Integer, compactLogFormat: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], extensionsQuery: QueryParam[List[String]], minDurationMsQuery: QueryParam[Integer], maxDurationMsQuery: QueryParam[Integer], compactLogFormatQuery: QueryParam[Boolean]): Task[OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo] = jsonOf[OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo]

    val path = "/system/console/configMgr/org.apache.sling.engine.impl.debug.RequestProgressTrackerLogFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("extensions", Some(extensionsQuery.toParamString(extensions))), ("minDurationMs", Some(minDurationMsQuery.toParamString(minDurationMs))), ("maxDurationMs", Some(maxDurationMsQuery.toParamString(maxDurationMs))), ("compactLogFormat", Some(compactLogFormatQuery.toParamString(compactLogFormat))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEngineImplLogRequestLogger(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], requestLogOutput: String, requestLogOutputtype: Integer, requestLogEnabled: Boolean, accessLogOutput: String, accessLogOutputtype: Integer, accessLogEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], requestLogOutputQuery: QueryParam[String], requestLogOutputtypeQuery: QueryParam[Integer], requestLogEnabledQuery: QueryParam[Boolean], accessLogOutputQuery: QueryParam[String], accessLogOutputtypeQuery: QueryParam[Integer], accessLogEnabledQuery: QueryParam[Boolean]): Task[OrgApacheSlingEngineImplLogRequestLoggerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEngineImplLogRequestLoggerInfo] = jsonOf[OrgApacheSlingEngineImplLogRequestLoggerInfo]

    val path = "/system/console/configMgr/org.apache.sling.engine.impl.log.RequestLogger"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("requestLogOutput", Some(request.log.outputQuery.toParamString(request.log.output))), ("requestLogOutputtype", Some(request.log.outputtypeQuery.toParamString(request.log.outputtype))), ("requestLogEnabled", Some(request.log.enabledQuery.toParamString(request.log.enabled))), ("accessLogOutput", Some(access.log.outputQuery.toParamString(access.log.output))), ("accessLogOutputtype", Some(access.log.outputtypeQuery.toParamString(access.log.outputtype))), ("accessLogEnabled", Some(access.log.enabledQuery.toParamString(access.log.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEngineImplLogRequestLoggerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEngineImplLogRequestLoggerService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], requestLogServiceFormat: String, requestLogServiceOutput: String, requestLogServiceOutputtype: Integer, requestLogServiceOnentry: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], requestLogServiceFormatQuery: QueryParam[String], requestLogServiceOutputQuery: QueryParam[String], requestLogServiceOutputtypeQuery: QueryParam[Integer], requestLogServiceOnentryQuery: QueryParam[Boolean]): Task[OrgApacheSlingEngineImplLogRequestLoggerServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEngineImplLogRequestLoggerServiceInfo] = jsonOf[OrgApacheSlingEngineImplLogRequestLoggerServiceInfo]

    val path = "/system/console/configMgr/org.apache.sling.engine.impl.log.RequestLoggerService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("requestLogServiceFormat", Some(request.log.service.formatQuery.toParamString(request.log.service.format))), ("requestLogServiceOutput", Some(request.log.service.outputQuery.toParamString(request.log.service.output))), ("requestLogServiceOutputtype", Some(request.log.service.outputtypeQuery.toParamString(request.log.service.outputtype))), ("requestLogServiceOnentry", Some(request.log.service.onentryQuery.toParamString(request.log.service.onentry))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEngineImplLogRequestLoggerServiceInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEngineImplSlingMainServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingMaxCalls: Integer, slingMaxInclusions: Integer, slingTraceAllow: Boolean, slingMaxRecordRequests: Integer, slingStorePatternRequests: List[String], slingServerinfo: String, slingAdditionalResponseHeaders: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingMaxCallsQuery: QueryParam[Integer], slingMaxInclusionsQuery: QueryParam[Integer], slingTraceAllowQuery: QueryParam[Boolean], slingMaxRecordRequestsQuery: QueryParam[Integer], slingStorePatternRequestsQuery: QueryParam[List[String]], slingServerinfoQuery: QueryParam[String], slingAdditionalResponseHeadersQuery: QueryParam[List[String]]): Task[OrgApacheSlingEngineImplSlingMainServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEngineImplSlingMainServletInfo] = jsonOf[OrgApacheSlingEngineImplSlingMainServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.engine.impl.SlingMainServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingMaxCalls", Some(sling.max.callsQuery.toParamString(sling.max.calls))), ("slingMaxInclusions", Some(sling.max.inclusionsQuery.toParamString(sling.max.inclusions))), ("slingTraceAllow", Some(sling.trace.allowQuery.toParamString(sling.trace.allow))), ("slingMaxRecordRequests", Some(sling.max.record.requestsQuery.toParamString(sling.max.record.requests))), ("slingStorePatternRequests", Some(sling.store.pattern.requestsQuery.toParamString(sling.store.pattern.requests))), ("slingServerinfo", Some(sling.serverinfoQuery.toParamString(sling.serverinfo))), ("slingAdditionalResponseHeaders", Some(sling.additional.response.headersQuery.toParamString(sling.additional.response.headers))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEngineImplSlingMainServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEngineParameters(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingDefaultParameterEncoding: String, slingDefaultMaxParameters: Integer, fileLocation: String, fileThreshold: Integer, fileMax: Integer, requestMax: Integer, slingDefaultParameterCheckForAdditionalContainerParameters: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingDefaultParameterEncodingQuery: QueryParam[String], slingDefaultMaxParametersQuery: QueryParam[Integer], fileLocationQuery: QueryParam[String], fileThresholdQuery: QueryParam[Integer], fileMaxQuery: QueryParam[Integer], requestMaxQuery: QueryParam[Integer], slingDefaultParameterCheckForAdditionalContainerParametersQuery: QueryParam[Boolean]): Task[OrgApacheSlingEngineParametersInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEngineParametersInfo] = jsonOf[OrgApacheSlingEngineParametersInfo]

    val path = "/system/console/configMgr/org.apache.sling.engine.parameters"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingDefaultParameterEncoding", Some(sling.default.parameter.encodingQuery.toParamString(sling.default.parameter.encoding))), ("slingDefaultMaxParameters", Some(sling.default.max.parametersQuery.toParamString(sling.default.max.parameters))), ("fileLocation", Some(file.locationQuery.toParamString(file.location))), ("fileThreshold", Some(file.thresholdQuery.toParamString(file.threshold))), ("fileMax", Some(file.maxQuery.toParamString(file.max))), ("requestMax", Some(request.maxQuery.toParamString(request.max))), ("slingDefaultParameterCheckForAdditionalContainerParameters", Some(sling.default.parameter.checkForAdditionalContainerParametersQuery.toParamString(sling.default.parameter.checkForAdditionalContainerParameters))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEngineParametersInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEventImplEventingThreadPool(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], minPoolSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], minPoolSizeQuery: QueryParam[Integer]): Task[OrgApacheSlingEventImplEventingThreadPoolInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEventImplEventingThreadPoolInfo] = jsonOf[OrgApacheSlingEventImplEventingThreadPoolInfo]

    val path = "/system/console/configMgr/org.apache.sling.event.impl.EventingThreadPool"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("minPoolSize", Some(minPoolSizeQuery.toParamString(minPoolSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEventImplEventingThreadPoolInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEventImplJobsDefaultJobManager(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], queuePriority: String, queueRetries: Integer, queueRetrydelay: Integer, queueMaxparallel: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], queuePriorityQuery: QueryParam[String], queueRetriesQuery: QueryParam[Integer], queueRetrydelayQuery: QueryParam[Integer], queueMaxparallelQuery: QueryParam[Integer]): Task[OrgApacheSlingEventImplJobsDefaultJobManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEventImplJobsDefaultJobManagerInfo] = jsonOf[OrgApacheSlingEventImplJobsDefaultJobManagerInfo]

    val path = "/system/console/configMgr/org.apache.sling.event.impl.jobs.DefaultJobManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("queuePriority", Some(queue.priorityQuery.toParamString(queue.priority))), ("queueRetries", Some(queue.retriesQuery.toParamString(queue.retries))), ("queueRetrydelay", Some(queue.retrydelayQuery.toParamString(queue.retrydelay))), ("queueMaxparallel", Some(queue.maxparallelQuery.toParamString(queue.maxparallel))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEventImplJobsDefaultJobManagerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEventImplJobsJcrPersistenceHandler(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jobConsumermanagerDisableDistribution: Boolean, startupDelay: Integer, cleanupPeriod: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jobConsumermanagerDisableDistributionQuery: QueryParam[Boolean], startupDelayQuery: QueryParam[Integer], cleanupPeriodQuery: QueryParam[Integer]): Task[OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo] = jsonOf[OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo]

    val path = "/system/console/configMgr/org.apache.sling.event.impl.jobs.jcr.PersistenceHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jobConsumermanagerDisableDistribution", Some(job.consumermanager.disableDistributionQuery.toParamString(job.consumermanager.disableDistribution))), ("startupDelay", Some(startup.delayQuery.toParamString(startup.delay))), ("cleanupPeriod", Some(cleanup.periodQuery.toParamString(cleanup.period))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEventImplJobsJobConsumerManager(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingInstallerConfigurationPersist: Boolean, jobConsumermanagerWhitelist: List[String], jobConsumermanagerBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingInstallerConfigurationPersistQuery: QueryParam[Boolean], jobConsumermanagerWhitelistQuery: QueryParam[List[String]], jobConsumermanagerBlacklistQuery: QueryParam[List[String]]): Task[OrgApacheSlingEventImplJobsJobConsumerManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEventImplJobsJobConsumerManagerInfo] = jsonOf[OrgApacheSlingEventImplJobsJobConsumerManagerInfo]

    val path = "/system/console/configMgr/org.apache.sling.event.impl.jobs.JobConsumerManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingInstallerConfigurationPersist", Some(org.apache.sling.installer.configuration.persistQuery.toParamString(org.apache.sling.installer.configuration.persist))), ("jobConsumermanagerWhitelist", Some(job.consumermanager.whitelistQuery.toParamString(job.consumermanager.whitelist))), ("jobConsumermanagerBlacklist", Some(job.consumermanager.blacklistQuery.toParamString(job.consumermanager.blacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEventImplJobsJobConsumerManagerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEventJobsQueueConfiguration(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], queueName: String, queueTopics: List[String], queueType: String, queuePriority: String, queueRetries: Integer, queueRetrydelay: Integer, queueMaxparallel: BigDecimal, queueKeepJobs: Boolean, queuePreferRunOnCreationInstance: Boolean, queueThreadPoolSize: Integer, serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], queueNameQuery: QueryParam[String], queueTopicsQuery: QueryParam[List[String]], queueTypeQuery: QueryParam[String], queuePriorityQuery: QueryParam[String], queueRetriesQuery: QueryParam[Integer], queueRetrydelayQuery: QueryParam[Integer], queueMaxparallelQuery: QueryParam[BigDecimal], queueKeepJobsQuery: QueryParam[Boolean], queuePreferRunOnCreationInstanceQuery: QueryParam[Boolean], queueThreadPoolSizeQuery: QueryParam[Integer], serviceRankingQuery: QueryParam[Integer]): Task[OrgApacheSlingEventJobsQueueConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEventJobsQueueConfigurationInfo] = jsonOf[OrgApacheSlingEventJobsQueueConfigurationInfo]

    val path = "/system/console/configMgr/org.apache.sling.event.jobs.QueueConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("queueName", Some(queue.nameQuery.toParamString(queue.name))), ("queueTopics", Some(queue.topicsQuery.toParamString(queue.topics))), ("queueType", Some(queue.typeQuery.toParamString(queue.type))), ("queuePriority", Some(queue.priorityQuery.toParamString(queue.priority))), ("queueRetries", Some(queue.retriesQuery.toParamString(queue.retries))), ("queueRetrydelay", Some(queue.retrydelayQuery.toParamString(queue.retrydelay))), ("queueMaxparallel", Some(queue.maxparallelQuery.toParamString(queue.maxparallel))), ("queueKeepJobs", Some(queue.keepJobsQuery.toParamString(queue.keepJobs))), ("queuePreferRunOnCreationInstance", Some(queue.preferRunOnCreationInstanceQuery.toParamString(queue.preferRunOnCreationInstance))), ("queueThreadPoolSize", Some(queue.threadPoolSizeQuery.toParamString(queue.threadPoolSize))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEventJobsQueueConfigurationInfo](req)

    } yield resp
  }
  
  def orgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingW(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], users: List[String], groups: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], usersQuery: QueryParam[List[String]], groupsQuery: QueryParam[List[String]]): Task[OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo] = jsonOf[OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo]

    val path = "/system/console/configMgr/org.apache.sling.extensions.webconsolesecurityprovider.internal.SlingWebConsoleSecurityProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("users", Some(usersQuery.toParamString(users))), ("groups", Some(groupsQuery.toParamString(groups))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo](req)

    } yield resp
  }
  
  def orgApacheSlingFeatureflagsFeature(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, description: String, enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], descriptionQuery: QueryParam[String], enabledQuery: QueryParam[Boolean]): Task[OrgApacheSlingFeatureflagsFeatureInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingFeatureflagsFeatureInfo] = jsonOf[OrgApacheSlingFeatureflagsFeatureInfo]

    val path = "/system/console/configMgr/org.apache.sling.featureflags.Feature"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("description", Some(descriptionQuery.toParamString(description))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingFeatureflagsFeatureInfo](req)

    } yield resp
  }
  
  def orgApacheSlingFeatureflagsImplConfiguredFeature(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, description: String, enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], descriptionQuery: QueryParam[String], enabledQuery: QueryParam[Boolean]): Task[OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo] = jsonOf[OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo]

    val path = "/system/console/configMgr/org.apache.sling.featureflags.impl.ConfiguredFeature"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("description", Some(descriptionQuery.toParamString(description))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHapiImplHApiUtilImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingHapiToolsResourcetype: String, orgApacheSlingHapiToolsCollectionresourcetype: String, orgApacheSlingHapiToolsSearchpaths: List[String], orgApacheSlingHapiToolsExternalurl: String, orgApacheSlingHapiToolsEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingHapiToolsResourcetypeQuery: QueryParam[String], orgApacheSlingHapiToolsCollectionresourcetypeQuery: QueryParam[String], orgApacheSlingHapiToolsSearchpathsQuery: QueryParam[List[String]], orgApacheSlingHapiToolsExternalurlQuery: QueryParam[String], orgApacheSlingHapiToolsEnabledQuery: QueryParam[Boolean]): Task[OrgApacheSlingHapiImplHApiUtilImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHapiImplHApiUtilImplInfo] = jsonOf[OrgApacheSlingHapiImplHApiUtilImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.hapi.impl.HApiUtilImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingHapiToolsResourcetype", Some(org.apache.sling.hapi.tools.resourcetypeQuery.toParamString(org.apache.sling.hapi.tools.resourcetype))), ("orgApacheSlingHapiToolsCollectionresourcetype", Some(org.apache.sling.hapi.tools.collectionresourcetypeQuery.toParamString(org.apache.sling.hapi.tools.collectionresourcetype))), ("orgApacheSlingHapiToolsSearchpaths", Some(org.apache.sling.hapi.tools.searchpathsQuery.toParamString(org.apache.sling.hapi.tools.searchpaths))), ("orgApacheSlingHapiToolsExternalurl", Some(org.apache.sling.hapi.tools.externalurlQuery.toParamString(org.apache.sling.hapi.tools.externalurl))), ("orgApacheSlingHapiToolsEnabled", Some(org.apache.sling.hapi.tools.enabledQuery.toParamString(org.apache.sling.hapi.tools.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHapiImplHApiUtilImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHcCoreImplCompositeHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String, filterTags: List[String], filterCombineTagsWithOr: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String], filterTagsQuery: QueryParam[List[String]], filterCombineTagsWithOrQuery: QueryParam[Boolean]): Task[OrgApacheSlingHcCoreImplCompositeHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHcCoreImplCompositeHealthCheckInfo] = jsonOf[OrgApacheSlingHcCoreImplCompositeHealthCheckInfo]

    val path = "/system/console/configMgr/org.apache.sling.hc.core.impl.CompositeHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))), ("filterTags", Some(filter.tagsQuery.toParamString(filter.tags))), ("filterCombineTagsWithOr", Some(filter.combineTagsWithOrQuery.toParamString(filter.combineTagsWithOr))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHcCoreImplCompositeHealthCheckInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHcCoreImplExecutorHealthCheckExecutorImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], timeoutInMs: Integer, longRunningFutureThresholdForCriticalMs: Integer, resultCacheTtlInMs: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], timeoutInMsQuery: QueryParam[Integer], longRunningFutureThresholdForCriticalMsQuery: QueryParam[Integer], resultCacheTtlInMsQuery: QueryParam[Integer]): Task[OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo] = jsonOf[OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.hc.core.impl.executor.HealthCheckExecutorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("timeoutInMs", Some(timeoutInMsQuery.toParamString(timeoutInMs))), ("longRunningFutureThresholdForCriticalMs", Some(longRunningFutureThresholdForCriticalMsQuery.toParamString(longRunningFutureThresholdForCriticalMs))), ("resultCacheTtlInMs", Some(resultCacheTtlInMsQuery.toParamString(resultCacheTtlInMs))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHcCoreImplJmxAttributeHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String, mbeanName: String, attributeName: String, attributeValueConstraint: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String], mbeanNameQuery: QueryParam[String], attributeNameQuery: QueryParam[String], attributeValueConstraintQuery: QueryParam[String]): Task[OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo] = jsonOf[OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo]

    val path = "/system/console/configMgr/org.apache.sling.hc.core.impl.JmxAttributeHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))), ("mbeanName", Some(mbean.nameQuery.toParamString(mbean.name))), ("attributeName", Some(attribute.nameQuery.toParamString(attribute.name))), ("attributeValueConstraint", Some(attribute.value.constraintQuery.toParamString(attribute.value.constraint))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHcCoreImplScriptableHealthCheck(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String, expression: String, languageExtension: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String], expressionQuery: QueryParam[String], languageExtensionQuery: QueryParam[String]): Task[OrgApacheSlingHcCoreImplScriptableHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHcCoreImplScriptableHealthCheckInfo] = jsonOf[OrgApacheSlingHcCoreImplScriptableHealthCheckInfo]

    val path = "/system/console/configMgr/org.apache.sling.hc.core.impl.ScriptableHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))), ("expression", Some(expressionQuery.toParamString(expression))), ("languageExtension", Some(language.extensionQuery.toParamString(language.extension))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHcCoreImplScriptableHealthCheckInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHcCoreImplServletHealthCheckExecutorServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], servletPath: String, disabled: Boolean, corsAccessControlAllowOrigin: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], servletPathQuery: QueryParam[String], disabledQuery: QueryParam[Boolean], corsAccessControlAllowOriginQuery: QueryParam[String]): Task[OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo] = jsonOf[OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.hc.core.impl.servlet.HealthCheckExecutorServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("servletPath", Some(servletPathQuery.toParamString(servletPath))), ("disabled", Some(disabledQuery.toParamString(disabled))), ("corsAccessControlAllowOrigin", Some(cors.accessControlAllowOriginQuery.toParamString(cors.accessControlAllowOrigin))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHcCoreImplServletResultTxtVerboseSerializer(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], totalWidth: Integer, colWidthName: Integer, colWidthResult: Integer, colWidthTiming: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], totalWidthQuery: QueryParam[Integer], colWidthNameQuery: QueryParam[Integer], colWidthResultQuery: QueryParam[Integer], colWidthTimingQuery: QueryParam[Integer]): Task[OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo] = jsonOf[OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo]

    val path = "/system/console/configMgr/org.apache.sling.hc.core.impl.servlet.ResultTxtVerboseSerializer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("totalWidth", Some(totalWidthQuery.toParamString(totalWidth))), ("colWidthName", Some(colWidthNameQuery.toParamString(colWidthName))), ("colWidthResult", Some(colWidthResultQuery.toParamString(colWidthResult))), ("colWidthTiming", Some(colWidthTimingQuery.toParamString(colWidthTiming))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingI18nImplI18NFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, slingFilterScope: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], slingFilterScopeQuery: QueryParam[List[String]]): Task[OrgApacheSlingI18nImplI18NFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingI18nImplI18NFilterInfo] = jsonOf[OrgApacheSlingI18nImplI18NFilterInfo]

    val path = "/system/console/configMgr/org.apache.sling.i18n.impl.I18NFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("slingFilterScope", Some(sling.filter.scopeQuery.toParamString(sling.filter.scope))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingI18nImplI18NFilterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingI18nImplJcrResourceBundleProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], localeDefault: String, preloadBundles: Boolean, invalidationDelay: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], localeDefaultQuery: QueryParam[String], preloadBundlesQuery: QueryParam[Boolean], invalidationDelayQuery: QueryParam[Integer]): Task[OrgApacheSlingI18nImplJcrResourceBundleProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingI18nImplJcrResourceBundleProviderInfo] = jsonOf[OrgApacheSlingI18nImplJcrResourceBundleProviderInfo]

    val path = "/system/console/configMgr/org.apache.sling.i18n.impl.JcrResourceBundleProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("localeDefault", Some(locale.defaultQuery.toParamString(locale.default))), ("preloadBundles", Some(preload.bundlesQuery.toParamString(preload.bundles))), ("invalidationDelay", Some(invalidation.delayQuery.toParamString(invalidation.delay))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingI18nImplJcrResourceBundleProviderInfo](req)

    } yield resp
  }
  
  def orgApacheSlingInstallerProviderJcrImplJcrInstaller(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], handlerSchemes: List[String], slingJcrinstallFolderNameRegexp: String, slingJcrinstallFolderMaxDepth: Integer, slingJcrinstallSearchPath: List[String], slingJcrinstallNewConfigPath: String, slingJcrinstallSignalPath: String, slingJcrinstallEnableWriteback: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], handlerSchemesQuery: QueryParam[List[String]], slingJcrinstallFolderNameRegexpQuery: QueryParam[String], slingJcrinstallFolderMaxDepthQuery: QueryParam[Integer], slingJcrinstallSearchPathQuery: QueryParam[List[String]], slingJcrinstallNewConfigPathQuery: QueryParam[String], slingJcrinstallSignalPathQuery: QueryParam[String], slingJcrinstallEnableWritebackQuery: QueryParam[Boolean]): Task[OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo] = jsonOf[OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo]

    val path = "/system/console/configMgr/org.apache.sling.installer.provider.jcr.impl.JcrInstaller"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("handlerSchemes", Some(handler.schemesQuery.toParamString(handler.schemes))), ("slingJcrinstallFolderNameRegexp", Some(sling.jcrinstall.folder.name.regexpQuery.toParamString(sling.jcrinstall.folder.name.regexp))), ("slingJcrinstallFolderMaxDepth", Some(sling.jcrinstall.folder.max.depthQuery.toParamString(sling.jcrinstall.folder.max.depth))), ("slingJcrinstallSearchPath", Some(sling.jcrinstall.search.pathQuery.toParamString(sling.jcrinstall.search.path))), ("slingJcrinstallNewConfigPath", Some(sling.jcrinstall.new.config.pathQuery.toParamString(sling.jcrinstall.new.config.path))), ("slingJcrinstallSignalPath", Some(sling.jcrinstall.signal.pathQuery.toParamString(sling.jcrinstall.signal.path))), ("slingJcrinstallEnableWriteback", Some(sling.jcrinstall.enable.writebackQuery.toParamString(sling.jcrinstall.enable.writeback))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrBaseInternalLoginAdminWhitelist(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], whitelistBypass: Boolean, whitelistBundlesRegexp: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], whitelistBypassQuery: QueryParam[Boolean], whitelistBundlesRegexpQuery: QueryParam[String]): Task[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo] = jsonOf[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.base.internal.LoginAdminWhitelist"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("whitelistBypass", Some(whitelist.bypassQuery.toParamString(whitelist.bypass))), ("whitelistBundlesRegexp", Some(whitelist.bundles.regexpQuery.toParamString(whitelist.bundles.regexp))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrBaseInternalLoginAdminWhitelistFragment(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], whitelistName: String, whitelistBundles: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], whitelistNameQuery: QueryParam[String], whitelistBundlesQuery: QueryParam[List[String]]): Task[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo] = jsonOf[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.base.internal.LoginAdminWhitelist.fragment"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("whitelistName", Some(whitelist.nameQuery.toParamString(whitelist.name))), ("whitelistBundles", Some(whitelist.bundlesQuery.toParamString(whitelist.bundles))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrDavexImplServletsSlingDavExServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], alias: String, davCreateAbsoluteUri: Boolean, davProtectedhandlers: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], aliasQuery: QueryParam[String], davCreateAbsoluteUriQuery: QueryParam[Boolean], davProtectedhandlersQuery: QueryParam[String]): Task[OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo] = jsonOf[OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("alias", Some(aliasQuery.toParamString(alias))), ("davCreateAbsoluteUri", Some(dav.create-absolute-uriQuery.toParamString(dav.create-absolute-uri))), ("davProtectedhandlers", Some(dav.protectedhandlersQuery.toParamString(dav.protectedhandlers))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrJackrabbitServerJndiRegistrationSupport(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], javaNamingFactoryInitial: String, javaNamingProviderUrl: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], javaNamingFactoryInitialQuery: QueryParam[String], javaNamingProviderUrlQuery: QueryParam[String]): Task[OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo] = jsonOf[OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.jackrabbit.server.JndiRegistrationSupport"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("javaNamingFactoryInitial", Some(java.naming.factory.initialQuery.toParamString(java.naming.factory.initial))), ("javaNamingProviderUrl", Some(java.naming.provider.urlQuery.toParamString(java.naming.provider.url))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrJackrabbitServerRmiRegistrationSupport(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], port: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], portQuery: QueryParam[Integer]): Task[OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo] = jsonOf[OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.jackrabbit.server.RmiRegistrationSupport"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("port", Some(portQuery.toParamString(port))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrRepoinitImplRepositoryInitializer(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], references: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], referencesQuery: QueryParam[List[String]]): Task[OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo] = jsonOf[OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.repoinit.impl.RepositoryInitializer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("references", Some(referencesQuery.toParamString(references))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrRepoinitRepositoryInitializer(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], references: List[String], scripts: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], referencesQuery: QueryParam[List[String]], scriptsQuery: QueryParam[List[String]]): Task[OrgApacheSlingJcrRepoinitRepositoryInitializerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrRepoinitRepositoryInitializerInfo] = jsonOf[OrgApacheSlingJcrRepoinitRepositoryInitializerInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.repoinit.RepositoryInitializer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("references", Some(referencesQuery.toParamString(references))), ("scripts", Some(scriptsQuery.toParamString(scripts))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrRepoinitRepositoryInitializerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], resourceResolverSearchpath: List[String], resourceResolverManglenamespaces: Boolean, resourceResolverAllowDirect: Boolean, resourceResolverRequiredProviders: List[String], resourceResolverRequiredProvidernames: List[String], resourceResolverVirtual: List[String], resourceResolverMapping: List[String], resourceResolverMapLocation: String, resourceResolverMapObservation: List[String], resourceResolverDefaultVanityRedirectStatus: Integer, resourceResolverEnableVanitypath: Boolean, resourceResolverVanitypathMaxEntries: Integer, resourceResolverVanitypathMaxEntriesStartup: Boolean, resourceResolverVanitypathBloomfilterMaxBytes: Integer, resourceResolverOptimizeAliasResolution: Boolean, resourceResolverVanitypathWhitelist: List[String], resourceResolverVanitypathBlacklist: List[String], resourceResolverVanityPrecedence: Boolean, resourceResolverProviderhandlingParanoid: Boolean, resourceResolverLogClosing: Boolean, resourceResolverLogUnclosed: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], resourceResolverSearchpathQuery: QueryParam[List[String]], resourceResolverManglenamespacesQuery: QueryParam[Boolean], resourceResolverAllowDirectQuery: QueryParam[Boolean], resourceResolverRequiredProvidersQuery: QueryParam[List[String]], resourceResolverRequiredProvidernamesQuery: QueryParam[List[String]], resourceResolverVirtualQuery: QueryParam[List[String]], resourceResolverMappingQuery: QueryParam[List[String]], resourceResolverMapLocationQuery: QueryParam[String], resourceResolverMapObservationQuery: QueryParam[List[String]], resourceResolverDefaultVanityRedirectStatusQuery: QueryParam[Integer], resourceResolverEnableVanitypathQuery: QueryParam[Boolean], resourceResolverVanitypathMaxEntriesQuery: QueryParam[Integer], resourceResolverVanitypathMaxEntriesStartupQuery: QueryParam[Boolean], resourceResolverVanitypathBloomfilterMaxBytesQuery: QueryParam[Integer], resourceResolverOptimizeAliasResolutionQuery: QueryParam[Boolean], resourceResolverVanitypathWhitelistQuery: QueryParam[List[String]], resourceResolverVanitypathBlacklistQuery: QueryParam[List[String]], resourceResolverVanityPrecedenceQuery: QueryParam[Boolean], resourceResolverProviderhandlingParanoidQuery: QueryParam[Boolean], resourceResolverLogClosingQuery: QueryParam[Boolean], resourceResolverLogUnclosedQuery: QueryParam[Boolean]): Task[OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo] = jsonOf[OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.resource.internal.JcrResourceResolverFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("resourceResolverSearchpath", Some(resource.resolver.searchpathQuery.toParamString(resource.resolver.searchpath))), ("resourceResolverManglenamespaces", Some(resource.resolver.manglenamespacesQuery.toParamString(resource.resolver.manglenamespaces))), ("resourceResolverAllowDirect", Some(resource.resolver.allowDirectQuery.toParamString(resource.resolver.allowDirect))), ("resourceResolverRequiredProviders", Some(resource.resolver.required.providersQuery.toParamString(resource.resolver.required.providers))), ("resourceResolverRequiredProvidernames", Some(resource.resolver.required.providernamesQuery.toParamString(resource.resolver.required.providernames))), ("resourceResolverVirtual", Some(resource.resolver.virtualQuery.toParamString(resource.resolver.virtual))), ("resourceResolverMapping", Some(resource.resolver.mappingQuery.toParamString(resource.resolver.mapping))), ("resourceResolverMapLocation", Some(resource.resolver.map.locationQuery.toParamString(resource.resolver.map.location))), ("resourceResolverMapObservation", Some(resource.resolver.map.observationQuery.toParamString(resource.resolver.map.observation))), ("resourceResolverDefaultVanityRedirectStatus", Some(resource.resolver.default.vanity.redirect.statusQuery.toParamString(resource.resolver.default.vanity.redirect.status))), ("resourceResolverEnableVanitypath", Some(resource.resolver.enable.vanitypathQuery.toParamString(resource.resolver.enable.vanitypath))), ("resourceResolverVanitypathMaxEntries", Some(resource.resolver.vanitypath.maxEntriesQuery.toParamString(resource.resolver.vanitypath.maxEntries))), ("resourceResolverVanitypathMaxEntriesStartup", Some(resource.resolver.vanitypath.maxEntries.startupQuery.toParamString(resource.resolver.vanitypath.maxEntries.startup))), ("resourceResolverVanitypathBloomfilterMaxBytes", Some(resource.resolver.vanitypath.bloomfilter.maxBytesQuery.toParamString(resource.resolver.vanitypath.bloomfilter.maxBytes))), ("resourceResolverOptimizeAliasResolution", Some(resource.resolver.optimize.alias.resolutionQuery.toParamString(resource.resolver.optimize.alias.resolution))), ("resourceResolverVanitypathWhitelist", Some(resource.resolver.vanitypath.whitelistQuery.toParamString(resource.resolver.vanitypath.whitelist))), ("resourceResolverVanitypathBlacklist", Some(resource.resolver.vanitypath.blacklistQuery.toParamString(resource.resolver.vanitypath.blacklist))), ("resourceResolverVanityPrecedence", Some(resource.resolver.vanity.precedenceQuery.toParamString(resource.resolver.vanity.precedence))), ("resourceResolverProviderhandlingParanoid", Some(resource.resolver.providerhandling.paranoidQuery.toParamString(resource.resolver.providerhandling.paranoid))), ("resourceResolverLogClosing", Some(resource.resolver.log.closingQuery.toParamString(resource.resolver.log.closing))), ("resourceResolverLogUnclosed", Some(resource.resolver.log.unclosedQuery.toParamString(resource.resolver.log.unclosed))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrResourceInternalJcrSystemUserValidator(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], allowOnlySystemUser: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], allowOnlySystemUserQuery: QueryParam[Boolean]): Task[OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo] = jsonOf[OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.resource.internal.JcrSystemUserValidator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("allowOnlySystemUser", Some(allow.only.system.userQuery.toParamString(allow.only.system.user))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrResourcesecurityImplResourceAccessGateFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, checkpathPrefix: String, jcrPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], checkpathPrefixQuery: QueryParam[String], jcrPathQuery: QueryParam[String]): Task[OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo] = jsonOf[OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.resourcesecurity.impl.ResourceAccessGateFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("checkpathPrefix", Some(checkpath.prefixQuery.toParamString(checkpath.prefix))), ("jcrPath", Some(jcrPathQuery.toParamString(jcrPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrWebdavImplHandlerDefaultHandlerService(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, typeCollections: String, typeNoncollections: String, typeContent: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], typeCollectionsQuery: QueryParam[String], typeNoncollectionsQuery: QueryParam[String], typeContentQuery: QueryParam[String]): Task[OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo] = jsonOf[OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.webdav.impl.handler.DefaultHandlerService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("typeCollections", Some(type.collectionsQuery.toParamString(type.collections))), ("typeNoncollections", Some(type.noncollectionsQuery.toParamString(type.noncollections))), ("typeContent", Some(type.contentQuery.toParamString(type.content))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServic(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer]): Task[OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo] = jsonOf[OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.webdav.impl.handler.DirListingExportHandlerService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrWebdavImplServletsSimpleWebDavServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], davRoot: String, davCreateAbsoluteUri: Boolean, davRealm: String, collectionTypes: List[String], filterPrefixes: List[String], filterTypes: String, filterUris: String, typeCollections: String, typeNoncollections: String, typeContent: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], davRootQuery: QueryParam[String], davCreateAbsoluteUriQuery: QueryParam[Boolean], davRealmQuery: QueryParam[String], collectionTypesQuery: QueryParam[List[String]], filterPrefixesQuery: QueryParam[List[String]], filterTypesQuery: QueryParam[String], filterUrisQuery: QueryParam[String], typeCollectionsQuery: QueryParam[String], typeNoncollectionsQuery: QueryParam[String], typeContentQuery: QueryParam[String]): Task[OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo] = jsonOf[OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.webdav.impl.servlets.SimpleWebDavServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("davRoot", Some(dav.rootQuery.toParamString(dav.root))), ("davCreateAbsoluteUri", Some(dav.create-absolute-uriQuery.toParamString(dav.create-absolute-uri))), ("davRealm", Some(dav.realmQuery.toParamString(dav.realm))), ("collectionTypes", Some(collection.typesQuery.toParamString(collection.types))), ("filterPrefixes", Some(filter.prefixesQuery.toParamString(filter.prefixes))), ("filterTypes", Some(filter.typesQuery.toParamString(filter.types))), ("filterUris", Some(filter.urisQuery.toParamString(filter.uris))), ("typeCollections", Some(type.collectionsQuery.toParamString(type.collections))), ("typeNoncollections", Some(type.noncollectionsQuery.toParamString(type.noncollections))), ("typeContent", Some(type.contentQuery.toParamString(type.content))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJmxProviderImplJMXResourceProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerRoots: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerRootsQuery: QueryParam[String]): Task[OrgApacheSlingJmxProviderImplJMXResourceProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJmxProviderImplJMXResourceProviderInfo] = jsonOf[OrgApacheSlingJmxProviderImplJMXResourceProviderInfo]

    val path = "/system/console/configMgr/org.apache.sling.jmx.provider.impl.JMXResourceProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerRoots", Some(provider.rootsQuery.toParamString(provider.roots))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJmxProviderImplJMXResourceProviderInfo](req)

    } yield resp
  }
  
  def orgApacheSlingModelsImplModelAdapterFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], osgiHttpWhiteboardListener: String, osgiHttpWhiteboardContextSelect: String, maxRecursionDepth: Integer, cleanupJobPeriod: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], osgiHttpWhiteboardListenerQuery: QueryParam[String], osgiHttpWhiteboardContextSelectQuery: QueryParam[String], maxRecursionDepthQuery: QueryParam[Integer], cleanupJobPeriodQuery: QueryParam[Integer]): Task[OrgApacheSlingModelsImplModelAdapterFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingModelsImplModelAdapterFactoryInfo] = jsonOf[OrgApacheSlingModelsImplModelAdapterFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.models.impl.ModelAdapterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("osgiHttpWhiteboardListener", Some(osgi.http.whiteboard.listenerQuery.toParamString(osgi.http.whiteboard.listener))), ("osgiHttpWhiteboardContextSelect", Some(osgi.http.whiteboard.context.selectQuery.toParamString(osgi.http.whiteboard.context.select))), ("maxRecursionDepth", Some(max.recursion.depthQuery.toParamString(max.recursion.depth))), ("cleanupJobPeriod", Some(cleanup.job.periodQuery.toParamString(cleanup.job.period))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingModelsImplModelAdapterFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingModelsJacksonexporterImplResourceModuleProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxRecursionLevels: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxRecursionLevelsQuery: QueryParam[Integer]): Task[OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo] = jsonOf[OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo]

    val path = "/system/console/configMgr/org.apache.sling.models.jacksonexporter.impl.ResourceModuleProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxRecursionLevels", Some(max.recursion.levelsQuery.toParamString(max.recursion.levels))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo](req)

    } yield resp
  }
  
  def orgApacheSlingResourceInventoryImplResourceInventoryPrinterFacto(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], felixInventoryPrinterName: String, felixInventoryPrinterTitle: String, `path`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], felixInventoryPrinterNameQuery: QueryParam[String], felixInventoryPrinterTitleQuery: QueryParam[String], `path`Query: QueryParam[String]): Task[OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo] = jsonOf[OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo]

    val path = "/system/console/configMgr/org.apache.sling.resource.inventory.impl.ResourceInventoryPrinterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("felixInventoryPrinterName", Some(felix.inventory.printer.nameQuery.toParamString(felix.inventory.printer.name))), ("felixInventoryPrinterTitle", Some(felix.inventory.printer.titleQuery.toParamString(felix.inventory.printer.title))), ("`path`", Some(pathQuery.toParamString(path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo](req)

    } yield resp
  }
  
  def orgApacheSlingResourcemergerImplMergedResourceProviderFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mergeRoot: String, mergeReadOnly: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mergeRootQuery: QueryParam[String], mergeReadOnlyQuery: QueryParam[Boolean]): Task[OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo] = jsonOf[OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.resourcemerger.impl.MergedResourceProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mergeRoot", Some(merge.rootQuery.toParamString(merge.root))), ("mergeReadOnly", Some(merge.readOnlyQuery.toParamString(merge.readOnly))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingResourcemergerPickerOverriding(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mergeRoot: String, mergeReadOnly: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mergeRootQuery: QueryParam[String], mergeReadOnlyQuery: QueryParam[Boolean]): Task[OrgApacheSlingResourcemergerPickerOverridingInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingResourcemergerPickerOverridingInfo] = jsonOf[OrgApacheSlingResourcemergerPickerOverridingInfo]

    val path = "/system/console/configMgr/org.apache.sling.resourcemerger.picker.overriding"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mergeRoot", Some(merge.rootQuery.toParamString(merge.root))), ("mergeReadOnly", Some(merge.readOnlyQuery.toParamString(merge.readOnly))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingResourcemergerPickerOverridingInfo](req)

    } yield resp
  }
  
  def orgApacheSlingScriptingCoreImplScriptCacheImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingScriptingCacheSize: Integer, orgApacheSlingScriptingCacheAdditionalExtensions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingScriptingCacheSizeQuery: QueryParam[Integer], orgApacheSlingScriptingCacheAdditionalExtensionsQuery: QueryParam[List[String]]): Task[OrgApacheSlingScriptingCoreImplScriptCacheImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingScriptingCoreImplScriptCacheImplInfo] = jsonOf[OrgApacheSlingScriptingCoreImplScriptCacheImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.scripting.core.impl.ScriptCacheImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingScriptingCacheSize", Some(org.apache.sling.scripting.cache.sizeQuery.toParamString(org.apache.sling.scripting.cache.size))), ("orgApacheSlingScriptingCacheAdditionalExtensions", Some(org.apache.sling.scripting.cache.additional_extensionsQuery.toParamString(org.apache.sling.scripting.cache.additional_extensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingScriptingCoreImplScriptCacheImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingScriptingCoreImplScriptingResourceResolverProvider(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], logStacktraceOnclose: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], logStacktraceOncloseQuery: QueryParam[Boolean]): Task[OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo] = jsonOf[OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo]

    val path = "/system/console/configMgr/org.apache.sling.scripting.core.impl.ScriptingResourceResolverProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("logStacktraceOnclose", Some(log.stacktrace.oncloseQuery.toParamString(log.stacktrace.onclose))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo](req)

    } yield resp
  }
  
  def orgApacheSlingScriptingJavaImplJavaScriptEngineFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], javaClassdebuginfo: Boolean, javaJavaEncoding: String, javaCompilerSourceVM: String, javaCompilerTargetVM: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], javaClassdebuginfoQuery: QueryParam[Boolean], javaJavaEncodingQuery: QueryParam[String], javaCompilerSourceVMQuery: QueryParam[String], javaCompilerTargetVMQuery: QueryParam[String]): Task[OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo] = jsonOf[OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.scripting.java.impl.JavaScriptEngineFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("javaClassdebuginfo", Some(java.classdebuginfoQuery.toParamString(java.classdebuginfo))), ("javaJavaEncoding", Some(java.javaEncodingQuery.toParamString(java.javaEncoding))), ("javaCompilerSourceVM", Some(java.compilerSourceVMQuery.toParamString(java.compilerSourceVM))), ("javaCompilerTargetVM", Some(java.compilerTargetVMQuery.toParamString(java.compilerTargetVM))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFa(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingScriptingJavascriptRhinoOptLevel: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingScriptingJavascriptRhinoOptLevelQuery: QueryParam[Integer]): Task[OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo] = jsonOf[OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo]

    val path = "/system/console/configMgr/org.apache.sling.scripting.javascript.internal.RhinoJavaScriptEngineFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingScriptingJavascriptRhinoOptLevel", Some(org.apache.sling.scripting.javascript.rhino.optLevelQuery.toParamString(org.apache.sling.scripting.javascript.rhino.optLevel))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo](req)

    } yield resp
  }
  
  def orgApacheSlingScriptingJspJspScriptEngineFactory(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jasperCompilerTargetVM: String, jasperCompilerSourceVM: String, jasperClassdebuginfo: Boolean, jasperEnablePooling: Boolean, jasperIeClassId: String, jasperGenStringAsCharArray: Boolean, jasperKeepgenerated: Boolean, jasperMappedfile: Boolean, jasperTrimSpaces: Boolean, jasperDisplaySourceFragments: Boolean, defaultIsSession: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jasperCompilerTargetVMQuery: QueryParam[String], jasperCompilerSourceVMQuery: QueryParam[String], jasperClassdebuginfoQuery: QueryParam[Boolean], jasperEnablePoolingQuery: QueryParam[Boolean], jasperIeClassIdQuery: QueryParam[String], jasperGenStringAsCharArrayQuery: QueryParam[Boolean], jasperKeepgeneratedQuery: QueryParam[Boolean], jasperMappedfileQuery: QueryParam[Boolean], jasperTrimSpacesQuery: QueryParam[Boolean], jasperDisplaySourceFragmentsQuery: QueryParam[Boolean], defaultIsSessionQuery: QueryParam[Boolean]): Task[OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo] = jsonOf[OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.scripting.jsp.JspScriptEngineFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jasperCompilerTargetVM", Some(jasper.compilerTargetVMQuery.toParamString(jasper.compilerTargetVM))), ("jasperCompilerSourceVM", Some(jasper.compilerSourceVMQuery.toParamString(jasper.compilerSourceVM))), ("jasperClassdebuginfo", Some(jasper.classdebuginfoQuery.toParamString(jasper.classdebuginfo))), ("jasperEnablePooling", Some(jasper.enablePoolingQuery.toParamString(jasper.enablePooling))), ("jasperIeClassId", Some(jasper.ieClassIdQuery.toParamString(jasper.ieClassId))), ("jasperGenStringAsCharArray", Some(jasper.genStringAsCharArrayQuery.toParamString(jasper.genStringAsCharArray))), ("jasperKeepgenerated", Some(jasper.keepgeneratedQuery.toParamString(jasper.keepgenerated))), ("jasperMappedfile", Some(jasper.mappedfileQuery.toParamString(jasper.mappedfile))), ("jasperTrimSpaces", Some(jasper.trimSpacesQuery.toParamString(jasper.trimSpaces))), ("jasperDisplaySourceFragments", Some(jasper.displaySourceFragmentsQuery.toParamString(jasper.displaySourceFragments))), ("defaultIsSession", Some(default.is.sessionQuery.toParamString(default.is.session))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProv(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingScriptingSightlyJsBindings: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingScriptingSightlyJsBindingsQuery: QueryParam[List[String]]): Task[OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo] = jsonOf[OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo]

    val path = "/system/console/configMgr/org.apache.sling.scripting.sightly.js.impl.jsapi.SlyBindingsValuesProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingScriptingSightlyJsBindings", Some(org.apache.sling.scripting.sightly.js.bindingsQuery.toParamString(org.apache.sling.scripting.sightly.js.bindings))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo](req)

    } yield resp
  }
  
  def orgApacheSlingSecurityImplContentDispositionFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingContentDispositionPaths: List[String], slingContentDispositionExcludedPaths: List[String], slingContentDispositionAllPaths: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingContentDispositionPathsQuery: QueryParam[List[String]], slingContentDispositionExcludedPathsQuery: QueryParam[List[String]], slingContentDispositionAllPathsQuery: QueryParam[Boolean]): Task[OrgApacheSlingSecurityImplContentDispositionFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingSecurityImplContentDispositionFilterInfo] = jsonOf[OrgApacheSlingSecurityImplContentDispositionFilterInfo]

    val path = "/system/console/configMgr/org.apache.sling.security.impl.ContentDispositionFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingContentDispositionPaths", Some(sling.content.disposition.pathsQuery.toParamString(sling.content.disposition.paths))), ("slingContentDispositionExcludedPaths", Some(sling.content.disposition.excluded.pathsQuery.toParamString(sling.content.disposition.excluded.paths))), ("slingContentDispositionAllPaths", Some(sling.content.disposition.all.pathsQuery.toParamString(sling.content.disposition.all.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingSecurityImplContentDispositionFilterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingSecurityImplReferrerFilter(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], allowEmpty: Boolean, allowHosts: List[String], allowHostsRegexp: List[String], filterMethods: List[String], excludeAgentsRegexp: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], allowEmptyQuery: QueryParam[Boolean], allowHostsQuery: QueryParam[List[String]], allowHostsRegexpQuery: QueryParam[List[String]], filterMethodsQuery: QueryParam[List[String]], excludeAgentsRegexpQuery: QueryParam[List[String]]): Task[OrgApacheSlingSecurityImplReferrerFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingSecurityImplReferrerFilterInfo] = jsonOf[OrgApacheSlingSecurityImplReferrerFilterInfo]

    val path = "/system/console/configMgr/org.apache.sling.security.impl.ReferrerFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("allowEmpty", Some(allow.emptyQuery.toParamString(allow.empty))), ("allowHosts", Some(allow.hostsQuery.toParamString(allow.hosts))), ("allowHostsRegexp", Some(allow.hosts.regexpQuery.toParamString(allow.hosts.regexp))), ("filterMethods", Some(filter.methodsQuery.toParamString(filter.methods))), ("excludeAgentsRegexp", Some(exclude.agents.regexpQuery.toParamString(exclude.agents.regexp))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingSecurityImplReferrerFilterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServiceusermappingImplServiceUserMapperImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], userMapping: List[String], userDefault: String, userEnableDefaultMapping: Boolean, requireValidation: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], userMappingQuery: QueryParam[List[String]], userDefaultQuery: QueryParam[String], userEnableDefaultMappingQuery: QueryParam[Boolean], requireValidationQuery: QueryParam[Boolean]): Task[OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo] = jsonOf[OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.serviceusermapping.impl.ServiceUserMapperImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("userMapping", Some(user.mappingQuery.toParamString(user.mapping))), ("userDefault", Some(user.defaultQuery.toParamString(user.default))), ("userEnableDefaultMapping", Some(user.enable.default.mappingQuery.toParamString(user.enable.default.mapping))), ("requireValidation", Some(require.validationQuery.toParamString(require.validation))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServiceusermappingImplServiceUserMapperImplAmended(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, userMapping: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], userMappingQuery: QueryParam[List[String]]): Task[OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo] = jsonOf[OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo]

    val path = "/system/console/configMgr/org.apache.sling.serviceusermapping.impl.ServiceUserMapperImpl.amended"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("userMapping", Some(user.mappingQuery.toParamString(user.mapping))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServletsGetDefaultGetServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], aliases: List[String], index: Boolean, indexFiles: List[String], enableHtml: Boolean, enableJson: Boolean, enableTxt: Boolean, enableXml: Boolean, jsonMaximumresults: Integer, ecmaSuport: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], aliasesQuery: QueryParam[List[String]], indexQuery: QueryParam[Boolean], indexFilesQuery: QueryParam[List[String]], enableHtmlQuery: QueryParam[Boolean], enableJsonQuery: QueryParam[Boolean], enableTxtQuery: QueryParam[Boolean], enableXmlQuery: QueryParam[Boolean], jsonMaximumresultsQuery: QueryParam[Integer], ecmaSuportQuery: QueryParam[Boolean]): Task[OrgApacheSlingServletsGetDefaultGetServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServletsGetDefaultGetServletInfo] = jsonOf[OrgApacheSlingServletsGetDefaultGetServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.servlets.get.DefaultGetServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("aliases", Some(aliasesQuery.toParamString(aliases))), ("index", Some(indexQuery.toParamString(index))), ("indexFiles", Some(index.filesQuery.toParamString(index.files))), ("enableHtml", Some(enable.htmlQuery.toParamString(enable.html))), ("enableJson", Some(enable.jsonQuery.toParamString(enable.json))), ("enableTxt", Some(enable.txtQuery.toParamString(enable.txt))), ("enableXml", Some(enable.xmlQuery.toParamString(enable.xml))), ("jsonMaximumresults", Some(json.maximumresultsQuery.toParamString(json.maximumresults))), ("ecmaSuport", Some(ecmaSuportQuery.toParamString(ecmaSuport))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServletsGetDefaultGetServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServletsGetImplVersionVersionInfoServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletSelectors: List[String], ecmaSuport: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletSelectorsQuery: QueryParam[List[String]], ecmaSuportQuery: QueryParam[Boolean]): Task[OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo] = jsonOf[OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.servlets.get.impl.version.VersionInfoServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("ecmaSuport", Some(ecmaSuportQuery.toParamString(ecmaSuport))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServletsPostImplHelperChunkCleanUpTask(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, schedulerConcurrent: Boolean, chunkCleanupAge: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], schedulerConcurrentQuery: QueryParam[Boolean], chunkCleanupAgeQuery: QueryParam[Integer]): Task[OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo] = jsonOf[OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo]

    val path = "/system/console/configMgr/org.apache.sling.servlets.post.impl.helper.ChunkCleanUpTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("schedulerConcurrent", Some(scheduler.concurrentQuery.toParamString(scheduler.concurrent))), ("chunkCleanupAge", Some(chunk.cleanup.ageQuery.toParamString(chunk.cleanup.age))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServletsPostImplSlingPostServlet(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], servletPostDateFormats: List[String], servletPostNodeNameHints: List[String], servletPostNodeNameMaxLength: Integer, servletPostCheckinNewVersionableNodes: Boolean, servletPostAutoCheckout: Boolean, servletPostAutoCheckin: Boolean, servletPostIgnorePattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], servletPostDateFormatsQuery: QueryParam[List[String]], servletPostNodeNameHintsQuery: QueryParam[List[String]], servletPostNodeNameMaxLengthQuery: QueryParam[Integer], servletPostCheckinNewVersionableNodesQuery: QueryParam[Boolean], servletPostAutoCheckoutQuery: QueryParam[Boolean], servletPostAutoCheckinQuery: QueryParam[Boolean], servletPostIgnorePatternQuery: QueryParam[String]): Task[OrgApacheSlingServletsPostImplSlingPostServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServletsPostImplSlingPostServletInfo] = jsonOf[OrgApacheSlingServletsPostImplSlingPostServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.servlets.post.impl.SlingPostServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("servletPostDateFormats", Some(servlet.post.dateFormatsQuery.toParamString(servlet.post.dateFormats))), ("servletPostNodeNameHints", Some(servlet.post.nodeNameHintsQuery.toParamString(servlet.post.nodeNameHints))), ("servletPostNodeNameMaxLength", Some(servlet.post.nodeNameMaxLengthQuery.toParamString(servlet.post.nodeNameMaxLength))), ("servletPostCheckinNewVersionableNodes", Some(servlet.post.checkinNewVersionableNodesQuery.toParamString(servlet.post.checkinNewVersionableNodes))), ("servletPostAutoCheckout", Some(servlet.post.autoCheckoutQuery.toParamString(servlet.post.autoCheckout))), ("servletPostAutoCheckin", Some(servlet.post.autoCheckinQuery.toParamString(servlet.post.autoCheckin))), ("servletPostIgnorePattern", Some(servlet.post.ignorePatternQuery.toParamString(servlet.post.ignorePattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServletsPostImplSlingPostServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServletsResolverSlingServletResolver(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], servletresolverServletRoot: String, servletresolverCacheSize: Integer, servletresolverPaths: List[String], servletresolverDefaultExtensions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], servletresolverServletRootQuery: QueryParam[String], servletresolverCacheSizeQuery: QueryParam[Integer], servletresolverPathsQuery: QueryParam[List[String]], servletresolverDefaultExtensionsQuery: QueryParam[List[String]]): Task[OrgApacheSlingServletsResolverSlingServletResolverInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServletsResolverSlingServletResolverInfo] = jsonOf[OrgApacheSlingServletsResolverSlingServletResolverInfo]

    val path = "/system/console/configMgr/org.apache.sling.servlets.resolver.SlingServletResolver"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("servletresolverServletRoot", Some(servletresolver.servletRootQuery.toParamString(servletresolver.servletRoot))), ("servletresolverCacheSize", Some(servletresolver.cacheSizeQuery.toParamString(servletresolver.cacheSize))), ("servletresolverPaths", Some(servletresolver.pathsQuery.toParamString(servletresolver.paths))), ("servletresolverDefaultExtensions", Some(servletresolver.defaultExtensionsQuery.toParamString(servletresolver.defaultExtensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServletsResolverSlingServletResolverInfo](req)

    } yield resp
  }
  
  def orgApacheSlingSettingsImplSlingSettingsServiceImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingName: String, slingDescription: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingNameQuery: QueryParam[String], slingDescriptionQuery: QueryParam[String]): Task[OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo] = jsonOf[OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.settings.impl.SlingSettingsServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingName", Some(sling.nameQuery.toParamString(sling.name))), ("slingDescription", Some(sling.descriptionQuery.toParamString(sling.description))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingStartupfilterImplStartupFilterImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], activeByDefault: Boolean, defaultMessage: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], activeByDefaultQuery: QueryParam[Boolean], defaultMessageQuery: QueryParam[String]): Task[OrgApacheSlingStartupfilterImplStartupFilterImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingStartupfilterImplStartupFilterImplInfo] = jsonOf[OrgApacheSlingStartupfilterImplStartupFilterImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.startupfilter.impl.StartupFilterImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("activeByDefault", Some(active.by.defaultQuery.toParamString(active.by.default))), ("defaultMessage", Some(default.messageQuery.toParamString(default.message))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingStartupfilterImplStartupFilterImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingTenantInternalTenantProviderImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], tenantRoot: String, tenantPathMatcher: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], tenantRootQuery: QueryParam[String], tenantPathMatcherQuery: QueryParam[List[String]]): Task[OrgApacheSlingTenantInternalTenantProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingTenantInternalTenantProviderImplInfo] = jsonOf[OrgApacheSlingTenantInternalTenantProviderImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.tenant.internal.TenantProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("tenantRoot", Some(tenant.rootQuery.toParamString(tenant.root))), ("tenantPathMatcher", Some(tenant.path.matcherQuery.toParamString(tenant.path.matcher))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingTenantInternalTenantProviderImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingTracerInternalLogTracer(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], tracerSets: List[String], enabled: Boolean, servletEnabled: Boolean, recordingCacheSizeInMB: Integer, recordingCacheDurationInSecs: Integer, recordingCompressionEnabled: Boolean, gzipResponse: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], tracerSetsQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], servletEnabledQuery: QueryParam[Boolean], recordingCacheSizeInMBQuery: QueryParam[Integer], recordingCacheDurationInSecsQuery: QueryParam[Integer], recordingCompressionEnabledQuery: QueryParam[Boolean], gzipResponseQuery: QueryParam[Boolean]): Task[OrgApacheSlingTracerInternalLogTracerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingTracerInternalLogTracerInfo] = jsonOf[OrgApacheSlingTracerInternalLogTracerInfo]

    val path = "/system/console/configMgr/org.apache.sling.tracer.internal.LogTracer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("tracerSets", Some(tracerSetsQuery.toParamString(tracerSets))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("servletEnabled", Some(servletEnabledQuery.toParamString(servletEnabled))), ("recordingCacheSizeInMB", Some(recordingCacheSizeInMBQuery.toParamString(recordingCacheSizeInMB))), ("recordingCacheDurationInSecs", Some(recordingCacheDurationInSecsQuery.toParamString(recordingCacheDurationInSecs))), ("recordingCompressionEnabled", Some(recordingCompressionEnabledQuery.toParamString(recordingCompressionEnabled))), ("gzipResponse", Some(gzipResponseQuery.toParamString(gzipResponse))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingTracerInternalLogTracerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingXssImplXSSFilterImpl(host: String, post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], policyPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], policyPathQuery: QueryParam[String]): Task[OrgApacheSlingXssImplXSSFilterImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingXssImplXSSFilterImplInfo] = jsonOf[OrgApacheSlingXssImplXSSFilterImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.xss.impl.XSSFilterImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("policyPath", Some(policyPathQuery.toParamString(policyPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(host + path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingXssImplXSSFilterImplInfo](req)

    } yield resp
  }
  
}

class HttpServiceConfigmgrApi(service: HttpService) {
  val client = Client.fromHttpService(service)

  def escape(value: String): String = URLEncoder.encode(value, "utf-8").replaceAll("\\+", "%20")

  def adaptiveFormAndInteractiveCommunicationWebChannelConfiguration(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], showPlaceholder: Boolean, maximumCacheEntries: Integer, afScriptingCompatversion: String, makeFileNameUnique: Boolean, generatingCompliantData: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], showPlaceholderQuery: QueryParam[Boolean], maximumCacheEntriesQuery: QueryParam[Integer], afScriptingCompatversionQuery: QueryParam[String], makeFileNameUniqueQuery: QueryParam[Boolean], generatingCompliantDataQuery: QueryParam[Boolean]): Task[AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo] = jsonOf[AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo]

    val path = "/system/console/configMgr/Adaptive Form and Interactive Communication Web Channel Configuration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("showPlaceholder", Some(showPlaceholderQuery.toParamString(showPlaceholder))), ("maximumCacheEntries", Some(maximumCacheEntriesQuery.toParamString(maximumCacheEntries))), ("afScriptingCompatversion", Some(af.scripting.compatversionQuery.toParamString(af.scripting.compatversion))), ("makeFileNameUnique", Some(makeFileNameUniqueQuery.toParamString(makeFileNameUnique))), ("generatingCompliantData", Some(generatingCompliantDataQuery.toParamString(generatingCompliantData))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo](req)

    } yield resp
  }
  
  def adaptiveFormAndInteractiveCommunicationWebChannelThemeConfigur(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fontList: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fontListQuery: QueryParam[List[String]]): Task[AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo] = jsonOf[AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo]

    val path = "/system/console/configMgr/Adaptive Form and Interactive Communication Web Channel Theme Configuration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fontList", Some(fontListQuery.toParamString(fontList))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo](req)

    } yield resp
  }
  
  def analyticsComponentQueryCacheService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsComponentQueryCacheSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsComponentQueryCacheSizeQuery: QueryParam[Integer]): Task[AnalyticsComponentQueryCacheServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[AnalyticsComponentQueryCacheServiceInfo] = jsonOf[AnalyticsComponentQueryCacheServiceInfo]

    val path = "/system/console/configMgr/Analytics Component Query Cache Service"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsComponentQueryCacheSize", Some(cq.analytics.component.query.cache.sizeQuery.toParamString(cq.analytics.component.query.cache.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[AnalyticsComponentQueryCacheServiceInfo](req)

    } yield resp
  }
  
  def apacheSlingHealthCheckResultHTMLSerializer(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], styleString: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], styleStringQuery: QueryParam[String]): Task[ApacheSlingHealthCheckResultHTMLSerializerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ApacheSlingHealthCheckResultHTMLSerializerInfo] = jsonOf[ApacheSlingHealthCheckResultHTMLSerializerInfo]

    val path = "/system/console/configMgr/Apache Sling Health Check Result HTML Serializer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("styleString", Some(styleStringQuery.toParamString(styleString))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ApacheSlingHealthCheckResultHTMLSerializerInfo](req)

    } yield resp
  }
  
  def comAdobeAemFormsndocumentsConfigAEMFormsManagerConfiguration(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], formsManagerConfigIncludeOOTBTemplates: Boolean, formsManagerConfigIncludeDeprecatedTemplates: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], formsManagerConfigIncludeOOTBTemplatesQuery: QueryParam[Boolean], formsManagerConfigIncludeDeprecatedTemplatesQuery: QueryParam[Boolean]): Task[ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo] = jsonOf[ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo]

    val path = "/system/console/configMgr/com.adobe.aem.formsndocuments.config.AEMFormsManagerConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("formsManagerConfigIncludeOOTBTemplates", Some(formsManagerConfig.includeOOTBTemplatesQuery.toParamString(formsManagerConfig.includeOOTBTemplates))), ("formsManagerConfigIncludeDeprecatedTemplates", Some(formsManagerConfig.includeDeprecatedTemplatesQuery.toParamString(formsManagerConfig.includeDeprecatedTemplates))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo](req)

    } yield resp
  }
  
  def comAdobeAemTransactionCoreImplTransactionRecorder(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], isTransactionRecordingEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], isTransactionRecordingEnabledQuery: QueryParam[Boolean]): Task[ComAdobeAemTransactionCoreImplTransactionRecorderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeAemTransactionCoreImplTransactionRecorderInfo] = jsonOf[ComAdobeAemTransactionCoreImplTransactionRecorderInfo]

    val path = "/system/console/configMgr/com.adobe.aem.transaction.core.impl.TransactionRecorder"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("isTransactionRecordingEnabled", Some(isTransactionRecordingEnabledQuery.toParamString(isTransactionRecordingEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeAemTransactionCoreImplTransactionRecorderInfo](req)

    } yield resp
  }
  
  def comAdobeAemUpgradePrechecksHcImplDeprecateIndexesHC(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String]): Task[ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo] = jsonOf[ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo]

    val path = "/system/console/configMgr/com.adobe.aem.upgrade.prechecks.hc.impl.DeprecateIndexesHC"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo](req)

    } yield resp
  }
  
  def comAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHC(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String]): Task[ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo] = jsonOf[ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo]

    val path = "/system/console/configMgr/com.adobe.aem.upgrade.prechecks.hc.impl.ReplicationAgentsDisabledHC"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo](req)

    } yield resp
  }
  
  def comAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], preUpgradeMaintenanceTasks: List[String], preUpgradeHcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], preUpgradeMaintenanceTasksQuery: QueryParam[List[String]], preUpgradeHcTagsQuery: QueryParam[List[String]]): Task[ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo] = jsonOf[ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo]

    val path = "/system/console/configMgr/com.adobe.aem.upgrade.prechecks.mbean.impl.PreUpgradeTasksMBeanImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("preUpgradeMaintenanceTasks", Some(pre-upgrade.maintenance.tasksQuery.toParamString(pre-upgrade.maintenance.tasks))), ("preUpgradeHcTags", Some(pre-upgrade.hc.tagsQuery.toParamString(pre-upgrade.hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo](req)

    } yield resp
  }
  
  def comAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], rootPath: String, fixInconsistencies: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], rootPathQuery: QueryParam[String], fixInconsistenciesQuery: QueryParam[Boolean]): Task[ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo] = jsonOf[ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo]

    val path = "/system/console/configMgr/com.adobe.aem.upgrade.prechecks.tasks.impl.ConsistencyCheckTaskImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("rootPath", Some(root.pathQuery.toParamString(root.path))), ("fixInconsistencies", Some(fix.inconsistenciesQuery.toParamString(fix.inconsistencies))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqAccountApiAccountManagementService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAccountmanagerTokenValidityPeriod: Integer, cqAccountmanagerConfigRequestnewaccountMail: String, cqAccountmanagerConfigRequestnewpwdMail: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAccountmanagerTokenValidityPeriodQuery: QueryParam[Integer], cqAccountmanagerConfigRequestnewaccountMailQuery: QueryParam[String], cqAccountmanagerConfigRequestnewpwdMailQuery: QueryParam[String]): Task[ComAdobeCqAccountApiAccountManagementServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqAccountApiAccountManagementServiceInfo] = jsonOf[ComAdobeCqAccountApiAccountManagementServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.account.api.AccountManagementService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAccountmanagerTokenValidityPeriod", Some(cq.accountmanager.token.validity.periodQuery.toParamString(cq.accountmanager.token.validity.period))), ("cqAccountmanagerConfigRequestnewaccountMail", Some(cq.accountmanager.config.requestnewaccount.mailQuery.toParamString(cq.accountmanager.config.requestnewaccount.mail))), ("cqAccountmanagerConfigRequestnewpwdMail", Some(cq.accountmanager.config.requestnewpwd.mailQuery.toParamString(cq.accountmanager.config.requestnewpwd.mail))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqAccountApiAccountManagementServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqAccountImplAccountManagementServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAccountmanagerConfigInformnewaccountMail: String, cqAccountmanagerConfigInformnewpwdMail: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAccountmanagerConfigInformnewaccountMailQuery: QueryParam[String], cqAccountmanagerConfigInformnewpwdMailQuery: QueryParam[String]): Task[ComAdobeCqAccountImplAccountManagementServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqAccountImplAccountManagementServletInfo] = jsonOf[ComAdobeCqAccountImplAccountManagementServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.account.impl.AccountManagementServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAccountmanagerConfigInformnewaccountMail", Some(cq.accountmanager.config.informnewaccount.mailQuery.toParamString(cq.accountmanager.config.informnewaccount.mail))), ("cqAccountmanagerConfigInformnewpwdMail", Some(cq.accountmanager.config.informnewpwd.mailQuery.toParamString(cq.accountmanager.config.informnewpwd.mail))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqAccountImplAccountManagementServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqAddressImplLocationLocationListServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAddressLocationDefaultMaxResults: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAddressLocationDefaultMaxResultsQuery: QueryParam[Integer]): Task[ComAdobeCqAddressImplLocationLocationListServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqAddressImplLocationLocationListServletInfo] = jsonOf[ComAdobeCqAddressImplLocationLocationListServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.address.impl.location.LocationListServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAddressLocationDefaultMaxResults", Some(cq.address.location.default.maxResultsQuery.toParamString(cq.address.location.default.maxResults))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqAddressImplLocationLocationListServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqAuditPurgeDam(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], auditlogRuleName: String, auditlogRuleContentpath: String, auditlogRuleMinimumage: Integer, auditlogRuleTypes: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], auditlogRuleNameQuery: QueryParam[String], auditlogRuleContentpathQuery: QueryParam[String], auditlogRuleMinimumageQuery: QueryParam[Integer], auditlogRuleTypesQuery: QueryParam[String]): Task[ComAdobeCqAuditPurgeDamInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqAuditPurgeDamInfo] = jsonOf[ComAdobeCqAuditPurgeDamInfo]

    val path = "/system/console/configMgr/com.adobe.cq.audit.purge.Dam"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("auditlogRuleName", Some(auditlog.rule.nameQuery.toParamString(auditlog.rule.name))), ("auditlogRuleContentpath", Some(auditlog.rule.contentpathQuery.toParamString(auditlog.rule.contentpath))), ("auditlogRuleMinimumage", Some(auditlog.rule.minimumageQuery.toParamString(auditlog.rule.minimumage))), ("auditlogRuleTypes", Some(auditlog.rule.typesQuery.toParamString(auditlog.rule.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqAuditPurgeDamInfo](req)

    } yield resp
  }
  
  def comAdobeCqAuditPurgePages(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], auditlogRuleName: String, auditlogRuleContentpath: String, auditlogRuleMinimumage: Integer, auditlogRuleTypes: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], auditlogRuleNameQuery: QueryParam[String], auditlogRuleContentpathQuery: QueryParam[String], auditlogRuleMinimumageQuery: QueryParam[Integer], auditlogRuleTypesQuery: QueryParam[String]): Task[ComAdobeCqAuditPurgePagesInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqAuditPurgePagesInfo] = jsonOf[ComAdobeCqAuditPurgePagesInfo]

    val path = "/system/console/configMgr/com.adobe.cq.audit.purge.Pages"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("auditlogRuleName", Some(auditlog.rule.nameQuery.toParamString(auditlog.rule.name))), ("auditlogRuleContentpath", Some(auditlog.rule.contentpathQuery.toParamString(auditlog.rule.contentpath))), ("auditlogRuleMinimumage", Some(auditlog.rule.minimumageQuery.toParamString(auditlog.rule.minimumage))), ("auditlogRuleTypes", Some(auditlog.rule.typesQuery.toParamString(auditlog.rule.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqAuditPurgePagesInfo](req)

    } yield resp
  }
  
  def comAdobeCqAuditPurgeReplication(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], auditlogRuleName: String, auditlogRuleContentpath: String, auditlogRuleMinimumage: Integer, auditlogRuleTypes: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], auditlogRuleNameQuery: QueryParam[String], auditlogRuleContentpathQuery: QueryParam[String], auditlogRuleMinimumageQuery: QueryParam[Integer], auditlogRuleTypesQuery: QueryParam[String]): Task[ComAdobeCqAuditPurgeReplicationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqAuditPurgeReplicationInfo] = jsonOf[ComAdobeCqAuditPurgeReplicationInfo]

    val path = "/system/console/configMgr/com.adobe.cq.audit.purge.Replication"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("auditlogRuleName", Some(auditlog.rule.nameQuery.toParamString(auditlog.rule.name))), ("auditlogRuleContentpath", Some(auditlog.rule.contentpathQuery.toParamString(auditlog.rule.contentpath))), ("auditlogRuleMinimumage", Some(auditlog.rule.minimumageQuery.toParamString(auditlog.rule.minimumage))), ("auditlogRuleTypes", Some(auditlog.rule.typesQuery.toParamString(auditlog.rule.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqAuditPurgeReplicationInfo](req)

    } yield resp
  }
  
  def comAdobeCqCdnRewriterImplAWSCloudFrontRewriter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, keypairId: String, keypairAlias: String, cdnrewriterAttributes: List[String], cdnRewriterDistributionDomain: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], keypairIdQuery: QueryParam[String], keypairAliasQuery: QueryParam[String], cdnrewriterAttributesQuery: QueryParam[List[String]], cdnRewriterDistributionDomainQuery: QueryParam[String]): Task[ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo] = jsonOf[ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.AWSCloudFrontRewriter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("keypairId", Some(keypair.idQuery.toParamString(keypair.id))), ("keypairAlias", Some(keypair.aliasQuery.toParamString(keypair.alias))), ("cdnrewriterAttributes", Some(cdnrewriter.attributesQuery.toParamString(cdnrewriter.attributes))), ("cdnRewriterDistributionDomain", Some(cdn.rewriter.distribution.domainQuery.toParamString(cdn.rewriter.distribution.domain))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo](req)

    } yield resp
  }
  
  def comAdobeCqCdnRewriterImplCDNConfigServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cdnConfigDistributionDomain: String, cdnConfigEnableRewriting: Boolean, cdnConfigPathPrefixes: List[String], cdnConfigCdnttl: Integer, cdnConfigApplicationProtocol: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cdnConfigDistributionDomainQuery: QueryParam[String], cdnConfigEnableRewritingQuery: QueryParam[Boolean], cdnConfigPathPrefixesQuery: QueryParam[List[String]], cdnConfigCdnttlQuery: QueryParam[Integer], cdnConfigApplicationProtocolQuery: QueryParam[String]): Task[ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo] = jsonOf[ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.CDNConfigServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cdnConfigDistributionDomain", Some(cdn.config.distribution.domainQuery.toParamString(cdn.config.distribution.domain))), ("cdnConfigEnableRewriting", Some(cdn.config.enable.rewritingQuery.toParamString(cdn.config.enable.rewriting))), ("cdnConfigPathPrefixes", Some(cdn.config.path.prefixesQuery.toParamString(cdn.config.path.prefixes))), ("cdnConfigCdnttl", Some(cdn.config.cdnttlQuery.toParamString(cdn.config.cdnttl))), ("cdnConfigApplicationProtocol", Some(cdn.config.application.protocolQuery.toParamString(cdn.config.application.protocol))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqCdnRewriterImplCDNRewriter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, cdnrewriterAttributes: List[String], cdnRewriterDistributionDomain: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], cdnrewriterAttributesQuery: QueryParam[List[String]], cdnRewriterDistributionDomainQuery: QueryParam[String]): Task[ComAdobeCqCdnRewriterImplCDNRewriterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCdnRewriterImplCDNRewriterInfo] = jsonOf[ComAdobeCqCdnRewriterImplCDNRewriterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.CDNRewriter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("cdnrewriterAttributes", Some(cdnrewriter.attributesQuery.toParamString(cdnrewriter.attributes))), ("cdnRewriterDistributionDomain", Some(cdn.rewriter.distribution.domainQuery.toParamString(cdn.rewriter.distribution.domain))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCdnRewriterImplCDNRewriterInfo](req)

    } yield resp
  }
  
  def comAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandle(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], flushAgents: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], flushAgentsQuery: QueryParam[List[String]]): Task[ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo] = jsonOf[ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo]

    val path = "/system/console/configMgr/com.adobe.cq.cloudconfig.core.impl.ConfigurationReplicationEventHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("flushAgents", Some(flush.agentsQuery.toParamString(flush.agents))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommerceImplAssetDynamicImageHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommerceAssetHandlerActive: Boolean, cqCommerceAssetHandlerName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommerceAssetHandlerActiveQuery: QueryParam[Boolean], cqCommerceAssetHandlerNameQuery: QueryParam[String]): Task[ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo] = jsonOf[ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.impl.asset.DynamicImageHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommerceAssetHandlerActive", Some(cq.commerce.asset.handler.activeQuery.toParamString(cq.commerce.asset.handler.active))), ("cqCommerceAssetHandlerName", Some(cq.commerce.asset.handler.nameQuery.toParamString(cq.commerce.asset.handler.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommerceImplAssetProductAssetHandlerProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommerceAssetHandlerFallback: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommerceAssetHandlerFallbackQuery: QueryParam[String]): Task[ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo] = jsonOf[ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.impl.asset.ProductAssetHandlerProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommerceAssetHandlerFallback", Some(cq.commerce.asset.handler.fallbackQuery.toParamString(cq.commerce.asset.handler.fallback))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommerceImplAssetStaticImageHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommerceAssetHandlerActive: Boolean, cqCommerceAssetHandlerName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommerceAssetHandlerActiveQuery: QueryParam[Boolean], cqCommerceAssetHandlerNameQuery: QueryParam[String]): Task[ComAdobeCqCommerceImplAssetStaticImageHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommerceImplAssetStaticImageHandlerInfo] = jsonOf[ComAdobeCqCommerceImplAssetStaticImageHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.impl.asset.StaticImageHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommerceAssetHandlerActive", Some(cq.commerce.asset.handler.activeQuery.toParamString(cq.commerce.asset.handler.active))), ("cqCommerceAssetHandlerName", Some(cq.commerce.asset.handler.nameQuery.toParamString(cq.commerce.asset.handler.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommerceImplAssetStaticImageHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommerceImplAssetVideoHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommerceAssetHandlerActive: Boolean, cqCommerceAssetHandlerName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommerceAssetHandlerActiveQuery: QueryParam[Boolean], cqCommerceAssetHandlerNameQuery: QueryParam[String]): Task[ComAdobeCqCommerceImplAssetVideoHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommerceImplAssetVideoHandlerInfo] = jsonOf[ComAdobeCqCommerceImplAssetVideoHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.impl.asset.VideoHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommerceAssetHandlerActive", Some(cq.commerce.asset.handler.activeQuery.toParamString(cq.commerce.asset.handler.active))), ("cqCommerceAssetHandlerName", Some(cq.commerce.asset.handler.nameQuery.toParamString(cq.commerce.asset.handler.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommerceImplAssetVideoHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommerceImplPromotionPromotionManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommercePromotionRoot: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommercePromotionRootQuery: QueryParam[String]): Task[ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo] = jsonOf[ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.impl.promotion.PromotionManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommercePromotionRoot", Some(cq.commerce.promotion.rootQuery.toParamString(cq.commerce.promotion.root))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommerceCataloggeneratorBucketsize: Integer, cqCommerceCataloggeneratorBucketname: String, cqCommerceCataloggeneratorExcludedtemplateproperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommerceCataloggeneratorBucketsizeQuery: QueryParam[Integer], cqCommerceCataloggeneratorBucketnameQuery: QueryParam[String], cqCommerceCataloggeneratorExcludedtemplatepropertiesQuery: QueryParam[List[String]]): Task[ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo] = jsonOf[ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.pim.impl.cataloggenerator.CatalogGeneratorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommerceCataloggeneratorBucketsize", Some(cq.commerce.cataloggenerator.bucketsizeQuery.toParamString(cq.commerce.cataloggenerator.bucketsize))), ("cqCommerceCataloggeneratorBucketname", Some(cq.commerce.cataloggenerator.bucketnameQuery.toParamString(cq.commerce.cataloggenerator.bucketname))), ("cqCommerceCataloggeneratorExcludedtemplateproperties", Some(cq.commerce.cataloggenerator.excludedtemplatepropertiesQuery.toParamString(cq.commerce.cataloggenerator.excludedtemplateproperties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommercePimImplPageEventListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqCommercePageeventlistenerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqCommercePageeventlistenerEnabledQuery: QueryParam[Boolean]): Task[ComAdobeCqCommercePimImplPageEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommercePimImplPageEventListenerInfo] = jsonOf[ComAdobeCqCommercePimImplPageEventListenerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.pim.impl.PageEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqCommercePageeventlistenerEnabled", Some(cq.commerce.pageeventlistener.enabledQuery.toParamString(cq.commerce.pageeventlistener.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommercePimImplPageEventListenerInfo](req)

    } yield resp
  }
  
  def comAdobeCqCommercePimImplProductfeedProductFeedServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], feedGeneratorAlgorithm: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], feedGeneratorAlgorithmQuery: QueryParam[String]): Task[ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo] = jsonOf[ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.commerce.pim.impl.productfeed.ProductFeedServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("feedGeneratorAlgorithm", Some(Feed generator algorithmQuery.toParamString(Feed generator algorithm))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqContentinsightImplReportingServicesSettingsProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], reportingservicesUrl: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], reportingservicesUrlQuery: QueryParam[String]): Task[ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo] = jsonOf[ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.contentinsight.impl.ReportingServicesSettingsProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("reportingservicesUrl", Some(reportingservices.urlQuery.toParamString(reportingservices.url))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqContentinsightImplServletsBrightEdgeProxyServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], brightedgeUrl: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], brightedgeUrlQuery: QueryParam[String]): Task[ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo] = jsonOf[ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.contentinsight.impl.servlets.BrightEdgeProxyServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("brightedgeUrl", Some(brightedge.urlQuery.toParamString(brightedge.url))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqContentinsightImplServletsReportingServicesProxyServle(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], reportingservicesProxyWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], reportingservicesProxyWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo] = jsonOf[ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo]

    val path = "/system/console/configMgr/com.adobe.cq.contentinsight.impl.servlets.ReportingServicesProxyServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("reportingservicesProxyWhitelist", Some(reportingservices.proxy.whitelistQuery.toParamString(reportingservices.proxy.whitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamCfmImplComponentComponentConfigImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], damCfmComponentResourceType: String, damCfmComponentFileReferenceProp: String, damCfmComponentElementsProp: String, damCfmComponentVariationProp: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], damCfmComponentResourceTypeQuery: QueryParam[String], damCfmComponentFileReferencePropQuery: QueryParam[String], damCfmComponentElementsPropQuery: QueryParam[String], damCfmComponentVariationPropQuery: QueryParam[String]): Task[ComAdobeCqDamCfmImplComponentComponentConfigImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamCfmImplComponentComponentConfigImplInfo] = jsonOf[ComAdobeCqDamCfmImplComponentComponentConfigImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.component.ComponentConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("damCfmComponentResourceType", Some(dam.cfm.component.resourceTypeQuery.toParamString(dam.cfm.component.resourceType))), ("damCfmComponentFileReferenceProp", Some(dam.cfm.component.fileReferencePropQuery.toParamString(dam.cfm.component.fileReferenceProp))), ("damCfmComponentElementsProp", Some(dam.cfm.component.elementsPropQuery.toParamString(dam.cfm.component.elementsProp))), ("damCfmComponentVariationProp", Some(dam.cfm.component.variationPropQuery.toParamString(dam.cfm.component.variationProp))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamCfmImplComponentComponentConfigImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamCfmImplConfFeatureConfigImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], damCfmResourceTypes: List[String], damCfmReferenceProperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], damCfmResourceTypesQuery: QueryParam[List[String]], damCfmReferencePropertiesQuery: QueryParam[List[String]]): Task[ComAdobeCqDamCfmImplConfFeatureConfigImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamCfmImplConfFeatureConfigImplInfo] = jsonOf[ComAdobeCqDamCfmImplConfFeatureConfigImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.conf.FeatureConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("damCfmResourceTypes", Some(dam.cfm.resourceTypesQuery.toParamString(dam.cfm.resourceTypes))), ("damCfmReferenceProperties", Some(dam.cfm.referencePropertiesQuery.toParamString(dam.cfm.referenceProperties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamCfmImplConfFeatureConfigImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamCfmImplContentRewriterAssetProcessor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pipelineType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pipelineTypeQuery: QueryParam[String]): Task[ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo] = jsonOf[ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.AssetProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pipelineType", Some(pipeline.typeQuery.toParamString(pipeline.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamCfmImplContentRewriterParRangeFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pipelineType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pipelineTypeQuery: QueryParam[String]): Task[ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo] = jsonOf[ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.ParRangeFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pipelineType", Some(pipeline.typeQuery.toParamString(pipeline.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamCfmImplContentRewriterPayloadFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pipelineType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pipelineTypeQuery: QueryParam[String]): Task[ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo] = jsonOf[ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.PayloadFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pipelineType", Some(pipeline.typeQuery.toParamString(pipeline.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamDmProcessImagePTiffManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxMemory: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxMemoryQuery: QueryParam[Integer]): Task[ComAdobeCqDamDmProcessImagePTiffManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamDmProcessImagePTiffManagerImplInfo] = jsonOf[ComAdobeCqDamDmProcessImagePTiffManagerImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.dm.process.image.PTiffManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxMemory", Some(maxMemoryQuery.toParamString(maxMemory))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamDmProcessImagePTiffManagerImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorker(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], dmreplicateonmodifyEnabled: Boolean, dmreplicateonmodifyForcesyncdeletes: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], dmreplicateonmodifyEnabledQuery: QueryParam[Boolean], dmreplicateonmodifyForcesyncdeletesQuery: QueryParam[Boolean]): Task[ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo] = jsonOf[ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.ips.impl.replication.trigger.ReplicateOnModifyWorker"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("dmreplicateonmodifyEnabled", Some(dmreplicateonmodify.enabledQuery.toParamString(dmreplicateonmodify.enabled))), ("dmreplicateonmodifyForcesyncdeletes", Some(dmreplicateonmodify.forcesyncdeletesQuery.toParamString(dmreplicateonmodify.forcesyncdeletes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamMacSyncHelperImplMACSyncClientImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeDamMacSyncClientSoTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeDamMacSyncClientSoTimeoutQuery: QueryParam[Integer]): Task[ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo] = jsonOf[ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.mac.sync.helper.impl.MACSyncClientImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeDamMacSyncClientSoTimeout", Some(com.adobe.dam.mac.sync.client.so.timeoutQuery.toParamString(com.adobe.dam.mac.sync.client.so.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamMacSyncImplDAMSyncServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeCqDamMacSyncDamsyncserviceRegisteredPaths: List[String], comAdobeCqDamMacSyncDamsyncserviceSyncRenditions: Boolean, comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMs: Integer, comAdobeCqDamMacSyncDamsyncservicePlatform: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeCqDamMacSyncDamsyncserviceRegisteredPathsQuery: QueryParam[List[String]], comAdobeCqDamMacSyncDamsyncserviceSyncRenditionsQuery: QueryParam[Boolean], comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMsQuery: QueryParam[Integer], comAdobeCqDamMacSyncDamsyncservicePlatformQuery: QueryParam[String]): Task[ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo] = jsonOf[ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.mac.sync.impl.DAMSyncServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeCqDamMacSyncDamsyncserviceRegisteredPaths", Some(com.adobe.cq.dam.mac.sync.damsyncservice.registered_pathsQuery.toParamString(com.adobe.cq.dam.mac.sync.damsyncservice.registered_paths))), ("comAdobeCqDamMacSyncDamsyncserviceSyncRenditions", Some(com.adobe.cq.dam.mac.sync.damsyncservice.sync.renditionsQuery.toParamString(com.adobe.cq.dam.mac.sync.damsyncservice.sync.renditions))), ("comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMs", Some(com.adobe.cq.dam.mac.sync.damsyncservice.replicate.thread.wait.msQuery.toParamString(com.adobe.cq.dam.mac.sync.damsyncservice.replicate.thread.wait.ms))), ("comAdobeCqDamMacSyncDamsyncservicePlatform", Some(com.adobe.cq.dam.mac.sync.damsyncservice.platformQuery.toParamString(com.adobe.cq.dam.mac.sync.damsyncservice.platform))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamProcessorNuiImplNuiAssetProcessor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], nuiEnabled: Boolean, nuiServiceUrl: String, nuiApiKey: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nuiEnabledQuery: QueryParam[Boolean], nuiServiceUrlQuery: QueryParam[String], nuiApiKeyQuery: QueryParam[String]): Task[ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo] = jsonOf[ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.processor.nui.impl.NuiAssetProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("nuiEnabled", Some(nuiEnabledQuery.toParamString(nuiEnabled))), ("nuiServiceUrl", Some(nuiServiceUrlQuery.toParamString(nuiServiceUrl))), ("nuiApiKey", Some(nuiApiKeyQuery.toParamString(nuiApiKey))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamS7imagingImplIsImageServerComponent(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], tcpPort: String, allowRemoteAccess: Boolean, maxRenderRgnPixels: String, maxMessageSize: String, randomAccessUrlTimeout: Integer, workerThreads: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], tcpPortQuery: QueryParam[String], allowRemoteAccessQuery: QueryParam[Boolean], maxRenderRgnPixelsQuery: QueryParam[String], maxMessageSizeQuery: QueryParam[String], randomAccessUrlTimeoutQuery: QueryParam[Integer], workerThreadsQuery: QueryParam[Integer]): Task[ComAdobeCqDamS7imagingImplIsImageServerComponentInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamS7imagingImplIsImageServerComponentInfo] = jsonOf[ComAdobeCqDamS7imagingImplIsImageServerComponentInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.s7imaging.impl.is.ImageServerComponent"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("tcpPort", Some(TcpPortQuery.toParamString(TcpPort))), ("allowRemoteAccess", Some(AllowRemoteAccessQuery.toParamString(AllowRemoteAccess))), ("maxRenderRgnPixels", Some(MaxRenderRgnPixelsQuery.toParamString(MaxRenderRgnPixels))), ("maxMessageSize", Some(MaxMessageSizeQuery.toParamString(MaxMessageSize))), ("randomAccessUrlTimeout", Some(RandomAccessUrlTimeoutQuery.toParamString(RandomAccessUrlTimeout))), ("workerThreads", Some(WorkerThreadsQuery.toParamString(WorkerThreads))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamS7imagingImplIsImageServerComponentInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamS7imagingImplPsPlatformServerServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cacheEnable: Boolean, cacheRootPaths: List[String], cacheMaxSize: Integer, cacheMaxEntries: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cacheEnableQuery: QueryParam[Boolean], cacheRootPathsQuery: QueryParam[List[String]], cacheMaxSizeQuery: QueryParam[Integer], cacheMaxEntriesQuery: QueryParam[Integer]): Task[ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo] = jsonOf[ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.s7imaging.impl.ps.PlatformServerServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cacheEnable", Some(cache.enableQuery.toParamString(cache.enable))), ("cacheRootPaths", Some(cache.rootPathsQuery.toParamString(cache.rootPaths))), ("cacheMaxSize", Some(cache.maxSizeQuery.toParamString(cache.maxSize))), ("cacheMaxEntries", Some(cache.maxEntriesQuery.toParamString(cache.maxEntries))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamWebdavImplIoAssetIOHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, pathPrefix: String, createVersion: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], pathPrefixQuery: QueryParam[String], createVersionQuery: QueryParam[Boolean]): Task[ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo] = jsonOf[ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.AssetIOHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("pathPrefix", Some(pathPrefixQuery.toParamString(pathPrefix))), ("createVersion", Some(createVersionQuery.toParamString(createVersion))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJob(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamWebdavVersionLinkingEnable: Boolean, cqDamWebdavVersionLinkingSchedulerPeriod: Integer, cqDamWebdavVersionLinkingStagingTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamWebdavVersionLinkingEnableQuery: QueryParam[Boolean], cqDamWebdavVersionLinkingSchedulerPeriodQuery: QueryParam[Integer], cqDamWebdavVersionLinkingStagingTimeoutQuery: QueryParam[Integer]): Task[ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo] = jsonOf[ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.DamWebdavVersionLinkingJob"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamWebdavVersionLinkingEnable", Some(cq.dam.webdav.version.linking.enableQuery.toParamString(cq.dam.webdav.version.linking.enable))), ("cqDamWebdavVersionLinkingSchedulerPeriod", Some(cq.dam.webdav.version.linking.scheduler.periodQuery.toParamString(cq.dam.webdav.version.linking.scheduler.period))), ("cqDamWebdavVersionLinkingStagingTimeout", Some(cq.dam.webdav.version.linking.staging.timeoutQuery.toParamString(cq.dam.webdav.version.linking.staging.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo](req)

    } yield resp
  }
  
  def comAdobeCqDamWebdavImplIoSpecialFilesHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comDayCqDamCoreImplIoSpecialFilesHandlerFilepatters: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comDayCqDamCoreImplIoSpecialFilesHandlerFilepattersQuery: QueryParam[List[String]]): Task[ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo] = jsonOf[ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.SpecialFilesHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comDayCqDamCoreImplIoSpecialFilesHandlerFilepatters", Some(com.day.cq.dam.core.impl.io.SpecialFilesHandler.filepattersQuery.toParamString(com.day.cq.dam.core.impl.io.SpecialFilesHandler.filepatters))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqDeserfwImplDeserializationFirewallImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], firewallDeserializationWhitelist: List[String], firewallDeserializationBlacklist: List[String], firewallDeserializationDiagnostics: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], firewallDeserializationWhitelistQuery: QueryParam[List[String]], firewallDeserializationBlacklistQuery: QueryParam[List[String]], firewallDeserializationDiagnosticsQuery: QueryParam[String]): Task[ComAdobeCqDeserfwImplDeserializationFirewallImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDeserfwImplDeserializationFirewallImplInfo] = jsonOf[ComAdobeCqDeserfwImplDeserializationFirewallImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.deserfw.impl.DeserializationFirewallImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("firewallDeserializationWhitelist", Some(firewall.deserialization.whitelistQuery.toParamString(firewall.deserialization.whitelist))), ("firewallDeserializationBlacklist", Some(firewall.deserialization.blacklistQuery.toParamString(firewall.deserialization.blacklist))), ("firewallDeserializationDiagnostics", Some(firewall.deserialization.diagnosticsQuery.toParamString(firewall.deserialization.diagnostics))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDeserfwImplDeserializationFirewallImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDtmImplServiceDTMWebServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], connectionTimeout: Integer, socketTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], connectionTimeoutQuery: QueryParam[Integer], socketTimeoutQuery: QueryParam[Integer]): Task[ComAdobeCqDtmImplServiceDTMWebServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDtmImplServiceDTMWebServiceImplInfo] = jsonOf[ComAdobeCqDtmImplServiceDTMWebServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dtm.impl.service.DTMWebServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("connectionTimeout", Some(connection.timeoutQuery.toParamString(connection.timeout))), ("socketTimeout", Some(socket.timeoutQuery.toParamString(socket.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDtmImplServiceDTMWebServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqDtmImplServletsDTMDeployHookServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], dtmStagingIpWhitelist: List[String], dtmProductionIpWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], dtmStagingIpWhitelistQuery: QueryParam[List[String]], dtmProductionIpWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqDtmImplServletsDTMDeployHookServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDtmImplServletsDTMDeployHookServletInfo] = jsonOf[ComAdobeCqDtmImplServletsDTMDeployHookServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dtm.impl.servlets.DTMDeployHookServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("dtmStagingIpWhitelist", Some(dtm.staging.ip.whitelistQuery.toParamString(dtm.staging.ip.whitelist))), ("dtmProductionIpWhitelist", Some(dtm.production.ip.whitelistQuery.toParamString(dtm.production.ip.whitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDtmImplServletsDTMDeployHookServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqDtmReactorImplServiceWebServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], endpointUri: String, connectionTimeout: Integer, socketTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], endpointUriQuery: QueryParam[String], connectionTimeoutQuery: QueryParam[Integer], socketTimeoutQuery: QueryParam[Integer]): Task[ComAdobeCqDtmReactorImplServiceWebServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqDtmReactorImplServiceWebServiceImplInfo] = jsonOf[ComAdobeCqDtmReactorImplServiceWebServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.dtm.reactor.impl.service.WebServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("endpointUri", Some(endpointUriQuery.toParamString(endpointUri))), ("connectionTimeout", Some(connectionTimeoutQuery.toParamString(connectionTimeout))), ("socketTimeout", Some(socketTimeoutQuery.toParamString(socketTimeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqDtmReactorImplServiceWebServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqExperiencelogImplExperienceLogConfigServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, disabledForGroups: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], disabledForGroupsQuery: QueryParam[List[String]]): Task[ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo] = jsonOf[ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.experiencelog.impl.ExperienceLogConfigServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("disabledForGroups", Some(disabledForGroupsQuery.toParamString(disabledForGroups))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqHcContentPackagesHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String, packageNames: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String], packageNamesQuery: QueryParam[List[String]]): Task[ComAdobeCqHcContentPackagesHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqHcContentPackagesHealthCheckInfo] = jsonOf[ComAdobeCqHcContentPackagesHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.cq.hc.ContentPackagesHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))), ("packageNames", Some(package.namesQuery.toParamString(package.names))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqHcContentPackagesHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeCqHistoryImplHistoryRequestFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], historyRequestFilterExcludedSelectors: List[String], historyRequestFilterExcludedExtensions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], historyRequestFilterExcludedSelectorsQuery: QueryParam[List[String]], historyRequestFilterExcludedExtensionsQuery: QueryParam[List[String]]): Task[ComAdobeCqHistoryImplHistoryRequestFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqHistoryImplHistoryRequestFilterInfo] = jsonOf[ComAdobeCqHistoryImplHistoryRequestFilterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.history.impl.HistoryRequestFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("historyRequestFilterExcludedSelectors", Some(history.requestFilter.excludedSelectorsQuery.toParamString(history.requestFilter.excludedSelectors))), ("historyRequestFilterExcludedExtensions", Some(history.requestFilter.excludedExtensionsQuery.toParamString(history.requestFilter.excludedExtensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqHistoryImplHistoryRequestFilterInfo](req)

    } yield resp
  }
  
  def comAdobeCqHistoryImplHistoryServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], historyServiceResourceTypes: List[String], historyServicePathFilter: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], historyServiceResourceTypesQuery: QueryParam[List[String]], historyServicePathFilterQuery: QueryParam[List[String]]): Task[ComAdobeCqHistoryImplHistoryServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqHistoryImplHistoryServiceImplInfo] = jsonOf[ComAdobeCqHistoryImplHistoryServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.history.impl.HistoryServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("historyServiceResourceTypes", Some(history.service.resourceTypesQuery.toParamString(history.service.resourceTypes))), ("historyServicePathFilter", Some(history.service.pathFilterQuery.toParamString(history.service.pathFilter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqHistoryImplHistoryServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqInboxImplTypeproviderItemTypeProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], inboxImplTypeproviderRegistrypaths: List[String], inboxImplTypeproviderLegacypaths: List[String], inboxImplTypeproviderDefaulturlFailureitem: String, inboxImplTypeproviderDefaulturlWorkitem: String, inboxImplTypeproviderDefaulturlTask: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], inboxImplTypeproviderRegistrypathsQuery: QueryParam[List[String]], inboxImplTypeproviderLegacypathsQuery: QueryParam[List[String]], inboxImplTypeproviderDefaulturlFailureitemQuery: QueryParam[String], inboxImplTypeproviderDefaulturlWorkitemQuery: QueryParam[String], inboxImplTypeproviderDefaulturlTaskQuery: QueryParam[String]): Task[ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo] = jsonOf[ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.inbox.impl.typeprovider.ItemTypeProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("inboxImplTypeproviderRegistrypaths", Some(inbox.impl.typeprovider.registrypathsQuery.toParamString(inbox.impl.typeprovider.registrypaths))), ("inboxImplTypeproviderLegacypaths", Some(inbox.impl.typeprovider.legacypathsQuery.toParamString(inbox.impl.typeprovider.legacypaths))), ("inboxImplTypeproviderDefaulturlFailureitem", Some(inbox.impl.typeprovider.defaulturl.failureitemQuery.toParamString(inbox.impl.typeprovider.defaulturl.failureitem))), ("inboxImplTypeproviderDefaulturlWorkitem", Some(inbox.impl.typeprovider.defaulturl.workitemQuery.toParamString(inbox.impl.typeprovider.defaulturl.workitem))), ("inboxImplTypeproviderDefaulturlTask", Some(inbox.impl.typeprovider.defaulturl.taskQuery.toParamString(inbox.impl.typeprovider.defaulturl.task))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqProjectsImplServletProjectImageServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], imageQuality: String, imageSupportedResolutions: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], imageQualityQuery: QueryParam[String], imageSupportedResolutionsQuery: QueryParam[String]): Task[ComAdobeCqProjectsImplServletProjectImageServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqProjectsImplServletProjectImageServletInfo] = jsonOf[ComAdobeCqProjectsImplServletProjectImageServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.projects.impl.servlet.ProjectImageServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("imageQuality", Some(image.qualityQuery.toParamString(image.quality))), ("imageSupportedResolutions", Some(image.supported.resolutionsQuery.toParamString(image.supported.resolutions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqProjectsImplServletProjectImageServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqProjectsPurgeScheduler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], scheduledpurgeName: String, scheduledpurgePurgeActive: Boolean, scheduledpurgeTemplates: List[String], scheduledpurgePurgeGroups: Boolean, scheduledpurgePurgeAssets: Boolean, scheduledpurgeTerminateRunningWorkflows: Boolean, scheduledpurgeDaysold: Integer, scheduledpurgeSaveThreshold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], scheduledpurgeNameQuery: QueryParam[String], scheduledpurgePurgeActiveQuery: QueryParam[Boolean], scheduledpurgeTemplatesQuery: QueryParam[List[String]], scheduledpurgePurgeGroupsQuery: QueryParam[Boolean], scheduledpurgePurgeAssetsQuery: QueryParam[Boolean], scheduledpurgeTerminateRunningWorkflowsQuery: QueryParam[Boolean], scheduledpurgeDaysoldQuery: QueryParam[Integer], scheduledpurgeSaveThresholdQuery: QueryParam[Integer]): Task[ComAdobeCqProjectsPurgeSchedulerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqProjectsPurgeSchedulerInfo] = jsonOf[ComAdobeCqProjectsPurgeSchedulerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.projects.purge.Scheduler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("scheduledpurgeName", Some(scheduledpurge.nameQuery.toParamString(scheduledpurge.name))), ("scheduledpurgePurgeActive", Some(scheduledpurge.purgeActiveQuery.toParamString(scheduledpurge.purgeActive))), ("scheduledpurgeTemplates", Some(scheduledpurge.templatesQuery.toParamString(scheduledpurge.templates))), ("scheduledpurgePurgeGroups", Some(scheduledpurge.purgeGroupsQuery.toParamString(scheduledpurge.purgeGroups))), ("scheduledpurgePurgeAssets", Some(scheduledpurge.purgeAssetsQuery.toParamString(scheduledpurge.purgeAssets))), ("scheduledpurgeTerminateRunningWorkflows", Some(scheduledpurge.terminateRunningWorkflowsQuery.toParamString(scheduledpurge.terminateRunningWorkflows))), ("scheduledpurgeDaysold", Some(scheduledpurge.daysoldQuery.toParamString(scheduledpurge.daysold))), ("scheduledpurgeSaveThreshold", Some(scheduledpurge.saveThresholdQuery.toParamString(scheduledpurge.saveThreshold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqProjectsPurgeSchedulerInfo](req)

    } yield resp
  }
  
  def comAdobeCqScheduledExporterImplScheduledExporterImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], includePaths: List[String], exporterUser: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], includePathsQuery: QueryParam[List[String]], exporterUserQuery: QueryParam[String]): Task[ComAdobeCqScheduledExporterImplScheduledExporterImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScheduledExporterImplScheduledExporterImplInfo] = jsonOf[ComAdobeCqScheduledExporterImplScheduledExporterImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.scheduled.exporter.impl.ScheduledExporterImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("includePaths", Some(include.pathsQuery.toParamString(include.paths))), ("exporterUser", Some(exporter.userQuery.toParamString(exporter.user))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScheduledExporterImplScheduledExporterImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeCqScreensAnalyticsImplUrl: String, comAdobeCqScreensAnalyticsImplApikey: String, comAdobeCqScreensAnalyticsImplProject: String, comAdobeCqScreensAnalyticsImplEnvironment: String, comAdobeCqScreensAnalyticsImplSendFrequency: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeCqScreensAnalyticsImplUrlQuery: QueryParam[String], comAdobeCqScreensAnalyticsImplApikeyQuery: QueryParam[String], comAdobeCqScreensAnalyticsImplProjectQuery: QueryParam[String], comAdobeCqScreensAnalyticsImplEnvironmentQuery: QueryParam[String], comAdobeCqScreensAnalyticsImplSendFrequencyQuery: QueryParam[Integer]): Task[ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo] = jsonOf[ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.analytics.impl.ScreensAnalyticsServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeCqScreensAnalyticsImplUrl", Some(com.adobe.cq.screens.analytics.impl.urlQuery.toParamString(com.adobe.cq.screens.analytics.impl.url))), ("comAdobeCqScreensAnalyticsImplApikey", Some(com.adobe.cq.screens.analytics.impl.apikeyQuery.toParamString(com.adobe.cq.screens.analytics.impl.apikey))), ("comAdobeCqScreensAnalyticsImplProject", Some(com.adobe.cq.screens.analytics.impl.projectQuery.toParamString(com.adobe.cq.screens.analytics.impl.project))), ("comAdobeCqScreensAnalyticsImplEnvironment", Some(com.adobe.cq.screens.analytics.impl.environmentQuery.toParamString(com.adobe.cq.screens.analytics.impl.environment))), ("comAdobeCqScreensAnalyticsImplSendFrequency", Some(com.adobe.cq.screens.analytics.impl.sendFrequencyQuery.toParamString(com.adobe.cq.screens.analytics.impl.sendFrequency))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensDeviceImplDeviceService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeAemScreensPlayerPingfrequency: Integer, comAdobeAemScreensDevicePaswordSpecialchars: String, comAdobeAemScreensDevicePaswordMinlowercasechars: Integer, comAdobeAemScreensDevicePaswordMinuppercasechars: Integer, comAdobeAemScreensDevicePaswordMinnumberchars: Integer, comAdobeAemScreensDevicePaswordMinspecialchars: Integer, comAdobeAemScreensDevicePaswordMinlength: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeAemScreensPlayerPingfrequencyQuery: QueryParam[Integer], comAdobeAemScreensDevicePaswordSpecialcharsQuery: QueryParam[String], comAdobeAemScreensDevicePaswordMinlowercasecharsQuery: QueryParam[Integer], comAdobeAemScreensDevicePaswordMinuppercasecharsQuery: QueryParam[Integer], comAdobeAemScreensDevicePaswordMinnumbercharsQuery: QueryParam[Integer], comAdobeAemScreensDevicePaswordMinspecialcharsQuery: QueryParam[Integer], comAdobeAemScreensDevicePaswordMinlengthQuery: QueryParam[Integer]): Task[ComAdobeCqScreensDeviceImplDeviceServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensDeviceImplDeviceServiceInfo] = jsonOf[ComAdobeCqScreensDeviceImplDeviceServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.device.impl.DeviceService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeAemScreensPlayerPingfrequency", Some(com.adobe.aem.screens.player.pingfrequencyQuery.toParamString(com.adobe.aem.screens.player.pingfrequency))), ("comAdobeAemScreensDevicePaswordSpecialchars", Some(com.adobe.aem.screens.device.pasword.specialcharsQuery.toParamString(com.adobe.aem.screens.device.pasword.specialchars))), ("comAdobeAemScreensDevicePaswordMinlowercasechars", Some(com.adobe.aem.screens.device.pasword.minlowercasecharsQuery.toParamString(com.adobe.aem.screens.device.pasword.minlowercasechars))), ("comAdobeAemScreensDevicePaswordMinuppercasechars", Some(com.adobe.aem.screens.device.pasword.minuppercasecharsQuery.toParamString(com.adobe.aem.screens.device.pasword.minuppercasechars))), ("comAdobeAemScreensDevicePaswordMinnumberchars", Some(com.adobe.aem.screens.device.pasword.minnumbercharsQuery.toParamString(com.adobe.aem.screens.device.pasword.minnumberchars))), ("comAdobeAemScreensDevicePaswordMinspecialchars", Some(com.adobe.aem.screens.device.pasword.minspecialcharsQuery.toParamString(com.adobe.aem.screens.device.pasword.minspecialchars))), ("comAdobeAemScreensDevicePaswordMinlength", Some(com.adobe.aem.screens.device.pasword.minlengthQuery.toParamString(com.adobe.aem.screens.device.pasword.minlength))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensDeviceImplDeviceServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensDeviceRegistrationImplRegistrationServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], deviceRegistrationTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], deviceRegistrationTimeoutQuery: QueryParam[Integer]): Task[ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo] = jsonOf[ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.device.registration.impl.RegistrationServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("deviceRegistrationTimeout", Some(deviceRegistrationTimeoutQuery.toParamString(deviceRegistrationTimeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensImplHandlerChannelsUpdateHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqPagesupdatehandlerImageresourcetypes: List[String], cqPagesupdatehandlerProductresourcetypes: List[String], cqPagesupdatehandlerVideoresourcetypes: List[String], cqPagesupdatehandlerDynamicsequenceresourcetypes: List[String], cqPagesupdatehandlerPreviewmodepaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqPagesupdatehandlerImageresourcetypesQuery: QueryParam[List[String]], cqPagesupdatehandlerProductresourcetypesQuery: QueryParam[List[String]], cqPagesupdatehandlerVideoresourcetypesQuery: QueryParam[List[String]], cqPagesupdatehandlerDynamicsequenceresourcetypesQuery: QueryParam[List[String]], cqPagesupdatehandlerPreviewmodepathsQuery: QueryParam[List[String]]): Task[ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo] = jsonOf[ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.impl.handler.ChannelsUpdateHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqPagesupdatehandlerImageresourcetypes", Some(cq.pagesupdatehandler.imageresourcetypesQuery.toParamString(cq.pagesupdatehandler.imageresourcetypes))), ("cqPagesupdatehandlerProductresourcetypes", Some(cq.pagesupdatehandler.productresourcetypesQuery.toParamString(cq.pagesupdatehandler.productresourcetypes))), ("cqPagesupdatehandlerVideoresourcetypes", Some(cq.pagesupdatehandler.videoresourcetypesQuery.toParamString(cq.pagesupdatehandler.videoresourcetypes))), ("cqPagesupdatehandlerDynamicsequenceresourcetypes", Some(cq.pagesupdatehandler.dynamicsequenceresourcetypesQuery.toParamString(cq.pagesupdatehandler.dynamicsequenceresourcetypes))), ("cqPagesupdatehandlerPreviewmodepaths", Some(cq.pagesupdatehandler.previewmodepathsQuery.toParamString(cq.pagesupdatehandler.previewmodepaths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJob(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String]): Task[ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo] = jsonOf[ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.impl.jobs.DistributedDevicesStatiUpdateJob"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensImplRemoteImplDistributedHttpClientImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeAemScreensImplRemoteRequestTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeAemScreensImplRemoteRequestTimeoutQuery: QueryParam[Integer]): Task[ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo] = jsonOf[ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.impl.remote.impl.DistributedHttpClientImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeAemScreensImplRemoteRequestTimeout", Some(com.adobe.aem.screens.impl.remote.request_timeoutQuery.toParamString(com.adobe.aem.screens.impl.remote.request_timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensImplScreensChannelPostProcessor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], screensChannelsPropertiesToRemove: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], screensChannelsPropertiesToRemoveQuery: QueryParam[List[String]]): Task[ComAdobeCqScreensImplScreensChannelPostProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensImplScreensChannelPostProcessorInfo] = jsonOf[ComAdobeCqScreensImplScreensChannelPostProcessorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.impl.ScreensChannelPostProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("screensChannelsPropertiesToRemove", Some(screens.channels.properties.to.removeQuery.toParamString(screens.channels.properties.to.remove))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensImplScreensChannelPostProcessorInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensMonitoringImplScreensMonitoringServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPath: List[String], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequency: String, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeout: Integer, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipients: String, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserver: String, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpport: Integer, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetls: Boolean, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsername: String, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPassword: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPathQuery: QueryParam[List[String]], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequencyQuery: QueryParam[String], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeoutQuery: QueryParam[Integer], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipientsQuery: QueryParam[String], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserverQuery: QueryParam[String], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpportQuery: QueryParam[Integer], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetlsQuery: QueryParam[Boolean], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsernameQuery: QueryParam[String], comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPasswordQuery: QueryParam[String]): Task[ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo] = jsonOf[ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPath", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.projectPathQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.projectPath))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequency", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.scheduleFrequencyQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.scheduleFrequency))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeout", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.pingTimeoutQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.pingTimeout))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipients", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.recipientsQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.recipients))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserver", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpserverQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpserver))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpport", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpportQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpport))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetls", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.usetlsQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.usetls))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsername", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.usernameQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.username))), ("comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPassword", Some(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.passwordQuery.toParamString(com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.password))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensMqActivemqImplArtemisJMSProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, globalSize: Integer, maxDiskUsage: Integer, persistenceEnabled: Boolean, threadPoolMaxSize: Integer, scheduledThreadPoolMaxSize: Integer, gracefulShutdownTimeout: Integer, queues: List[String], topics: List[String], addressesMaxDeliveryAttempts: Integer, addressesExpiryDelay: Integer, addressesAddressFullMessagePolicy: String, addressesMaxSizeBytes: Integer, addressesPageSizeBytes: Integer, addressesPageCacheMaxSize: Integer, clusterUser: String, clusterPassword: String, clusterCallTimeout: Integer, clusterCallFailoverTimeout: Integer, clusterClientFailureCheckPeriod: Integer, clusterNotificationAttempts: Integer, clusterNotificationInterval: Integer, idCacheSize: Integer, clusterConfirmationWindowSize: Integer, clusterConnectionTtl: Integer, clusterDuplicateDetection: Boolean, clusterInitialConnectAttempts: Integer, clusterMaxRetryInterval: Integer, clusterMinLargeMessageSize: Integer, clusterProducerWindowSize: Integer, clusterReconnectAttempts: Integer, clusterRetryInterval: Integer, clusterRetryIntervalMultiplier: BigDecimal)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], globalSizeQuery: QueryParam[Integer], maxDiskUsageQuery: QueryParam[Integer], persistenceEnabledQuery: QueryParam[Boolean], threadPoolMaxSizeQuery: QueryParam[Integer], scheduledThreadPoolMaxSizeQuery: QueryParam[Integer], gracefulShutdownTimeoutQuery: QueryParam[Integer], queuesQuery: QueryParam[List[String]], topicsQuery: QueryParam[List[String]], addressesMaxDeliveryAttemptsQuery: QueryParam[Integer], addressesExpiryDelayQuery: QueryParam[Integer], addressesAddressFullMessagePolicyQuery: QueryParam[String], addressesMaxSizeBytesQuery: QueryParam[Integer], addressesPageSizeBytesQuery: QueryParam[Integer], addressesPageCacheMaxSizeQuery: QueryParam[Integer], clusterUserQuery: QueryParam[String], clusterPasswordQuery: QueryParam[String], clusterCallTimeoutQuery: QueryParam[Integer], clusterCallFailoverTimeoutQuery: QueryParam[Integer], clusterClientFailureCheckPeriodQuery: QueryParam[Integer], clusterNotificationAttemptsQuery: QueryParam[Integer], clusterNotificationIntervalQuery: QueryParam[Integer], idCacheSizeQuery: QueryParam[Integer], clusterConfirmationWindowSizeQuery: QueryParam[Integer], clusterConnectionTtlQuery: QueryParam[Integer], clusterDuplicateDetectionQuery: QueryParam[Boolean], clusterInitialConnectAttemptsQuery: QueryParam[Integer], clusterMaxRetryIntervalQuery: QueryParam[Integer], clusterMinLargeMessageSizeQuery: QueryParam[Integer], clusterProducerWindowSizeQuery: QueryParam[Integer], clusterReconnectAttemptsQuery: QueryParam[Integer], clusterRetryIntervalQuery: QueryParam[Integer], clusterRetryIntervalMultiplierQuery: QueryParam[BigDecimal]): Task[ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo] = jsonOf[ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.mq.activemq.impl.ArtemisJMSProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("globalSize", Some(global.sizeQuery.toParamString(global.size))), ("maxDiskUsage", Some(max.disk.usageQuery.toParamString(max.disk.usage))), ("persistenceEnabled", Some(persistence.enabledQuery.toParamString(persistence.enabled))), ("threadPoolMaxSize", Some(thread.pool.max.sizeQuery.toParamString(thread.pool.max.size))), ("scheduledThreadPoolMaxSize", Some(scheduled.thread.pool.max.sizeQuery.toParamString(scheduled.thread.pool.max.size))), ("gracefulShutdownTimeout", Some(graceful.shutdown.timeoutQuery.toParamString(graceful.shutdown.timeout))), ("queues", Some(queuesQuery.toParamString(queues))), ("topics", Some(topicsQuery.toParamString(topics))), ("addressesMaxDeliveryAttempts", Some(addresses.max.delivery.attemptsQuery.toParamString(addresses.max.delivery.attempts))), ("addressesExpiryDelay", Some(addresses.expiry.delayQuery.toParamString(addresses.expiry.delay))), ("addressesAddressFullMessagePolicy", Some(addresses.address.full.message.policyQuery.toParamString(addresses.address.full.message.policy))), ("addressesMaxSizeBytes", Some(addresses.max.size.bytesQuery.toParamString(addresses.max.size.bytes))), ("addressesPageSizeBytes", Some(addresses.page.size.bytesQuery.toParamString(addresses.page.size.bytes))), ("addressesPageCacheMaxSize", Some(addresses.page.cache.max.sizeQuery.toParamString(addresses.page.cache.max.size))), ("clusterUser", Some(cluster.userQuery.toParamString(cluster.user))), ("clusterPassword", Some(cluster.passwordQuery.toParamString(cluster.password))), ("clusterCallTimeout", Some(cluster.call.timeoutQuery.toParamString(cluster.call.timeout))), ("clusterCallFailoverTimeout", Some(cluster.call.failover.timeoutQuery.toParamString(cluster.call.failover.timeout))), ("clusterClientFailureCheckPeriod", Some(cluster.client.failure.check.periodQuery.toParamString(cluster.client.failure.check.period))), ("clusterNotificationAttempts", Some(cluster.notification.attemptsQuery.toParamString(cluster.notification.attempts))), ("clusterNotificationInterval", Some(cluster.notification.intervalQuery.toParamString(cluster.notification.interval))), ("idCacheSize", Some(id.cache.sizeQuery.toParamString(id.cache.size))), ("clusterConfirmationWindowSize", Some(cluster.confirmation.window.sizeQuery.toParamString(cluster.confirmation.window.size))), ("clusterConnectionTtl", Some(cluster.connection.ttlQuery.toParamString(cluster.connection.ttl))), ("clusterDuplicateDetection", Some(cluster.duplicate.detectionQuery.toParamString(cluster.duplicate.detection))), ("clusterInitialConnectAttempts", Some(cluster.initial.connect.attemptsQuery.toParamString(cluster.initial.connect.attempts))), ("clusterMaxRetryInterval", Some(cluster.max.retry.intervalQuery.toParamString(cluster.max.retry.interval))), ("clusterMinLargeMessageSize", Some(cluster.min.large.message.sizeQuery.toParamString(cluster.min.large.message.size))), ("clusterProducerWindowSize", Some(cluster.producer.window.sizeQuery.toParamString(cluster.producer.window.size))), ("clusterReconnectAttempts", Some(cluster.reconnect.attemptsQuery.toParamString(cluster.reconnect.attempts))), ("clusterRetryInterval", Some(cluster.retry.intervalQuery.toParamString(cluster.retry.interval))), ("clusterRetryIntervalMultiplier", Some(cluster.retry.interval.multiplierQuery.toParamString(cluster.retry.interval.multiplier))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPath: List[String], comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequency: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPathQuery: QueryParam[List[String]], comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequencyQuery: QueryParam[String]): Task[ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo] = jsonOf[ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPath", Some(com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.projectPathQuery.toParamString(com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.projectPath))), ("comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequency", Some(com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.scheduleFrequencyQuery.toParamString(com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.scheduleFrequency))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensOfflinecontentImplOfflineContentServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], disableSmartSync: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], disableSmartSyncQuery: QueryParam[Boolean]): Task[ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo] = jsonOf[ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.offlinecontent.impl.OfflineContentServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("disableSmartSync", Some(disableSmartSyncQuery.toParamString(disableSmartSync))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqScreensSegmentationImplSegmentationFeatureFlag(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enableDataTriggeredContent: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableDataTriggeredContentQuery: QueryParam[Boolean]): Task[ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo] = jsonOf[ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo]

    val path = "/system/console/configMgr/com.adobe.cq.screens.segmentation.impl.SegmentationFeatureFlag"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enableDataTriggeredContent", Some(enableDataTriggeredContentQuery.toParamString(enableDataTriggeredContent))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo](req)

    } yield resp
  }
  
  def comAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthCh(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo] = jsonOf[ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo]

    val path = "/system/console/configMgr/com.adobe.cq.security.hc.bundles.impl.HtmlLibraryManagerConfigHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo](req)

    } yield resp
  }
  
  def comAdobeCqSecurityHcBundlesImplWcmFilterHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo] = jsonOf[ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.cq.security.hc.bundles.impl.WcmFilterHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], dispatcherAddress: String, dispatcherFilterAllowed: List[String], dispatcherFilterBlocked: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], dispatcherAddressQuery: QueryParam[String], dispatcherFilterAllowedQuery: QueryParam[List[String]], dispatcherFilterBlockedQuery: QueryParam[List[String]]): Task[ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo] = jsonOf[ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.cq.security.hc.dispatcher.impl.DispatcherAccessHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("dispatcherAddress", Some(dispatcher.addressQuery.toParamString(dispatcher.address))), ("dispatcherFilterAllowed", Some(dispatcher.filter.allowedQuery.toParamString(dispatcher.filter.allowed))), ("dispatcherFilterBlocked", Some(dispatcher.filter.blockedQuery.toParamString(dispatcher.filter.blocked))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeCqSecurityHcPackagesImplExampleContentHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo] = jsonOf[ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.cq.security.hc.packages.impl.ExampleContentHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeCqSecurityHcWebserverImplClickjackingHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], webserverAddress: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], webserverAddressQuery: QueryParam[String]): Task[ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo] = jsonOf[ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.cq.security.hc.webserver.impl.ClickjackingHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("webserverAddress", Some(webserver.addressQuery.toParamString(webserver.address))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialAccountverificationImplAccountManagementConfigIm(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enable: Boolean, ttl1: Integer, ttl2: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableQuery: QueryParam[Boolean], ttl1Query: QueryParam[Integer], ttl2Query: QueryParam[Integer]): Task[ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo] = jsonOf[ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.accountverification.impl.AccountManagementConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enable", Some(enableQuery.toParamString(enable))), ("ttl1", Some(ttl1Query.toParamString(ttl1))), ("ttl2", Some(ttl2Query.toParamString(ttl2))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialActivitystreamsClientImplSocialActivityComponen(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo] = jsonOf[ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.activitystreams.client.impl.SocialActivityComponentFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCo(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo] = jsonOf[ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.activitystreams.client.impl.SocialActivityStreamComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialActivitystreamsListenerImplEventListenerHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String, eventFilter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String], eventFilterQuery: QueryParam[String]): Task[ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo] = jsonOf[ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.EventListenerHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialActivitystreamsListenerImplModerationEventExten(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], accepted: Boolean, ranked: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], acceptedQuery: QueryParam[Boolean], rankedQuery: QueryParam[Integer]): Task[ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo] = jsonOf[ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.ModerationEventExtension"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("accepted", Some(acceptedQuery.toParamString(accepted))), ("ranked", Some(rankedQuery.toParamString(ranked))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialActivitystreamsListenerImplRatingEventActivityS(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], ranking: Integer, enable: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], rankingQuery: QueryParam[Integer], enableQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo] = jsonOf[ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.RatingEventActivitySuppressor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("ranking", Some(rankingQuery.toParamString(ranking))), ("enable", Some(enableQuery.toParamString(enable))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialActivitystreamsListenerImplResourceActivityStre(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], streamPath: String, streamName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], streamPathQuery: QueryParam[String], streamNameQuery: QueryParam[String]): Task[ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo] = jsonOf[ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.ResourceActivityStreamProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("streamPath", Some(streamPathQuery.toParamString(streamPath))), ("streamName", Some(streamNameQuery.toParamString(streamName))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsI(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxRetry: Integer, fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxRetryQuery: QueryParam[Integer], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo] = jsonOf[ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.calendar.client.endpoints.impl.CalendarOperationsImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxRetry", Some(MaxRetryQuery.toParamString(MaxRetry))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCalendarClientOperationextensionsEventAttachmen(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], attachmentTypeBlacklist: String, extensionOrder: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[String], extensionOrderQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo] = jsonOf[ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.calendar.client.operationextensions.EventAttachment"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))), ("extensionOrder", Some(extension.orderQuery.toParamString(extension.order))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCalendarServletsTimeZoneServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], timezonesExpirytime: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], timezonesExpirytimeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCalendarServletsTimeZoneServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCalendarServletsTimeZoneServletInfo] = jsonOf[ComAdobeCqSocialCalendarServletsTimeZoneServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.calendar.servlets.TimeZoneServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("timezonesExpirytime", Some(timezones.expirytimeQuery.toParamString(timezones.expirytime))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCalendarServletsTimeZoneServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEvent(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], ranking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], rankingQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo] = jsonOf[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.CommentDeleteEventActivitySuppressor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("ranking", Some(rankingQuery.toParamString(ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSe(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo] = jsonOf[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.CommentOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperati(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo] = jsonOf[ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.TranslationOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialC(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], numUserLimit: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], numUserLimitQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo] = jsonOf[ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.comments.listing.impl.SearchCommentSocialComponentListProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("numUserLimit", Some(numUserLimitQuery.toParamString(numUserLimit))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPos(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enableScheduledPostsSearch: Boolean, numberOfMinutes: Integer, maxSearchLimit: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableScheduledPostsSearchQuery: QueryParam[Boolean], numberOfMinutesQuery: QueryParam[Integer], maxSearchLimitQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo] = jsonOf[ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.comments.scheduler.impl.SearchScheduledPosts"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enableScheduledPostsSearch", Some(enableScheduledPostsSearchQuery.toParamString(enableScheduledPostsSearch))), ("numberOfMinutes", Some(numberOfMinutesQuery.toParamString(numberOfMinutes))), ("maxSearchLimit", Some(maxSearchLimitQuery.toParamString(maxSearchLimit))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsCorsCORSAuthenticationFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], corsEnabling: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], corsEnablingQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo] = jsonOf[ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.cors.CORSAuthenticationFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("corsEnabling", Some(cors.enablingQuery.toParamString(cors.enabling))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.AndroidEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], contextPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], contextPathQuery: QueryParam[String]): Task[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CommentEmailBuilderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("contextPath", Some(context.pathQuery.toParamString(context.path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String]): Task[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CommentEmailEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CustomEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImp(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], patternTime: String, patternNewline: String, patternDayOfMonth: String, patternMonth: String, patternYear: String, patternDate: String, patternDateTime: String, patternEmail: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], patternTimeQuery: QueryParam[String], patternNewlineQuery: QueryParam[String], patternDayOfMonthQuery: QueryParam[String], patternMonthQuery: QueryParam[String], patternYearQuery: QueryParam[String], patternDateQuery: QueryParam[String], patternDateTimeQuery: QueryParam[String], patternEmailQuery: QueryParam[String]): Task[ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailQuotedTextPatternsImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("patternTime", Some(pattern.timeQuery.toParamString(pattern.time))), ("patternNewline", Some(pattern.newlineQuery.toParamString(pattern.newline))), ("patternDayOfMonth", Some(pattern.dayOfMonthQuery.toParamString(pattern.dayOfMonth))), ("patternMonth", Some(pattern.monthQuery.toParamString(pattern.month))), ("patternYear", Some(pattern.yearQuery.toParamString(pattern.year))), ("patternDate", Some(pattern.dateQuery.toParamString(pattern.date))), ("patternDateTime", Some(pattern.dateTimeQuery.toParamString(pattern.dateTime))), ("patternEmail", Some(pattern.emailQuery.toParamString(pattern.email))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImp(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], emailName: String, emailCreatePostFromReply: Boolean, emailAddCommentIdTo: String, emailSubjectMaximumLength: Integer, emailReplyToAddress: String, emailReplyToDelimiter: String, emailTrackerIdPrefixInSubject: String, emailTrackerIdPrefixInBody: String, emailAsHTML: Boolean, emailDefaultUserName: String, emailTemplatesRootPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], emailNameQuery: QueryParam[String], emailCreatePostFromReplyQuery: QueryParam[Boolean], emailAddCommentIdToQuery: QueryParam[String], emailSubjectMaximumLengthQuery: QueryParam[Integer], emailReplyToAddressQuery: QueryParam[String], emailReplyToDelimiterQuery: QueryParam[String], emailTrackerIdPrefixInSubjectQuery: QueryParam[String], emailTrackerIdPrefixInBodyQuery: QueryParam[String], emailAsHTMLQuery: QueryParam[Boolean], emailDefaultUserNameQuery: QueryParam[String], emailTemplatesRootPathQuery: QueryParam[String]): Task[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailReplyConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("emailName", Some(email.nameQuery.toParamString(email.name))), ("emailCreatePostFromReply", Some(email.createPostFromReplyQuery.toParamString(email.createPostFromReply))), ("emailAddCommentIdTo", Some(email.addCommentIdToQuery.toParamString(email.addCommentIdTo))), ("emailSubjectMaximumLength", Some(email.subjectMaximumLengthQuery.toParamString(email.subjectMaximumLength))), ("emailReplyToAddress", Some(email.replyToAddressQuery.toParamString(email.replyToAddress))), ("emailReplyToDelimiter", Some(email.replyToDelimiterQuery.toParamString(email.replyToDelimiter))), ("emailTrackerIdPrefixInSubject", Some(email.trackerIdPrefixInSubjectQuery.toParamString(email.trackerIdPrefixInSubject))), ("emailTrackerIdPrefixInBody", Some(email.trackerIdPrefixInBodyQuery.toParamString(email.trackerIdPrefixInBody))), ("emailAsHTML", Some(email.asHTMLQuery.toParamString(email.asHTML))), ("emailDefaultUserName", Some(email.defaultUserNameQuery.toParamString(email.defaultUserName))), ("emailTemplatesRootPath", Some(email.templates.rootPathQuery.toParamString(email.templates.rootPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplEmailReplyImporter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], connectProtocol: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], connectProtocolQuery: QueryParam[String]): Task[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailReplyImporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("connectProtocol", Some(connectProtocolQuery.toParamString(connectProtocol))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.GmailEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.IOSEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.MacmailEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.OutLookEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], replyEmailPatterns: List[String], priorityOrder: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], replyEmailPatternsQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.UnknownEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priorityOrder: Integer, replyEmailPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityOrderQuery: QueryParam[Integer], replyEmailPatternsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo] = jsonOf[ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.YahooEmailClientProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priorityOrder", Some(priorityOrderQuery.toParamString(priorityOrder))), ("replyEmailPatterns", Some(replyEmailPatternsQuery.toParamString(replyEmailPatterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUpload(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], numberOfDays: Integer, ageOfFile: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], numberOfDaysQuery: QueryParam[Integer], ageOfFileQuery: QueryParam[Integer]): Task[ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo] = jsonOf[ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.maintainance.impl.DeleteTempUGCImageUploads"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("numberOfDays", Some(numberOfDaysQuery.toParamString(numberOfDays))), ("ageOfFile", Some(ageOfFileQuery.toParamString(ageOfFile))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String, eventFilter: String, verbs: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String], eventFilterQuery: QueryParam[String], verbsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo] = jsonOf[ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.ugclimiter.impl.UGCLimiterServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("verbs", Some(verbsQuery.toParamString(verbs))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimit(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enable: Boolean, uGCLimit: Integer, ugcLimitDuration: Integer, domains: List[String], toList: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableQuery: QueryParam[Boolean], uGCLimitQuery: QueryParam[Integer], ugcLimitDurationQuery: QueryParam[Integer], domainsQuery: QueryParam[List[String]], toListQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo] = jsonOf[ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.commons.ugclimitsconfig.impl.CommunityUserUGCLimitsConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enable", Some(enableQuery.toParamString(enable))), ("uGCLimit", Some(UGCLimitQuery.toParamString(UGCLimit))), ("ugcLimitDuration", Some(ugcLimitDurationQuery.toParamString(ugcLimitDuration))), ("domains", Some(domainsQuery.toParamString(domains))), ("toList", Some(toListQuery.toParamString(toList))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialConnectOauthImplFacebookProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String, oauthCloudConfigRoot: String, providerConfigRoot: String, providerConfigCreateTagsEnabled: Boolean, providerConfigUserFolder: String, providerConfigFacebookFetchFields: Boolean, providerConfigFacebookFields: List[String], providerConfigRefreshUserdataEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String], oauthCloudConfigRootQuery: QueryParam[String], providerConfigRootQuery: QueryParam[String], providerConfigCreateTagsEnabledQuery: QueryParam[Boolean], providerConfigUserFolderQuery: QueryParam[String], providerConfigFacebookFetchFieldsQuery: QueryParam[Boolean], providerConfigFacebookFieldsQuery: QueryParam[List[String]], providerConfigRefreshUserdataEnabledQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo] = jsonOf[ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.FacebookProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))), ("oauthCloudConfigRoot", Some(oauth.cloud.config.rootQuery.toParamString(oauth.cloud.config.root))), ("providerConfigRoot", Some(provider.config.rootQuery.toParamString(provider.config.root))), ("providerConfigCreateTagsEnabled", Some(provider.config.create.tags.enabledQuery.toParamString(provider.config.create.tags.enabled))), ("providerConfigUserFolder", Some(provider.config.user.folderQuery.toParamString(provider.config.user.folder))), ("providerConfigFacebookFetchFields", Some(provider.config.facebook.fetch.fieldsQuery.toParamString(provider.config.facebook.fetch.fields))), ("providerConfigFacebookFields", Some(provider.config.facebook.fieldsQuery.toParamString(provider.config.facebook.fields))), ("providerConfigRefreshUserdataEnabled", Some(provider.config.refresh.userdata.enabledQuery.toParamString(provider.config.refresh.userdata.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandle(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: List[String], serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer]): Task[ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo] = jsonOf[ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.SocialOAuthAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapper(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], facebook: List[String], twitter: List[String], providerConfigUserFolder: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], facebookQuery: QueryParam[List[String]], twitterQuery: QueryParam[List[String]], providerConfigUserFolderQuery: QueryParam[String]): Task[ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo] = jsonOf[ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.SocialOAuthUserProfileMapper"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("facebook", Some(facebookQuery.toParamString(facebook))), ("twitter", Some(twitterQuery.toParamString(twitter))), ("providerConfigUserFolder", Some(provider.config.user.folderQuery.toParamString(provider.config.user.folder))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialConnectOauthImplTwitterProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String, oauthCloudConfigRoot: String, providerConfigRoot: String, providerConfigUserFolder: String, providerConfigTwitterEnableParams: Boolean, providerConfigTwitterParams: List[String], providerConfigRefreshUserdataEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String], oauthCloudConfigRootQuery: QueryParam[String], providerConfigRootQuery: QueryParam[String], providerConfigUserFolderQuery: QueryParam[String], providerConfigTwitterEnableParamsQuery: QueryParam[Boolean], providerConfigTwitterParamsQuery: QueryParam[List[String]], providerConfigRefreshUserdataEnabledQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo] = jsonOf[ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.TwitterProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))), ("oauthCloudConfigRoot", Some(oauth.cloud.config.rootQuery.toParamString(oauth.cloud.config.root))), ("providerConfigRoot", Some(provider.config.rootQuery.toParamString(provider.config.root))), ("providerConfigUserFolder", Some(provider.config.user.folderQuery.toParamString(provider.config.user.folder))), ("providerConfigTwitterEnableParams", Some(provider.config.twitter.enable.paramsQuery.toParamString(provider.config.twitter.enable.params))), ("providerConfigTwitterParams", Some(provider.config.twitter.paramsQuery.toParamString(provider.config.twitter.params))), ("providerConfigRefreshUserdataEnabled", Some(provider.config.refresh.userdata.enabledQuery.toParamString(provider.config.refresh.userdata.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmen(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqSocialContentFragmentsServicesEnabled: Boolean, cqSocialContentFragmentsServicesWaitTimeSeconds: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqSocialContentFragmentsServicesEnabledQuery: QueryParam[Boolean], cqSocialContentFragmentsServicesWaitTimeSecondsQuery: QueryParam[Integer]): Task[ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo] = jsonOf[ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.content.fragments.services.impl.CommunitiesFragmentCreationServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqSocialContentFragmentsServicesEnabled", Some(cq.social.content.fragments.services.enabledQuery.toParamString(cq.social.content.fragments.services.enabled))), ("cqSocialContentFragmentsServicesWaitTimeSeconds", Some(cq.social.content.fragments.services.waitTimeSecondsQuery.toParamString(cq.social.content.fragments.services.waitTimeSeconds))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialDatastoreAsImplASResourceProviderFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], versionId: String, cacheOn: Boolean, concurrencyLevel: Integer, cacheStartSize: Integer, cacheTtl: Integer, cacheSize: Integer, timeLimit: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], versionIdQuery: QueryParam[String], cacheOnQuery: QueryParam[Boolean], concurrencyLevelQuery: QueryParam[Integer], cacheStartSizeQuery: QueryParam[Integer], cacheTtlQuery: QueryParam[Integer], cacheSizeQuery: QueryParam[Integer], timeLimitQuery: QueryParam[Integer]): Task[ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo] = jsonOf[ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.datastore.as.impl.ASResourceProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("versionId", Some(version.idQuery.toParamString(version.id))), ("cacheOn", Some(cache.onQuery.toParamString(cache.on))), ("concurrencyLevel", Some(concurrency.levelQuery.toParamString(concurrency.level))), ("cacheStartSize", Some(cache.start.sizeQuery.toParamString(cache.start.size))), ("cacheTtl", Some(cache.ttlQuery.toParamString(cache.ttl))), ("cacheSize", Some(cache.sizeQuery.toParamString(cache.size))), ("timeLimit", Some(time.limitQuery.toParamString(time.limit))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], solrZkTimeout: String, solrCommit: String, cacheOn: Boolean, concurrencyLevel: Integer, cacheStartSize: Integer, cacheTtl: Integer, cacheSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], solrZkTimeoutQuery: QueryParam[String], solrCommitQuery: QueryParam[String], cacheOnQuery: QueryParam[Boolean], concurrencyLevelQuery: QueryParam[Integer], cacheStartSizeQuery: QueryParam[Integer], cacheTtlQuery: QueryParam[Integer], cacheSizeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo] = jsonOf[ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.datastore.op.impl.SocialMSResourceProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("solrZkTimeout", Some(solr.zk.timeoutQuery.toParamString(solr.zk.timeout))), ("solrCommit", Some(solr.commitQuery.toParamString(solr.commit))), ("cacheOn", Some(cache.onQuery.toParamString(cache.on))), ("concurrencyLevel", Some(concurrency.levelQuery.toParamString(concurrency.level))), ("cacheStartSize", Some(cache.start.sizeQuery.toParamString(cache.start.size))), ("cacheTtl", Some(cache.ttlQuery.toParamString(cache.ttl))), ("cacheSize", Some(cache.sizeQuery.toParamString(cache.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], solrZkTimeout: String, solrCommit: String, cacheOn: Boolean, concurrencyLevel: Integer, cacheStartSize: Integer, cacheTtl: Integer, cacheSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], solrZkTimeoutQuery: QueryParam[String], solrCommitQuery: QueryParam[String], cacheOnQuery: QueryParam[Boolean], concurrencyLevelQuery: QueryParam[Integer], cacheStartSizeQuery: QueryParam[Integer], cacheTtlQuery: QueryParam[Integer], cacheSizeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo] = jsonOf[ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.datastore.rdb.impl.SocialRDBResourceProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("solrZkTimeout", Some(solr.zk.timeoutQuery.toParamString(solr.zk.timeout))), ("solrCommit", Some(solr.commitQuery.toParamString(solr.commit))), ("cacheOn", Some(cache.onQuery.toParamString(cache.on))), ("concurrencyLevel", Some(concurrency.levelQuery.toParamString(concurrency.level))), ("cacheStartSize", Some(cache.start.sizeQuery.toParamString(cache.start.size))), ("cacheTtl", Some(cache.ttlQuery.toParamString(cache.ttl))), ("cacheSize", Some(cache.sizeQuery.toParamString(cache.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorF(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], isMemberCheck: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], isMemberCheckQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo] = jsonOf[ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.enablement.adaptors.EnablementLearningPathAdaptorFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("isMemberCheck", Some(isMemberCheckQuery.toParamString(isMemberCheck))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFacto(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], isMemberCheck: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], isMemberCheckQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo] = jsonOf[ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.enablement.adaptors.EnablementResourceAdaptorFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("isMemberCheck", Some(isMemberCheckQuery.toParamString(isMemberCheck))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialEnablementLearningpathEndpointsImplEnablementL(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo] = jsonOf[ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.enablement.learningpath.endpoints.impl.EnablementLearningPathModelOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialEnablementResourceEndpointsImplEnablementResou(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo] = jsonOf[ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.enablement.resource.endpoints.impl.EnablementResourceModelOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialEnablementServicesImplAuthorMarkerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer]): Task[ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo] = jsonOf[ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.enablement.services.impl.AuthorMarkerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGe(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletSelectors: String, slingServletExtensions: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletSelectorsQuery: QueryParam[String], slingServletExtensionsQuery: QueryParam[String]): Task[ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo] = jsonOf[ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.filelibrary.client.endpoints.FilelibraryDownloadGetServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("slingServletExtensions", Some(sling.servlet.extensionsQuery.toParamString(sling.servlet.extensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOpera(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo] = jsonOf[ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.filelibrary.client.endpoints.impl.FileLibraryOperationsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialForumClientEndpointsImplForumOperationsService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo] = jsonOf[ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.forum.client.endpoints.impl.ForumOperationsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialForumDispatcherImplFlushOperations(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], extensionOrder: Integer, flushForumontopic: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], extensionOrderQuery: QueryParam[Integer], flushForumontopicQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo] = jsonOf[ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.forum.dispatcher.impl.FlushOperations"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("extensionOrder", Some(extension.orderQuery.toParamString(extension.order))), ("flushForumontopic", Some(flush.forumontopicQuery.toParamString(flush.forumontopic))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialGroupClientImplCommunityGroupCollectionComponen(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], groupListingPaginationEnable: Boolean, groupListingLazyloadingEnable: Boolean, pageSize: Integer, priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], groupListingPaginationEnableQuery: QueryParam[Boolean], groupListingLazyloadingEnableQuery: QueryParam[Boolean], pageSizeQuery: QueryParam[Integer], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo] = jsonOf[ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.group.client.impl.CommunityGroupCollectionComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("groupListingPaginationEnable", Some(group.listing.pagination.enableQuery.toParamString(group.listing.pagination.enable))), ("groupListingLazyloadingEnable", Some(group.listing.lazyloading.enableQuery.toParamString(group.listing.lazyloading.enable))), ("pageSize", Some(page.sizeQuery.toParamString(page.size))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialGroupImplGroupServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxWaitTime: Integer, minWaitBetweenRetries: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxWaitTimeQuery: QueryParam[Integer], minWaitBetweenRetriesQuery: QueryParam[Integer]): Task[ComAdobeCqSocialGroupImplGroupServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialGroupImplGroupServiceImplInfo] = jsonOf[ComAdobeCqSocialGroupImplGroupServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.group.impl.GroupServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxWaitTime", Some(maxWaitTimeQuery.toParamString(maxWaitTime))), ("minWaitBetweenRetries", Some(minWaitBetweenRetriesQuery.toParamString(minWaitBetweenRetries))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialGroupImplGroupServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialHandlebarsGuavaTemplateCacheImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], parameterGuavaCacheEnabled: Boolean, parameterGuavaCacheParams: String, parameterGuavaCacheReload: Boolean, serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], parameterGuavaCacheEnabledQuery: QueryParam[Boolean], parameterGuavaCacheParamsQuery: QueryParam[String], parameterGuavaCacheReloadQuery: QueryParam[Boolean], serviceRankingQuery: QueryParam[Integer]): Task[ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo] = jsonOf[ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.handlebars.GuavaTemplateCacheImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("parameterGuavaCacheEnabled", Some(parameter.guava.cache.enabledQuery.toParamString(parameter.guava.cache.enabled))), ("parameterGuavaCacheParams", Some(parameter.guava.cache.paramsQuery.toParamString(parameter.guava.cache.params))), ("parameterGuavaCacheReload", Some(parameter.guava.cache.reloadQuery.toParamString(parameter.guava.cache.reload))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsS(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo] = jsonOf[ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ideation.client.endpoints.impl.IdeationOperationsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialJournalClientEndpointsImplJournalOperationsSer(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo] = jsonOf[ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.journal.client.endpoints.impl.JournalOperationsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfile(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo] = jsonOf[ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.members.endpoints.impl.CommunityMemberGroupProfileOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileO(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo] = jsonOf[ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.members.endpoints.impl.CommunityMemberUserProfileOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentF(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], everyoneLimit: Integer, priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], everyoneLimitQuery: QueryParam[Integer], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo] = jsonOf[ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.members.impl.CommunityMemberGroupProfileComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("everyoneLimit", Some(everyoneLimitQuery.toParamString(everyoneLimit))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialMessagingClientEndpointsImplMessagingOperation(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], messageProperties: List[String], messageBoxSizeLimit: Integer, messageCountLimit: Integer, notifyFailure: Boolean, failureMessageFrom: String, failureTemplatePath: String, maxRetries: Integer, minWaitBetweenRetries: Integer, countUpdatePoolSize: Integer, inboxPath: String, sentitemsPath: String, supportAttachments: Boolean, supportGroupMessaging: Boolean, maxTotalRecipients: Integer, batchSize: Integer, maxTotalAttachmentSize: Integer, attachmentTypeBlacklist: List[String], allowedAttachmentTypes: List[String], serviceSelector: String, fieldWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], messagePropertiesQuery: QueryParam[List[String]], messageBoxSizeLimitQuery: QueryParam[Integer], messageCountLimitQuery: QueryParam[Integer], notifyFailureQuery: QueryParam[Boolean], failureMessageFromQuery: QueryParam[String], failureTemplatePathQuery: QueryParam[String], maxRetriesQuery: QueryParam[Integer], minWaitBetweenRetriesQuery: QueryParam[Integer], countUpdatePoolSizeQuery: QueryParam[Integer], inboxPathQuery: QueryParam[String], sentitemsPathQuery: QueryParam[String], supportAttachmentsQuery: QueryParam[Boolean], supportGroupMessagingQuery: QueryParam[Boolean], maxTotalRecipientsQuery: QueryParam[Integer], batchSizeQuery: QueryParam[Integer], maxTotalAttachmentSizeQuery: QueryParam[Integer], attachmentTypeBlacklistQuery: QueryParam[List[String]], allowedAttachmentTypesQuery: QueryParam[List[String]], serviceSelectorQuery: QueryParam[String], fieldWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo] = jsonOf[ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.messaging.client.endpoints.impl.MessagingOperationsServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("messageProperties", Some(message.propertiesQuery.toParamString(message.properties))), ("messageBoxSizeLimit", Some(messageBoxSizeLimitQuery.toParamString(messageBoxSizeLimit))), ("messageCountLimit", Some(messageCountLimitQuery.toParamString(messageCountLimit))), ("notifyFailure", Some(notifyFailureQuery.toParamString(notifyFailure))), ("failureMessageFrom", Some(failureMessageFromQuery.toParamString(failureMessageFrom))), ("failureTemplatePath", Some(failureTemplatePathQuery.toParamString(failureTemplatePath))), ("maxRetries", Some(maxRetriesQuery.toParamString(maxRetries))), ("minWaitBetweenRetries", Some(minWaitBetweenRetriesQuery.toParamString(minWaitBetweenRetries))), ("countUpdatePoolSize", Some(countUpdatePoolSizeQuery.toParamString(countUpdatePoolSize))), ("inboxPath", Some(inbox.pathQuery.toParamString(inbox.path))), ("sentitemsPath", Some(sentitems.pathQuery.toParamString(sentitems.path))), ("supportAttachments", Some(supportAttachmentsQuery.toParamString(supportAttachments))), ("supportGroupMessaging", Some(supportGroupMessagingQuery.toParamString(supportGroupMessaging))), ("maxTotalRecipients", Some(maxTotalRecipientsQuery.toParamString(maxTotalRecipients))), ("batchSize", Some(batchSizeQuery.toParamString(batchSize))), ("maxTotalAttachmentSize", Some(maxTotalAttachmentSizeQuery.toParamString(maxTotalAttachmentSize))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))), ("allowedAttachmentTypes", Some(allowedAttachmentTypesQuery.toParamString(allowedAttachmentTypes))), ("serviceSelector", Some(serviceSelectorQuery.toParamString(serviceSelector))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialModerationDashboardApiFilterGroupSocialComponen(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], resourceTypeFilters: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], resourceTypeFiltersQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo] = jsonOf[ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.FilterGroupSocialComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("resourceTypeFilters", Some(resourceType.filtersQuery.toParamString(resourceType.filters))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialModerationDashboardApiModerationDashboardSocial(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo] = jsonOf[ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.ModerationDashboardSocialComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialModerationDashboardApiUserDetailsSocialComponen(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo] = jsonOf[ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.UserDetailsSocialComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialModerationDashboardInternalImplFilterGroupSoci(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], resourceTypeFilters: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], resourceTypeFiltersQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo] = jsonOf[ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.internal.impl.FilterGroupSocialComponentFactoryV2"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("resourceTypeFilters", Some(resourceType.filtersQuery.toParamString(resourceType.filters))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialNotificationsImplMentionsRouter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String, eventFilter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String], eventFilterQuery: QueryParam[String]): Task[ComAdobeCqSocialNotificationsImplMentionsRouterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialNotificationsImplMentionsRouterInfo] = jsonOf[ComAdobeCqSocialNotificationsImplMentionsRouterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.notifications.impl.MentionsRouter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialNotificationsImplMentionsRouterInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialNotificationsImplNotificationManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxUnreadNotificationCount: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxUnreadNotificationCountQuery: QueryParam[Integer]): Task[ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo] = jsonOf[ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.notifications.impl.NotificationManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxUnreadNotificationCount", Some(max.unread.notification.countQuery.toParamString(max.unread.notification.count))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialNotificationsImplNotificationsRouter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String, eventFilter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String], eventFilterQuery: QueryParam[String]): Task[ComAdobeCqSocialNotificationsImplNotificationsRouterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialNotificationsImplNotificationsRouterInfo] = jsonOf[ComAdobeCqSocialNotificationsImplNotificationsRouterInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.notifications.impl.NotificationsRouter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialNotificationsImplNotificationsRouterInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServic(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo] = jsonOf[ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.qna.client.endpoints.impl.QnaForumOperationsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportI(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqSocialReportingAnalyticsPollingImporterInterval: Integer, cqSocialReportingAnalyticsPollingImporterPageSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqSocialReportingAnalyticsPollingImporterIntervalQuery: QueryParam[Integer], cqSocialReportingAnalyticsPollingImporterPageSizeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo] = jsonOf[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.AnalyticsReportImporterServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqSocialReportingAnalyticsPollingImporterInterval", Some(cq.social.reporting.analytics.polling.importer.intervalQuery.toParamString(cq.social.reporting.analytics.polling.importer.interval))), ("cqSocialReportingAnalyticsPollingImporterPageSize", Some(cq.social.reporting.analytics.polling.importer.pageSizeQuery.toParamString(cq.social.reporting.analytics.polling.importer.pageSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportM(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], reportFetchDelay: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], reportFetchDelayQuery: QueryParam[Integer]): Task[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo] = jsonOf[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.AnalyticsReportManagementServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("reportFetchDelay", Some(report.fetch.delayQuery.toParamString(report.fetch.delay))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportS(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqSocialConsoleAnalyticsSitesMapping: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqSocialConsoleAnalyticsSitesMappingQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo] = jsonOf[ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.SiteTrendReportSocialComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqSocialConsoleAnalyticsSitesMapping", Some(cq.social.console.analytics.sites.mappingQuery.toParamString(cq.social.console.analytics.sites.mapping))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialReviewClientEndpointsImplReviewOperationsServi(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], attachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], attachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo] = jsonOf[ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.review.client.endpoints.impl.ReviewOperationsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("attachmentTypeBlacklist", Some(attachmentTypeBlacklistQuery.toParamString(attachmentTypeBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialScfCoreOperationsImplSocialOperationsServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletSelectors: String, slingServletExtensions: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletSelectorsQuery: QueryParam[String], slingServletExtensionsQuery: QueryParam[String]): Task[ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo] = jsonOf[ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.scf.core.operations.impl.SocialOperationsServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("slingServletExtensions", Some(sling.servlet.extensionsQuery.toParamString(sling.servlet.extensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialScfEndpointsImplDefaultSocialGetServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletSelectors: List[String], slingServletExtensions: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletSelectorsQuery: QueryParam[List[String]], slingServletExtensionsQuery: QueryParam[String]): Task[ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo] = jsonOf[ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.scf.endpoints.impl.DefaultSocialGetServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("slingServletExtensions", Some(sling.servlet.extensionsQuery.toParamString(sling.servlet.extensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialScoringImplScoringEventListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String, eventFilter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String], eventFilterQuery: QueryParam[String]): Task[ComAdobeCqSocialScoringImplScoringEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialScoringImplScoringEventListenerInfo] = jsonOf[ComAdobeCqSocialScoringImplScoringEventListenerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.scoring.impl.ScoringEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialScoringImplScoringEventListenerInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialServiceusersInternalImplServiceUserWrapperImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enableFallback: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableFallbackQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo] = jsonOf[ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.serviceusers.internal.impl.ServiceUserWrapperImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enableFallback", Some(enableFallbackQuery.toParamString(enableFallback))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSiteEndpointsImplSiteOperationService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fieldWhitelist: List[String], sitePathFilters: List[String], sitePackageGroup: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fieldWhitelistQuery: QueryParam[List[String]], sitePathFiltersQuery: QueryParam[List[String]], sitePackageGroupQuery: QueryParam[String]): Task[ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo] = jsonOf[ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.site.endpoints.impl.SiteOperationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fieldWhitelist", Some(fieldWhitelistQuery.toParamString(fieldWhitelist))), ("sitePathFilters", Some(sitePathFiltersQuery.toParamString(sitePathFilters))), ("sitePackageGroup", Some(sitePackageGroupQuery.toParamString(sitePackageGroup))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceIm(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqSocialConsoleAnalyticsComponents: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqSocialConsoleAnalyticsComponentsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo] = jsonOf[ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.site.impl.AnalyticsComponentConfigurationServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqSocialConsoleAnalyticsComponents", Some(cq.social.console.analytics.componentsQuery.toParamString(cq.social.console.analytics.components))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSiteImplSiteConfiguratorImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], componentsUsingTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], componentsUsingTagsQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo] = jsonOf[ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.site.impl.SiteConfiguratorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("componentsUsingTags", Some(componentsUsingTagsQuery.toParamString(componentsUsingTags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSrpImplSocialSolrConnector(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], srpType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], srpTypeQuery: QueryParam[String]): Task[ComAdobeCqSocialSrpImplSocialSolrConnectorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSrpImplSocialSolrConnectorInfo] = jsonOf[ComAdobeCqSocialSrpImplSocialSolrConnectorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.srp.impl.SocialSolrConnector"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("srpType", Some(srp.typeQuery.toParamString(srp.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSrpImplSocialSolrConnectorInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSyncImplDiffChangesObserver(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, agentName: String, diffPath: String, propertyNames: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], agentNameQuery: QueryParam[String], diffPathQuery: QueryParam[String], propertyNamesQuery: QueryParam[String]): Task[ComAdobeCqSocialSyncImplDiffChangesObserverInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSyncImplDiffChangesObserverInfo] = jsonOf[ComAdobeCqSocialSyncImplDiffChangesObserverInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.sync.impl.DiffChangesObserver"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("agentName", Some(agentNameQuery.toParamString(agentName))), ("diffPath", Some(diffPathQuery.toParamString(diffPath))), ("propertyNames", Some(propertyNamesQuery.toParamString(propertyNames))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSyncImplDiffChangesObserverInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSyncImplGroupSyncListenerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], nodetypes: List[String], ignorableprops: List[String], ignorablenodes: String, enabled: Boolean, distfolders: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nodetypesQuery: QueryParam[List[String]], ignorablepropsQuery: QueryParam[List[String]], ignorablenodesQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], distfoldersQuery: QueryParam[String]): Task[ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo] = jsonOf[ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.sync.impl.GroupSyncListenerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("nodetypes", Some(nodetypesQuery.toParamString(nodetypes))), ("ignorableprops", Some(ignorablepropsQuery.toParamString(ignorableprops))), ("ignorablenodes", Some(ignorablenodesQuery.toParamString(ignorablenodes))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("distfolders", Some(distfoldersQuery.toParamString(distfolders))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSyncImplPublisherSyncServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], activeRunModes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], activeRunModesQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo] = jsonOf[ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.sync.impl.PublisherSyncServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("activeRunModes", Some(activeRunModesQuery.toParamString(activeRunModes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialSyncImplUserSyncListenerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], nodetypes: List[String], ignorableprops: List[String], ignorablenodes: List[String], enabled: Boolean, distfolders: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nodetypesQuery: QueryParam[List[String]], ignorablepropsQuery: QueryParam[List[String]], ignorablenodesQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], distfoldersQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialSyncImplUserSyncListenerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialSyncImplUserSyncListenerImplInfo] = jsonOf[ComAdobeCqSocialSyncImplUserSyncListenerImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.sync.impl.UserSyncListenerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("nodetypes", Some(nodetypesQuery.toParamString(nodetypes))), ("ignorableprops", Some(ignorablepropsQuery.toParamString(ignorableprops))), ("ignorablenodes", Some(ignorablenodesQuery.toParamString(ignorablenodes))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("distfolders", Some(distfoldersQuery.toParamString(distfolders))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialSyncImplUserSyncListenerImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialTranslationImplTranslationServiceConfigManager(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], translateLanguage: String, translateDisplay: String, translateAttribution: Boolean, translateCaching: String, translateSmartRendering: String, translateCachingDuration: String, translateSessionSaveInterval: String, translateSessionSaveBatchLimit: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], translateLanguageQuery: QueryParam[String], translateDisplayQuery: QueryParam[String], translateAttributionQuery: QueryParam[Boolean], translateCachingQuery: QueryParam[String], translateSmartRenderingQuery: QueryParam[String], translateCachingDurationQuery: QueryParam[String], translateSessionSaveIntervalQuery: QueryParam[String], translateSessionSaveBatchLimitQuery: QueryParam[String]): Task[ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo] = jsonOf[ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.translation.impl.TranslationServiceConfigManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("translateLanguage", Some(translate.languageQuery.toParamString(translate.language))), ("translateDisplay", Some(translate.displayQuery.toParamString(translate.display))), ("translateAttribution", Some(translate.attributionQuery.toParamString(translate.attribution))), ("translateCaching", Some(translate.cachingQuery.toParamString(translate.caching))), ("translateSmartRendering", Some(translate.smart.renderingQuery.toParamString(translate.smart.rendering))), ("translateCachingDuration", Some(translate.caching.durationQuery.toParamString(translate.caching.duration))), ("translateSessionSaveInterval", Some(translate.session.save.intervalQuery.toParamString(translate.session.save.interval))), ("translateSessionSaveBatchLimit", Some(translate.session.save.batchLimitQuery.toParamString(translate.session.save.batchLimit))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialTranslationImplUGCLanguageDetector(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: String, eventFilter: String, translateListenerType: List[String], translatePropertyList: List[String], poolSize: Integer, maxPoolSize: Integer, queueSize: Integer, keepAliveTime: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[String], eventFilterQuery: QueryParam[String], translateListenerTypeQuery: QueryParam[List[String]], translatePropertyListQuery: QueryParam[List[String]], poolSizeQuery: QueryParam[Integer], maxPoolSizeQuery: QueryParam[Integer], queueSizeQuery: QueryParam[Integer], keepAliveTimeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo] = jsonOf[ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.translation.impl.UGCLanguageDetector"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("translateListenerType", Some(translate.listener.typeQuery.toParamString(translate.listener.type))), ("translatePropertyList", Some(translate.property.listQuery.toParamString(translate.property.list))), ("poolSize", Some(poolSizeQuery.toParamString(poolSize))), ("maxPoolSize", Some(maxPoolSizeQuery.toParamString(maxPoolSize))), ("queueSize", Some(queueSizeQuery.toParamString(queueSize))), ("keepAliveTime", Some(keepAliveTimeQuery.toParamString(keepAliveTime))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseDispatcherImplFlushServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], threadPoolSize: Integer, delayTime: Integer, workerSleepTime: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], threadPoolSizeQuery: QueryParam[Integer], delayTimeQuery: QueryParam[Integer], workerSleepTimeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo] = jsonOf[ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.dispatcher.impl.FlushServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("threadPoolSize", Some(threadPoolSizeQuery.toParamString(threadPoolSize))), ("delayTime", Some(delayTimeQuery.toParamString(delayTime))), ("workerSleepTime", Some(workerSleepTimeQuery.toParamString(workerSleepTime))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseImplAysncReverseReplicatorImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], poolSize: Integer, maxPoolSize: Integer, queueSize: Integer, keepAliveTime: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], poolSizeQuery: QueryParam[Integer], maxPoolSizeQuery: QueryParam[Integer], queueSizeQuery: QueryParam[Integer], keepAliveTimeQuery: QueryParam[Integer]): Task[ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo] = jsonOf[ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.AysncReverseReplicatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("poolSize", Some(poolSizeQuery.toParamString(poolSize))), ("maxPoolSize", Some(maxPoolSizeQuery.toParamString(maxPoolSize))), ("queueSize", Some(queueSizeQuery.toParamString(queueSize))), ("keepAliveTime", Some(keepAliveTimeQuery.toParamString(keepAliveTime))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseImplPublisherConfigurationImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], isPrimaryPublisher: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], isPrimaryPublisherQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo] = jsonOf[ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.PublisherConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("isPrimaryPublisher", Some(isPrimaryPublisherQuery.toParamString(isPrimaryPublisher))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseImplSocialUtilsImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], legacyCloudUGCPathMapping: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], legacyCloudUGCPathMappingQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo] = jsonOf[ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.SocialUtilsImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("legacyCloudUGCPathMapping", Some(legacyCloudUGCPathMappingQuery.toParamString(legacyCloudUGCPathMapping))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseModerationImplAutoModerationImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], automoderationSequence: List[String], automoderationOnfailurestop: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], automoderationSequenceQuery: QueryParam[List[String]], automoderationOnfailurestopQuery: QueryParam[Boolean]): Task[ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo] = jsonOf[ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.moderation.impl.AutoModerationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("automoderationSequence", Some(automoderation.sequenceQuery.toParamString(automoderation.sequence))), ("automoderationOnfailurestop", Some(automoderation.onfailurestopQuery.toParamString(automoderation.onfailurestop))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseModerationImplSentimentProcess(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], watchwordsPositive: List[String], watchwordsNegative: List[String], watchwordsPath: String, sentimentPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], watchwordsPositiveQuery: QueryParam[List[String]], watchwordsNegativeQuery: QueryParam[List[String]], watchwordsPathQuery: QueryParam[String], sentimentPathQuery: QueryParam[String]): Task[ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo] = jsonOf[ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.moderation.impl.SentimentProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("watchwordsPositive", Some(watchwords.positiveQuery.toParamString(watchwords.positive))), ("watchwordsNegative", Some(watchwords.negativeQuery.toParamString(watchwords.negative))), ("watchwordsPath", Some(watchwords.pathQuery.toParamString(watchwords.path))), ("sentimentPath", Some(sentiment.pathQuery.toParamString(sentiment.path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackli(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultAttachmentTypeBlacklist: List[String], baselineAttachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultAttachmentTypeBlacklistQuery: QueryParam[List[String]], baselineAttachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo] = jsonOf[ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.security.impl.DefaultAttachmentTypeBlacklistService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultAttachmentTypeBlacklist", Some(default.attachment.type.blacklistQuery.toParamString(default.attachment.type.blacklist))), ("baselineAttachmentTypeBlacklist", Some(baseline.attachment.type.blacklistQuery.toParamString(baseline.attachment.type.blacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], parameterWhitelist: List[String], parameterWhitelistPrefixes: List[String], binaryParameterWhitelist: List[String], modifierWhitelist: List[String], operationWhitelist: List[String], operationWhitelistPrefixes: List[String], typehintWhitelist: List[String], resourcetypeWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], parameterWhitelistQuery: QueryParam[List[String]], parameterWhitelistPrefixesQuery: QueryParam[List[String]], binaryParameterWhitelistQuery: QueryParam[List[String]], modifierWhitelistQuery: QueryParam[List[String]], operationWhitelistQuery: QueryParam[List[String]], operationWhitelistPrefixesQuery: QueryParam[List[String]], typehintWhitelistQuery: QueryParam[List[String]], resourcetypeWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo] = jsonOf[ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.ugcbase.security.impl.SaferSlingPostValidatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("parameterWhitelist", Some(parameter.whitelistQuery.toParamString(parameter.whitelist))), ("parameterWhitelistPrefixes", Some(parameter.whitelist.prefixesQuery.toParamString(parameter.whitelist.prefixes))), ("binaryParameterWhitelist", Some(binary.parameter.whitelistQuery.toParamString(binary.parameter.whitelist))), ("modifierWhitelist", Some(modifier.whitelistQuery.toParamString(modifier.whitelist))), ("operationWhitelist", Some(operation.whitelistQuery.toParamString(operation.whitelist))), ("operationWhitelistPrefixes", Some(operation.whitelist.prefixesQuery.toParamString(operation.whitelist.prefixes))), ("typehintWhitelist", Some(typehint.whitelistQuery.toParamString(typehint.whitelist))), ("resourcetypeWhitelist", Some(resourcetype.whitelistQuery.toParamString(resourcetype.whitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletExtensions: String, slingServletPaths: String, slingServletMethods: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletExtensionsQuery: QueryParam[String], slingServletPathsQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[String]): Task[ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo] = jsonOf[ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.user.endpoints.impl.UsersGroupFromPublishServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletExtensions", Some(sling.servlet.extensionsQuery.toParamString(sling.servlet.extensions))), ("slingServletPaths", Some(sling.servlet.pathsQuery.toParamString(sling.servlet.paths))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo](req)

    } yield resp
  }
  
  def comAdobeCqSocialUserImplTransportHttpToPublisher(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enable: Boolean, agentConfiguration: List[String], contextPath: String, disabledCipherSuites: List[String], enabledCipherSuites: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableQuery: QueryParam[Boolean], agentConfigurationQuery: QueryParam[List[String]], contextPathQuery: QueryParam[String], disabledCipherSuitesQuery: QueryParam[List[String]], enabledCipherSuitesQuery: QueryParam[List[String]]): Task[ComAdobeCqSocialUserImplTransportHttpToPublisherInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqSocialUserImplTransportHttpToPublisherInfo] = jsonOf[ComAdobeCqSocialUserImplTransportHttpToPublisherInfo]

    val path = "/system/console/configMgr/com.adobe.cq.social.user.impl.transport.HttpToPublisher"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enable", Some(enableQuery.toParamString(enable))), ("agentConfiguration", Some(agent.configurationQuery.toParamString(agent.configuration))), ("contextPath", Some(context.pathQuery.toParamString(context.path))), ("disabledCipherSuites", Some(disabled.cipher.suitesQuery.toParamString(disabled.cipher.suites))), ("enabledCipherSuites", Some(enabled.cipher.suitesQuery.toParamString(enabled.cipher.suites))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqSocialUserImplTransportHttpToPublisherInfo](req)

    } yield resp
  }
  
  def comAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFact(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], resourceTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], resourceTypesQuery: QueryParam[List[String]]): Task[ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo] = jsonOf[ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo]

    val path = "/system/console/configMgr/com.adobe.cq.ui.wcm.commons.internal.servlets.rte.RTEFilterServletFactory.amended"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("resourceTypes", Some(resource.typesQuery.toParamString(resource.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo](req)

    } yield resp
  }
  
  def comAdobeCqUpgradesCleanupImplUpgradeContentCleanup(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], deletePathRegexps: List[String], deleteSql2Query: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], deletePathRegexpsQuery: QueryParam[List[String]], deleteSql2QueryQuery: QueryParam[String]): Task[ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo] = jsonOf[ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo]

    val path = "/system/console/configMgr/com.adobe.cq.upgrades.cleanup.impl.UpgradeContentCleanup"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("deletePathRegexps", Some(delete.path.regexpsQuery.toParamString(delete.path.regexps))), ("deleteSql2Query", Some(delete.sql2.queryQuery.toParamString(delete.sql2.query))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo](req)

    } yield resp
  }
  
  def comAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanup(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], deleteNameRegexps: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], deleteNameRegexpsQuery: QueryParam[List[String]]): Task[ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo] = jsonOf[ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo]

    val path = "/system/console/configMgr/com.adobe.cq.upgrades.cleanup.impl.UpgradeInstallFolderCleanup"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("deleteNameRegexps", Some(delete.name.regexpsQuery.toParamString(delete.name.regexps))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], threshold: Integer, jobTopicName: String, emailEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], thresholdQuery: QueryParam[Integer], jobTopicNameQuery: QueryParam[String], emailEnabledQuery: QueryParam[Boolean]): Task[ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo] = jsonOf[ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncDeleteConfigProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("threshold", Some(thresholdQuery.toParamString(threshold))), ("jobTopicName", Some(jobTopicNameQuery.toParamString(jobTopicName))), ("emailEnabled", Some(emailEnabledQuery.toParamString(emailEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTask(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, jobPurgeThreshold: Integer, jobPurgeMaxJobs: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], jobPurgeThresholdQuery: QueryParam[Integer], jobPurgeMaxJobsQuery: QueryParam[Integer]): Task[ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo] = jsonOf[ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncJobCleanUpTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("jobPurgeThreshold", Some(job.purge.thresholdQuery.toParamString(job.purge.threshold))), ("jobPurgeMaxJobs", Some(job.purge.max.jobsQuery.toParamString(job.purge.max.jobs))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], threshold: Integer, jobTopicName: String, emailEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], thresholdQuery: QueryParam[Integer], jobTopicNameQuery: QueryParam[String], emailEnabledQuery: QueryParam[Boolean]): Task[ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo] = jsonOf[ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncMoveConfigProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("threshold", Some(thresholdQuery.toParamString(threshold))), ("jobTopicName", Some(jobTopicNameQuery.toParamString(jobTopicName))), ("emailEnabled", Some(emailEnabledQuery.toParamString(emailEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], threshold: Integer, jobTopicName: String, emailEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], thresholdQuery: QueryParam[Integer], jobTopicNameQuery: QueryParam[String], emailEnabledQuery: QueryParam[Boolean]): Task[ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo] = jsonOf[ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncPageMoveConfigProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("threshold", Some(thresholdQuery.toParamString(threshold))), ("jobTopicName", Some(jobTopicNameQuery.toParamString(jobTopicName))), ("emailEnabled", Some(emailEnabledQuery.toParamString(emailEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmLaunchesImplLaunchesEventHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String, launchesEventhandlerThreadpoolMaxsize: Integer, launchesEventhandlerThreadpoolPriority: String, launchesEventhandlerUpdatelastmodification: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String], launchesEventhandlerThreadpoolMaxsizeQuery: QueryParam[Integer], launchesEventhandlerThreadpoolPriorityQuery: QueryParam[String], launchesEventhandlerUpdatelastmodificationQuery: QueryParam[Boolean]): Task[ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo] = jsonOf[ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.launches.impl.LaunchesEventHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("launchesEventhandlerThreadpoolMaxsize", Some(launches.eventhandler.threadpool.maxsizeQuery.toParamString(launches.eventhandler.threadpool.maxsize))), ("launchesEventhandlerThreadpoolPriority", Some(launches.eventhandler.threadpool.priorityQuery.toParamString(launches.eventhandler.threadpool.priority))), ("launchesEventhandlerUpdatelastmodification", Some(launches.eventhandler.updatelastmodificationQuery.toParamString(launches.eventhandler.updatelastmodification))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmMobileQrcodeServletQRCodeImageGenerator(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmQrcodeServletWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmQrcodeServletWhitelistQuery: QueryParam[List[String]]): Task[ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo] = jsonOf[ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.mobile.qrcode.servlet.QRCodeImageGenerator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmQrcodeServletWhitelist", Some(cq.wcm.qrcode.servlet.whitelistQuery.toParamString(cq.wcm.qrcode.servlet.whitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmStyleInternalComponentStyleInfoCacheImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], size: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], sizeQuery: QueryParam[Integer]): Task[ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo] = jsonOf[ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.style.internal.ComponentStyleInfoCacheImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("size", Some(sizeQuery.toParamString(size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo](req)

    } yield resp
  }
  
  def comAdobeCqWcmTranslationImplTranslationPlatformConfigurationImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], syncTranslationStateSchedulingFormat: String, schedulingRepeatTranslationSchedulingFormat: String, syncTranslationStateLockTimeoutInMinutes: String, exportFormat: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], syncTranslationStateSchedulingFormatQuery: QueryParam[String], schedulingRepeatTranslationSchedulingFormatQuery: QueryParam[String], syncTranslationStateLockTimeoutInMinutesQuery: QueryParam[String], exportFormatQuery: QueryParam[String]): Task[ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo] = jsonOf[ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo]

    val path = "/system/console/configMgr/com.adobe.cq.wcm.translation.impl.TranslationPlatformConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("syncTranslationStateSchedulingFormat", Some(syncTranslationState.schedulingFormatQuery.toParamString(syncTranslationState.schedulingFormat))), ("schedulingRepeatTranslationSchedulingFormat", Some(schedulingRepeatTranslation.schedulingFormatQuery.toParamString(schedulingRepeatTranslation.schedulingFormat))), ("syncTranslationStateLockTimeoutInMinutes", Some(syncTranslationState.lockTimeoutInMinutesQuery.toParamString(syncTranslationState.lockTimeoutInMinutes))), ("exportFormat", Some(export.formatQuery.toParamString(export.format))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo](req)

    } yield resp
  }
  
  def comAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], portalOutboxes: List[String], draftDataService: String, draftMetadataService: String, submitDataService: String, submitMetadataService: String, pendingSignDataService: String, pendingSignMetadataService: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], portalOutboxesQuery: QueryParam[List[String]], draftDataServiceQuery: QueryParam[String], draftMetadataServiceQuery: QueryParam[String], submitDataServiceQuery: QueryParam[String], submitMetadataServiceQuery: QueryParam[String], pendingSignDataServiceQuery: QueryParam[String], pendingSignMetadataServiceQuery: QueryParam[String]): Task[ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo] = jsonOf[ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo]

    val path = "/system/console/configMgr/com.adobe.fd.fp.config.FormsPortalDraftsandSubmissionConfigService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("portalOutboxes", Some(portal.outboxesQuery.toParamString(portal.outboxes))), ("draftDataService", Some(draft.data.serviceQuery.toParamString(draft.data.service))), ("draftMetadataService", Some(draft.metadata.serviceQuery.toParamString(draft.metadata.service))), ("submitDataService", Some(submit.data.serviceQuery.toParamString(submit.data.service))), ("submitMetadataService", Some(submit.metadata.serviceQuery.toParamString(submit.metadata.service))), ("pendingSignDataService", Some(pendingSign.data.serviceQuery.toParamString(pendingSign.data.service))), ("pendingSignMetadataService", Some(pendingSign.metadata.serviceQuery.toParamString(pendingSign.metadata.service))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo](req)

    } yield resp
  }
  
  def comAdobeFdFpConfigFormsPortalSchedulerService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], formportalInterval: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], formportalIntervalQuery: QueryParam[String]): Task[ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo] = jsonOf[ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo]

    val path = "/system/console/configMgr/com.adobe.fd.fp.config.FormsPortalSchedulerService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("formportalInterval", Some(formportal.intervalQuery.toParamString(formportal.interval))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo](req)

    } yield resp
  }
  
  def comAdobeFormsCommonServiceImplDefaultDataProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], alloweddataFileLocations: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], alloweddataFileLocationsQuery: QueryParam[List[String]]): Task[ComAdobeFormsCommonServiceImplDefaultDataProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeFormsCommonServiceImplDefaultDataProviderInfo] = jsonOf[ComAdobeFormsCommonServiceImplDefaultDataProviderInfo]

    val path = "/system/console/configMgr/com.adobe.forms.common.service.impl.DefaultDataProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("alloweddataFileLocations", Some(alloweddataFileLocationsQuery.toParamString(alloweddataFileLocations))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeFormsCommonServiceImplDefaultDataProviderInfo](req)

    } yield resp
  }
  
  def comAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImp(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], tempStorageConfig: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], tempStorageConfigQuery: QueryParam[String]): Task[ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo] = jsonOf[ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo]

    val path = "/system/console/configMgr/com.adobe.forms.common.service.impl.FormsCommonConfigurationServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("tempStorageConfig", Some(tempStorageConfigQuery.toParamString(tempStorageConfig))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo](req)

    } yield resp
  }
  
  def comAdobeFormsCommonServletTempCleanUpTask(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, durationForTemporaryStorage: String, durationForAnonymousStorage: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], durationForTemporaryStorageQuery: QueryParam[String], durationForAnonymousStorageQuery: QueryParam[String]): Task[ComAdobeFormsCommonServletTempCleanUpTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeFormsCommonServletTempCleanUpTaskInfo] = jsonOf[ComAdobeFormsCommonServletTempCleanUpTaskInfo]

    val path = "/system/console/configMgr/com.adobe.forms.common.servlet.TempCleanUpTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("durationForTemporaryStorage", Some(Duration for Temporary StorageQuery.toParamString(Duration for Temporary Storage))), ("durationForAnonymousStorage", Some(Duration for Anonymous StorageQuery.toParamString(Duration for Anonymous Storage))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeFormsCommonServletTempCleanUpTaskInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAcpPlatformPlatformServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], queryLimit: Integer, fileTypeExtensionMap: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], queryLimitQuery: QueryParam[Integer], fileTypeExtensionMapQuery: QueryParam[List[String]]): Task[ComAdobeGraniteAcpPlatformPlatformServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAcpPlatformPlatformServletInfo] = jsonOf[ComAdobeGraniteAcpPlatformPlatformServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.acp.platform.PlatformServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("queryLimit", Some(query.limitQuery.toParamString(query.limit))), ("fileTypeExtensionMap", Some(file.type.extension.mapQuery.toParamString(file.type.extension.map))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAcpPlatformPlatformServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteActivitystreamsImplActivityManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], aggregateRelationships: List[String], aggregateDescendVirtual: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], aggregateRelationshipsQuery: QueryParam[List[String]], aggregateDescendVirtualQuery: QueryParam[Boolean]): Task[ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo] = jsonOf[ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.activitystreams.impl.ActivityManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("aggregateRelationships", Some(aggregate.relationshipsQuery.toParamString(aggregate.relationships))), ("aggregateDescendVirtual", Some(aggregate.descend.virtualQuery.toParamString(aggregate.descend.virtual))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAnalyzerBaseSystemStatusServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], disabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], disabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo] = jsonOf[ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.analyzer.base.SystemStatusServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("disabled", Some(disabledQuery.toParamString(disabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], disabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], disabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo] = jsonOf[ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.analyzer.scripts.compile.AllScriptsCompilerServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("disabled", Some(disabledQuery.toParamString(disabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteApicontrollerFilterResolverHookFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeCqCdnCdnRewriter: String, comAdobeCqCloudConfigComponents: String, comAdobeCqCloudConfigCore: String, comAdobeCqCloudConfigUi: String, comAdobeCqComAdobeCqEditor: String, comAdobeCqComAdobeCqProjectsCore: String, comAdobeCqComAdobeCqProjectsWcmCore: String, comAdobeCqComAdobeCqUiCommons: String, comAdobeCqComAdobeCqWcmStyle: String, comAdobeCqCqActivitymapIntegration: String, comAdobeCqCqContexthubCommons: String, comAdobeCqCqDtm: String, comAdobeCqCqHealthcheck: String, comAdobeCqCqMultisiteTargeting: String, comAdobeCqCqPreUpgradeCleanup: String, comAdobeCqCqProductInfoProvider: String, comAdobeCqCqRestSites: String, comAdobeCqCqSecurityHc: String, comAdobeCqDamCqDamSvgHandler: String, comAdobeCqDamCqScene7Imaging: String, comAdobeCqDtmReactorCore: String, comAdobeCqDtmReactorUi: String, comAdobeCqExpJspelResolver: String, comAdobeCqInboxCqInbox: String, comAdobeCqJsonSchemaParser: String, comAdobeCqMediaCqMediaPublishingDpsFpCore: String, comAdobeCqMobileCqMobileCaas: String, comAdobeCqMobileCqMobileIndexBuilder: String, comAdobeCqMobileCqMobilePhonegapBuild: String, comAdobeCqMyspell: String, comAdobeCqSampleWeRetailCore: String, comAdobeCqScreensComAdobeCqScreensDcc: String, comAdobeCqScreensComAdobeCqScreensMqCore: String, comAdobeCqSocialCqSocialAsProvider: String, comAdobeCqSocialCqSocialBadgingBasicImpl: String, comAdobeCqSocialCqSocialBadgingImpl: String, comAdobeCqSocialCqSocialCalendarImpl: String, comAdobeCqSocialCqSocialContentFragmentsImpl: String, comAdobeCqSocialCqSocialEnablementImpl: String, comAdobeCqSocialCqSocialGraphImpl: String, comAdobeCqSocialCqSocialIdeationImpl: String, comAdobeCqSocialCqSocialJcrProvider: String, comAdobeCqSocialCqSocialMembersImpl: String, comAdobeCqSocialCqSocialMsProvider: String, comAdobeCqSocialCqSocialNotificationsChannelsWeb: String, comAdobeCqSocialCqSocialNotificationsImpl: String, comAdobeCqSocialCqSocialRdbProvider: String, comAdobeCqSocialCqSocialScfImpl: String, comAdobeCqSocialCqSocialScoringBasicImpl: String, comAdobeCqSocialCqSocialScoringImpl: String, comAdobeCqSocialCqSocialServiceusersImpl: String, comAdobeCqSocialCqSocialSrpImpl: String, comAdobeCqSocialCqSocialUgcbaseImpl: String, comAdobeDamCqDamCfmImpl: String, comAdobeFormsFoundationFormsFoundationBase: String, comAdobeGraniteApicontroller: String, comAdobeGraniteAssetCore: String, comAdobeGraniteAuthSso: String, comAdobeGraniteBundlesHcImpl: String, comAdobeGraniteCompatRouter: String, comAdobeGraniteConf: String, comAdobeGraniteConfUiCore: String, comAdobeGraniteCors: String, comAdobeGraniteCrxExplorer: String, comAdobeGraniteCrxdeLite: String, comAdobeGraniteCryptoConfig: String, comAdobeGraniteCryptoExtension: String, comAdobeGraniteCryptoFile: String, comAdobeGraniteCryptoJcr: String, comAdobeGraniteCsrf: String, comAdobeGraniteDistributionCore: String, comAdobeGraniteDropwizardMetrics: String, comAdobeGraniteFragsImpl: String, comAdobeGraniteGibson: String, comAdobeGraniteInfocollector: String, comAdobeGraniteInstallerFactoryPackages: String, comAdobeGraniteJettySsl: String, comAdobeGraniteJobsAsync: String, comAdobeGraniteMaintenanceOak: String, comAdobeGraniteMonitoringCore: String, comAdobeGraniteQueries: String, comAdobeGraniteReplicationHcImpl: String, comAdobeGraniteRepositoryChecker: String, comAdobeGraniteRepositoryHcImpl: String, comAdobeGraniteRestAssets: String, comAdobeGraniteSecurityUi: String, comAdobeGraniteStartup: String, comAdobeGraniteTagsoup: String, comAdobeGraniteTaskmanagementCore: String, comAdobeGraniteTaskmanagementWorkflow: String, comAdobeGraniteUiClientlibsCompilerLess: String, comAdobeGraniteUiClientlibsProcessorGcc: String, comAdobeGraniteWebconsolePlugins: String, comAdobeGraniteWorkflowConsole: String, comAdobeXmpWorkerFilesNativeFragmentLinux: String, comAdobeXmpWorkerFilesNativeFragmentMacosx: String, comAdobeXmpWorkerFilesNativeFragmentWin: String, comDayCommonsOsgiWrapperSimpleJndi: String, comDayCqCqAuthhandler: String, comDayCqCqCompatConfigupdate: String, comDayCqCqLicensebranding: String, comDayCqCqNotifcationImpl: String, comDayCqCqReplicationAudit: String, comDayCqCqSearchExt: String, comDayCqDamCqDamAnnotationPrint: String, comDayCqDamCqDamAssetUsage: String, comDayCqDamCqDamS7dam: String, comDayCqDamCqDamSimilaritysearch: String, comDayCqDamDamWebdavSupport: String, comDayCqPreUpgradeTasks: String, comDayCqReplicationExtensions: String, comDayCqWcmCqMsmCore: String, comDayCqWcmCqWcmTranslation: String, dayCommonsJrawio: String, orgApacheAriesJmxWhiteboard: String, orgApacheFelixHttpSslfilter: String, orgApacheFelixOrgApacheFelixThreaddump: String, orgApacheFelixWebconsolePluginsDs: String, orgApacheFelixWebconsolePluginsEvent: String, orgApacheFelixWebconsolePluginsMemoryusage: String, orgApacheFelixWebconsolePluginsPackageadmin: String, orgApacheJackrabbitOakAuthLdap: String, orgApacheJackrabbitOakSegmentTar: String, orgApacheJackrabbitOakSolrOsgi: String, orgApacheSlingBundleresourceImpl: String, orgApacheSlingCommonsFsclassloader: String, orgApacheSlingCommonsLogWebconsole: String, orgApacheSlingDatasource: String, orgApacheSlingDiscoveryBase: String, orgApacheSlingDiscoveryOak: String, orgApacheSlingDiscoverySupport: String, orgApacheSlingDistributionApi: String, orgApacheSlingDistributionCore: String, orgApacheSlingExtensionsWebconsolesecurityprovider: String, orgApacheSlingHcWebconsole: String, orgApacheSlingInstallerConsole: String, orgApacheSlingInstallerProviderFile: String, orgApacheSlingInstallerProviderJcr: String, orgApacheSlingJcrDavex: String, orgApacheSlingJcrResourcesecurity: String, orgApacheSlingJmxProvider: String, orgApacheSlingLaunchpadInstaller: String, orgApacheSlingModelsImpl: String, orgApacheSlingRepoinitParser: String, orgApacheSlingResourceInventory: String, orgApacheSlingResourceresolver: String, orgApacheSlingScriptingJavascript: String, orgApacheSlingScriptingJst: String, orgApacheSlingScriptingSightlyJsProvider: String, orgApacheSlingScriptingSightlyModelsProvider: String, orgApacheSlingSecurity: String, orgApacheSlingServletsCompat: String, orgApacheSlingServletsGet: String, orgApacheSlingStartupfilterDisabler: String, orgApacheSlingTracer: String, weRetailClientAppCore: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeCqCdnCdnRewriterQuery: QueryParam[String], comAdobeCqCloudConfigComponentsQuery: QueryParam[String], comAdobeCqCloudConfigCoreQuery: QueryParam[String], comAdobeCqCloudConfigUiQuery: QueryParam[String], comAdobeCqComAdobeCqEditorQuery: QueryParam[String], comAdobeCqComAdobeCqProjectsCoreQuery: QueryParam[String], comAdobeCqComAdobeCqProjectsWcmCoreQuery: QueryParam[String], comAdobeCqComAdobeCqUiCommonsQuery: QueryParam[String], comAdobeCqComAdobeCqWcmStyleQuery: QueryParam[String], comAdobeCqCqActivitymapIntegrationQuery: QueryParam[String], comAdobeCqCqContexthubCommonsQuery: QueryParam[String], comAdobeCqCqDtmQuery: QueryParam[String], comAdobeCqCqHealthcheckQuery: QueryParam[String], comAdobeCqCqMultisiteTargetingQuery: QueryParam[String], comAdobeCqCqPreUpgradeCleanupQuery: QueryParam[String], comAdobeCqCqProductInfoProviderQuery: QueryParam[String], comAdobeCqCqRestSitesQuery: QueryParam[String], comAdobeCqCqSecurityHcQuery: QueryParam[String], comAdobeCqDamCqDamSvgHandlerQuery: QueryParam[String], comAdobeCqDamCqScene7ImagingQuery: QueryParam[String], comAdobeCqDtmReactorCoreQuery: QueryParam[String], comAdobeCqDtmReactorUiQuery: QueryParam[String], comAdobeCqExpJspelResolverQuery: QueryParam[String], comAdobeCqInboxCqInboxQuery: QueryParam[String], comAdobeCqJsonSchemaParserQuery: QueryParam[String], comAdobeCqMediaCqMediaPublishingDpsFpCoreQuery: QueryParam[String], comAdobeCqMobileCqMobileCaasQuery: QueryParam[String], comAdobeCqMobileCqMobileIndexBuilderQuery: QueryParam[String], comAdobeCqMobileCqMobilePhonegapBuildQuery: QueryParam[String], comAdobeCqMyspellQuery: QueryParam[String], comAdobeCqSampleWeRetailCoreQuery: QueryParam[String], comAdobeCqScreensComAdobeCqScreensDccQuery: QueryParam[String], comAdobeCqScreensComAdobeCqScreensMqCoreQuery: QueryParam[String], comAdobeCqSocialCqSocialAsProviderQuery: QueryParam[String], comAdobeCqSocialCqSocialBadgingBasicImplQuery: QueryParam[String], comAdobeCqSocialCqSocialBadgingImplQuery: QueryParam[String], comAdobeCqSocialCqSocialCalendarImplQuery: QueryParam[String], comAdobeCqSocialCqSocialContentFragmentsImplQuery: QueryParam[String], comAdobeCqSocialCqSocialEnablementImplQuery: QueryParam[String], comAdobeCqSocialCqSocialGraphImplQuery: QueryParam[String], comAdobeCqSocialCqSocialIdeationImplQuery: QueryParam[String], comAdobeCqSocialCqSocialJcrProviderQuery: QueryParam[String], comAdobeCqSocialCqSocialMembersImplQuery: QueryParam[String], comAdobeCqSocialCqSocialMsProviderQuery: QueryParam[String], comAdobeCqSocialCqSocialNotificationsChannelsWebQuery: QueryParam[String], comAdobeCqSocialCqSocialNotificationsImplQuery: QueryParam[String], comAdobeCqSocialCqSocialRdbProviderQuery: QueryParam[String], comAdobeCqSocialCqSocialScfImplQuery: QueryParam[String], comAdobeCqSocialCqSocialScoringBasicImplQuery: QueryParam[String], comAdobeCqSocialCqSocialScoringImplQuery: QueryParam[String], comAdobeCqSocialCqSocialServiceusersImplQuery: QueryParam[String], comAdobeCqSocialCqSocialSrpImplQuery: QueryParam[String], comAdobeCqSocialCqSocialUgcbaseImplQuery: QueryParam[String], comAdobeDamCqDamCfmImplQuery: QueryParam[String], comAdobeFormsFoundationFormsFoundationBaseQuery: QueryParam[String], comAdobeGraniteApicontrollerQuery: QueryParam[String], comAdobeGraniteAssetCoreQuery: QueryParam[String], comAdobeGraniteAuthSsoQuery: QueryParam[String], comAdobeGraniteBundlesHcImplQuery: QueryParam[String], comAdobeGraniteCompatRouterQuery: QueryParam[String], comAdobeGraniteConfQuery: QueryParam[String], comAdobeGraniteConfUiCoreQuery: QueryParam[String], comAdobeGraniteCorsQuery: QueryParam[String], comAdobeGraniteCrxExplorerQuery: QueryParam[String], comAdobeGraniteCrxdeLiteQuery: QueryParam[String], comAdobeGraniteCryptoConfigQuery: QueryParam[String], comAdobeGraniteCryptoExtensionQuery: QueryParam[String], comAdobeGraniteCryptoFileQuery: QueryParam[String], comAdobeGraniteCryptoJcrQuery: QueryParam[String], comAdobeGraniteCsrfQuery: QueryParam[String], comAdobeGraniteDistributionCoreQuery: QueryParam[String], comAdobeGraniteDropwizardMetricsQuery: QueryParam[String], comAdobeGraniteFragsImplQuery: QueryParam[String], comAdobeGraniteGibsonQuery: QueryParam[String], comAdobeGraniteInfocollectorQuery: QueryParam[String], comAdobeGraniteInstallerFactoryPackagesQuery: QueryParam[String], comAdobeGraniteJettySslQuery: QueryParam[String], comAdobeGraniteJobsAsyncQuery: QueryParam[String], comAdobeGraniteMaintenanceOakQuery: QueryParam[String], comAdobeGraniteMonitoringCoreQuery: QueryParam[String], comAdobeGraniteQueriesQuery: QueryParam[String], comAdobeGraniteReplicationHcImplQuery: QueryParam[String], comAdobeGraniteRepositoryCheckerQuery: QueryParam[String], comAdobeGraniteRepositoryHcImplQuery: QueryParam[String], comAdobeGraniteRestAssetsQuery: QueryParam[String], comAdobeGraniteSecurityUiQuery: QueryParam[String], comAdobeGraniteStartupQuery: QueryParam[String], comAdobeGraniteTagsoupQuery: QueryParam[String], comAdobeGraniteTaskmanagementCoreQuery: QueryParam[String], comAdobeGraniteTaskmanagementWorkflowQuery: QueryParam[String], comAdobeGraniteUiClientlibsCompilerLessQuery: QueryParam[String], comAdobeGraniteUiClientlibsProcessorGccQuery: QueryParam[String], comAdobeGraniteWebconsolePluginsQuery: QueryParam[String], comAdobeGraniteWorkflowConsoleQuery: QueryParam[String], comAdobeXmpWorkerFilesNativeFragmentLinuxQuery: QueryParam[String], comAdobeXmpWorkerFilesNativeFragmentMacosxQuery: QueryParam[String], comAdobeXmpWorkerFilesNativeFragmentWinQuery: QueryParam[String], comDayCommonsOsgiWrapperSimpleJndiQuery: QueryParam[String], comDayCqCqAuthhandlerQuery: QueryParam[String], comDayCqCqCompatConfigupdateQuery: QueryParam[String], comDayCqCqLicensebrandingQuery: QueryParam[String], comDayCqCqNotifcationImplQuery: QueryParam[String], comDayCqCqReplicationAuditQuery: QueryParam[String], comDayCqCqSearchExtQuery: QueryParam[String], comDayCqDamCqDamAnnotationPrintQuery: QueryParam[String], comDayCqDamCqDamAssetUsageQuery: QueryParam[String], comDayCqDamCqDamS7damQuery: QueryParam[String], comDayCqDamCqDamSimilaritysearchQuery: QueryParam[String], comDayCqDamDamWebdavSupportQuery: QueryParam[String], comDayCqPreUpgradeTasksQuery: QueryParam[String], comDayCqReplicationExtensionsQuery: QueryParam[String], comDayCqWcmCqMsmCoreQuery: QueryParam[String], comDayCqWcmCqWcmTranslationQuery: QueryParam[String], dayCommonsJrawioQuery: QueryParam[String], orgApacheAriesJmxWhiteboardQuery: QueryParam[String], orgApacheFelixHttpSslfilterQuery: QueryParam[String], orgApacheFelixOrgApacheFelixThreaddumpQuery: QueryParam[String], orgApacheFelixWebconsolePluginsDsQuery: QueryParam[String], orgApacheFelixWebconsolePluginsEventQuery: QueryParam[String], orgApacheFelixWebconsolePluginsMemoryusageQuery: QueryParam[String], orgApacheFelixWebconsolePluginsPackageadminQuery: QueryParam[String], orgApacheJackrabbitOakAuthLdapQuery: QueryParam[String], orgApacheJackrabbitOakSegmentTarQuery: QueryParam[String], orgApacheJackrabbitOakSolrOsgiQuery: QueryParam[String], orgApacheSlingBundleresourceImplQuery: QueryParam[String], orgApacheSlingCommonsFsclassloaderQuery: QueryParam[String], orgApacheSlingCommonsLogWebconsoleQuery: QueryParam[String], orgApacheSlingDatasourceQuery: QueryParam[String], orgApacheSlingDiscoveryBaseQuery: QueryParam[String], orgApacheSlingDiscoveryOakQuery: QueryParam[String], orgApacheSlingDiscoverySupportQuery: QueryParam[String], orgApacheSlingDistributionApiQuery: QueryParam[String], orgApacheSlingDistributionCoreQuery: QueryParam[String], orgApacheSlingExtensionsWebconsolesecurityproviderQuery: QueryParam[String], orgApacheSlingHcWebconsoleQuery: QueryParam[String], orgApacheSlingInstallerConsoleQuery: QueryParam[String], orgApacheSlingInstallerProviderFileQuery: QueryParam[String], orgApacheSlingInstallerProviderJcrQuery: QueryParam[String], orgApacheSlingJcrDavexQuery: QueryParam[String], orgApacheSlingJcrResourcesecurityQuery: QueryParam[String], orgApacheSlingJmxProviderQuery: QueryParam[String], orgApacheSlingLaunchpadInstallerQuery: QueryParam[String], orgApacheSlingModelsImplQuery: QueryParam[String], orgApacheSlingRepoinitParserQuery: QueryParam[String], orgApacheSlingResourceInventoryQuery: QueryParam[String], orgApacheSlingResourceresolverQuery: QueryParam[String], orgApacheSlingScriptingJavascriptQuery: QueryParam[String], orgApacheSlingScriptingJstQuery: QueryParam[String], orgApacheSlingScriptingSightlyJsProviderQuery: QueryParam[String], orgApacheSlingScriptingSightlyModelsProviderQuery: QueryParam[String], orgApacheSlingSecurityQuery: QueryParam[String], orgApacheSlingServletsCompatQuery: QueryParam[String], orgApacheSlingServletsGetQuery: QueryParam[String], orgApacheSlingStartupfilterDisablerQuery: QueryParam[String], orgApacheSlingTracerQuery: QueryParam[String], weRetailClientAppCoreQuery: QueryParam[String]): Task[ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo] = jsonOf[ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo]

    val path = "/system/console/configMgr/com.adobe.granite.apicontroller.FilterResolverHookFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeCqCdnCdnRewriter", Some(com.adobe.cq.cdn.cdn-rewriterQuery.toParamString(com.adobe.cq.cdn.cdn-rewriter))), ("comAdobeCqCloudConfigComponents", Some(com.adobe.cq.cloud-config.componentsQuery.toParamString(com.adobe.cq.cloud-config.components))), ("comAdobeCqCloudConfigCore", Some(com.adobe.cq.cloud-config.coreQuery.toParamString(com.adobe.cq.cloud-config.core))), ("comAdobeCqCloudConfigUi", Some(com.adobe.cq.cloud-config.uiQuery.toParamString(com.adobe.cq.cloud-config.ui))), ("comAdobeCqComAdobeCqEditor", Some(com.adobe.cq.com.adobe.cq.editorQuery.toParamString(com.adobe.cq.com.adobe.cq.editor))), ("comAdobeCqComAdobeCqProjectsCore", Some(com.adobe.cq.com.adobe.cq.projects.coreQuery.toParamString(com.adobe.cq.com.adobe.cq.projects.core))), ("comAdobeCqComAdobeCqProjectsWcmCore", Some(com.adobe.cq.com.adobe.cq.projects.wcm.coreQuery.toParamString(com.adobe.cq.com.adobe.cq.projects.wcm.core))), ("comAdobeCqComAdobeCqUiCommons", Some(com.adobe.cq.com.adobe.cq.ui.commonsQuery.toParamString(com.adobe.cq.com.adobe.cq.ui.commons))), ("comAdobeCqComAdobeCqWcmStyle", Some(com.adobe.cq.com.adobe.cq.wcm.styleQuery.toParamString(com.adobe.cq.com.adobe.cq.wcm.style))), ("comAdobeCqCqActivitymapIntegration", Some(com.adobe.cq.cq-activitymap-integrationQuery.toParamString(com.adobe.cq.cq-activitymap-integration))), ("comAdobeCqCqContexthubCommons", Some(com.adobe.cq.cq-contexthub-commonsQuery.toParamString(com.adobe.cq.cq-contexthub-commons))), ("comAdobeCqCqDtm", Some(com.adobe.cq.cq-dtmQuery.toParamString(com.adobe.cq.cq-dtm))), ("comAdobeCqCqHealthcheck", Some(com.adobe.cq.cq-healthcheckQuery.toParamString(com.adobe.cq.cq-healthcheck))), ("comAdobeCqCqMultisiteTargeting", Some(com.adobe.cq.cq-multisite-targetingQuery.toParamString(com.adobe.cq.cq-multisite-targeting))), ("comAdobeCqCqPreUpgradeCleanup", Some(com.adobe.cq.cq-pre-upgrade-cleanupQuery.toParamString(com.adobe.cq.cq-pre-upgrade-cleanup))), ("comAdobeCqCqProductInfoProvider", Some(com.adobe.cq.cq-product-info-providerQuery.toParamString(com.adobe.cq.cq-product-info-provider))), ("comAdobeCqCqRestSites", Some(com.adobe.cq.cq-rest-sitesQuery.toParamString(com.adobe.cq.cq-rest-sites))), ("comAdobeCqCqSecurityHc", Some(com.adobe.cq.cq-security-hcQuery.toParamString(com.adobe.cq.cq-security-hc))), ("comAdobeCqDamCqDamSvgHandler", Some(com.adobe.cq.dam.cq-dam-svg-handlerQuery.toParamString(com.adobe.cq.dam.cq-dam-svg-handler))), ("comAdobeCqDamCqScene7Imaging", Some(com.adobe.cq.dam.cq-scene7-imagingQuery.toParamString(com.adobe.cq.dam.cq-scene7-imaging))), ("comAdobeCqDtmReactorCore", Some(com.adobe.cq.dtm-reactor.coreQuery.toParamString(com.adobe.cq.dtm-reactor.core))), ("comAdobeCqDtmReactorUi", Some(com.adobe.cq.dtm-reactor.uiQuery.toParamString(com.adobe.cq.dtm-reactor.ui))), ("comAdobeCqExpJspelResolver", Some(com.adobe.cq.exp-jspel-resolverQuery.toParamString(com.adobe.cq.exp-jspel-resolver))), ("comAdobeCqInboxCqInbox", Some(com.adobe.cq.inbox.cq-inboxQuery.toParamString(com.adobe.cq.inbox.cq-inbox))), ("comAdobeCqJsonSchemaParser", Some(com.adobe.cq.json-schema-parserQuery.toParamString(com.adobe.cq.json-schema-parser))), ("comAdobeCqMediaCqMediaPublishingDpsFpCore", Some(com.adobe.cq.media.cq-media-publishing-dps-fp-coreQuery.toParamString(com.adobe.cq.media.cq-media-publishing-dps-fp-core))), ("comAdobeCqMobileCqMobileCaas", Some(com.adobe.cq.mobile.cq-mobile-caasQuery.toParamString(com.adobe.cq.mobile.cq-mobile-caas))), ("comAdobeCqMobileCqMobileIndexBuilder", Some(com.adobe.cq.mobile.cq-mobile-index-builderQuery.toParamString(com.adobe.cq.mobile.cq-mobile-index-builder))), ("comAdobeCqMobileCqMobilePhonegapBuild", Some(com.adobe.cq.mobile.cq-mobile-phonegap-buildQuery.toParamString(com.adobe.cq.mobile.cq-mobile-phonegap-build))), ("comAdobeCqMyspell", Some(com.adobe.cq.myspellQuery.toParamString(com.adobe.cq.myspell))), ("comAdobeCqSampleWeRetailCore", Some(com.adobe.cq.sample.we.retail.coreQuery.toParamString(com.adobe.cq.sample.we.retail.core))), ("comAdobeCqScreensComAdobeCqScreensDcc", Some(com.adobe.cq.screens.com.adobe.cq.screens.dccQuery.toParamString(com.adobe.cq.screens.com.adobe.cq.screens.dcc))), ("comAdobeCqScreensComAdobeCqScreensMqCore", Some(com.adobe.cq.screens.com.adobe.cq.screens.mq.coreQuery.toParamString(com.adobe.cq.screens.com.adobe.cq.screens.mq.core))), ("comAdobeCqSocialCqSocialAsProvider", Some(com.adobe.cq.social.cq-social-as-providerQuery.toParamString(com.adobe.cq.social.cq-social-as-provider))), ("comAdobeCqSocialCqSocialBadgingBasicImpl", Some(com.adobe.cq.social.cq-social-badging-basic-implQuery.toParamString(com.adobe.cq.social.cq-social-badging-basic-impl))), ("comAdobeCqSocialCqSocialBadgingImpl", Some(com.adobe.cq.social.cq-social-badging-implQuery.toParamString(com.adobe.cq.social.cq-social-badging-impl))), ("comAdobeCqSocialCqSocialCalendarImpl", Some(com.adobe.cq.social.cq-social-calendar-implQuery.toParamString(com.adobe.cq.social.cq-social-calendar-impl))), ("comAdobeCqSocialCqSocialContentFragmentsImpl", Some(com.adobe.cq.social.cq-social-content-fragments-implQuery.toParamString(com.adobe.cq.social.cq-social-content-fragments-impl))), ("comAdobeCqSocialCqSocialEnablementImpl", Some(com.adobe.cq.social.cq-social-enablement-implQuery.toParamString(com.adobe.cq.social.cq-social-enablement-impl))), ("comAdobeCqSocialCqSocialGraphImpl", Some(com.adobe.cq.social.cq-social-graph-implQuery.toParamString(com.adobe.cq.social.cq-social-graph-impl))), ("comAdobeCqSocialCqSocialIdeationImpl", Some(com.adobe.cq.social.cq-social-ideation-implQuery.toParamString(com.adobe.cq.social.cq-social-ideation-impl))), ("comAdobeCqSocialCqSocialJcrProvider", Some(com.adobe.cq.social.cq-social-jcr-providerQuery.toParamString(com.adobe.cq.social.cq-social-jcr-provider))), ("comAdobeCqSocialCqSocialMembersImpl", Some(com.adobe.cq.social.cq-social-members-implQuery.toParamString(com.adobe.cq.social.cq-social-members-impl))), ("comAdobeCqSocialCqSocialMsProvider", Some(com.adobe.cq.social.cq-social-ms-providerQuery.toParamString(com.adobe.cq.social.cq-social-ms-provider))), ("comAdobeCqSocialCqSocialNotificationsChannelsWeb", Some(com.adobe.cq.social.cq-social-notifications-channels-webQuery.toParamString(com.adobe.cq.social.cq-social-notifications-channels-web))), ("comAdobeCqSocialCqSocialNotificationsImpl", Some(com.adobe.cq.social.cq-social-notifications-implQuery.toParamString(com.adobe.cq.social.cq-social-notifications-impl))), ("comAdobeCqSocialCqSocialRdbProvider", Some(com.adobe.cq.social.cq-social-rdb-providerQuery.toParamString(com.adobe.cq.social.cq-social-rdb-provider))), ("comAdobeCqSocialCqSocialScfImpl", Some(com.adobe.cq.social.cq-social-scf-implQuery.toParamString(com.adobe.cq.social.cq-social-scf-impl))), ("comAdobeCqSocialCqSocialScoringBasicImpl", Some(com.adobe.cq.social.cq-social-scoring-basic-implQuery.toParamString(com.adobe.cq.social.cq-social-scoring-basic-impl))), ("comAdobeCqSocialCqSocialScoringImpl", Some(com.adobe.cq.social.cq-social-scoring-implQuery.toParamString(com.adobe.cq.social.cq-social-scoring-impl))), ("comAdobeCqSocialCqSocialServiceusersImpl", Some(com.adobe.cq.social.cq-social-serviceusers-implQuery.toParamString(com.adobe.cq.social.cq-social-serviceusers-impl))), ("comAdobeCqSocialCqSocialSrpImpl", Some(com.adobe.cq.social.cq-social-srp-implQuery.toParamString(com.adobe.cq.social.cq-social-srp-impl))), ("comAdobeCqSocialCqSocialUgcbaseImpl", Some(com.adobe.cq.social.cq-social-ugcbase-implQuery.toParamString(com.adobe.cq.social.cq-social-ugcbase-impl))), ("comAdobeDamCqDamCfmImpl", Some(com.adobe.dam.cq-dam-cfm-implQuery.toParamString(com.adobe.dam.cq-dam-cfm-impl))), ("comAdobeFormsFoundationFormsFoundationBase", Some(com.adobe.forms.foundation-forms-foundation-baseQuery.toParamString(com.adobe.forms.foundation-forms-foundation-base))), ("comAdobeGraniteApicontroller", Some(com.adobe.granite.apicontrollerQuery.toParamString(com.adobe.granite.apicontroller))), ("comAdobeGraniteAssetCore", Some(com.adobe.granite.asset.coreQuery.toParamString(com.adobe.granite.asset.core))), ("comAdobeGraniteAuthSso", Some(com.adobe.granite.auth.ssoQuery.toParamString(com.adobe.granite.auth.sso))), ("comAdobeGraniteBundlesHcImpl", Some(com.adobe.granite.bundles.hc.implQuery.toParamString(com.adobe.granite.bundles.hc.impl))), ("comAdobeGraniteCompatRouter", Some(com.adobe.granite.compat-routerQuery.toParamString(com.adobe.granite.compat-router))), ("comAdobeGraniteConf", Some(com.adobe.granite.confQuery.toParamString(com.adobe.granite.conf))), ("comAdobeGraniteConfUiCore", Some(com.adobe.granite.conf.ui.coreQuery.toParamString(com.adobe.granite.conf.ui.core))), ("comAdobeGraniteCors", Some(com.adobe.granite.corsQuery.toParamString(com.adobe.granite.cors))), ("comAdobeGraniteCrxExplorer", Some(com.adobe.granite.crx-explorerQuery.toParamString(com.adobe.granite.crx-explorer))), ("comAdobeGraniteCrxdeLite", Some(com.adobe.granite.crxde-liteQuery.toParamString(com.adobe.granite.crxde-lite))), ("comAdobeGraniteCryptoConfig", Some(com.adobe.granite.crypto.configQuery.toParamString(com.adobe.granite.crypto.config))), ("comAdobeGraniteCryptoExtension", Some(com.adobe.granite.crypto.extensionQuery.toParamString(com.adobe.granite.crypto.extension))), ("comAdobeGraniteCryptoFile", Some(com.adobe.granite.crypto.fileQuery.toParamString(com.adobe.granite.crypto.file))), ("comAdobeGraniteCryptoJcr", Some(com.adobe.granite.crypto.jcrQuery.toParamString(com.adobe.granite.crypto.jcr))), ("comAdobeGraniteCsrf", Some(com.adobe.granite.csrfQuery.toParamString(com.adobe.granite.csrf))), ("comAdobeGraniteDistributionCore", Some(com.adobe.granite.distribution.coreQuery.toParamString(com.adobe.granite.distribution.core))), ("comAdobeGraniteDropwizardMetrics", Some(com.adobe.granite.dropwizard.metricsQuery.toParamString(com.adobe.granite.dropwizard.metrics))), ("comAdobeGraniteFragsImpl", Some(com.adobe.granite.frags.implQuery.toParamString(com.adobe.granite.frags.impl))), ("comAdobeGraniteGibson", Some(com.adobe.granite.gibsonQuery.toParamString(com.adobe.granite.gibson))), ("comAdobeGraniteInfocollector", Some(com.adobe.granite.infocollectorQuery.toParamString(com.adobe.granite.infocollector))), ("comAdobeGraniteInstallerFactoryPackages", Some(com.adobe.granite.installer.factory.packagesQuery.toParamString(com.adobe.granite.installer.factory.packages))), ("comAdobeGraniteJettySsl", Some(com.adobe.granite.jetty.sslQuery.toParamString(com.adobe.granite.jetty.ssl))), ("comAdobeGraniteJobsAsync", Some(com.adobe.granite.jobs.asyncQuery.toParamString(com.adobe.granite.jobs.async))), ("comAdobeGraniteMaintenanceOak", Some(com.adobe.granite.maintenance.oakQuery.toParamString(com.adobe.granite.maintenance.oak))), ("comAdobeGraniteMonitoringCore", Some(com.adobe.granite.monitoring.coreQuery.toParamString(com.adobe.granite.monitoring.core))), ("comAdobeGraniteQueries", Some(com.adobe.granite.queriesQuery.toParamString(com.adobe.granite.queries))), ("comAdobeGraniteReplicationHcImpl", Some(com.adobe.granite.replication.hc.implQuery.toParamString(com.adobe.granite.replication.hc.impl))), ("comAdobeGraniteRepositoryChecker", Some(com.adobe.granite.repository.checkerQuery.toParamString(com.adobe.granite.repository.checker))), ("comAdobeGraniteRepositoryHcImpl", Some(com.adobe.granite.repository.hc.implQuery.toParamString(com.adobe.granite.repository.hc.impl))), ("comAdobeGraniteRestAssets", Some(com.adobe.granite.rest.assetsQuery.toParamString(com.adobe.granite.rest.assets))), ("comAdobeGraniteSecurityUi", Some(com.adobe.granite.security.uiQuery.toParamString(com.adobe.granite.security.ui))), ("comAdobeGraniteStartup", Some(com.adobe.granite.startupQuery.toParamString(com.adobe.granite.startup))), ("comAdobeGraniteTagsoup", Some(com.adobe.granite.tagsoupQuery.toParamString(com.adobe.granite.tagsoup))), ("comAdobeGraniteTaskmanagementCore", Some(com.adobe.granite.taskmanagement.coreQuery.toParamString(com.adobe.granite.taskmanagement.core))), ("comAdobeGraniteTaskmanagementWorkflow", Some(com.adobe.granite.taskmanagement.workflowQuery.toParamString(com.adobe.granite.taskmanagement.workflow))), ("comAdobeGraniteUiClientlibsCompilerLess", Some(com.adobe.granite.ui.clientlibs.compiler.lessQuery.toParamString(com.adobe.granite.ui.clientlibs.compiler.less))), ("comAdobeGraniteUiClientlibsProcessorGcc", Some(com.adobe.granite.ui.clientlibs.processor.gccQuery.toParamString(com.adobe.granite.ui.clientlibs.processor.gcc))), ("comAdobeGraniteWebconsolePlugins", Some(com.adobe.granite.webconsole.pluginsQuery.toParamString(com.adobe.granite.webconsole.plugins))), ("comAdobeGraniteWorkflowConsole", Some(com.adobe.granite.workflow.consoleQuery.toParamString(com.adobe.granite.workflow.console))), ("comAdobeXmpWorkerFilesNativeFragmentLinux", Some(com.adobe.xmp.worker.files.native.fragment.linuxQuery.toParamString(com.adobe.xmp.worker.files.native.fragment.linux))), ("comAdobeXmpWorkerFilesNativeFragmentMacosx", Some(com.adobe.xmp.worker.files.native.fragment.macosxQuery.toParamString(com.adobe.xmp.worker.files.native.fragment.macosx))), ("comAdobeXmpWorkerFilesNativeFragmentWin", Some(com.adobe.xmp.worker.files.native.fragment.winQuery.toParamString(com.adobe.xmp.worker.files.native.fragment.win))), ("comDayCommonsOsgiWrapperSimpleJndi", Some(com.day.commons.osgi.wrapper.simple-jndiQuery.toParamString(com.day.commons.osgi.wrapper.simple-jndi))), ("comDayCqCqAuthhandler", Some(com.day.cq.cq-authhandlerQuery.toParamString(com.day.cq.cq-authhandler))), ("comDayCqCqCompatConfigupdate", Some(com.day.cq.cq-compat-configupdateQuery.toParamString(com.day.cq.cq-compat-configupdate))), ("comDayCqCqLicensebranding", Some(com.day.cq.cq-licensebrandingQuery.toParamString(com.day.cq.cq-licensebranding))), ("comDayCqCqNotifcationImpl", Some(com.day.cq.cq-notifcation-implQuery.toParamString(com.day.cq.cq-notifcation-impl))), ("comDayCqCqReplicationAudit", Some(com.day.cq.cq-replication-auditQuery.toParamString(com.day.cq.cq-replication-audit))), ("comDayCqCqSearchExt", Some(com.day.cq.cq-search-extQuery.toParamString(com.day.cq.cq-search-ext))), ("comDayCqDamCqDamAnnotationPrint", Some(com.day.cq.dam.cq-dam-annotation-printQuery.toParamString(com.day.cq.dam.cq-dam-annotation-print))), ("comDayCqDamCqDamAssetUsage", Some(com.day.cq.dam.cq-dam-asset-usageQuery.toParamString(com.day.cq.dam.cq-dam-asset-usage))), ("comDayCqDamCqDamS7dam", Some(com.day.cq.dam.cq-dam-s7damQuery.toParamString(com.day.cq.dam.cq-dam-s7dam))), ("comDayCqDamCqDamSimilaritysearch", Some(com.day.cq.dam.cq-dam-similaritysearchQuery.toParamString(com.day.cq.dam.cq-dam-similaritysearch))), ("comDayCqDamDamWebdavSupport", Some(com.day.cq.dam.dam-webdav-supportQuery.toParamString(com.day.cq.dam.dam-webdav-support))), ("comDayCqPreUpgradeTasks", Some(com.day.cq.pre-upgrade-tasksQuery.toParamString(com.day.cq.pre-upgrade-tasks))), ("comDayCqReplicationExtensions", Some(com.day.cq.replication.extensionsQuery.toParamString(com.day.cq.replication.extensions))), ("comDayCqWcmCqMsmCore", Some(com.day.cq.wcm.cq-msm-coreQuery.toParamString(com.day.cq.wcm.cq-msm-core))), ("comDayCqWcmCqWcmTranslation", Some(com.day.cq.wcm.cq-wcm-translationQuery.toParamString(com.day.cq.wcm.cq-wcm-translation))), ("dayCommonsJrawio", Some(day-commons-jrawioQuery.toParamString(day-commons-jrawio))), ("orgApacheAriesJmxWhiteboard", Some(org.apache.aries.jmx.whiteboardQuery.toParamString(org.apache.aries.jmx.whiteboard))), ("orgApacheFelixHttpSslfilter", Some(org.apache.felix.http.sslfilterQuery.toParamString(org.apache.felix.http.sslfilter))), ("orgApacheFelixOrgApacheFelixThreaddump", Some(org.apache.felix.org.apache.felix.threaddumpQuery.toParamString(org.apache.felix.org.apache.felix.threaddump))), ("orgApacheFelixWebconsolePluginsDs", Some(org.apache.felix.webconsole.plugins.dsQuery.toParamString(org.apache.felix.webconsole.plugins.ds))), ("orgApacheFelixWebconsolePluginsEvent", Some(org.apache.felix.webconsole.plugins.eventQuery.toParamString(org.apache.felix.webconsole.plugins.event))), ("orgApacheFelixWebconsolePluginsMemoryusage", Some(org.apache.felix.webconsole.plugins.memoryusageQuery.toParamString(org.apache.felix.webconsole.plugins.memoryusage))), ("orgApacheFelixWebconsolePluginsPackageadmin", Some(org.apache.felix.webconsole.plugins.packageadminQuery.toParamString(org.apache.felix.webconsole.plugins.packageadmin))), ("orgApacheJackrabbitOakAuthLdap", Some(org.apache.jackrabbit.oak-auth-ldapQuery.toParamString(org.apache.jackrabbit.oak-auth-ldap))), ("orgApacheJackrabbitOakSegmentTar", Some(org.apache.jackrabbit.oak-segment-tarQuery.toParamString(org.apache.jackrabbit.oak-segment-tar))), ("orgApacheJackrabbitOakSolrOsgi", Some(org.apache.jackrabbit.oak-solr-osgiQuery.toParamString(org.apache.jackrabbit.oak-solr-osgi))), ("orgApacheSlingBundleresourceImpl", Some(org.apache.sling.bundleresource.implQuery.toParamString(org.apache.sling.bundleresource.impl))), ("orgApacheSlingCommonsFsclassloader", Some(org.apache.sling.commons.fsclassloaderQuery.toParamString(org.apache.sling.commons.fsclassloader))), ("orgApacheSlingCommonsLogWebconsole", Some(org.apache.sling.commons.log.webconsoleQuery.toParamString(org.apache.sling.commons.log.webconsole))), ("orgApacheSlingDatasource", Some(org.apache.sling.datasourceQuery.toParamString(org.apache.sling.datasource))), ("orgApacheSlingDiscoveryBase", Some(org.apache.sling.discovery.baseQuery.toParamString(org.apache.sling.discovery.base))), ("orgApacheSlingDiscoveryOak", Some(org.apache.sling.discovery.oakQuery.toParamString(org.apache.sling.discovery.oak))), ("orgApacheSlingDiscoverySupport", Some(org.apache.sling.discovery.supportQuery.toParamString(org.apache.sling.discovery.support))), ("orgApacheSlingDistributionApi", Some(org.apache.sling.distribution.apiQuery.toParamString(org.apache.sling.distribution.api))), ("orgApacheSlingDistributionCore", Some(org.apache.sling.distribution.coreQuery.toParamString(org.apache.sling.distribution.core))), ("orgApacheSlingExtensionsWebconsolesecurityprovider", Some(org.apache.sling.extensions.webconsolesecurityproviderQuery.toParamString(org.apache.sling.extensions.webconsolesecurityprovider))), ("orgApacheSlingHcWebconsole", Some(org.apache.sling.hc.webconsoleQuery.toParamString(org.apache.sling.hc.webconsole))), ("orgApacheSlingInstallerConsole", Some(org.apache.sling.installer.consoleQuery.toParamString(org.apache.sling.installer.console))), ("orgApacheSlingInstallerProviderFile", Some(org.apache.sling.installer.provider.fileQuery.toParamString(org.apache.sling.installer.provider.file))), ("orgApacheSlingInstallerProviderJcr", Some(org.apache.sling.installer.provider.jcrQuery.toParamString(org.apache.sling.installer.provider.jcr))), ("orgApacheSlingJcrDavex", Some(org.apache.sling.jcr.davexQuery.toParamString(org.apache.sling.jcr.davex))), ("orgApacheSlingJcrResourcesecurity", Some(org.apache.sling.jcr.resourcesecurityQuery.toParamString(org.apache.sling.jcr.resourcesecurity))), ("orgApacheSlingJmxProvider", Some(org.apache.sling.jmx.providerQuery.toParamString(org.apache.sling.jmx.provider))), ("orgApacheSlingLaunchpadInstaller", Some(org.apache.sling.launchpad.installerQuery.toParamString(org.apache.sling.launchpad.installer))), ("orgApacheSlingModelsImpl", Some(org.apache.sling.models.implQuery.toParamString(org.apache.sling.models.impl))), ("orgApacheSlingRepoinitParser", Some(org.apache.sling.repoinit.parserQuery.toParamString(org.apache.sling.repoinit.parser))), ("orgApacheSlingResourceInventory", Some(org.apache.sling.resource.inventoryQuery.toParamString(org.apache.sling.resource.inventory))), ("orgApacheSlingResourceresolver", Some(org.apache.sling.resourceresolverQuery.toParamString(org.apache.sling.resourceresolver))), ("orgApacheSlingScriptingJavascript", Some(org.apache.sling.scripting.javascriptQuery.toParamString(org.apache.sling.scripting.javascript))), ("orgApacheSlingScriptingJst", Some(org.apache.sling.scripting.jstQuery.toParamString(org.apache.sling.scripting.jst))), ("orgApacheSlingScriptingSightlyJsProvider", Some(org.apache.sling.scripting.sightly.js.providerQuery.toParamString(org.apache.sling.scripting.sightly.js.provider))), ("orgApacheSlingScriptingSightlyModelsProvider", Some(org.apache.sling.scripting.sightly.models.providerQuery.toParamString(org.apache.sling.scripting.sightly.models.provider))), ("orgApacheSlingSecurity", Some(org.apache.sling.securityQuery.toParamString(org.apache.sling.security))), ("orgApacheSlingServletsCompat", Some(org.apache.sling.servlets.compatQuery.toParamString(org.apache.sling.servlets.compat))), ("orgApacheSlingServletsGet", Some(org.apache.sling.servlets.getQuery.toParamString(org.apache.sling.servlets.get))), ("orgApacheSlingStartupfilterDisabler", Some(org.apache.sling.startupfilter.disablerQuery.toParamString(org.apache.sling.startupfilter.disabler))), ("orgApacheSlingTracer", Some(org.apache.sling.tracerQuery.toParamString(org.apache.sling.tracer))), ("weRetailClientAppCore", Some(we.retail.client.app.coreQuery.toParamString(we.retail.client.app.core))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthCertImplClientCertAuthHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], serviceRankingQuery: QueryParam[Integer]): Task[ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo] = jsonOf[ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.cert.impl.ClientCertAuthHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthIms(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], configid: String, scope: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], configidQuery: QueryParam[String], scopeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthImsInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthImsInfo] = jsonOf[ComAdobeGraniteAuthImsInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.ims"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("configid", Some(configidQuery.toParamString(configid))), ("scope", Some(scopeQuery.toParamString(scope))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthImsInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtension(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String]): Task[ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo] = jsonOf[ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.ims.impl.ExternalUserIdMappingProviderExtension"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], authImsClientSecret: String, customizerType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], authImsClientSecretQuery: QueryParam[String], customizerTypeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo] = jsonOf[ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSAccessTokenRequestCustomizerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("authImsClientSecret", Some(auth.ims.client.secretQuery.toParamString(auth.ims.client.secret))), ("customizerType", Some(customizer.typeQuery.toParamString(customizer.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthImsImplIMSInstanceCredentialsValidator(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String]): Task[ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo] = jsonOf[ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSInstanceCredentialsValidator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthImsImplIMSProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String, oauthProviderImsAuthorizationUrl: String, oauthProviderImsTokenUrl: String, oauthProviderImsProfileUrl: String, oauthProviderImsExtendedDetailsUrls: List[String], oauthProviderImsValidateTokenUrl: String, oauthProviderImsSessionProperty: String, oauthProviderImsServiceTokenClientId: String, oauthProviderImsServiceTokenClientSecret: String, oauthProviderImsServiceToken: String, imsOrgRef: String, imsGroupMapping: List[String], oauthProviderImsOnlyLicenseGroup: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String], oauthProviderImsAuthorizationUrlQuery: QueryParam[String], oauthProviderImsTokenUrlQuery: QueryParam[String], oauthProviderImsProfileUrlQuery: QueryParam[String], oauthProviderImsExtendedDetailsUrlsQuery: QueryParam[List[String]], oauthProviderImsValidateTokenUrlQuery: QueryParam[String], oauthProviderImsSessionPropertyQuery: QueryParam[String], oauthProviderImsServiceTokenClientIdQuery: QueryParam[String], oauthProviderImsServiceTokenClientSecretQuery: QueryParam[String], oauthProviderImsServiceTokenQuery: QueryParam[String], imsOrgRefQuery: QueryParam[String], imsGroupMappingQuery: QueryParam[List[String]], oauthProviderImsOnlyLicenseGroupQuery: QueryParam[Boolean]): Task[ComAdobeGraniteAuthImsImplIMSProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthImsImplIMSProviderImplInfo] = jsonOf[ComAdobeGraniteAuthImsImplIMSProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))), ("oauthProviderImsAuthorizationUrl", Some(oauth.provider.ims.authorization.urlQuery.toParamString(oauth.provider.ims.authorization.url))), ("oauthProviderImsTokenUrl", Some(oauth.provider.ims.token.urlQuery.toParamString(oauth.provider.ims.token.url))), ("oauthProviderImsProfileUrl", Some(oauth.provider.ims.profile.urlQuery.toParamString(oauth.provider.ims.profile.url))), ("oauthProviderImsExtendedDetailsUrls", Some(oauth.provider.ims.extended.details.urlsQuery.toParamString(oauth.provider.ims.extended.details.urls))), ("oauthProviderImsValidateTokenUrl", Some(oauth.provider.ims.validate.token.urlQuery.toParamString(oauth.provider.ims.validate.token.url))), ("oauthProviderImsSessionProperty", Some(oauth.provider.ims.session.propertyQuery.toParamString(oauth.provider.ims.session.property))), ("oauthProviderImsServiceTokenClientId", Some(oauth.provider.ims.service.token.client.idQuery.toParamString(oauth.provider.ims.service.token.client.id))), ("oauthProviderImsServiceTokenClientSecret", Some(oauth.provider.ims.service.token.client.secretQuery.toParamString(oauth.provider.ims.service.token.client.secret))), ("oauthProviderImsServiceToken", Some(oauth.provider.ims.service.tokenQuery.toParamString(oauth.provider.ims.service.token))), ("imsOrgRef", Some(ims.org.refQuery.toParamString(ims.org.ref))), ("imsGroupMapping", Some(ims.group.mappingQuery.toParamString(ims.group.mapping))), ("oauthProviderImsOnlyLicenseGroup", Some(oauth.provider.ims.only.license.groupQuery.toParamString(oauth.provider.ims.only.license.group))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthImsImplIMSProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthImsImplImsConfigProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthConfigmanagerImsConfigid: String, imsOwningEntity: String, aemInstanceId: String, imsServiceCode: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthConfigmanagerImsConfigidQuery: QueryParam[String], imsOwningEntityQuery: QueryParam[String], aemInstanceIdQuery: QueryParam[String], imsServiceCodeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo] = jsonOf[ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.ims.impl.ImsConfigProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthConfigmanagerImsConfigid", Some(oauth.configmanager.ims.configidQuery.toParamString(oauth.configmanager.ims.configid))), ("imsOwningEntity", Some(ims.owningEntityQuery.toParamString(ims.owningEntity))), ("aemInstanceId", Some(aem.instanceIdQuery.toParamString(aem.instanceId))), ("imsServiceCode", Some(ims.serviceCodeQuery.toParamString(ims.serviceCode))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthAccesstokenProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, authTokenProviderTitle: String, authTokenProviderDefaultClaims: List[String], authTokenProviderEndpoint: String, authAccessTokenRequest: String, authTokenProviderKeypairAlias: String, authTokenProviderConnTimeout: Integer, authTokenProviderSoTimeout: Integer, authTokenProviderClientId: String, authTokenProviderScope: String, authTokenProviderReuseAccessToken: Boolean, authTokenProviderRelaxedSsl: Boolean, tokenRequestCustomizerType: String, authTokenValidatorType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], authTokenProviderTitleQuery: QueryParam[String], authTokenProviderDefaultClaimsQuery: QueryParam[List[String]], authTokenProviderEndpointQuery: QueryParam[String], authAccessTokenRequestQuery: QueryParam[String], authTokenProviderKeypairAliasQuery: QueryParam[String], authTokenProviderConnTimeoutQuery: QueryParam[Integer], authTokenProviderSoTimeoutQuery: QueryParam[Integer], authTokenProviderClientIdQuery: QueryParam[String], authTokenProviderScopeQuery: QueryParam[String], authTokenProviderReuseAccessTokenQuery: QueryParam[Boolean], authTokenProviderRelaxedSslQuery: QueryParam[Boolean], tokenRequestCustomizerTypeQuery: QueryParam[String], authTokenValidatorTypeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthAccesstokenProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthAccesstokenProviderInfo] = jsonOf[ComAdobeGraniteAuthOauthAccesstokenProviderInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.accesstoken.provider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("authTokenProviderTitle", Some(auth.token.provider.titleQuery.toParamString(auth.token.provider.title))), ("authTokenProviderDefaultClaims", Some(auth.token.provider.default.claimsQuery.toParamString(auth.token.provider.default.claims))), ("authTokenProviderEndpoint", Some(auth.token.provider.endpointQuery.toParamString(auth.token.provider.endpoint))), ("authAccessTokenRequest", Some(auth.access.token.requestQuery.toParamString(auth.access.token.request))), ("authTokenProviderKeypairAlias", Some(auth.token.provider.keypair.aliasQuery.toParamString(auth.token.provider.keypair.alias))), ("authTokenProviderConnTimeout", Some(auth.token.provider.conn.timeoutQuery.toParamString(auth.token.provider.conn.timeout))), ("authTokenProviderSoTimeout", Some(auth.token.provider.so.timeoutQuery.toParamString(auth.token.provider.so.timeout))), ("authTokenProviderClientId", Some(auth.token.provider.client.idQuery.toParamString(auth.token.provider.client.id))), ("authTokenProviderScope", Some(auth.token.provider.scopeQuery.toParamString(auth.token.provider.scope))), ("authTokenProviderReuseAccessToken", Some(auth.token.provider.reuse.access.tokenQuery.toParamString(auth.token.provider.reuse.access.token))), ("authTokenProviderRelaxedSsl", Some(auth.token.provider.relaxed.sslQuery.toParamString(auth.token.provider.relaxed.ssl))), ("tokenRequestCustomizerType", Some(token.request.customizer.typeQuery.toParamString(token.request.customizer.type))), ("authTokenValidatorType", Some(auth.token.validator.typeQuery.toParamString(auth.token.validator.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthAccesstokenProviderInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplBearerAuthenticationHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, oauthClientIdsAllowed: List[String], authBearerSyncIms: Boolean, authTokenRequestParameter: String, oauthBearerConfigid: String, oauthJwtSupport: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], oauthClientIdsAllowedQuery: QueryParam[List[String]], authBearerSyncImsQuery: QueryParam[Boolean], authTokenRequestParameterQuery: QueryParam[String], oauthBearerConfigidQuery: QueryParam[String], oauthJwtSupportQuery: QueryParam[Boolean]): Task[ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo] = jsonOf[ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.BearerAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("oauthClientIdsAllowed", Some(oauth.clientIds.allowedQuery.toParamString(oauth.clientIds.allowed))), ("authBearerSyncIms", Some(auth.bearer.sync.imsQuery.toParamString(auth.bearer.sync.ims))), ("authTokenRequestParameter", Some(auth.tokenRequestParameterQuery.toParamString(auth.tokenRequestParameter))), ("oauthBearerConfigid", Some(oauth.bearer.configidQuery.toParamString(oauth.bearer.configid))), ("oauthJwtSupport", Some(oauth.jwt.supportQuery.toParamString(oauth.jwt.support))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplDefaultTokenValidatorImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], authTokenValidatorType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], authTokenValidatorTypeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo] = jsonOf[ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.DefaultTokenValidatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("authTokenValidatorType", Some(auth.token.validator.typeQuery.toParamString(auth.token.validator.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplFacebookProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo] = jsonOf[ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.FacebookProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplGithubProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String, oauthProviderGithubAuthorizationUrl: String, oauthProviderGithubTokenUrl: String, oauthProviderGithubProfileUrl: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String], oauthProviderGithubAuthorizationUrlQuery: QueryParam[String], oauthProviderGithubTokenUrlQuery: QueryParam[String], oauthProviderGithubProfileUrlQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplGithubProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplGithubProviderImplInfo] = jsonOf[ComAdobeGraniteAuthOauthImplGithubProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.GithubProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))), ("oauthProviderGithubAuthorizationUrl", Some(oauth.provider.github.authorization.urlQuery.toParamString(oauth.provider.github.authorization.url))), ("oauthProviderGithubTokenUrl", Some(oauth.provider.github.token.urlQuery.toParamString(oauth.provider.github.token.url))), ("oauthProviderGithubProfileUrl", Some(oauth.provider.github.profile.urlQuery.toParamString(oauth.provider.github.profile.url))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplGithubProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplGraniteProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String, oauthProviderGraniteAuthorizationUrl: String, oauthProviderGraniteTokenUrl: String, oauthProviderGraniteProfileUrl: String, oauthProviderGraniteExtendedDetailsUrls: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String], oauthProviderGraniteAuthorizationUrlQuery: QueryParam[String], oauthProviderGraniteTokenUrlQuery: QueryParam[String], oauthProviderGraniteProfileUrlQuery: QueryParam[String], oauthProviderGraniteExtendedDetailsUrlsQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplGraniteProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplGraniteProviderInfo] = jsonOf[ComAdobeGraniteAuthOauthImplGraniteProviderInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.GraniteProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))), ("oauthProviderGraniteAuthorizationUrl", Some(oauth.provider.granite.authorization.urlQuery.toParamString(oauth.provider.granite.authorization.url))), ("oauthProviderGraniteTokenUrl", Some(oauth.provider.granite.token.urlQuery.toParamString(oauth.provider.granite.token.url))), ("oauthProviderGraniteProfileUrl", Some(oauth.provider.granite.profile.urlQuery.toParamString(oauth.provider.granite.profile.url))), ("oauthProviderGraniteExtendedDetailsUrls", Some(oauth.provider.granite.extended.details.urlsQuery.toParamString(oauth.provider.granite.extended.details.urls))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplGraniteProviderInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplHelperProviderConfigManager(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthCookieLoginTimeout: String, oauthCookieMaxAge: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthCookieLoginTimeoutQuery: QueryParam[String], oauthCookieMaxAgeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo] = jsonOf[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.helper.ProviderConfigManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthCookieLoginTimeout", Some(oauth.cookie.login.timeoutQuery.toParamString(oauth.cookie.login.timeout))), ("oauthCookieMaxAge", Some(oauth.cookie.max.ageQuery.toParamString(oauth.cookie.max.age))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternal(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthCookieLoginTimeout: String, oauthCookieMaxAge: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthCookieLoginTimeoutQuery: QueryParam[String], oauthCookieMaxAgeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo] = jsonOf[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.helper.ProviderConfigManagerInternal"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthCookieLoginTimeout", Some(oauth.cookie.login.timeoutQuery.toParamString(oauth.cookie.login.timeout))), ("oauthCookieMaxAge", Some(oauth.cookie.max.ageQuery.toParamString(oauth.cookie.max.age))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplOAuthAuthenticationHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo] = jsonOf[ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.OAuthAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthImplTwitterProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthProviderId: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthProviderIdQuery: QueryParam[String]): Task[ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo] = jsonOf[ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.impl.TwitterProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthProviderId", Some(oauth.provider.idQuery.toParamString(oauth.provider.id))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthOauthProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthConfigId: String, oauthClientId: String, oauthClientSecret: String, oauthScope: List[String], oauthConfigProviderId: String, oauthCreateUsers: Boolean, oauthUseridProperty: String, forceStrictUsernameMatching: Boolean, oauthEncodeUserids: Boolean, oauthHashUserids: Boolean, oauthCallBackUrl: String, oauthAccessTokenPersist: Boolean, oauthAccessTokenPersistCookie: Boolean, oauthCsrfStateProtection: Boolean, oauthRedirectRequestParams: Boolean, oauthConfigSiblingsAllow: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthConfigIdQuery: QueryParam[String], oauthClientIdQuery: QueryParam[String], oauthClientSecretQuery: QueryParam[String], oauthScopeQuery: QueryParam[List[String]], oauthConfigProviderIdQuery: QueryParam[String], oauthCreateUsersQuery: QueryParam[Boolean], oauthUseridPropertyQuery: QueryParam[String], forceStrictUsernameMatchingQuery: QueryParam[Boolean], oauthEncodeUseridsQuery: QueryParam[Boolean], oauthHashUseridsQuery: QueryParam[Boolean], oauthCallBackUrlQuery: QueryParam[String], oauthAccessTokenPersistQuery: QueryParam[Boolean], oauthAccessTokenPersistCookieQuery: QueryParam[Boolean], oauthCsrfStateProtectionQuery: QueryParam[Boolean], oauthRedirectRequestParamsQuery: QueryParam[Boolean], oauthConfigSiblingsAllowQuery: QueryParam[Boolean]): Task[ComAdobeGraniteAuthOauthProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthOauthProviderInfo] = jsonOf[ComAdobeGraniteAuthOauthProviderInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.oauth.provider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthConfigId", Some(oauth.config.idQuery.toParamString(oauth.config.id))), ("oauthClientId", Some(oauth.client.idQuery.toParamString(oauth.client.id))), ("oauthClientSecret", Some(oauth.client.secretQuery.toParamString(oauth.client.secret))), ("oauthScope", Some(oauth.scopeQuery.toParamString(oauth.scope))), ("oauthConfigProviderId", Some(oauth.config.provider.idQuery.toParamString(oauth.config.provider.id))), ("oauthCreateUsers", Some(oauth.create.usersQuery.toParamString(oauth.create.users))), ("oauthUseridProperty", Some(oauth.userid.propertyQuery.toParamString(oauth.userid.property))), ("forceStrictUsernameMatching", Some(force.strict.username.matchingQuery.toParamString(force.strict.username.matching))), ("oauthEncodeUserids", Some(oauth.encode.useridsQuery.toParamString(oauth.encode.userids))), ("oauthHashUserids", Some(oauth.hash.useridsQuery.toParamString(oauth.hash.userids))), ("oauthCallBackUrl", Some(oauth.callBackUrlQuery.toParamString(oauth.callBackUrl))), ("oauthAccessTokenPersist", Some(oauth.access.token.persistQuery.toParamString(oauth.access.token.persist))), ("oauthAccessTokenPersistCookie", Some(oauth.access.token.persist.cookieQuery.toParamString(oauth.access.token.persist.cookie))), ("oauthCsrfStateProtection", Some(oauth.csrf.state.protectionQuery.toParamString(oauth.csrf.state.protection))), ("oauthRedirectRequestParams", Some(oauth.redirect.request.paramsQuery.toParamString(oauth.redirect.request.params))), ("oauthConfigSiblingsAllow", Some(oauth.config.siblings.allowQuery.toParamString(oauth.config.siblings.allow))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthOauthProviderInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthRequirementImplDefaultRequirementHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], supportedPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], supportedPathsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo] = jsonOf[ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.requirement.impl.DefaultRequirementHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("supportedPaths", Some(supportedPathsQuery.toParamString(supportedPaths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthSamlSamlAuthenticationHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: List[String], serviceRanking: Integer, idpUrl: String, idpCertAlias: String, idpHttpRedirect: Boolean, serviceProviderEntityId: String, assertionConsumerServiceURL: String, spPrivateKeyAlias: String, keyStorePassword: String, defaultRedirectUrl: String, userIDAttribute: String, useEncryption: Boolean, createUser: Boolean, userIntermediatePath: String, addGroupMemberships: Boolean, groupMembershipAttribute: String, defaultGroups: List[String], nameIdFormat: String, synchronizeAttributes: List[String], handleLogout: Boolean, logoutUrl: String, clockTolerance: Integer, digestMethod: String, signatureMethod: String, identitySyncType: String, idpIdentifier: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], idpUrlQuery: QueryParam[String], idpCertAliasQuery: QueryParam[String], idpHttpRedirectQuery: QueryParam[Boolean], serviceProviderEntityIdQuery: QueryParam[String], assertionConsumerServiceURLQuery: QueryParam[String], spPrivateKeyAliasQuery: QueryParam[String], keyStorePasswordQuery: QueryParam[String], defaultRedirectUrlQuery: QueryParam[String], userIDAttributeQuery: QueryParam[String], useEncryptionQuery: QueryParam[Boolean], createUserQuery: QueryParam[Boolean], userIntermediatePathQuery: QueryParam[String], addGroupMembershipsQuery: QueryParam[Boolean], groupMembershipAttributeQuery: QueryParam[String], defaultGroupsQuery: QueryParam[List[String]], nameIdFormatQuery: QueryParam[String], synchronizeAttributesQuery: QueryParam[List[String]], handleLogoutQuery: QueryParam[Boolean], logoutUrlQuery: QueryParam[String], clockToleranceQuery: QueryParam[Integer], digestMethodQuery: QueryParam[String], signatureMethodQuery: QueryParam[String], identitySyncTypeQuery: QueryParam[String], idpIdentifierQuery: QueryParam[String]): Task[ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo] = jsonOf[ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("idpUrl", Some(idpUrlQuery.toParamString(idpUrl))), ("idpCertAlias", Some(idpCertAliasQuery.toParamString(idpCertAlias))), ("idpHttpRedirect", Some(idpHttpRedirectQuery.toParamString(idpHttpRedirect))), ("serviceProviderEntityId", Some(serviceProviderEntityIdQuery.toParamString(serviceProviderEntityId))), ("assertionConsumerServiceURL", Some(assertionConsumerServiceURLQuery.toParamString(assertionConsumerServiceURL))), ("spPrivateKeyAlias", Some(spPrivateKeyAliasQuery.toParamString(spPrivateKeyAlias))), ("keyStorePassword", Some(keyStorePasswordQuery.toParamString(keyStorePassword))), ("defaultRedirectUrl", Some(defaultRedirectUrlQuery.toParamString(defaultRedirectUrl))), ("userIDAttribute", Some(userIDAttributeQuery.toParamString(userIDAttribute))), ("useEncryption", Some(useEncryptionQuery.toParamString(useEncryption))), ("createUser", Some(createUserQuery.toParamString(createUser))), ("userIntermediatePath", Some(userIntermediatePathQuery.toParamString(userIntermediatePath))), ("addGroupMemberships", Some(addGroupMembershipsQuery.toParamString(addGroupMemberships))), ("groupMembershipAttribute", Some(groupMembershipAttributeQuery.toParamString(groupMembershipAttribute))), ("defaultGroups", Some(defaultGroupsQuery.toParamString(defaultGroups))), ("nameIdFormat", Some(nameIdFormatQuery.toParamString(nameIdFormat))), ("synchronizeAttributes", Some(synchronizeAttributesQuery.toParamString(synchronizeAttributes))), ("handleLogout", Some(handleLogoutQuery.toParamString(handleLogout))), ("logoutUrl", Some(logoutUrlQuery.toParamString(logoutUrl))), ("clockTolerance", Some(clockToleranceQuery.toParamString(clockTolerance))), ("digestMethod", Some(digestMethodQuery.toParamString(digestMethod))), ("signatureMethod", Some(signatureMethodQuery.toParamString(signatureMethod))), ("identitySyncType", Some(identitySyncTypeQuery.toParamString(identitySyncType))), ("idpIdentifier", Some(idpIdentifierQuery.toParamString(idpIdentifier))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteAuthSsoImplSsoAuthenticationHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, serviceRanking: Integer, jaasControlFlag: String, jaasRealmName: String, jaasRanking: Integer, headers: List[String], cookies: List[String], parameters: List[String], usermap: List[String], format: String, trustedCredentialsAttribute: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], serviceRankingQuery: QueryParam[Integer], jaasControlFlagQuery: QueryParam[String], jaasRealmNameQuery: QueryParam[String], jaasRankingQuery: QueryParam[Integer], headersQuery: QueryParam[List[String]], cookiesQuery: QueryParam[List[String]], parametersQuery: QueryParam[List[String]], usermapQuery: QueryParam[List[String]], formatQuery: QueryParam[String], trustedCredentialsAttributeQuery: QueryParam[String]): Task[ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo] = jsonOf[ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.auth.sso.impl.SsoAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("jaasControlFlag", Some(jaas.controlFlagQuery.toParamString(jaas.controlFlag))), ("jaasRealmName", Some(jaas.realmNameQuery.toParamString(jaas.realmName))), ("jaasRanking", Some(jaas.rankingQuery.toParamString(jaas.ranking))), ("headers", Some(headersQuery.toParamString(headers))), ("cookies", Some(cookiesQuery.toParamString(cookies))), ("parameters", Some(parametersQuery.toParamString(parameters))), ("usermap", Some(usermapQuery.toParamString(usermap))), ("format", Some(formatQuery.toParamString(format))), ("trustedCredentialsAttribute", Some(trustedCredentialsAttributeQuery.toParamString(trustedCredentialsAttribute))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplCodeCacheHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], minimumCodeCacheSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], minimumCodeCacheSizeQuery: QueryParam[Integer]): Task[ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.CodeCacheHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("minimumCodeCacheSize", Some(minimum.code.cache.sizeQuery.toParamString(minimum.code.cache.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.CrxdeSupportBundleHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplDavExBundleHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.DavExBundleHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplInactiveBundlesHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], ignoredBundles: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], ignoredBundlesQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.InactiveBundlesHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("ignoredBundles", Some(ignored.bundlesQuery.toParamString(ignored.bundles))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplJobsHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], maxQueuedJobs: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], maxQueuedJobsQuery: QueryParam[Integer]): Task[ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.JobsHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("maxQueuedJobs", Some(max.queued.jobsQuery.toParamString(max.queued.jobs))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplSlingGetServletHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingGetServletHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingJavaScriptHandlerHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingJspScriptHandlerHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingReferrerFilterHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteBundlesHcImplWebDavBundleHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo] = jsonOf[ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.bundles.hc.impl.WebDavBundleHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCommentsInternalCommentReplicationContentFilterFac(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], replicateCommentResourceTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], replicateCommentResourceTypesQuery: QueryParam[List[String]]): Task[ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo] = jsonOf[ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo]

    val path = "/system/console/configMgr/com.adobe.granite.comments.internal.CommentReplicationContentFilterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("replicateCommentResourceTypes", Some(replicate.comment.resourceTypesQuery.toParamString(replicate.comment.resourceTypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCompatrouterImplCompatSwitchingServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], compatgroups: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], compatgroupsQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo] = jsonOf[ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.compatrouter.impl.CompatSwitchingServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("compatgroups", Some(compatgroupsQuery.toParamString(compatgroups))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCompatrouterImplRoutingConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], id: String, compatPath: String, newPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], idQuery: QueryParam[String], compatPathQuery: QueryParam[String], newPathQuery: QueryParam[String]): Task[ComAdobeGraniteCompatrouterImplRoutingConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCompatrouterImplRoutingConfigInfo] = jsonOf[ComAdobeGraniteCompatrouterImplRoutingConfigInfo]

    val path = "/system/console/configMgr/com.adobe.granite.compatrouter.impl.RoutingConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("id", Some(idQuery.toParamString(id))), ("compatPath", Some(compatPathQuery.toParamString(compatPath))), ("newPath", Some(newPathQuery.toParamString(newPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCompatrouterImplRoutingConfigInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCompatrouterImplSwitchMappingConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], group: String, ids: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], groupQuery: QueryParam[String], idsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo] = jsonOf[ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo]

    val path = "/system/console/configMgr/com.adobe.granite.compatrouter.impl.SwitchMappingConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("group", Some(groupQuery.toParamString(group))), ("ids", Some(idsQuery.toParamString(ids))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolving(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, fallbackPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], fallbackPathsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo] = jsonOf[ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo]

    val path = "/system/console/configMgr/com.adobe.granite.conf.impl.RuntimeAwareConfigurationResourceResolvingStrategy"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("fallbackPaths", Some(fallbackPathsQuery.toParamString(fallbackPaths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteContexthubImplContextHubImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeGraniteContexthubSilentMode: Boolean, comAdobeGraniteContexthubShowUi: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeGraniteContexthubSilentModeQuery: QueryParam[Boolean], comAdobeGraniteContexthubShowUiQuery: QueryParam[Boolean]): Task[ComAdobeGraniteContexthubImplContextHubImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteContexthubImplContextHubImplInfo] = jsonOf[ComAdobeGraniteContexthubImplContextHubImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.contexthub.impl.ContextHubImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeGraniteContexthubSilentMode", Some(com.adobe.granite.contexthub.silent_modeQuery.toParamString(com.adobe.granite.contexthub.silent_mode))), ("comAdobeGraniteContexthubShowUi", Some(com.adobe.granite.contexthub.show_uiQuery.toParamString(com.adobe.granite.contexthub.show_ui))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteContexthubImplContextHubImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCorsImplCORSPolicyImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], alloworigin: List[String], alloworiginregexp: List[String], allowedpaths: List[String], exposedheaders: List[String], maxage: Integer, supportedheaders: List[String], supportedmethods: List[String], supportscredentials: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], alloworiginQuery: QueryParam[List[String]], alloworiginregexpQuery: QueryParam[List[String]], allowedpathsQuery: QueryParam[List[String]], exposedheadersQuery: QueryParam[List[String]], maxageQuery: QueryParam[Integer], supportedheadersQuery: QueryParam[List[String]], supportedmethodsQuery: QueryParam[List[String]], supportscredentialsQuery: QueryParam[Boolean]): Task[ComAdobeGraniteCorsImplCORSPolicyImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCorsImplCORSPolicyImplInfo] = jsonOf[ComAdobeGraniteCorsImplCORSPolicyImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.cors.impl.CORSPolicyImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("alloworigin", Some(alloworiginQuery.toParamString(alloworigin))), ("alloworiginregexp", Some(alloworiginregexpQuery.toParamString(alloworiginregexp))), ("allowedpaths", Some(allowedpathsQuery.toParamString(allowedpaths))), ("exposedheaders", Some(exposedheadersQuery.toParamString(exposedheaders))), ("maxage", Some(maxageQuery.toParamString(maxage))), ("supportedheaders", Some(supportedheadersQuery.toParamString(supportedheaders))), ("supportedmethods", Some(supportedmethodsQuery.toParamString(supportedmethods))), ("supportscredentials", Some(supportscredentialsQuery.toParamString(supportscredentials))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCorsImplCORSPolicyImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCsrfImplCSRFFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], filterMethods: List[String], filterEnableSafeUserAgents: Boolean, filterSafeUserAgents: List[String], filterExcludedPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], filterMethodsQuery: QueryParam[List[String]], filterEnableSafeUserAgentsQuery: QueryParam[Boolean], filterSafeUserAgentsQuery: QueryParam[List[String]], filterExcludedPathsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteCsrfImplCSRFFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCsrfImplCSRFFilterInfo] = jsonOf[ComAdobeGraniteCsrfImplCSRFFilterInfo]

    val path = "/system/console/configMgr/com.adobe.granite.csrf.impl.CSRFFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("filterMethods", Some(filter.methodsQuery.toParamString(filter.methods))), ("filterEnableSafeUserAgents", Some(filter.enable.safe.user.agentsQuery.toParamString(filter.enable.safe.user.agents))), ("filterSafeUserAgents", Some(filter.safe.user.agentsQuery.toParamString(filter.safe.user.agents))), ("filterExcludedPaths", Some(filter.excluded.pathsQuery.toParamString(filter.excluded.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCsrfImplCSRFFilterInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteCsrfImplCSRFServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], csrfTokenExpiresIn: Integer, slingAuthRequirements: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], csrfTokenExpiresInQuery: QueryParam[Integer], slingAuthRequirementsQuery: QueryParam[String]): Task[ComAdobeGraniteCsrfImplCSRFServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteCsrfImplCSRFServletInfo] = jsonOf[ComAdobeGraniteCsrfImplCSRFServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.csrf.impl.CSRFServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("csrfTokenExpiresIn", Some(csrf.token.expires.inQuery.toParamString(csrf.token.expires.in))), ("slingAuthRequirements", Some(sling.auth.requirementsQuery.toParamString(sling.auth.requirements))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteCsrfImplCSRFServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplCryptoDistributionTransportSe(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, username: String, encryptedPassword: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], usernameQuery: QueryParam[String], encryptedPasswordQuery: QueryParam[String]): Task[ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.CryptoDistributionTransportSecretProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("username", Some(usernameQuery.toParamString(username))), ("encryptedPassword", Some(encryptedPasswordQuery.toParamString(encryptedPassword))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplDiffDiffChangesObserver(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, agentName: String, diffPath: String, observedPath: String, serviceName: String, propertyNames: String, distributionDelay: Integer, serviceUserTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], agentNameQuery: QueryParam[String], diffPathQuery: QueryParam[String], observedPathQuery: QueryParam[String], serviceNameQuery: QueryParam[String], propertyNamesQuery: QueryParam[String], distributionDelayQuery: QueryParam[Integer], serviceUserTargetQuery: QueryParam[String]): Task[ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.diff.DiffChangesObserver"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("agentName", Some(agentNameQuery.toParamString(agentName))), ("diffPath", Some(diffPathQuery.toParamString(diffPath))), ("observedPath", Some(observedPathQuery.toParamString(observedPath))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("propertyNames", Some(propertyNamesQuery.toParamString(propertyNames))), ("distributionDelay", Some(distributionDelayQuery.toParamString(distributionDelay))), ("serviceUserTarget", Some(serviceUser.targetQuery.toParamString(serviceUser.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplDiffDiffEventListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], diffPath: String, serviceName: String, serviceUserTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], diffPathQuery: QueryParam[String], serviceNameQuery: QueryParam[String], serviceUserTargetQuery: QueryParam[String]): Task[ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.diff.DiffEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("diffPath", Some(diffPathQuery.toParamString(diffPath))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("serviceUserTarget", Some(serviceUser.targetQuery.toParamString(serviceUser.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplDistributionToReplicationEven(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], importerName: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], importerNameQuery: QueryParam[List[String]]): Task[ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.DistributionToReplicationEventTransformer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("importerName", Some(importer.nameQuery.toParamString(importer.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplReplicationAdaptersReplicat(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerName: String, forwardRequests: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerNameQuery: QueryParam[String], forwardRequestsQuery: QueryParam[Boolean]): Task[ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.replication.adapters.ReplicationAgentProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerName", Some(providerNameQuery.toParamString(providerName))), ("forwardRequests", Some(forward.requestsQuery.toParamString(forward.requests))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplReplicationDistributionTrans(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], forwardRequests: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], forwardRequestsQuery: QueryParam[Boolean]): Task[ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.replication.DistributionTransportHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("forwardRequests", Some(forward.requestsQuery.toParamString(forward.requests))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteDistributionCoreImplTransportAccessTokenDistribu(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, serviceName: String, userId: String, accessTokenProviderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], serviceNameQuery: QueryParam[String], userIdQuery: QueryParam[String], accessTokenProviderTargetQuery: QueryParam[String]): Task[ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo] = jsonOf[ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo]

    val path = "/system/console/configMgr/com.adobe.granite.distribution.core.impl.transport.AccessTokenDistributionTransportSecretProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("userId", Some(userIdQuery.toParamString(userId))), ("accessTokenProviderTarget", Some(accessTokenProvider.targetQuery.toParamString(accessTokenProvider.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteFragsImplCheckHttpHeaderFlag(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], featureName: String, featureDescription: String, httpHeaderName: String, httpHeaderValuepattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], featureNameQuery: QueryParam[String], featureDescriptionQuery: QueryParam[String], httpHeaderNameQuery: QueryParam[String], httpHeaderValuepatternQuery: QueryParam[String]): Task[ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo] = jsonOf[ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo]

    val path = "/system/console/configMgr/com.adobe.granite.frags.impl.CheckHttpHeaderFlag"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("featureName", Some(feature.nameQuery.toParamString(feature.name))), ("featureDescription", Some(feature.descriptionQuery.toParamString(feature.description))), ("httpHeaderName", Some(http.header.nameQuery.toParamString(http.header.name))), ("httpHeaderValuepattern", Some(http.header.valuepatternQuery.toParamString(http.header.valuepattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteFragsImplRandomFeature(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], featureName: String, featureDescription: String, activePercentage: String, cookieName: String, cookieMaxAge: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], featureNameQuery: QueryParam[String], featureDescriptionQuery: QueryParam[String], activePercentageQuery: QueryParam[String], cookieNameQuery: QueryParam[String], cookieMaxAgeQuery: QueryParam[Integer]): Task[ComAdobeGraniteFragsImplRandomFeatureInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteFragsImplRandomFeatureInfo] = jsonOf[ComAdobeGraniteFragsImplRandomFeatureInfo]

    val path = "/system/console/configMgr/com.adobe.granite.frags.impl.RandomFeature"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("featureName", Some(feature.nameQuery.toParamString(feature.name))), ("featureDescription", Some(feature.descriptionQuery.toParamString(feature.description))), ("activePercentage", Some(active.percentageQuery.toParamString(active.percentage))), ("cookieName", Some(cookie.nameQuery.toParamString(cookie.name))), ("cookieMaxAge", Some(cookie.maxAgeQuery.toParamString(cookie.maxAge))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteFragsImplRandomFeatureInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteHttpcacheFileFileCacheStore(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeGraniteHttpcacheFileDocumentRoot: String, comAdobeGraniteHttpcacheFileIncludeHost: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeGraniteHttpcacheFileDocumentRootQuery: QueryParam[String], comAdobeGraniteHttpcacheFileIncludeHostQuery: QueryParam[String]): Task[ComAdobeGraniteHttpcacheFileFileCacheStoreInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteHttpcacheFileFileCacheStoreInfo] = jsonOf[ComAdobeGraniteHttpcacheFileFileCacheStoreInfo]

    val path = "/system/console/configMgr/com.adobe.granite.httpcache.file.FileCacheStore"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeGraniteHttpcacheFileDocumentRoot", Some(com.adobe.granite.httpcache.file.documentRootQuery.toParamString(com.adobe.granite.httpcache.file.documentRoot))), ("comAdobeGraniteHttpcacheFileIncludeHost", Some(com.adobe.granite.httpcache.file.includeHostQuery.toParamString(com.adobe.granite.httpcache.file.includeHost))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteHttpcacheFileFileCacheStoreInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteHttpcacheImplOuterCacheFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeGraniteHttpcacheUrlPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeGraniteHttpcacheUrlPathsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo] = jsonOf[ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo]

    val path = "/system/console/configMgr/com.adobe.granite.httpcache.impl.OuterCacheFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeGraniteHttpcacheUrlPaths", Some(com.adobe.granite.httpcache.url.pathsQuery.toParamString(com.adobe.granite.httpcache.url.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteI18nImplBundlePseudoTranslations(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pseudoPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pseudoPatternsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo] = jsonOf[ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo]

    val path = "/system/console/configMgr/com.adobe.granite.i18n.impl.bundle.PseudoTranslations"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pseudoPatterns", Some(pseudo.patternsQuery.toParamString(pseudo.patterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteI18nImplPreferencesLocaleResolverService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], securityPreferencesName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], securityPreferencesNameQuery: QueryParam[String]): Task[ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo] = jsonOf[ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo]

    val path = "/system/console/configMgr/com.adobe.granite.i18n.impl.PreferencesLocaleResolverService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("securityPreferencesName", Some(security.preferences.nameQuery.toParamString(security.preferences.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteInfocollectorInfoCollector(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], graniteInfocollectorIncludeThreadDumps: Boolean, graniteInfocollectorIncludeHeapDump: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], graniteInfocollectorIncludeThreadDumpsQuery: QueryParam[Boolean], graniteInfocollectorIncludeHeapDumpQuery: QueryParam[Boolean]): Task[ComAdobeGraniteInfocollectorInfoCollectorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteInfocollectorInfoCollectorInfo] = jsonOf[ComAdobeGraniteInfocollectorInfoCollectorInfo]

    val path = "/system/console/configMgr/com.adobe.granite.infocollector.InfoCollector"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("graniteInfocollectorIncludeThreadDumps", Some(granite.infocollector.includeThreadDumpsQuery.toParamString(granite.infocollector.includeThreadDumps))), ("graniteInfocollectorIncludeHeapDump", Some(granite.infocollector.includeHeapDumpQuery.toParamString(granite.infocollector.includeHeapDump))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteInfocollectorInfoCollectorInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteJettySslInternalGraniteSslConnectorFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comAdobeGraniteJettySslPort: Integer, comAdobeGraniteJettySslKeystoreUser: String, comAdobeGraniteJettySslKeystorePassword: String, comAdobeGraniteJettySslCiphersuitesExcluded: List[String], comAdobeGraniteJettySslCiphersuitesIncluded: List[String], comAdobeGraniteJettySslClientCertificate: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comAdobeGraniteJettySslPortQuery: QueryParam[Integer], comAdobeGraniteJettySslKeystoreUserQuery: QueryParam[String], comAdobeGraniteJettySslKeystorePasswordQuery: QueryParam[String], comAdobeGraniteJettySslCiphersuitesExcludedQuery: QueryParam[List[String]], comAdobeGraniteJettySslCiphersuitesIncludedQuery: QueryParam[List[String]], comAdobeGraniteJettySslClientCertificateQuery: QueryParam[String]): Task[ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo] = jsonOf[ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo]

    val path = "/system/console/configMgr/com.adobe.granite.jetty.ssl.internal.GraniteSslConnectorFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comAdobeGraniteJettySslPort", Some(com.adobe.granite.jetty.ssl.portQuery.toParamString(com.adobe.granite.jetty.ssl.port))), ("comAdobeGraniteJettySslKeystoreUser", Some(com.adobe.granite.jetty.ssl.keystore.userQuery.toParamString(com.adobe.granite.jetty.ssl.keystore.user))), ("comAdobeGraniteJettySslKeystorePassword", Some(com.adobe.granite.jetty.ssl.keystore.passwordQuery.toParamString(com.adobe.granite.jetty.ssl.keystore.password))), ("comAdobeGraniteJettySslCiphersuitesExcluded", Some(com.adobe.granite.jetty.ssl.ciphersuites.excludedQuery.toParamString(com.adobe.granite.jetty.ssl.ciphersuites.excluded))), ("comAdobeGraniteJettySslCiphersuitesIncluded", Some(com.adobe.granite.jetty.ssl.ciphersuites.includedQuery.toParamString(com.adobe.granite.jetty.ssl.ciphersuites.included))), ("comAdobeGraniteJettySslClientCertificate", Some(com.adobe.granite.jetty.ssl.client.certificateQuery.toParamString(com.adobe.granite.jetty.ssl.client.certificate))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteLicenseImplLicenseCheckFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], checkInternval: Integer, excludeIds: List[String], encryptPing: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], checkInternvalQuery: QueryParam[Integer], excludeIdsQuery: QueryParam[List[String]], encryptPingQuery: QueryParam[Boolean]): Task[ComAdobeGraniteLicenseImplLicenseCheckFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteLicenseImplLicenseCheckFilterInfo] = jsonOf[ComAdobeGraniteLicenseImplLicenseCheckFilterInfo]

    val path = "/system/console/configMgr/com.adobe.granite.license.impl.LicenseCheckFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("checkInternval", Some(checkInternvalQuery.toParamString(checkInternval))), ("excludeIds", Some(excludeIdsQuery.toParamString(excludeIds))), ("encryptPing", Some(encryptPingQuery.toParamString(encryptPing))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteLicenseImplLicenseCheckFilterInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteLoggingImplLogAnalyserImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], messagesQueueSize: Integer, loggerConfig: List[String], messagesSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], messagesQueueSizeQuery: QueryParam[Integer], loggerConfigQuery: QueryParam[List[String]], messagesSizeQuery: QueryParam[Integer]): Task[ComAdobeGraniteLoggingImplLogAnalyserImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteLoggingImplLogAnalyserImplInfo] = jsonOf[ComAdobeGraniteLoggingImplLogAnalyserImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.logging.impl.LogAnalyserImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("messagesQueueSize", Some(messages.queue.sizeQuery.toParamString(messages.queue.size))), ("loggerConfig", Some(logger.configQuery.toParamString(logger.config))), ("messagesSize", Some(messages.sizeQuery.toParamString(messages.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteLoggingImplLogAnalyserImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteLoggingImplLogErrorHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo] = jsonOf[ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.logging.impl.LogErrorHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTask(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], graniteMaintenanceMandatory: Boolean, jobTopics: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], graniteMaintenanceMandatoryQuery: QueryParam[Boolean], jobTopicsQuery: QueryParam[String]): Task[ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo] = jsonOf[ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo]

    val path = "/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.DataStoreGarbageCollectionTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("graniteMaintenanceMandatory", Some(granite.maintenance.mandatoryQuery.toParamString(granite.maintenance.mandatory))), ("jobTopics", Some(job.topicsQuery.toParamString(job.topics))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTask(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jobTopics: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jobTopicsQuery: QueryParam[String]): Task[ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo] = jsonOf[ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo]

    val path = "/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.LuceneBinariesCleanupTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jobTopics", Some(job.topicsQuery.toParamString(job.topics))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteMaintenanceCrxImplRevisionCleanupTask(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fullGcDays: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fullGcDaysQuery: QueryParam[List[String]]): Task[ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo] = jsonOf[ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo]

    val path = "/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.RevisionCleanupTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fullGcDays", Some(full.gc.daysQuery.toParamString(full.gc.days))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteMonitoringImplScriptConfigImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], scriptFilename: String, scriptDisplay: String, scriptPath: String, scriptPlatform: List[String], interval: Integer, jmxdomain: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], scriptFilenameQuery: QueryParam[String], scriptDisplayQuery: QueryParam[String], scriptPathQuery: QueryParam[String], scriptPlatformQuery: QueryParam[List[String]], intervalQuery: QueryParam[Integer], jmxdomainQuery: QueryParam[String]): Task[ComAdobeGraniteMonitoringImplScriptConfigImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteMonitoringImplScriptConfigImplInfo] = jsonOf[ComAdobeGraniteMonitoringImplScriptConfigImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.monitoring.impl.ScriptConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("scriptFilename", Some(script.filenameQuery.toParamString(script.filename))), ("scriptDisplay", Some(script.displayQuery.toParamString(script.display))), ("scriptPath", Some(script.pathQuery.toParamString(script.path))), ("scriptPlatform", Some(script.platformQuery.toParamString(script.platform))), ("interval", Some(intervalQuery.toParamString(interval))), ("jmxdomain", Some(jmxdomainQuery.toParamString(jmxdomain))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteMonitoringImplScriptConfigImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHan(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, jaasControlFlag: String, jaasRealmName: String, jaasRanking: Integer, oauthOfflineValidation: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], jaasControlFlagQuery: QueryParam[String], jaasRealmNameQuery: QueryParam[String], jaasRankingQuery: QueryParam[Integer], oauthOfflineValidationQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo] = jsonOf[ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo]

    val path = "/system/console/configMgr/com.adobe.granite.oauth.server.auth.impl.OAuth2ServerAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("jaasControlFlag", Some(jaas.controlFlagQuery.toParamString(jaas.controlFlag))), ("jaasRealmName", Some(jaas.realmNameQuery.toParamString(jaas.realmName))), ("jaasRanking", Some(jaas.rankingQuery.toParamString(jaas.ranking))), ("oauthOfflineValidation", Some(oauth.offline.validationQuery.toParamString(oauth.offline.validation))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOauthServerImplAccessTokenCleanupTask(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String]): Task[ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo] = jsonOf[ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo]

    val path = "/system/console/configMgr/com.adobe.granite.oauth.server.impl.AccessTokenCleanupTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOauthServerImplOAuth2ClientRevocationServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthClientRevocationActive: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthClientRevocationActiveQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo] = jsonOf[ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2ClientRevocationServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthClientRevocationActive", Some(oauth.client.revocation.activeQuery.toParamString(oauth.client.revocation.active))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOauthServerImplOAuth2RevocationEndpointServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletPaths: String, oauthRevocationActive: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletPathsQuery: QueryParam[String], oauthRevocationActiveQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo] = jsonOf[ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2RevocationEndpointServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletPaths", Some(sling.servlet.pathsQuery.toParamString(sling.servlet.paths))), ("oauthRevocationActive", Some(oauth.revocation.activeQuery.toParamString(oauth.revocation.active))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOauthServerImplOAuth2TokenEndpointServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthIssuer: String, oauthAccessTokenExpiresIn: String, osgiHttpWhiteboardServletPattern: String, osgiHttpWhiteboardContextSelect: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthIssuerQuery: QueryParam[String], oauthAccessTokenExpiresInQuery: QueryParam[String], osgiHttpWhiteboardServletPatternQuery: QueryParam[String], osgiHttpWhiteboardContextSelectQuery: QueryParam[String]): Task[ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo] = jsonOf[ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2TokenEndpointServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthIssuer", Some(oauth.issuerQuery.toParamString(oauth.issuer))), ("oauthAccessTokenExpiresIn", Some(oauth.access.token.expires.inQuery.toParamString(oauth.access.token.expires.in))), ("osgiHttpWhiteboardServletPattern", Some(osgi.http.whiteboard.servlet.patternQuery.toParamString(osgi.http.whiteboard.servlet.pattern))), ("osgiHttpWhiteboardContextSelect", Some(osgi.http.whiteboard.context.selectQuery.toParamString(osgi.http.whiteboard.context.select))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOauthServerImplOAuth2TokenRevocationServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], oauthTokenRevocationActive: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], oauthTokenRevocationActiveQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo] = jsonOf[ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2TokenRevocationServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("oauthTokenRevocationActive", Some(oauth.token.revocation.activeQuery.toParamString(oauth.token.revocation.active))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOffloadingImplOffloadingConfigurator(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], offloadingTransporter: String, offloadingCleanupPayload: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], offloadingTransporterQuery: QueryParam[String], offloadingCleanupPayloadQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo] = jsonOf[ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo]

    val path = "/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingConfigurator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("offloadingTransporter", Some(offloading.transporterQuery.toParamString(offloading.transporter))), ("offloadingCleanupPayload", Some(offloading.cleanup.payloadQuery.toParamString(offloading.cleanup.payload))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOffloadingImplOffloadingJobCloner(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], offloadingJobclonerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], offloadingJobclonerEnabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo] = jsonOf[ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingJobCloner"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("offloadingJobclonerEnabled", Some(offloading.jobcloner.enabledQuery.toParamString(offloading.jobcloner.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOffloadingImplOffloadingJobOffloader(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], offloadingOffloaderEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], offloadingOffloaderEnabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo] = jsonOf[ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo]

    val path = "/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingJobOffloader"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("offloadingOffloaderEnabled", Some(offloading.offloader.enabledQuery.toParamString(offloading.offloader.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOffloadingImplTransporterOffloadingAgentManager(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], offloadingAgentmanagerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], offloadingAgentmanagerEnabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo] = jsonOf[ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.offloading.impl.transporter.OffloadingAgentManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("offloadingAgentmanagerEnabled", Some(offloading.agentmanager.enabledQuery.toParamString(offloading.agentmanager.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspo(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultTransportAgentToWorkerPrefix: String, defaultTransportAgentToMasterPrefix: String, defaultTransportInputPackage: String, defaultTransportOutputPackage: String, defaultTransportReplicationSynchronous: Boolean, defaultTransportContentpackage: Boolean, offloadingTransporterDefaultEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultTransportAgentToWorkerPrefixQuery: QueryParam[String], defaultTransportAgentToMasterPrefixQuery: QueryParam[String], defaultTransportInputPackageQuery: QueryParam[String], defaultTransportOutputPackageQuery: QueryParam[String], defaultTransportReplicationSynchronousQuery: QueryParam[Boolean], defaultTransportContentpackageQuery: QueryParam[Boolean], offloadingTransporterDefaultEnabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo] = jsonOf[ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo]

    val path = "/system/console/configMgr/com.adobe.granite.offloading.impl.transporter.OffloadingDefaultTransporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultTransportAgentToWorkerPrefix", Some(default.transport.agent-to-worker.prefixQuery.toParamString(default.transport.agent-to-worker.prefix))), ("defaultTransportAgentToMasterPrefix", Some(default.transport.agent-to-master.prefixQuery.toParamString(default.transport.agent-to-master.prefix))), ("defaultTransportInputPackage", Some(default.transport.input.packageQuery.toParamString(default.transport.input.package))), ("defaultTransportOutputPackage", Some(default.transport.output.packageQuery.toParamString(default.transport.output.package))), ("defaultTransportReplicationSynchronous", Some(default.transport.replication.synchronousQuery.toParamString(default.transport.replication.synchronous))), ("defaultTransportContentpackage", Some(default.transport.contentpackageQuery.toParamString(default.transport.contentpackage))), ("offloadingTransporterDefaultEnabled", Some(offloading.transporter.default.enabledQuery.toParamString(offloading.transporter.default.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOmnisearchImplCoreOmniSearchServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], omnisearchSuggestionRequiretextMin: Integer, omnisearchSuggestionSpellcheckRequire: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], omnisearchSuggestionRequiretextMinQuery: QueryParam[Integer], omnisearchSuggestionSpellcheckRequireQuery: QueryParam[Boolean]): Task[ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo] = jsonOf[ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.omnisearch.impl.core.OmniSearchServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("omnisearchSuggestionRequiretextMin", Some(omnisearch.suggestion.requiretext.minQuery.toParamString(omnisearch.suggestion.requiretext.min))), ("omnisearchSuggestionSpellcheckRequire", Some(omnisearch.suggestion.spellcheck.requireQuery.toParamString(omnisearch.suggestion.spellcheck.require))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteOptoutImplOptOutServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], optoutCookies: List[String], optoutHeaders: List[String], optoutWhitelistCookies: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], optoutCookiesQuery: QueryParam[List[String]], optoutHeadersQuery: QueryParam[List[String]], optoutWhitelistCookiesQuery: QueryParam[List[String]]): Task[ComAdobeGraniteOptoutImplOptOutServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteOptoutImplOptOutServiceImplInfo] = jsonOf[ComAdobeGraniteOptoutImplOptOutServiceImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.optout.impl.OptOutServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("optoutCookies", Some(optout.cookiesQuery.toParamString(optout.cookies))), ("optoutHeaders", Some(optout.headersQuery.toParamString(optout.headers))), ("optoutWhitelistCookies", Some(optout.whitelist.cookiesQuery.toParamString(optout.whitelist.cookies))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteOptoutImplOptOutServiceImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteQueriesImplHcAsyncIndexHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], indexingCriticalThreshold: Integer, indexingWarnThreshold: Integer, hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], indexingCriticalThresholdQuery: QueryParam[Integer], indexingWarnThresholdQuery: QueryParam[Integer], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo] = jsonOf[ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.queries.impl.hc.AsyncIndexHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("indexingCriticalThreshold", Some(indexing.critical.thresholdQuery.toParamString(indexing.critical.threshold))), ("indexingWarnThreshold", Some(indexing.warn.thresholdQuery.toParamString(indexing.warn.threshold))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteQueriesImplHcLargeIndexHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], largeIndexCriticalThreshold: Integer, largeIndexWarnThreshold: Integer, hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], largeIndexCriticalThresholdQuery: QueryParam[Integer], largeIndexWarnThresholdQuery: QueryParam[Integer], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo] = jsonOf[ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.queries.impl.hc.LargeIndexHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("largeIndexCriticalThreshold", Some(large.index.critical.thresholdQuery.toParamString(large.index.critical.threshold))), ("largeIndexWarnThreshold", Some(large.index.warn.thresholdQuery.toParamString(large.index.warn.threshold))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteQueriesImplHcQueriesStatusHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo] = jsonOf[ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueriesStatusHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteQueriesImplHcQueryHealthCheckMetrics(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], getPeriod: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], getPeriodQuery: QueryParam[Integer]): Task[ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo] = jsonOf[ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo]

    val path = "/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueryHealthCheckMetrics"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("getPeriod", Some(getPeriodQuery.toParamString(getPeriod))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteQueriesImplHcQueryLimitsHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo] = jsonOf[ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueryLimitsHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteReplicationHcImplReplicationQueueHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], numberOfRetriesAllowed: Integer, hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], numberOfRetriesAllowedQuery: QueryParam[Integer], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo] = jsonOf[ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.replication.hc.impl.ReplicationQueueHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("numberOfRetriesAllowed", Some(number.of.retries.allowedQuery.toParamString(number.of.retries.allowed))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteReplicationHcImplReplicationTransportUsersHealthC(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo] = jsonOf[ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo]

    val path = "/system/console/configMgr/com.adobe.granite.replication.hc.impl.ReplicationTransportUsersHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.AuthorizableNodeNameHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthC(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], excludeSearchPath: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], excludeSearchPathQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.content.sling.SlingContentHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("excludeSearchPath", Some(exclude.search.pathQuery.toParamString(exclude.search.path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplContinuousRGCHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.ContinuousRGCHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthChe(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.DefaultAccessUserProfileHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], accountLogins: List[String], consoleLogins: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], accountLoginsQuery: QueryParam[List[String]], consoleLoginsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.DefaultLoginsHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("accountLogins", Some(account.loginsQuery.toParamString(account.logins))), ("consoleLogins", Some(console.loginsQuery.toParamString(console.logins))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplDiskSpaceHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String], diskSpaceWarnThreshold: Integer, diskSpaceErrorThreshold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]], diskSpaceWarnThresholdQuery: QueryParam[Integer], diskSpaceErrorThresholdQuery: QueryParam[Integer]): Task[ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.DiskSpaceHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("diskSpaceWarnThreshold", Some(disk.space.warn.thresholdQuery.toParamString(disk.space.warn.threshold))), ("diskSpaceErrorThreshold", Some(disk.space.error.thresholdQuery.toParamString(disk.space.error.threshold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo] = jsonOf[ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.hc.impl.ObservationQueueLengthHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryImplCommitStatsConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, intervalSeconds: Integer, commitsPerIntervalThreshold: Integer, maxLocationLength: Integer, maxDetailsShown: Integer, minDetailsPercentage: Integer, threadMatchers: List[String], maxGreedyDepth: Integer, greedyStackMatchers: String, stackFilters: List[String], stackMatchers: List[String], stackCategorizers: List[String], stackShorteners: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], intervalSecondsQuery: QueryParam[Integer], commitsPerIntervalThresholdQuery: QueryParam[Integer], maxLocationLengthQuery: QueryParam[Integer], maxDetailsShownQuery: QueryParam[Integer], minDetailsPercentageQuery: QueryParam[Integer], threadMatchersQuery: QueryParam[List[String]], maxGreedyDepthQuery: QueryParam[Integer], greedyStackMatchersQuery: QueryParam[String], stackFiltersQuery: QueryParam[List[String]], stackMatchersQuery: QueryParam[List[String]], stackCategorizersQuery: QueryParam[List[String]], stackShortenersQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryImplCommitStatsConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryImplCommitStatsConfigInfo] = jsonOf[ComAdobeGraniteRepositoryImplCommitStatsConfigInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.impl.CommitStatsConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("intervalSeconds", Some(intervalSecondsQuery.toParamString(intervalSeconds))), ("commitsPerIntervalThreshold", Some(commitsPerIntervalThresholdQuery.toParamString(commitsPerIntervalThreshold))), ("maxLocationLength", Some(maxLocationLengthQuery.toParamString(maxLocationLength))), ("maxDetailsShown", Some(maxDetailsShownQuery.toParamString(maxDetailsShown))), ("minDetailsPercentage", Some(minDetailsPercentageQuery.toParamString(minDetailsPercentage))), ("threadMatchers", Some(threadMatchersQuery.toParamString(threadMatchers))), ("maxGreedyDepth", Some(maxGreedyDepthQuery.toParamString(maxGreedyDepth))), ("greedyStackMatchers", Some(greedyStackMatchersQuery.toParamString(greedyStackMatchers))), ("stackFilters", Some(stackFiltersQuery.toParamString(stackFilters))), ("stackMatchers", Some(stackMatchersQuery.toParamString(stackMatchers))), ("stackCategorizers", Some(stackCategorizersQuery.toParamString(stackCategorizers))), ("stackShorteners", Some(stackShortenersQuery.toParamString(stackShorteners))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryImplCommitStatsConfigInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRepositoryServiceUserConfiguration(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, serviceusersSimpleSubjectPopulation: Boolean, serviceusersList: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], serviceusersSimpleSubjectPopulationQuery: QueryParam[Boolean], serviceusersListQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRepositoryServiceUserConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRepositoryServiceUserConfigurationInfo] = jsonOf[ComAdobeGraniteRepositoryServiceUserConfigurationInfo]

    val path = "/system/console/configMgr/com.adobe.granite.repository.ServiceUserConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("serviceusersSimpleSubjectPopulation", Some(serviceusers.simpleSubjectPopulationQuery.toParamString(serviceusers.simpleSubjectPopulation))), ("serviceusersList", Some(serviceusers.listQuery.toParamString(serviceusers.list))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRepositoryServiceUserConfigurationInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckIm(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo] = jsonOf[ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo]

    val path = "/system/console/configMgr/com.adobe.granite.requests.logging.impl.hc.RequestsStatusHealthCheckImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteResourcestatusImplCompositeStatusType(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, types: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], typesQuery: QueryParam[List[String]]): Task[ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo] = jsonOf[ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo]

    val path = "/system/console/configMgr/com.adobe.granite.resourcestatus.impl.CompositeStatusType"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("types", Some(typesQuery.toParamString(types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteResourcestatusImplStatusResourceProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerRoot: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerRootQuery: QueryParam[String]): Task[ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo] = jsonOf[ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.resourcestatus.impl.StatusResourceProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerRoot", Some(provider.rootQuery.toParamString(provider.root))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRestAssetsImplAssetContentDispositionFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mimeAllowEmpty: Boolean, mimeAllowed: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mimeAllowEmptyQuery: QueryParam[Boolean], mimeAllowedQuery: QueryParam[List[String]]): Task[ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo] = jsonOf[ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo]

    val path = "/system/console/configMgr/com.adobe.granite.rest.assets.impl.AssetContentDispositionFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mimeAllowEmpty", Some(mime.allowEmptyQuery.toParamString(mime.allowEmpty))), ("mimeAllowed", Some(mime.allowedQuery.toParamString(mime.allowed))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRestImplApiEndpointResourceProviderFactoryImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerRoots: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerRootsQuery: QueryParam[String]): Task[ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo] = jsonOf[ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.rest.impl.ApiEndpointResourceProviderFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerRoots", Some(provider.rootsQuery.toParamString(provider.roots))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteRestImplServletDefaultGETServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultLimit: Integer, useAbsoluteUri: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultLimitQuery: QueryParam[Integer], useAbsoluteUriQuery: QueryParam[Boolean]): Task[ComAdobeGraniteRestImplServletDefaultGETServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteRestImplServletDefaultGETServletInfo] = jsonOf[ComAdobeGraniteRestImplServletDefaultGETServletInfo]

    val path = "/system/console/configMgr/com.adobe.granite.rest.impl.servlet.DefaultGETServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultLimit", Some(default.limitQuery.toParamString(default.limit))), ("useAbsoluteUri", Some(use.absolute.uriQuery.toParamString(use.absolute.uri))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteRestImplServletDefaultGETServletInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationS(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcTags: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcTagsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo] = jsonOf[ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo]

    val path = "/system/console/configMgr/com.adobe.granite.security.user.ui.internal.servlets.SSLConfigurationServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteSecurityUserUserPropertiesService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], adapterCondition: String, graniteUserpropertiesNodetypes: List[String], graniteUserpropertiesResourcetypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], adapterConditionQuery: QueryParam[String], graniteUserpropertiesNodetypesQuery: QueryParam[List[String]], graniteUserpropertiesResourcetypesQuery: QueryParam[List[String]]): Task[ComAdobeGraniteSecurityUserUserPropertiesServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteSecurityUserUserPropertiesServiceInfo] = jsonOf[ComAdobeGraniteSecurityUserUserPropertiesServiceInfo]

    val path = "/system/console/configMgr/com.adobe.granite.security.user.UserPropertiesService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("adapterCondition", Some(adapter.conditionQuery.toParamString(adapter.condition))), ("graniteUserpropertiesNodetypes", Some(granite.userproperties.nodetypesQuery.toParamString(granite.userproperties.nodetypes))), ("graniteUserpropertiesResourcetypes", Some(granite.userproperties.resourcetypesQuery.toParamString(granite.userproperties.resourcetypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteSecurityUserUserPropertiesServiceInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteSocialgraphImplSocialGraphFactoryImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], group2memberRelationshipOutgoing: String, group2memberExcludedOutgoing: List[String], group2memberRelationshipIncoming: String, group2memberExcludedIncoming: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], group2memberRelationshipOutgoingQuery: QueryParam[String], group2memberExcludedOutgoingQuery: QueryParam[List[String]], group2memberRelationshipIncomingQuery: QueryParam[String], group2memberExcludedIncomingQuery: QueryParam[List[String]]): Task[ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo] = jsonOf[ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.socialgraph.impl.SocialGraphFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("group2memberRelationshipOutgoing", Some(group2member.relationship.outgoingQuery.toParamString(group2member.relationship.outgoing))), ("group2memberExcludedOutgoing", Some(group2member.excluded.outgoingQuery.toParamString(group2member.excluded.outgoing))), ("group2memberRelationshipIncoming", Some(group2member.relationship.incomingQuery.toParamString(group2member.relationship.incoming))), ("group2memberExcludedIncoming", Some(group2member.excluded.incomingQuery.toParamString(group2member.excluded.incoming))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteSystemMonitoringImplSystemStatsMBeanImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, jmxObjectname: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], jmxObjectnameQuery: QueryParam[String]): Task[ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo] = jsonOf[ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.system.monitoring.impl.SystemStatsMBeanImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("jmxObjectname", Some(jmx.objectnameQuery.toParamString(jmx.objectname))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteTaskmanagementImplJcrTaskAdapterFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], adapterCondition: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], adapterConditionQuery: QueryParam[String]): Task[ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo] = jsonOf[ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo]

    val path = "/system/console/configMgr/com.adobe.granite.taskmanagement.impl.jcr.TaskAdapterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("adapterCondition", Some(adapter.conditionQuery.toParamString(adapter.condition))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteTaskmanagementImplJcrTaskArchiveService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], archivingEnabled: Boolean, schedulerExpression: String, archiveSinceDaysCompleted: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], archivingEnabledQuery: QueryParam[Boolean], schedulerExpressionQuery: QueryParam[String], archiveSinceDaysCompletedQuery: QueryParam[Integer]): Task[ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo] = jsonOf[ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo]

    val path = "/system/console/configMgr/com.adobe.granite.taskmanagement.impl.jcr.TaskArchiveService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("archivingEnabled", Some(archiving.enabledQuery.toParamString(archiving.enabled))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("archiveSinceDaysCompleted", Some(archive.since.days.completedQuery.toParamString(archive.since.days.completed))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTask(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], purgeCompleted: Boolean, completedAge: Integer, purgeActive: Boolean, activeAge: Integer, saveThreshold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], purgeCompletedQuery: QueryParam[Boolean], completedAgeQuery: QueryParam[Integer], purgeActiveQuery: QueryParam[Boolean], activeAgeQuery: QueryParam[Integer], saveThresholdQuery: QueryParam[Integer]): Task[ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo] = jsonOf[ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo]

    val path = "/system/console/configMgr/com.adobe.granite.taskmanagement.impl.purge.TaskPurgeMaintenanceTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("purgeCompleted", Some(purgeCompletedQuery.toParamString(purgeCompleted))), ("completedAge", Some(completedAgeQuery.toParamString(completedAge))), ("purgeActive", Some(purgeActiveQuery.toParamString(purgeActive))), ("activeAge", Some(activeAgeQuery.toParamString(activeAge))), ("saveThreshold", Some(saveThresholdQuery.toParamString(saveThreshold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], adapterCondition: String, taskmanagerAdmingroups: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], adapterConditionQuery: QueryParam[String], taskmanagerAdmingroupsQuery: QueryParam[List[String]]): Task[ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo] = jsonOf[ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo]

    val path = "/system/console/configMgr/com.adobe.granite.taskmanagement.impl.service.TaskManagerAdapterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("adapterCondition", Some(adapter.conditionQuery.toParamString(adapter.condition))), ("taskmanagerAdmingroups", Some(taskmanager.admingroupsQuery.toParamString(taskmanager.admingroups))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteThreaddumpThreadDumpCollector(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerPeriod: Integer, schedulerRunOn: String, graniteThreaddumpEnabled: Boolean, graniteThreaddumpDumpsPerFile: Integer, graniteThreaddumpEnableGzipCompression: Boolean, graniteThreaddumpEnableDirectoriesCompression: Boolean, graniteThreaddumpEnableJStack: Boolean, graniteThreaddumpMaxBackupDays: Integer, graniteThreaddumpBackupCleanTrigger: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerPeriodQuery: QueryParam[Integer], schedulerRunOnQuery: QueryParam[String], graniteThreaddumpEnabledQuery: QueryParam[Boolean], graniteThreaddumpDumpsPerFileQuery: QueryParam[Integer], graniteThreaddumpEnableGzipCompressionQuery: QueryParam[Boolean], graniteThreaddumpEnableDirectoriesCompressionQuery: QueryParam[Boolean], graniteThreaddumpEnableJStackQuery: QueryParam[Boolean], graniteThreaddumpMaxBackupDaysQuery: QueryParam[Integer], graniteThreaddumpBackupCleanTriggerQuery: QueryParam[String]): Task[ComAdobeGraniteThreaddumpThreadDumpCollectorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteThreaddumpThreadDumpCollectorInfo] = jsonOf[ComAdobeGraniteThreaddumpThreadDumpCollectorInfo]

    val path = "/system/console/configMgr/com.adobe.granite.threaddump.ThreadDumpCollector"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerPeriod", Some(scheduler.periodQuery.toParamString(scheduler.period))), ("schedulerRunOn", Some(scheduler.runOnQuery.toParamString(scheduler.runOn))), ("graniteThreaddumpEnabled", Some(granite.threaddump.enabledQuery.toParamString(granite.threaddump.enabled))), ("graniteThreaddumpDumpsPerFile", Some(granite.threaddump.dumpsPerFileQuery.toParamString(granite.threaddump.dumpsPerFile))), ("graniteThreaddumpEnableGzipCompression", Some(granite.threaddump.enableGzipCompressionQuery.toParamString(granite.threaddump.enableGzipCompression))), ("graniteThreaddumpEnableDirectoriesCompression", Some(granite.threaddump.enableDirectoriesCompressionQuery.toParamString(granite.threaddump.enableDirectoriesCompression))), ("graniteThreaddumpEnableJStack", Some(granite.threaddump.enableJStackQuery.toParamString(granite.threaddump.enableJStack))), ("graniteThreaddumpMaxBackupDays", Some(granite.threaddump.maxBackupDaysQuery.toParamString(granite.threaddump.maxBackupDays))), ("graniteThreaddumpBackupCleanTrigger", Some(granite.threaddump.backupCleanTriggerQuery.toParamString(granite.threaddump.backupCleanTrigger))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteThreaddumpThreadDumpCollectorInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTransl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], translationFactory: String, defaultConnectorLabel: String, defaultConnectorAttribution: String, defaultConnectorWorkspaceId: String, defaultConnectorSubscriptionKey: String, languageMapLocation: String, categoryMapLocation: String, retryAttempts: Integer, timeoutCount: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], translationFactoryQuery: QueryParam[String], defaultConnectorLabelQuery: QueryParam[String], defaultConnectorAttributionQuery: QueryParam[String], defaultConnectorWorkspaceIdQuery: QueryParam[String], defaultConnectorSubscriptionKeyQuery: QueryParam[String], languageMapLocationQuery: QueryParam[String], categoryMapLocationQuery: QueryParam[String], retryAttemptsQuery: QueryParam[Integer], timeoutCountQuery: QueryParam[Integer]): Task[ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo] = jsonOf[ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo]

    val path = "/system/console/configMgr/com.adobe.granite.translation.connector.msft.core.impl.MicrosoftTranslationServiceFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("translationFactory", Some(translationFactoryQuery.toParamString(translationFactory))), ("defaultConnectorLabel", Some(defaultConnectorLabelQuery.toParamString(defaultConnectorLabel))), ("defaultConnectorAttribution", Some(defaultConnectorAttributionQuery.toParamString(defaultConnectorAttribution))), ("defaultConnectorWorkspaceId", Some(defaultConnectorWorkspaceIdQuery.toParamString(defaultConnectorWorkspaceId))), ("defaultConnectorSubscriptionKey", Some(defaultConnectorSubscriptionKeyQuery.toParamString(defaultConnectorSubscriptionKey))), ("languageMapLocation", Some(languageMapLocationQuery.toParamString(languageMapLocation))), ("categoryMapLocation", Some(categoryMapLocationQuery.toParamString(categoryMapLocation))), ("retryAttempts", Some(retryAttemptsQuery.toParamString(retryAttempts))), ("timeoutCount", Some(timeoutCountQuery.toParamString(timeoutCount))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteTranslationCoreImplTranslationManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultConnectorName: String, defaultCategory: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultConnectorNameQuery: QueryParam[String], defaultCategoryQuery: QueryParam[String]): Task[ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo] = jsonOf[ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.translation.core.impl.TranslationManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultConnectorName", Some(defaultConnectorNameQuery.toParamString(defaultConnectorName))), ("defaultCategory", Some(defaultCategoryQuery.toParamString(defaultCategory))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteUiClientlibsImplHtmlLibraryManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], htmllibmanagerTiming: Boolean, htmllibmanagerDebugInitJs: String, htmllibmanagerMinify: Boolean, htmllibmanagerDebug: Boolean, htmllibmanagerGzip: Boolean, htmllibmanagerMaxDataUriSize: Integer, htmllibmanagerMaxage: Integer, htmllibmanagerForceCQUrlInfo: Boolean, htmllibmanagerDefaultthemename: String, htmllibmanagerDefaultuserthemename: String, htmllibmanagerClientmanager: String, htmllibmanagerPathList: List[String], htmllibmanagerExcludedPathList: List[String], htmllibmanagerProcessorJs: List[String], htmllibmanagerProcessorCss: List[String], htmllibmanagerLongcachePatterns: List[String], htmllibmanagerLongcacheFormat: String, htmllibmanagerUseFileSystemOutputCache: Boolean, htmllibmanagerFileSystemOutputCacheLocation: String, htmllibmanagerDisableReplacement: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], htmllibmanagerTimingQuery: QueryParam[Boolean], htmllibmanagerDebugInitJsQuery: QueryParam[String], htmllibmanagerMinifyQuery: QueryParam[Boolean], htmllibmanagerDebugQuery: QueryParam[Boolean], htmllibmanagerGzipQuery: QueryParam[Boolean], htmllibmanagerMaxDataUriSizeQuery: QueryParam[Integer], htmllibmanagerMaxageQuery: QueryParam[Integer], htmllibmanagerForceCQUrlInfoQuery: QueryParam[Boolean], htmllibmanagerDefaultthemenameQuery: QueryParam[String], htmllibmanagerDefaultuserthemenameQuery: QueryParam[String], htmllibmanagerClientmanagerQuery: QueryParam[String], htmllibmanagerPathListQuery: QueryParam[List[String]], htmllibmanagerExcludedPathListQuery: QueryParam[List[String]], htmllibmanagerProcessorJsQuery: QueryParam[List[String]], htmllibmanagerProcessorCssQuery: QueryParam[List[String]], htmllibmanagerLongcachePatternsQuery: QueryParam[List[String]], htmllibmanagerLongcacheFormatQuery: QueryParam[String], htmllibmanagerUseFileSystemOutputCacheQuery: QueryParam[Boolean], htmllibmanagerFileSystemOutputCacheLocationQuery: QueryParam[String], htmllibmanagerDisableReplacementQuery: QueryParam[List[String]]): Task[ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo] = jsonOf[ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo]

    val path = "/system/console/configMgr/com.adobe.granite.ui.clientlibs.impl.HtmlLibraryManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("htmllibmanagerTiming", Some(htmllibmanager.timingQuery.toParamString(htmllibmanager.timing))), ("htmllibmanagerDebugInitJs", Some(htmllibmanager.debug.init.jsQuery.toParamString(htmllibmanager.debug.init.js))), ("htmllibmanagerMinify", Some(htmllibmanager.minifyQuery.toParamString(htmllibmanager.minify))), ("htmllibmanagerDebug", Some(htmllibmanager.debugQuery.toParamString(htmllibmanager.debug))), ("htmllibmanagerGzip", Some(htmllibmanager.gzipQuery.toParamString(htmllibmanager.gzip))), ("htmllibmanagerMaxDataUriSize", Some(htmllibmanager.maxDataUriSizeQuery.toParamString(htmllibmanager.maxDataUriSize))), ("htmllibmanagerMaxage", Some(htmllibmanager.maxageQuery.toParamString(htmllibmanager.maxage))), ("htmllibmanagerForceCQUrlInfo", Some(htmllibmanager.forceCQUrlInfoQuery.toParamString(htmllibmanager.forceCQUrlInfo))), ("htmllibmanagerDefaultthemename", Some(htmllibmanager.defaultthemenameQuery.toParamString(htmllibmanager.defaultthemename))), ("htmllibmanagerDefaultuserthemename", Some(htmllibmanager.defaultuserthemenameQuery.toParamString(htmllibmanager.defaultuserthemename))), ("htmllibmanagerClientmanager", Some(htmllibmanager.clientmanagerQuery.toParamString(htmllibmanager.clientmanager))), ("htmllibmanagerPathList", Some(htmllibmanager.path.listQuery.toParamString(htmllibmanager.path.list))), ("htmllibmanagerExcludedPathList", Some(htmllibmanager.excluded.path.listQuery.toParamString(htmllibmanager.excluded.path.list))), ("htmllibmanagerProcessorJs", Some(htmllibmanager.processor.jsQuery.toParamString(htmllibmanager.processor.js))), ("htmllibmanagerProcessorCss", Some(htmllibmanager.processor.cssQuery.toParamString(htmllibmanager.processor.css))), ("htmllibmanagerLongcachePatterns", Some(htmllibmanager.longcache.patternsQuery.toParamString(htmllibmanager.longcache.patterns))), ("htmllibmanagerLongcacheFormat", Some(htmllibmanager.longcache.formatQuery.toParamString(htmllibmanager.longcache.format))), ("htmllibmanagerUseFileSystemOutputCache", Some(htmllibmanager.useFileSystemOutputCacheQuery.toParamString(htmllibmanager.useFileSystemOutputCache))), ("htmllibmanagerFileSystemOutputCacheLocation", Some(htmllibmanager.fileSystemOutputCacheLocationQuery.toParamString(htmllibmanager.fileSystemOutputCacheLocation))), ("htmllibmanagerDisableReplacement", Some(htmllibmanager.disable.replacementQuery.toParamString(htmllibmanager.disable.replacement))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeature(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo] = jsonOf[ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.console.frags.WorkflowWithdrawFeature"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowConsolePublishWorkflowPublishEventService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], graniteWorkflowWorkflowPublishEventServiceEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], graniteWorkflowWorkflowPublishEventServiceEnabledQuery: QueryParam[Boolean]): Task[ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo] = jsonOf[ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.console.publish.WorkflowPublishEventService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("graniteWorkflowWorkflowPublishEventServiceEnabled", Some(granite.workflow.WorkflowPublishEventService.enabledQuery.toParamString(granite.workflow.WorkflowPublishEventService.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCoreJcrWorkflowBucketManager(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], bucketSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], bucketSizeQuery: QueryParam[Integer]): Task[ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo] = jsonOf[ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.jcr.WorkflowBucketManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("bucketSize", Some(bucketSizeQuery.toParamString(bucketSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCoreJobExternalProcessJobHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultTimeout: Integer, maxTimeout: Integer, defaultPeriod: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultTimeoutQuery: QueryParam[Integer], maxTimeoutQuery: QueryParam[Integer], defaultPeriodQuery: QueryParam[Integer]): Task[ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo] = jsonOf[ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.job.ExternalProcessJobHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultTimeout", Some(default.timeoutQuery.toParamString(default.timeout))), ("maxTimeout", Some(max.timeoutQuery.toParamString(max.timeout))), ("defaultPeriod", Some(default.periodQuery.toParamString(default.period))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCoreJobJobHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jobTopics: List[String], allowSelfProcessTermination: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jobTopicsQuery: QueryParam[List[String]], allowSelfProcessTerminationQuery: QueryParam[Boolean]): Task[ComAdobeGraniteWorkflowCoreJobJobHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCoreJobJobHandlerInfo] = jsonOf[ComAdobeGraniteWorkflowCoreJobJobHandlerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.job.JobHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jobTopics", Some(job.topicsQuery.toParamString(job.topics))), ("allowSelfProcessTermination", Some(allow.self.process.terminationQuery.toParamString(allow.self.process.termination))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCoreJobJobHandlerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsum(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jobTopics: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jobTopicsQuery: QueryParam[String]): Task[ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo] = jsonOf[ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.offloading.WorkflowOffloadingJobConsumer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jobTopics", Some(job.topicsQuery.toParamString(job.topics))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCorePayloadMapCache(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], getSystemWorkflowModels: List[String], getPackageRootPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], getSystemWorkflowModelsQuery: QueryParam[List[String]], getPackageRootPathQuery: QueryParam[String]): Task[ComAdobeGraniteWorkflowCorePayloadMapCacheInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCorePayloadMapCacheInfo] = jsonOf[ComAdobeGraniteWorkflowCorePayloadMapCacheInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.PayloadMapCache"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("getSystemWorkflowModels", Some(getSystemWorkflowModelsQuery.toParamString(getSystemWorkflowModels))), ("getPackageRootPath", Some(getPackageRootPathQuery.toParamString(getPackageRootPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCorePayloadMapCacheInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCorePayloadmapPayloadMoveListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], payloadMoveWhiteList: List[String], payloadMoveHandleFromWorkflowProcess: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], payloadMoveWhiteListQuery: QueryParam[List[String]], payloadMoveHandleFromWorkflowProcessQuery: QueryParam[Boolean]): Task[ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo] = jsonOf[ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.payloadmap.PayloadMoveListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("payloadMoveWhiteList", Some(payload.move.white.listQuery.toParamString(payload.move.white.list))), ("payloadMoveHandleFromWorkflowProcess", Some(payload.move.handle.from.workflow.processQuery.toParamString(payload.move.handle.from.workflow.process))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCoreWorkflowConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWorkflowConfigWorkflowPackagesRootPath: List[String], cqWorkflowConfigWorkflowProcessLegacyMode: Boolean, cqWorkflowConfigAllowLocking: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWorkflowConfigWorkflowPackagesRootPathQuery: QueryParam[List[String]], cqWorkflowConfigWorkflowProcessLegacyModeQuery: QueryParam[Boolean], cqWorkflowConfigAllowLockingQuery: QueryParam[Boolean]): Task[ComAdobeGraniteWorkflowCoreWorkflowConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCoreWorkflowConfigInfo] = jsonOf[ComAdobeGraniteWorkflowCoreWorkflowConfigInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.WorkflowConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWorkflowConfigWorkflowPackagesRootPath", Some(cq.workflow.config.workflow.packages.root.pathQuery.toParamString(cq.workflow.config.workflow.packages.root.path))), ("cqWorkflowConfigWorkflowProcessLegacyMode", Some(cq.workflow.config.workflow.process.legacy.modeQuery.toParamString(cq.workflow.config.workflow.process.legacy.mode))), ("cqWorkflowConfigAllowLocking", Some(cq.workflow.config.allow.lockingQuery.toParamString(cq.workflow.config.allow.locking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCoreWorkflowConfigInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowCoreWorkflowSessionFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], graniteWorkflowinboxSortPropertyName: String, graniteWorkflowinboxSortOrder: String, cqWorkflowJobRetry: Integer, cqWorkflowSuperuser: List[String], graniteWorkflowInboxQuerySize: Integer, graniteWorkflowAdminUserGroupFilter: Boolean, graniteWorkflowEnforceWorkitemAssigneePermissions: Boolean, graniteWorkflowEnforceWorkflowInitiatorPermissions: Boolean, graniteWorkflowInjectTenantIdInJobTopics: Boolean, graniteWorkflowMaxPurgeSaveThreshold: Integer, graniteWorkflowMaxPurgeQueryCount: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], graniteWorkflowinboxSortPropertyNameQuery: QueryParam[String], graniteWorkflowinboxSortOrderQuery: QueryParam[String], cqWorkflowJobRetryQuery: QueryParam[Integer], cqWorkflowSuperuserQuery: QueryParam[List[String]], graniteWorkflowInboxQuerySizeQuery: QueryParam[Integer], graniteWorkflowAdminUserGroupFilterQuery: QueryParam[Boolean], graniteWorkflowEnforceWorkitemAssigneePermissionsQuery: QueryParam[Boolean], graniteWorkflowEnforceWorkflowInitiatorPermissionsQuery: QueryParam[Boolean], graniteWorkflowInjectTenantIdInJobTopicsQuery: QueryParam[Boolean], graniteWorkflowMaxPurgeSaveThresholdQuery: QueryParam[Integer], graniteWorkflowMaxPurgeQueryCountQuery: QueryParam[Integer]): Task[ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo] = jsonOf[ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.core.WorkflowSessionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("graniteWorkflowinboxSortPropertyName", Some(granite.workflowinbox.sort.propertyNameQuery.toParamString(granite.workflowinbox.sort.propertyName))), ("graniteWorkflowinboxSortOrder", Some(granite.workflowinbox.sort.orderQuery.toParamString(granite.workflowinbox.sort.order))), ("cqWorkflowJobRetry", Some(cq.workflow.job.retryQuery.toParamString(cq.workflow.job.retry))), ("cqWorkflowSuperuser", Some(cq.workflow.superuserQuery.toParamString(cq.workflow.superuser))), ("graniteWorkflowInboxQuerySize", Some(granite.workflow.inboxQuerySizeQuery.toParamString(granite.workflow.inboxQuerySize))), ("graniteWorkflowAdminUserGroupFilter", Some(granite.workflow.adminUserGroupFilterQuery.toParamString(granite.workflow.adminUserGroupFilter))), ("graniteWorkflowEnforceWorkitemAssigneePermissions", Some(granite.workflow.enforceWorkitemAssigneePermissionsQuery.toParamString(granite.workflow.enforceWorkitemAssigneePermissions))), ("graniteWorkflowEnforceWorkflowInitiatorPermissions", Some(granite.workflow.enforceWorkflowInitiatorPermissionsQuery.toParamString(granite.workflow.enforceWorkflowInitiatorPermissions))), ("graniteWorkflowInjectTenantIdInJobTopics", Some(granite.workflow.injectTenantIdInJobTopicsQuery.toParamString(granite.workflow.injectTenantIdInJobTopics))), ("graniteWorkflowMaxPurgeSaveThreshold", Some(granite.workflow.maxPurgeSaveThresholdQuery.toParamString(granite.workflow.maxPurgeSaveThreshold))), ("graniteWorkflowMaxPurgeQueryCount", Some(granite.workflow.maxPurgeQueryCountQuery.toParamString(granite.workflow.maxPurgeQueryCount))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo](req)

    } yield resp
  }
  
  def comAdobeGraniteWorkflowPurgeScheduler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], scheduledpurgeName: String, scheduledpurgeWorkflowStatus: String, scheduledpurgeModelIds: List[String], scheduledpurgeDaysold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], scheduledpurgeNameQuery: QueryParam[String], scheduledpurgeWorkflowStatusQuery: QueryParam[String], scheduledpurgeModelIdsQuery: QueryParam[List[String]], scheduledpurgeDaysoldQuery: QueryParam[Integer]): Task[ComAdobeGraniteWorkflowPurgeSchedulerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeGraniteWorkflowPurgeSchedulerInfo] = jsonOf[ComAdobeGraniteWorkflowPurgeSchedulerInfo]

    val path = "/system/console/configMgr/com.adobe.granite.workflow.purge.Scheduler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("scheduledpurgeName", Some(scheduledpurge.nameQuery.toParamString(scheduledpurge.name))), ("scheduledpurgeWorkflowStatus", Some(scheduledpurge.workflowStatusQuery.toParamString(scheduledpurge.workflowStatus))), ("scheduledpurgeModelIds", Some(scheduledpurge.modelIdsQuery.toParamString(scheduledpurge.modelIds))), ("scheduledpurgeDaysold", Some(scheduledpurge.daysoldQuery.toParamString(scheduledpurge.daysold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeGraniteWorkflowPurgeSchedulerInfo](req)

    } yield resp
  }
  
  def comAdobeOctopusNcommBootstrap(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxConnections: Integer, maxRequests: Integer, requestTimeout: Integer, requestRetries: Integer, launchTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxConnectionsQuery: QueryParam[Integer], maxRequestsQuery: QueryParam[Integer], requestTimeoutQuery: QueryParam[Integer], requestRetriesQuery: QueryParam[Integer], launchTimeoutQuery: QueryParam[Integer]): Task[ComAdobeOctopusNcommBootstrapInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeOctopusNcommBootstrapInfo] = jsonOf[ComAdobeOctopusNcommBootstrapInfo]

    val path = "/system/console/configMgr/com.adobe.octopus.ncomm.bootstrap"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxConnections", Some(maxConnectionsQuery.toParamString(maxConnections))), ("maxRequests", Some(maxRequestsQuery.toParamString(maxRequests))), ("requestTimeout", Some(requestTimeoutQuery.toParamString(requestTimeout))), ("requestRetries", Some(requestRetriesQuery.toParamString(requestRetries))), ("launchTimeout", Some(launchTimeoutQuery.toParamString(launchTimeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeOctopusNcommBootstrapInfo](req)

    } yield resp
  }
  
  def comAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullS(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], communitiesIntegrationLivefyreSlingEventFilter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], communitiesIntegrationLivefyreSlingEventFilterQuery: QueryParam[String]): Task[ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo] = jsonOf[ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo]

    val path = "/system/console/configMgr/com.adobe.social.integrations.livefyre.user.pingforpull.impl.PingPullServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("communitiesIntegrationLivefyreSlingEventFilter", Some(communities.integration.livefyre.sling.event.filterQuery.toParamString(communities.integration.livefyre.sling.event.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo](req)

    } yield resp
  }
  
  def comAdobeXmpWorkerFilesNcommXMPFilesNComm(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxConnections: String, maxRequests: String, requestTimeout: String, logDir: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxConnectionsQuery: QueryParam[String], maxRequestsQuery: QueryParam[String], requestTimeoutQuery: QueryParam[String], logDirQuery: QueryParam[String]): Task[ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo] = jsonOf[ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo]

    val path = "/system/console/configMgr/com.adobe.xmp.worker.files.ncomm.XMPFilesNComm"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxConnections", Some(maxConnectionsQuery.toParamString(maxConnections))), ("maxRequests", Some(maxRequestsQuery.toParamString(maxRequests))), ("requestTimeout", Some(requestTimeoutQuery.toParamString(requestTimeout))), ("logDir", Some(logDirQuery.toParamString(logDir))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo](req)

    } yield resp
  }
  
  def comDayCommonsDatasourceJdbcpoolJdbcPoolService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jdbcDriverClass: String, jdbcConnectionUri: String, jdbcUsername: String, jdbcPassword: String, jdbcValidationQuery: String, defaultReadonly: Boolean, defaultAutocommit: Boolean, poolSize: Integer, poolMaxWaitMsec: Integer, datasourceName: String, datasourceSvcProperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jdbcDriverClassQuery: QueryParam[String], jdbcConnectionUriQuery: QueryParam[String], jdbcUsernameQuery: QueryParam[String], jdbcPasswordQuery: QueryParam[String], jdbcValidationQueryQuery: QueryParam[String], defaultReadonlyQuery: QueryParam[Boolean], defaultAutocommitQuery: QueryParam[Boolean], poolSizeQuery: QueryParam[Integer], poolMaxWaitMsecQuery: QueryParam[Integer], datasourceNameQuery: QueryParam[String], datasourceSvcPropertiesQuery: QueryParam[List[String]]): Task[ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo] = jsonOf[ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo]

    val path = "/system/console/configMgr/com.day.commons.datasource.jdbcpool.JdbcPoolService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jdbcDriverClass", Some(jdbc.driver.classQuery.toParamString(jdbc.driver.class))), ("jdbcConnectionUri", Some(jdbc.connection.uriQuery.toParamString(jdbc.connection.uri))), ("jdbcUsername", Some(jdbc.usernameQuery.toParamString(jdbc.username))), ("jdbcPassword", Some(jdbc.passwordQuery.toParamString(jdbc.password))), ("jdbcValidationQuery", Some(jdbc.validation.queryQuery.toParamString(jdbc.validation.query))), ("defaultReadonly", Some(default.readonlyQuery.toParamString(default.readonly))), ("defaultAutocommit", Some(default.autocommitQuery.toParamString(default.autocommit))), ("poolSize", Some(pool.sizeQuery.toParamString(pool.size))), ("poolMaxWaitMsec", Some(pool.max.wait.msecQuery.toParamString(pool.max.wait.msec))), ("datasourceName", Some(datasource.nameQuery.toParamString(datasource.name))), ("datasourceSvcProperties", Some(datasource.svc.propertiesQuery.toParamString(datasource.svc.properties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo](req)

    } yield resp
  }
  
  def comDayCommonsHttpclient(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], proxyEnabled: Boolean, proxyHost: String, proxyUser: String, proxyPassword: String, proxyNtlmHost: String, proxyNtlmDomain: String, proxyExceptions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], proxyEnabledQuery: QueryParam[Boolean], proxyHostQuery: QueryParam[String], proxyUserQuery: QueryParam[String], proxyPasswordQuery: QueryParam[String], proxyNtlmHostQuery: QueryParam[String], proxyNtlmDomainQuery: QueryParam[String], proxyExceptionsQuery: QueryParam[List[String]]): Task[ComDayCommonsHttpclientInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCommonsHttpclientInfo] = jsonOf[ComDayCommonsHttpclientInfo]

    val path = "/system/console/configMgr/com.day.commons.httpclient"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("proxyEnabled", Some(proxy.enabledQuery.toParamString(proxy.enabled))), ("proxyHost", Some(proxy.hostQuery.toParamString(proxy.host))), ("proxyUser", Some(proxy.userQuery.toParamString(proxy.user))), ("proxyPassword", Some(proxy.passwordQuery.toParamString(proxy.password))), ("proxyNtlmHost", Some(proxy.ntlm.hostQuery.toParamString(proxy.ntlm.host))), ("proxyNtlmDomain", Some(proxy.ntlm.domainQuery.toParamString(proxy.ntlm.domain))), ("proxyExceptions", Some(proxy.exceptionsQuery.toParamString(proxy.exceptions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCommonsHttpclientInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsImplStorePropertiesChangeListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqStoreListenerAdditionalStorePaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqStoreListenerAdditionalStorePathsQuery: QueryParam[List[String]]): Task[ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo] = jsonOf[ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.impl.StorePropertiesChangeListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqStoreListenerAdditionalStorePaths", Some(cq.store.listener.additionalStorePathsQuery.toParamString(cq.store.listener.additionalStorePaths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsSitecatalystImplExporterClassificationsExporte(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], allowedPaths: List[String], cqAnalyticsSaintExporterPagesize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], allowedPathsQuery: QueryParam[List[String]], cqAnalyticsSaintExporterPagesizeQuery: QueryParam[Integer]): Task[ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo] = jsonOf[ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.exporter.ClassificationsExporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("allowedPaths", Some(allowed.pathsQuery.toParamString(allowed.paths))), ("cqAnalyticsSaintExporterPagesize", Some(cq.analytics.saint.exporter.pagesizeQuery.toParamString(cq.analytics.saint.exporter.pagesize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsSitecatalystImplImporterReportImporter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], reportFetchAttempts: Integer, reportFetchDelay: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], reportFetchAttemptsQuery: QueryParam[Integer], reportFetchDelayQuery: QueryParam[Integer]): Task[ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo] = jsonOf[ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.importer.ReportImporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("reportFetchAttempts", Some(report.fetch.attemptsQuery.toParamString(report.fetch.attempts))), ("reportFetchDelay", Some(report.fetch.delayQuery.toParamString(report.fetch.delay))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsAdapterfactoryContextstores: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsAdapterfactoryContextstoresQuery: QueryParam[List[String]]): Task[ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo] = jsonOf[ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.SitecatalystAdapterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsAdapterfactoryContextstores", Some(cq.analytics.adapterfactory.contextstoresQuery.toParamString(cq.analytics.adapterfactory.contextstores))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsSitecatalystServiceDatacenterUrl: List[String], devhostnamepatterns: List[String], connectionTimeout: Integer, socketTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsSitecatalystServiceDatacenterUrlQuery: QueryParam[List[String]], devhostnamepatternsQuery: QueryParam[List[String]], connectionTimeoutQuery: QueryParam[Integer], socketTimeoutQuery: QueryParam[Integer]): Task[ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo] = jsonOf[ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.SitecatalystHttpClientImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsSitecatalystServiceDatacenterUrl", Some(cq.analytics.sitecatalyst.service.datacenter.urlQuery.toParamString(cq.analytics.sitecatalyst.service.datacenter.url))), ("devhostnamepatterns", Some(devhostnamepatternsQuery.toParamString(devhostnamepatterns))), ("connectionTimeout", Some(connection.timeoutQuery.toParamString(connection.timeout))), ("socketTimeout", Some(socket.timeoutQuery.toParamString(socket.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplAccountOptionsUpdater(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsTestandtargetAccountoptionsupdaterEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsTestandtargetAccountoptionsupdaterEnabledQuery: QueryParam[Boolean]): Task[ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.AccountOptionsUpdater"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsTestandtargetAccountoptionsupdaterEnabled", Some(cq.analytics.testandtarget.accountoptionsupdater.enabledQuery.toParamString(cq.analytics.testandtarget.accountoptionsupdater.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabledQuery: QueryParam[Boolean]): Task[ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.DeleteAuthorActivityListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabled", Some(cq.analytics.testandtarget.deleteauthoractivitylistener.enabledQuery.toParamString(cq.analytics.testandtarget.deleteauthoractivitylistener.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabledQuery: QueryParam[Boolean]): Task[ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.PushAuthorCampaignPageListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabled", Some(cq.analytics.testandtarget.pushauthorcampaignpagelistener.enabledQuery.toParamString(cq.analytics.testandtarget.pushauthorcampaignpagelistener.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplSegmentImporter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsTestandtargetSegmentimporterEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsTestandtargetSegmentimporterEnabledQuery: QueryParam[Boolean]): Task[ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.SegmentImporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsTestandtargetSegmentimporterEnabled", Some(cq.analytics.testandtarget.segmentimporter.enabledQuery.toParamString(cq.analytics.testandtarget.segmentimporter.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplServiceWebServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], endpointUri: String, connectionTimeout: Integer, socketTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], endpointUriQuery: QueryParam[String], connectionTimeoutQuery: QueryParam[Integer], socketTimeoutQuery: QueryParam[Integer]): Task[ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.service.WebServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("endpointUri", Some(endpointUriQuery.toParamString(endpointUri))), ("connectionTimeout", Some(connectionTimeoutQuery.toParamString(connectionTimeout))), ("socketTimeout", Some(socketTimeoutQuery.toParamString(socketTimeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplServletsAdminServerServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], testandtargetEndpointUrl: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], testandtargetEndpointUrlQuery: QueryParam[String]): Task[ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.servlets.AdminServerServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("testandtargetEndpointUrl", Some(testandtarget.endpoint.urlQuery.toParamString(testandtarget.endpoint.url))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo](req)

    } yield resp
  }
  
  def comDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAnalyticsTestandtargetApiUrl: String, cqAnalyticsTestandtargetTimeout: Integer, cqAnalyticsTestandtargetSockettimeout: Integer, cqAnalyticsTestandtargetRecommendationsUrlReplace: String, cqAnalyticsTestandtargetRecommendationsUrlReplacewith: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAnalyticsTestandtargetApiUrlQuery: QueryParam[String], cqAnalyticsTestandtargetTimeoutQuery: QueryParam[Integer], cqAnalyticsTestandtargetSockettimeoutQuery: QueryParam[Integer], cqAnalyticsTestandtargetRecommendationsUrlReplaceQuery: QueryParam[String], cqAnalyticsTestandtargetRecommendationsUrlReplacewithQuery: QueryParam[String]): Task[ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo] = jsonOf[ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo]

    val path = "/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.TestandtargetHttpClientImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAnalyticsTestandtargetApiUrl", Some(cq.analytics.testandtarget.api.urlQuery.toParamString(cq.analytics.testandtarget.api.url))), ("cqAnalyticsTestandtargetTimeout", Some(cq.analytics.testandtarget.timeoutQuery.toParamString(cq.analytics.testandtarget.timeout))), ("cqAnalyticsTestandtargetSockettimeout", Some(cq.analytics.testandtarget.sockettimeoutQuery.toParamString(cq.analytics.testandtarget.sockettimeout))), ("cqAnalyticsTestandtargetRecommendationsUrlReplace", Some(cq.analytics.testandtarget.recommendations.url.replaceQuery.toParamString(cq.analytics.testandtarget.recommendations.url.replace))), ("cqAnalyticsTestandtargetRecommendationsUrlReplacewith", Some(cq.analytics.testandtarget.recommendations.url.replacewithQuery.toParamString(cq.analytics.testandtarget.recommendations.url.replacewith))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo](req)

    } yield resp
  }
  
  def comDayCqAuthImplCugCugSupportImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cugExemptedPrincipals: List[String], cugEnabled: Boolean, cugPrincipalsRegex: String, cugPrincipalsReplacement: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cugExemptedPrincipalsQuery: QueryParam[List[String]], cugEnabledQuery: QueryParam[Boolean], cugPrincipalsRegexQuery: QueryParam[String], cugPrincipalsReplacementQuery: QueryParam[String]): Task[ComDayCqAuthImplCugCugSupportImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAuthImplCugCugSupportImplInfo] = jsonOf[ComDayCqAuthImplCugCugSupportImplInfo]

    val path = "/system/console/configMgr/com.day.cq.auth.impl.cug.CugSupportImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cugExemptedPrincipals", Some(cug.exempted.principalsQuery.toParamString(cug.exempted.principals))), ("cugEnabled", Some(cug.enabledQuery.toParamString(cug.enabled))), ("cugPrincipalsRegex", Some(cug.principals.regexQuery.toParamString(cug.principals.regex))), ("cugPrincipalsReplacement", Some(cug.principals.replacementQuery.toParamString(cug.principals.replacement))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAuthImplCugCugSupportImplInfo](req)

    } yield resp
  }
  
  def comDayCqAuthImplLoginSelectorHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, serviceRanking: Integer, authLoginselectorMappings: List[String], authLoginselectorChangepwMappings: List[String], authLoginselectorDefaultloginpage: String, authLoginselectorDefaultchangepwpage: String, authLoginselectorHandle: List[String], authLoginselectorHandleAllExtensions: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], serviceRankingQuery: QueryParam[Integer], authLoginselectorMappingsQuery: QueryParam[List[String]], authLoginselectorChangepwMappingsQuery: QueryParam[List[String]], authLoginselectorDefaultloginpageQuery: QueryParam[String], authLoginselectorDefaultchangepwpageQuery: QueryParam[String], authLoginselectorHandleQuery: QueryParam[List[String]], authLoginselectorHandleAllExtensionsQuery: QueryParam[Boolean]): Task[ComDayCqAuthImplLoginSelectorHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqAuthImplLoginSelectorHandlerInfo] = jsonOf[ComDayCqAuthImplLoginSelectorHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.auth.impl.LoginSelectorHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("authLoginselectorMappings", Some(auth.loginselector.mappingsQuery.toParamString(auth.loginselector.mappings))), ("authLoginselectorChangepwMappings", Some(auth.loginselector.changepw.mappingsQuery.toParamString(auth.loginselector.changepw.mappings))), ("authLoginselectorDefaultloginpage", Some(auth.loginselector.defaultloginpageQuery.toParamString(auth.loginselector.defaultloginpage))), ("authLoginselectorDefaultchangepwpage", Some(auth.loginselector.defaultchangepwpageQuery.toParamString(auth.loginselector.defaultchangepwpage))), ("authLoginselectorHandle", Some(auth.loginselector.handleQuery.toParamString(auth.loginselector.handle))), ("authLoginselectorHandleAllExtensions", Some(auth.loginselector.handle.all.extensionsQuery.toParamString(auth.loginselector.handle.all.extensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqAuthImplLoginSelectorHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqCommonsImplExternalizerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], externalizerDomains: List[String], externalizerHost: String, externalizerContextpath: String, externalizerEncodedpath: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], externalizerDomainsQuery: QueryParam[List[String]], externalizerHostQuery: QueryParam[String], externalizerContextpathQuery: QueryParam[String], externalizerEncodedpathQuery: QueryParam[Boolean]): Task[ComDayCqCommonsImplExternalizerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqCommonsImplExternalizerImplInfo] = jsonOf[ComDayCqCommonsImplExternalizerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.commons.impl.ExternalizerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("externalizerDomains", Some(externalizer.domainsQuery.toParamString(externalizer.domains))), ("externalizerHost", Some(externalizer.hostQuery.toParamString(externalizer.host))), ("externalizerContextpath", Some(externalizer.contextpathQuery.toParamString(externalizer.contextpath))), ("externalizerEncodedpath", Some(externalizer.encodedpathQuery.toParamString(externalizer.encodedpath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqCommonsImplExternalizerImplInfo](req)

    } yield resp
  }
  
  def comDayCqCommonsServletsRootMappingServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], rootmappingTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], rootmappingTargetQuery: QueryParam[String]): Task[ComDayCqCommonsServletsRootMappingServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqCommonsServletsRootMappingServletInfo] = jsonOf[ComDayCqCommonsServletsRootMappingServletInfo]

    val path = "/system/console/configMgr/com.day.cq.commons.servlets.RootMappingServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("rootmappingTarget", Some(rootmapping.targetQuery.toParamString(rootmapping.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqCommonsServletsRootMappingServletInfo](req)

    } yield resp
  }
  
  def comDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionChecke(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], codeupgradetasks: List[String], codeupgradetaskfilters: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], codeupgradetasksQuery: QueryParam[List[String]], codeupgradetaskfiltersQuery: QueryParam[List[String]]): Task[ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo] = jsonOf[ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo]

    val path = "/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.CodeUpgradeExecutionConditionChecker"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("codeupgradetasks", Some(codeupgradetasksQuery.toParamString(codeupgradetasks))), ("codeupgradetaskfilters", Some(codeupgradetaskfiltersQuery.toParamString(codeupgradetaskfilters))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo](req)

    } yield resp
  }
  
  def comDayCqCompatCodeupgradeImplUpgradeTaskIgnoreList(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], upgradeTaskIgnoreList: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], upgradeTaskIgnoreListQuery: QueryParam[List[String]]): Task[ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo] = jsonOf[ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo]

    val path = "/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.UpgradeTaskIgnoreList"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("upgradeTaskIgnoreList", Some(upgradeTaskIgnoreListQuery.toParamString(upgradeTaskIgnoreList))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo](req)

    } yield resp
  }
  
  def comDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelist(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], effectiveBundleListPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], effectiveBundleListPathQuery: QueryParam[String]): Task[ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo] = jsonOf[ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo]

    val path = "/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.VersionRangeTaskIgnorelist"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("effectiveBundleListPath", Some(effectiveBundleListPathQuery.toParamString(effectiveBundleListPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo](req)

    } yield resp
  }
  
  def comDayCqContentsyncImplContentSyncManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], contentsyncFallbackAuthorizable: String, contentsyncFallbackUpdateuser: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], contentsyncFallbackAuthorizableQuery: QueryParam[String], contentsyncFallbackUpdateuserQuery: QueryParam[String]): Task[ComDayCqContentsyncImplContentSyncManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqContentsyncImplContentSyncManagerImplInfo] = jsonOf[ComDayCqContentsyncImplContentSyncManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.contentsync.impl.ContentSyncManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("contentsyncFallbackAuthorizable", Some(contentsync.fallback.authorizableQuery.toParamString(contentsync.fallback.authorizable))), ("contentsyncFallbackUpdateuser", Some(contentsync.fallback.updateuserQuery.toParamString(contentsync.fallback.updateuser))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqContentsyncImplContentSyncManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCommonsHandlerStandardImageHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], largeFileThreshold: Integer, largeCommentThreshold: Integer, cqDamEnableExtMetaExtraction: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], largeFileThresholdQuery: QueryParam[Integer], largeCommentThresholdQuery: QueryParam[Integer], cqDamEnableExtMetaExtractionQuery: QueryParam[Boolean]): Task[ComDayCqDamCommonsHandlerStandardImageHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCommonsHandlerStandardImageHandlerInfo] = jsonOf[ComDayCqDamCommonsHandlerStandardImageHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.commons.handler.StandardImageHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("largeFileThreshold", Some(large_file_thresholdQuery.toParamString(large_file_threshold))), ("largeCommentThreshold", Some(large_comment_thresholdQuery.toParamString(large_comment_threshold))), ("cqDamEnableExtMetaExtraction", Some(cq.dam.enable.ext.meta.extractionQuery.toParamString(cq.dam.enable.ext.meta.extraction))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCommonsHandlerStandardImageHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCommonsMetadataXmpFilterBlackWhite(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], xmpFilterApplyWhitelist: Boolean, xmpFilterWhitelist: List[String], xmpFilterApplyBlacklist: Boolean, xmpFilterBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], xmpFilterApplyWhitelistQuery: QueryParam[Boolean], xmpFilterWhitelistQuery: QueryParam[List[String]], xmpFilterApplyBlacklistQuery: QueryParam[Boolean], xmpFilterBlacklistQuery: QueryParam[List[String]]): Task[ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo] = jsonOf[ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.commons.metadata.XmpFilterBlackWhite"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("xmpFilterApplyWhitelist", Some(xmp.filter.apply_whitelistQuery.toParamString(xmp.filter.apply_whitelist))), ("xmpFilterWhitelist", Some(xmp.filter.whitelistQuery.toParamString(xmp.filter.whitelist))), ("xmpFilterApplyBlacklist", Some(xmp.filter.apply_blacklistQuery.toParamString(xmp.filter.apply_blacklist))), ("xmpFilterBlacklist", Some(xmp.filter.blacklistQuery.toParamString(xmp.filter.blacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo](req)

    } yield resp
  }
  
  def comDayCqDamCommonsUtilImplAssetCacheImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], largeFileMin: Integer, cacheApply: Boolean, mimeTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], largeFileMinQuery: QueryParam[Integer], cacheApplyQuery: QueryParam[Boolean], mimeTypesQuery: QueryParam[List[String]]): Task[ComDayCqDamCommonsUtilImplAssetCacheImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCommonsUtilImplAssetCacheImplInfo] = jsonOf[ComDayCqDamCommonsUtilImplAssetCacheImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.commons.util.impl.AssetCacheImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("largeFileMin", Some(large.file.minQuery.toParamString(large.file.min))), ("cacheApply", Some(cache.applyQuery.toParamString(cache.apply))), ("mimeTypes", Some(mime.typesQuery.toParamString(mime.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCommonsUtilImplAssetCacheImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplAnnotationPdfAnnotationPdfConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamConfigAnnotationPdfDocumentWidth: Integer, cqDamConfigAnnotationPdfDocumentHeight: Integer, cqDamConfigAnnotationPdfDocumentPaddingHorizontal: Integer, cqDamConfigAnnotationPdfDocumentPaddingVertical: Integer, cqDamConfigAnnotationPdfFontSize: Integer, cqDamConfigAnnotationPdfFontColor: String, cqDamConfigAnnotationPdfFontFamily: String, cqDamConfigAnnotationPdfFontLight: String, cqDamConfigAnnotationPdfMarginTextImage: Integer, cqDamConfigAnnotationPdfMinImageHeight: Integer, cqDamConfigAnnotationPdfReviewStatusWidth: Integer, cqDamConfigAnnotationPdfReviewStatusColorApproved: String, cqDamConfigAnnotationPdfReviewStatusColorRejected: String, cqDamConfigAnnotationPdfReviewStatusColorChangesRequested: String, cqDamConfigAnnotationPdfAnnotationMarkerWidth: Integer, cqDamConfigAnnotationPdfAssetMinheight: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamConfigAnnotationPdfDocumentWidthQuery: QueryParam[Integer], cqDamConfigAnnotationPdfDocumentHeightQuery: QueryParam[Integer], cqDamConfigAnnotationPdfDocumentPaddingHorizontalQuery: QueryParam[Integer], cqDamConfigAnnotationPdfDocumentPaddingVerticalQuery: QueryParam[Integer], cqDamConfigAnnotationPdfFontSizeQuery: QueryParam[Integer], cqDamConfigAnnotationPdfFontColorQuery: QueryParam[String], cqDamConfigAnnotationPdfFontFamilyQuery: QueryParam[String], cqDamConfigAnnotationPdfFontLightQuery: QueryParam[String], cqDamConfigAnnotationPdfMarginTextImageQuery: QueryParam[Integer], cqDamConfigAnnotationPdfMinImageHeightQuery: QueryParam[Integer], cqDamConfigAnnotationPdfReviewStatusWidthQuery: QueryParam[Integer], cqDamConfigAnnotationPdfReviewStatusColorApprovedQuery: QueryParam[String], cqDamConfigAnnotationPdfReviewStatusColorRejectedQuery: QueryParam[String], cqDamConfigAnnotationPdfReviewStatusColorChangesRequestedQuery: QueryParam[String], cqDamConfigAnnotationPdfAnnotationMarkerWidthQuery: QueryParam[Integer], cqDamConfigAnnotationPdfAssetMinheightQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo] = jsonOf[ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.annotation.pdf.AnnotationPdfConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamConfigAnnotationPdfDocumentWidth", Some(cq.dam.config.annotation.pdf.document.widthQuery.toParamString(cq.dam.config.annotation.pdf.document.width))), ("cqDamConfigAnnotationPdfDocumentHeight", Some(cq.dam.config.annotation.pdf.document.heightQuery.toParamString(cq.dam.config.annotation.pdf.document.height))), ("cqDamConfigAnnotationPdfDocumentPaddingHorizontal", Some(cq.dam.config.annotation.pdf.document.padding.horizontalQuery.toParamString(cq.dam.config.annotation.pdf.document.padding.horizontal))), ("cqDamConfigAnnotationPdfDocumentPaddingVertical", Some(cq.dam.config.annotation.pdf.document.padding.verticalQuery.toParamString(cq.dam.config.annotation.pdf.document.padding.vertical))), ("cqDamConfigAnnotationPdfFontSize", Some(cq.dam.config.annotation.pdf.font.sizeQuery.toParamString(cq.dam.config.annotation.pdf.font.size))), ("cqDamConfigAnnotationPdfFontColor", Some(cq.dam.config.annotation.pdf.font.colorQuery.toParamString(cq.dam.config.annotation.pdf.font.color))), ("cqDamConfigAnnotationPdfFontFamily", Some(cq.dam.config.annotation.pdf.font.familyQuery.toParamString(cq.dam.config.annotation.pdf.font.family))), ("cqDamConfigAnnotationPdfFontLight", Some(cq.dam.config.annotation.pdf.font.lightQuery.toParamString(cq.dam.config.annotation.pdf.font.light))), ("cqDamConfigAnnotationPdfMarginTextImage", Some(cq.dam.config.annotation.pdf.marginTextImageQuery.toParamString(cq.dam.config.annotation.pdf.marginTextImage))), ("cqDamConfigAnnotationPdfMinImageHeight", Some(cq.dam.config.annotation.pdf.minImageHeightQuery.toParamString(cq.dam.config.annotation.pdf.minImageHeight))), ("cqDamConfigAnnotationPdfReviewStatusWidth", Some(cq.dam.config.annotation.pdf.reviewStatus.widthQuery.toParamString(cq.dam.config.annotation.pdf.reviewStatus.width))), ("cqDamConfigAnnotationPdfReviewStatusColorApproved", Some(cq.dam.config.annotation.pdf.reviewStatus.color.approvedQuery.toParamString(cq.dam.config.annotation.pdf.reviewStatus.color.approved))), ("cqDamConfigAnnotationPdfReviewStatusColorRejected", Some(cq.dam.config.annotation.pdf.reviewStatus.color.rejectedQuery.toParamString(cq.dam.config.annotation.pdf.reviewStatus.color.rejected))), ("cqDamConfigAnnotationPdfReviewStatusColorChangesRequested", Some(cq.dam.config.annotation.pdf.reviewStatus.color.changesRequestedQuery.toParamString(cq.dam.config.annotation.pdf.reviewStatus.color.changesRequested))), ("cqDamConfigAnnotationPdfAnnotationMarkerWidth", Some(cq.dam.config.annotation.pdf.annotationMarker.widthQuery.toParamString(cq.dam.config.annotation.pdf.annotationMarker.width))), ("cqDamConfigAnnotationPdfAssetMinheight", Some(cq.dam.config.annotation.pdf.asset.minheightQuery.toParamString(cq.dam.config.annotation.pdf.asset.minheight))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplAssetMoveListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplAssetMoveListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplAssetMoveListenerInfo] = jsonOf[ComDayCqDamCoreImplAssetMoveListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.AssetMoveListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplAssetMoveListenerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplAssethomeAssetHomePageConfiguration(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], isEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], isEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo] = jsonOf[ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.assethome.AssetHomePageConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("isEnabled", Some(isEnabledQuery.toParamString(isEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamAdhocAssetSharePrezipMaxcontentsize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamAdhocAssetSharePrezipMaxcontentsizeQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo] = jsonOf[ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.assetlinkshare.AdhocAssetShareProxyServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamAdhocAssetSharePrezipMaxcontentsize", Some(cq.dam.adhoc.asset.share.prezip.maxcontentsizeQuery.toParamString(cq.dam.adhoc.asset.share.prezip.maxcontentsize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplCacheCQBufferedImageCache(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamImageCacheMaxMemory: Integer, cqDamImageCacheMaxAge: Integer, cqDamImageCacheMaxDimension: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamImageCacheMaxMemoryQuery: QueryParam[Integer], cqDamImageCacheMaxAgeQuery: QueryParam[Integer], cqDamImageCacheMaxDimensionQuery: QueryParam[String]): Task[ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo] = jsonOf[ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.cache.CQBufferedImageCache"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamImageCacheMaxMemory", Some(cq.dam.image.cache.max.memoryQuery.toParamString(cq.dam.image.cache.max.memory))), ("cqDamImageCacheMaxAge", Some(cq.dam.image.cache.max.ageQuery.toParamString(cq.dam.image.cache.max.age))), ("cqDamImageCacheMaxDimension", Some(cq.dam.image.cache.max.dimensionQuery.toParamString(cq.dam.image.cache.max.dimension))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplDamChangeEventListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], changeeventlistenerObservedPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], changeeventlistenerObservedPathsQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplDamChangeEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplDamChangeEventListenerInfo] = jsonOf[ComDayCqDamCoreImplDamChangeEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.DamChangeEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("changeeventlistenerObservedPaths", Some(changeeventlistener.observed.pathsQuery.toParamString(changeeventlistener.observed.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplDamChangeEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplDamEventPurgeService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, maxSavedActivities: Integer, saveInterval: Integer, enableActivityPurge: Boolean, eventTypes: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], maxSavedActivitiesQuery: QueryParam[Integer], saveIntervalQuery: QueryParam[Integer], enableActivityPurgeQuery: QueryParam[Boolean], eventTypesQuery: QueryParam[String]): Task[ComDayCqDamCoreImplDamEventPurgeServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplDamEventPurgeServiceInfo] = jsonOf[ComDayCqDamCoreImplDamEventPurgeServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.DamEventPurgeService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("maxSavedActivities", Some(maxSavedActivitiesQuery.toParamString(maxSavedActivities))), ("saveInterval", Some(saveIntervalQuery.toParamString(saveInterval))), ("enableActivityPurge", Some(enableActivityPurgeQuery.toParamString(enableActivityPurge))), ("eventTypes", Some(eventTypesQuery.toParamString(eventTypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplDamEventPurgeServiceInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplDamEventRecorderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String, eventQueueLength: Integer, eventrecorderEnabled: Boolean, eventrecorderBlacklist: List[String], eventrecorderEventtypes: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String], eventQueueLengthQuery: QueryParam[Integer], eventrecorderEnabledQuery: QueryParam[Boolean], eventrecorderBlacklistQuery: QueryParam[List[String]], eventrecorderEventtypesQuery: QueryParam[String]): Task[ComDayCqDamCoreImplDamEventRecorderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplDamEventRecorderImplInfo] = jsonOf[ComDayCqDamCoreImplDamEventRecorderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.DamEventRecorderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("eventQueueLength", Some(event.queue.lengthQuery.toParamString(event.queue.length))), ("eventrecorderEnabled", Some(eventrecorder.enabledQuery.toParamString(eventrecorder.enabled))), ("eventrecorderBlacklist", Some(eventrecorder.blacklistQuery.toParamString(eventrecorder.blacklist))), ("eventrecorderEventtypes", Some(eventrecorder.eventtypesQuery.toParamString(eventrecorder.eventtypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplDamEventRecorderImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplEventDamEventAuditListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String, enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String], enabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplEventDamEventAuditListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplEventDamEventAuditListenerInfo] = jsonOf[ComDayCqDamCoreImplEventDamEventAuditListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.event.DamEventAuditListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplEventDamEventAuditListenerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplExpiryNotificationJobImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamExpiryNotificationSchedulerIstimebased: Boolean, cqDamExpiryNotificationSchedulerTimebasedRule: String, cqDamExpiryNotificationSchedulerPeriodRule: Integer, sendEmail: Boolean, assetExpiredLimit: Integer, priorNotificationSeconds: Integer, cqDamExpiryNotificationUrlProtocol: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamExpiryNotificationSchedulerIstimebasedQuery: QueryParam[Boolean], cqDamExpiryNotificationSchedulerTimebasedRuleQuery: QueryParam[String], cqDamExpiryNotificationSchedulerPeriodRuleQuery: QueryParam[Integer], sendEmailQuery: QueryParam[Boolean], assetExpiredLimitQuery: QueryParam[Integer], priorNotificationSecondsQuery: QueryParam[Integer], cqDamExpiryNotificationUrlProtocolQuery: QueryParam[String]): Task[ComDayCqDamCoreImplExpiryNotificationJobImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplExpiryNotificationJobImplInfo] = jsonOf[ComDayCqDamCoreImplExpiryNotificationJobImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.ExpiryNotificationJobImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamExpiryNotificationSchedulerIstimebased", Some(cq.dam.expiry.notification.scheduler.istimebasedQuery.toParamString(cq.dam.expiry.notification.scheduler.istimebased))), ("cqDamExpiryNotificationSchedulerTimebasedRule", Some(cq.dam.expiry.notification.scheduler.timebased.ruleQuery.toParamString(cq.dam.expiry.notification.scheduler.timebased.rule))), ("cqDamExpiryNotificationSchedulerPeriodRule", Some(cq.dam.expiry.notification.scheduler.period.ruleQuery.toParamString(cq.dam.expiry.notification.scheduler.period.rule))), ("sendEmail", Some(send_emailQuery.toParamString(send_email))), ("assetExpiredLimit", Some(asset_expired_limitQuery.toParamString(asset_expired_limit))), ("priorNotificationSeconds", Some(prior_notification_secondsQuery.toParamString(prior_notification_seconds))), ("cqDamExpiryNotificationUrlProtocol", Some(cq.dam.expiry.notification.url.protocolQuery.toParamString(cq.dam.expiry.notification.url.protocol))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplExpiryNotificationJobImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeat(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], isEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], isEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo] = jsonOf[ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.foldermetadataschema.FolderMetadataSchemaFeatureFlag"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("isEnabled", Some(isEnabledQuery.toParamString(isEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplGfxCommonsGfxRenderer(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], skipBufferedcache: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], skipBufferedcacheQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplGfxCommonsGfxRendererInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplGfxCommonsGfxRendererInfo] = jsonOf[ComDayCqDamCoreImplGfxCommonsGfxRendererInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.gfx.CommonsGfxRenderer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("skipBufferedcache", Some(skip.bufferedcacheQuery.toParamString(skip.bufferedcache))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplGfxCommonsGfxRendererInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplHandlerEPSFormatHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mimetype: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mimetypeQuery: QueryParam[String]): Task[ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo] = jsonOf[ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.handler.EPSFormatHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mimetype", Some(mimetypeQuery.toParamString(mimetype))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplHandlerIndesignFormatHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mimetype: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mimetypeQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo] = jsonOf[ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.handler.IndesignFormatHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mimetype", Some(mimetypeQuery.toParamString(mimetype))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplHandlerJpegHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamEnableExtMetaExtraction: Boolean, largeFileThreshold: Integer, largeCommentThreshold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamEnableExtMetaExtractionQuery: QueryParam[Boolean], largeFileThresholdQuery: QueryParam[Integer], largeCommentThresholdQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplHandlerJpegHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplHandlerJpegHandlerInfo] = jsonOf[ComDayCqDamCoreImplHandlerJpegHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.handler.JpegHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamEnableExtMetaExtraction", Some(cq.dam.enable.ext.meta.extractionQuery.toParamString(cq.dam.enable.ext.meta.extraction))), ("largeFileThreshold", Some(large_file_thresholdQuery.toParamString(large_file_threshold))), ("largeCommentThreshold", Some(large_comment_thresholdQuery.toParamString(large_comment_threshold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplHandlerJpegHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplHandlerXmpNCommXMPHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], xmphandlerCqFormats: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], xmphandlerCqFormatsQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo] = jsonOf[ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.handler.xmp.NCommXMPHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("xmphandlerCqFormats", Some(xmphandler.cq.formatsQuery.toParamString(xmphandler.cq.formats))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplJmxAssetIndexUpdateMonitor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jmxObjectname: String, propertyMeasureEnabled: Boolean, propertyName: String, propertyMaxWaitMs: Integer, propertyMaxRate: BigDecimal, fulltextMeasureEnabled: Boolean, fulltextName: String, fulltextMaxWaitMs: Integer, fulltextMaxRate: BigDecimal)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jmxObjectnameQuery: QueryParam[String], propertyMeasureEnabledQuery: QueryParam[Boolean], propertyNameQuery: QueryParam[String], propertyMaxWaitMsQuery: QueryParam[Integer], propertyMaxRateQuery: QueryParam[BigDecimal], fulltextMeasureEnabledQuery: QueryParam[Boolean], fulltextNameQuery: QueryParam[String], fulltextMaxWaitMsQuery: QueryParam[Integer], fulltextMaxRateQuery: QueryParam[BigDecimal]): Task[ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo] = jsonOf[ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetIndexUpdateMonitor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jmxObjectname", Some(jmx.objectnameQuery.toParamString(jmx.objectname))), ("propertyMeasureEnabled", Some(property.measure.enabledQuery.toParamString(property.measure.enabled))), ("propertyName", Some(property.nameQuery.toParamString(property.name))), ("propertyMaxWaitMs", Some(property.max.wait.msQuery.toParamString(property.max.wait.ms))), ("propertyMaxRate", Some(property.max.rateQuery.toParamString(property.max.rate))), ("fulltextMeasureEnabled", Some(fulltext.measure.enabledQuery.toParamString(fulltext.measure.enabled))), ("fulltextName", Some(fulltext.nameQuery.toParamString(fulltext.name))), ("fulltextMaxWaitMs", Some(fulltext.max.wait.msQuery.toParamString(fulltext.max.wait.ms))), ("fulltextMaxRate", Some(fulltext.max.rateQuery.toParamString(fulltext.max.rate))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplJmxAssetMigrationMBeanImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jmxObjectname: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jmxObjectnameQuery: QueryParam[String]): Task[ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo] = jsonOf[ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetMigrationMBeanImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jmxObjectname", Some(jmx.objectnameQuery.toParamString(jmx.objectname))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplJmxAssetUpdateMonitorImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jmxObjectname: String, active: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jmxObjectnameQuery: QueryParam[String], activeQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo] = jsonOf[ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetUpdateMonitorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jmxObjectname", Some(jmx.objectnameQuery.toParamString(jmx.objectname))), ("active", Some(activeQuery.toParamString(active))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], operation: String, emailEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], operationQuery: QueryParam[String], emailEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo] = jsonOf[ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.jobs.metadataexport.AsyncMetadataExportConfigProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("operation", Some(operationQuery.toParamString(operation))), ("emailEnabled", Some(emailEnabledQuery.toParamString(emailEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], operation: String, operationIcon: String, topicName: String, emailEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], operationQuery: QueryParam[String], operationIconQuery: QueryParam[String], topicNameQuery: QueryParam[String], emailEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo] = jsonOf[ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.jobs.metadataimport.AsyncMetadataImportConfigProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("operation", Some(operationQuery.toParamString(operation))), ("operationIcon", Some(operationIconQuery.toParamString(operationIcon))), ("topicName", Some(topicNameQuery.toParamString(topicName))), ("emailEnabled", Some(emailEnabledQuery.toParamString(emailEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplLightboxLightboxServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletPaths: String, slingServletMethods: List[String], cqDamEnableAnonymous: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletPathsQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[List[String]], cqDamEnableAnonymousQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplLightboxLightboxServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplLightboxLightboxServletInfo] = jsonOf[ComDayCqDamCoreImplLightboxLightboxServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.lightbox.LightboxServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletPaths", Some(sling.servlet.pathsQuery.toParamString(sling.servlet.paths))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))), ("cqDamEnableAnonymous", Some(cq.dam.enable.anonymousQuery.toParamString(cq.dam.enable.anonymous))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplLightboxLightboxServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplMetadataEditorSelectComponentHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], granitedata: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], granitedataQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo] = jsonOf[ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.metadata.editor.SelectComponentHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("granitedata", Some(granite:dataQuery.toParamString(granite:data))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelper(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamAllowAllMime: Boolean, cqDamAllowedAssetMimes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamAllowAllMimeQuery: QueryParam[Boolean], cqDamAllowedAssetMimesQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo] = jsonOf[ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.mimeType.AssetUploadRestrictionHelper"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamAllowAllMime", Some(cq.dam.allow.all.mimeQuery.toParamString(cq.dam.allow.all.mime))), ("cqDamAllowedAssetMimes", Some(cq.dam.allowed.asset.mimesQuery.toParamString(cq.dam.allowed.asset.mimes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplMimeTypeDamMimeTypeServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamDetectAssetMimeFromContent: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamDetectAssetMimeFromContentQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo] = jsonOf[ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.mimeType.DamMimeTypeServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamDetectAssetMimeFromContent", Some(cq.dam.detect.asset.mime.from.contentQuery.toParamString(cq.dam.detect.asset.mime.from.content))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplMissingMetadataNotificationJob(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamMissingmetadataNotificationSchedulerIstimebased: Boolean, cqDamMissingmetadataNotificationSchedulerTimebasedRule: String, cqDamMissingmetadataNotificationSchedulerPeriodRule: Integer, cqDamMissingmetadataNotificationRecipient: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamMissingmetadataNotificationSchedulerIstimebasedQuery: QueryParam[Boolean], cqDamMissingmetadataNotificationSchedulerTimebasedRuleQuery: QueryParam[String], cqDamMissingmetadataNotificationSchedulerPeriodRuleQuery: QueryParam[Integer], cqDamMissingmetadataNotificationRecipientQuery: QueryParam[String]): Task[ComDayCqDamCoreImplMissingMetadataNotificationJobInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplMissingMetadataNotificationJobInfo] = jsonOf[ComDayCqDamCoreImplMissingMetadataNotificationJobInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.MissingMetadataNotificationJob"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamMissingmetadataNotificationSchedulerIstimebased", Some(cq.dam.missingmetadata.notification.scheduler.istimebasedQuery.toParamString(cq.dam.missingmetadata.notification.scheduler.istimebased))), ("cqDamMissingmetadataNotificationSchedulerTimebasedRule", Some(cq.dam.missingmetadata.notification.scheduler.timebased.ruleQuery.toParamString(cq.dam.missingmetadata.notification.scheduler.timebased.rule))), ("cqDamMissingmetadataNotificationSchedulerPeriodRule", Some(cq.dam.missingmetadata.notification.scheduler.period.ruleQuery.toParamString(cq.dam.missingmetadata.notification.scheduler.period.rule))), ("cqDamMissingmetadataNotificationRecipient", Some(cq.dam.missingmetadata.notification.recipientQuery.toParamString(cq.dam.missingmetadata.notification.recipient))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplMissingMetadataNotificationJobInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPr(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String, notifyOnComplete: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String], notifyOnCompleteQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo] = jsonOf[ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.process.SendTransientWorkflowCompletedEmailProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("notifyOnComplete", Some(Notify on CompleteQuery.toParamString(Notify on Complete))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplProcessTextExtractionProcess(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mimeTypes: List[String], maxExtract: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mimeTypesQuery: QueryParam[List[String]], maxExtractQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplProcessTextExtractionProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplProcessTextExtractionProcessInfo] = jsonOf[ComDayCqDamCoreImplProcessTextExtractionProcessInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.process.TextExtractionProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mimeTypes", Some(mimeTypesQuery.toParamString(mimeTypes))), ("maxExtract", Some(maxExtractQuery.toParamString(maxExtract))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplProcessTextExtractionProcessInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplRenditionMakerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], xmpPropagate: Boolean, xmpExcludes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], xmpPropagateQuery: QueryParam[Boolean], xmpExcludesQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplRenditionMakerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplRenditionMakerImplInfo] = jsonOf[ComDayCqDamCoreImplRenditionMakerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.RenditionMakerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("xmpPropagate", Some(xmp.propagateQuery.toParamString(xmp.propagate))), ("xmpExcludes", Some(xmp.excludesQuery.toParamString(xmp.excludes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplRenditionMakerImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplReportsReportExportService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], queryBatchSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], queryBatchSizeQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplReportsReportExportServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplReportsReportExportServiceInfo] = jsonOf[ComDayCqDamCoreImplReportsReportExportServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.reports.ReportExportService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("queryBatchSize", Some(queryBatchSizeQuery.toParamString(queryBatchSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplReportsReportExportServiceInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplReportsReportPurgeService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, maxSavedReports: Integer, timeDuration: Integer, enableReportPurge: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], maxSavedReportsQuery: QueryParam[Integer], timeDurationQuery: QueryParam[Integer], enableReportPurgeQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplReportsReportPurgeServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplReportsReportPurgeServiceInfo] = jsonOf[ComDayCqDamCoreImplReportsReportPurgeServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.reports.ReportPurgeService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("maxSavedReports", Some(maxSavedReportsQuery.toParamString(maxSavedReports))), ("timeDuration", Some(timeDurationQuery.toParamString(timeDuration))), ("enableReportPurge", Some(enableReportPurgeQuery.toParamString(enableReportPurge))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplReportsReportPurgeServiceInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletAssetDownloadServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletAssetDownloadServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletAssetDownloadServletInfo] = jsonOf[ComDayCqDamCoreImplServletAssetDownloadServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetDownloadServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletAssetDownloadServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletAssetStatusServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamBatchStatusMaxassets: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamBatchStatusMaxassetsQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplServletAssetStatusServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletAssetStatusServletInfo] = jsonOf[ComDayCqDamCoreImplServletAssetStatusServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetStatusServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamBatchStatusMaxassets", Some(cq.dam.batch.status.maxassetsQuery.toParamString(cq.dam.batch.status.maxassets))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletAssetStatusServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletAssetXMPSearchServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamBatchIndesignMaxassets: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamBatchIndesignMaxassetsQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplServletAssetXMPSearchServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletAssetXMPSearchServletInfo] = jsonOf[ComDayCqDamCoreImplServletAssetXMPSearchServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetXMPSearchServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamBatchIndesignMaxassets", Some(cq.dam.batch.indesign.maxassetsQuery.toParamString(cq.dam.batch.indesign.maxassets))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletAssetXMPSearchServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletBatchMetadataServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamBatchMetadataAssetDefault: List[String], cqDamBatchMetadataCollectionDefault: List[String], cqDamBatchMetadataMaxresources: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamBatchMetadataAssetDefaultQuery: QueryParam[List[String]], cqDamBatchMetadataCollectionDefaultQuery: QueryParam[List[String]], cqDamBatchMetadataMaxresourcesQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplServletBatchMetadataServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletBatchMetadataServletInfo] = jsonOf[ComDayCqDamCoreImplServletBatchMetadataServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.BatchMetadataServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamBatchMetadataAssetDefault", Some(cq.dam.batch.metadata.asset.defaultQuery.toParamString(cq.dam.batch.metadata.asset.default))), ("cqDamBatchMetadataCollectionDefault", Some(cq.dam.batch.metadata.collection.defaultQuery.toParamString(cq.dam.batch.metadata.collection.default))), ("cqDamBatchMetadataMaxresources", Some(cq.dam.batch.metadata.maxresourcesQuery.toParamString(cq.dam.batch.metadata.maxresources))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletBatchMetadataServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletBinaryProviderServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletResourceTypes: List[String], slingServletMethods: List[String], cqDamDrmEnable: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletResourceTypesQuery: QueryParam[List[String]], slingServletMethodsQuery: QueryParam[List[String]], cqDamDrmEnableQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletBinaryProviderServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletBinaryProviderServletInfo] = jsonOf[ComDayCqDamCoreImplServletBinaryProviderServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.BinaryProviderServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletResourceTypes", Some(sling.servlet.resourceTypesQuery.toParamString(sling.servlet.resourceTypes))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))), ("cqDamDrmEnable", Some(cq.dam.drm.enableQuery.toParamString(cq.dam.drm.enable))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletBinaryProviderServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletCollectionServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamBatchCollectionProperties: List[String], cqDamBatchCollectionMaxcollections: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamBatchCollectionPropertiesQuery: QueryParam[List[String]], cqDamBatchCollectionMaxcollectionsQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplServletCollectionServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletCollectionServletInfo] = jsonOf[ComDayCqDamCoreImplServletCollectionServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CollectionServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamBatchCollectionProperties", Some(cq.dam.batch.collection.propertiesQuery.toParamString(cq.dam.batch.collection.properties))), ("cqDamBatchCollectionMaxcollections", Some(cq.dam.batch.collection.maxcollectionsQuery.toParamString(cq.dam.batch.collection.maxcollections))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletCollectionServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletCollectionsServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamBatchCollectionsProperties: List[String], cqDamBatchCollectionsLimit: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamBatchCollectionsPropertiesQuery: QueryParam[List[String]], cqDamBatchCollectionsLimitQuery: QueryParam[Integer]): Task[ComDayCqDamCoreImplServletCollectionsServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletCollectionsServletInfo] = jsonOf[ComDayCqDamCoreImplServletCollectionsServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CollectionsServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamBatchCollectionsProperties", Some(cq.dam.batch.collections.propertiesQuery.toParamString(cq.dam.batch.collections.properties))), ("cqDamBatchCollectionsLimit", Some(cq.dam.batch.collections.limitQuery.toParamString(cq.dam.batch.collections.limit))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletCollectionsServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletCompanionServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], moreInfo: String, mntoverlaydamguicontentassetsmoreinfoHtmlpath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], moreInfoQuery: QueryParam[String], mntoverlaydamguicontentassetsmoreinfoHtmlpathQuery: QueryParam[String]): Task[ComDayCqDamCoreImplServletCompanionServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletCompanionServletInfo] = jsonOf[ComDayCqDamCoreImplServletCompanionServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CompanionServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("moreInfo", Some(More InfoQuery.toParamString(More Info))), ("mntoverlaydamguicontentassetsmoreinfoHtmlpath", Some(/mnt/overlay/dam/gui/content/assets/moreinfo.html/${path}Query.toParamString(/mnt/overlay/dam/gui/content/assets/moreinfo.html/${path}))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletCompanionServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletCreateAssetServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], detectDuplicate: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], detectDuplicateQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletCreateAssetServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletCreateAssetServletInfo] = jsonOf[ComDayCqDamCoreImplServletCreateAssetServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CreateAssetServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("detectDuplicate", Some(detect_duplicateQuery.toParamString(detect_duplicate))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletCreateAssetServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletDamContentDispositionFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqMimeTypeBlacklist: List[String], cqDamEmptyMime: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqMimeTypeBlacklistQuery: QueryParam[List[String]], cqDamEmptyMimeQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletDamContentDispositionFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletDamContentDispositionFilterInfo] = jsonOf[ComDayCqDamCoreImplServletDamContentDispositionFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.DamContentDispositionFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqMimeTypeBlacklist", Some(cq.mime.type.blacklistQuery.toParamString(cq.mime.type.blacklist))), ("cqDamEmptyMime", Some(cq.dam.empty.mimeQuery.toParamString(cq.dam.empty.mime))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletDamContentDispositionFilterInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletGuidLookupFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamCoreGuidlookupfilterEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamCoreGuidlookupfilterEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletGuidLookupFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletGuidLookupFilterInfo] = jsonOf[ComDayCqDamCoreImplServletGuidLookupFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.GuidLookupFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamCoreGuidlookupfilterEnabled", Some(cq.dam.core.guidlookupfilter.enabledQuery.toParamString(cq.dam.core.guidlookupfilter.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletGuidLookupFilterInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletHealthCheckServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamSyncWorkflowId: String, cqDamSyncFolderTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamSyncWorkflowIdQuery: QueryParam[String], cqDamSyncFolderTypesQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreImplServletHealthCheckServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletHealthCheckServletInfo] = jsonOf[ComDayCqDamCoreImplServletHealthCheckServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.HealthCheckServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamSyncWorkflowId", Some(cq.dam.sync.workflow.idQuery.toParamString(cq.dam.sync.workflow.id))), ("cqDamSyncFolderTypes", Some(cq.dam.sync.folder.typesQuery.toParamString(cq.dam.sync.folder.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletHealthCheckServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletMetadataGetServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletResourceTypes: String, slingServletMethods: String, slingServletExtensions: String, slingServletSelectors: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletResourceTypesQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[String], slingServletExtensionsQuery: QueryParam[String], slingServletSelectorsQuery: QueryParam[String]): Task[ComDayCqDamCoreImplServletMetadataGetServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletMetadataGetServletInfo] = jsonOf[ComDayCqDamCoreImplServletMetadataGetServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.MetadataGetServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletResourceTypes", Some(sling.servlet.resourceTypesQuery.toParamString(sling.servlet.resourceTypes))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))), ("slingServletExtensions", Some(sling.servlet.extensionsQuery.toParamString(sling.servlet.extensions))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletMetadataGetServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletMultipleLicenseAcceptServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamDrmEnable: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamDrmEnableQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo] = jsonOf[ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.MultipleLicenseAcceptServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamDrmEnable", Some(cq.dam.drm.enableQuery.toParamString(cq.dam.drm.enable))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplServletResourceCollectionServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletResourceTypes: List[String], slingServletMethods: String, slingServletSelectors: String, downloadConfig: String, viewSelector: String, sendEmail: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletResourceTypesQuery: QueryParam[List[String]], slingServletMethodsQuery: QueryParam[String], slingServletSelectorsQuery: QueryParam[String], downloadConfigQuery: QueryParam[String], viewSelectorQuery: QueryParam[String], sendEmailQuery: QueryParam[Boolean]): Task[ComDayCqDamCoreImplServletResourceCollectionServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplServletResourceCollectionServletInfo] = jsonOf[ComDayCqDamCoreImplServletResourceCollectionServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.servlet.ResourceCollectionServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletResourceTypes", Some(sling.servlet.resourceTypesQuery.toParamString(sling.servlet.resourceTypes))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("downloadConfig", Some(download.configQuery.toParamString(download.config))), ("viewSelector", Some(view.selectorQuery.toParamString(view.selector))), ("sendEmail", Some(send_emailQuery.toParamString(send_email))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplServletResourceCollectionServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], createPreviewEnabled: Boolean, updatePreviewEnabled: Boolean, queueSize: Integer, folderPreviewRenditionRegex: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], createPreviewEnabledQuery: QueryParam[Boolean], updatePreviewEnabledQuery: QueryParam[Boolean], queueSizeQuery: QueryParam[Integer], folderPreviewRenditionRegexQuery: QueryParam[String]): Task[ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo] = jsonOf[ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.ui.preview.FolderPreviewUpdaterImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("createPreviewEnabled", Some(createPreviewEnabledQuery.toParamString(createPreviewEnabled))), ("updatePreviewEnabled", Some(updatePreviewEnabledQuery.toParamString(updatePreviewEnabled))), ("queueSize", Some(queueSizeQuery.toParamString(queueSize))), ("folderPreviewRenditionRegex", Some(folderPreviewRenditionRegexQuery.toParamString(folderPreviewRenditionRegex))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreImplUnzipUnzipConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamConfigUnzipMaxuncompressedsize: Integer, cqDamConfigUnzipEncoding: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamConfigUnzipMaxuncompressedsizeQuery: QueryParam[Integer], cqDamConfigUnzipEncodingQuery: QueryParam[String]): Task[ComDayCqDamCoreImplUnzipUnzipConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreImplUnzipUnzipConfigInfo] = jsonOf[ComDayCqDamCoreImplUnzipUnzipConfigInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.impl.unzip.UnzipConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamConfigUnzipMaxuncompressedsize", Some(cq.dam.config.unzip.maxuncompressedsizeQuery.toParamString(cq.dam.config.unzip.maxuncompressedsize))), ("cqDamConfigUnzipEncoding", Some(cq.dam.config.unzip.encodingQuery.toParamString(cq.dam.config.unzip.encoding))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreImplUnzipUnzipConfigInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreProcessExifToolExtractMetadataProcess(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String, cqDamEnableSha1: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String], cqDamEnableSha1Query: QueryParam[Boolean]): Task[ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo] = jsonOf[ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.process.ExifToolExtractMetadataProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("cqDamEnableSha1", Some(cq.dam.enable.sha1Query.toParamString(cq.dam.enable.sha1))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreProcessExtractMetadataProcess(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String, cqDamEnableSha1: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String], cqDamEnableSha1Query: QueryParam[Boolean]): Task[ComDayCqDamCoreProcessExtractMetadataProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreProcessExtractMetadataProcessInfo] = jsonOf[ComDayCqDamCoreProcessExtractMetadataProcessInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.process.ExtractMetadataProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("cqDamEnableSha1", Some(cq.dam.enable.sha1Query.toParamString(cq.dam.enable.sha1))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreProcessExtractMetadataProcessInfo](req)

    } yield resp
  }
  
  def comDayCqDamCoreProcessMetadataProcessorProcess(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String, cqDamEnableSha1: Boolean, cqDamMetadataXssprotectedProperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String], cqDamEnableSha1Query: QueryParam[Boolean], cqDamMetadataXssprotectedPropertiesQuery: QueryParam[List[String]]): Task[ComDayCqDamCoreProcessMetadataProcessorProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamCoreProcessMetadataProcessorProcessInfo] = jsonOf[ComDayCqDamCoreProcessMetadataProcessorProcessInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.core.process.MetadataProcessorProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("cqDamEnableSha1", Some(cq.dam.enable.sha1Query.toParamString(cq.dam.enable.sha1))), ("cqDamMetadataXssprotectedProperties", Some(cq.dam.metadata.xssprotected.propertiesQuery.toParamString(cq.dam.metadata.xssprotected.properties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamCoreProcessMetadataProcessorProcessInfo](req)

    } yield resp
  }
  
  def comDayCqDamHandlerFfmpegLocatorImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], executableSearchpath: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], executableSearchpathQuery: QueryParam[List[String]]): Task[ComDayCqDamHandlerFfmpegLocatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamHandlerFfmpegLocatorImplInfo] = jsonOf[ComDayCqDamHandlerFfmpegLocatorImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.handler.ffmpeg.LocatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("executableSearchpath", Some(executable.searchpathQuery.toParamString(executable.searchpath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamHandlerFfmpegLocatorImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String, fontmgrSystemFontDir: List[String], fontmgrAdobeFontDir: String, fontmgrCustomerFontDir: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String], fontmgrSystemFontDirQuery: QueryParam[List[String]], fontmgrAdobeFontDirQuery: QueryParam[String], fontmgrCustomerFontDirQuery: QueryParam[String]): Task[ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo] = jsonOf[ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.handler.gibson.fontmanager.impl.FontManagerServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("fontmgrSystemFontDir", Some(fontmgr.system.font.dirQuery.toParamString(fontmgr.system.font.dir))), ("fontmgrAdobeFontDir", Some(fontmgr.adobe.font.dirQuery.toParamString(fontmgr.adobe.font.dir))), ("fontmgrCustomerFontDir", Some(fontmgr.customer.font.dirQuery.toParamString(fontmgr.customer.font.dir))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamHandlerStandardPdfPdfHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], rasterAnnotation: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], rasterAnnotationQuery: QueryParam[Boolean]): Task[ComDayCqDamHandlerStandardPdfPdfHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamHandlerStandardPdfPdfHandlerInfo] = jsonOf[ComDayCqDamHandlerStandardPdfPdfHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.handler.standard.pdf.PdfHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("rasterAnnotation", Some(raster.annotationQuery.toParamString(raster.annotation))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamHandlerStandardPdfPdfHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamHandlerStandardPsPostScriptHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], rasterAnnotation: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], rasterAnnotationQuery: QueryParam[Boolean]): Task[ComDayCqDamHandlerStandardPsPostScriptHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamHandlerStandardPsPostScriptHandlerInfo] = jsonOf[ComDayCqDamHandlerStandardPsPostScriptHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.handler.standard.ps.PostScriptHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("rasterAnnotation", Some(raster.annotationQuery.toParamString(raster.annotation))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamHandlerStandardPsPostScriptHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamHandlerStandardPsdPsdHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], largeFileThreshold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], largeFileThresholdQuery: QueryParam[Integer]): Task[ComDayCqDamHandlerStandardPsdPsdHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamHandlerStandardPsdPsdHandlerInfo] = jsonOf[ComDayCqDamHandlerStandardPsdPsdHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.handler.standard.psd.PsdHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("largeFileThreshold", Some(large_file_thresholdQuery.toParamString(large_file_threshold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamHandlerStandardPsdPsdHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamIdsImplIDSJobProcessor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enableMultisession: Boolean, idsCcEnable: Boolean, enableRetry: Boolean, enableRetryScripterror: Boolean, externalizerDomainCqhost: String, externalizerDomainHttp: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableMultisessionQuery: QueryParam[Boolean], idsCcEnableQuery: QueryParam[Boolean], enableRetryQuery: QueryParam[Boolean], enableRetryScripterrorQuery: QueryParam[Boolean], externalizerDomainCqhostQuery: QueryParam[String], externalizerDomainHttpQuery: QueryParam[String]): Task[ComDayCqDamIdsImplIDSJobProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamIdsImplIDSJobProcessorInfo] = jsonOf[ComDayCqDamIdsImplIDSJobProcessorInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.ids.impl.IDSJobProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enableMultisession", Some(enable.multisessionQuery.toParamString(enable.multisession))), ("idsCcEnable", Some(ids.cc.enableQuery.toParamString(ids.cc.enable))), ("enableRetry", Some(enable.retryQuery.toParamString(enable.retry))), ("enableRetryScripterror", Some(enable.retry.scripterrorQuery.toParamString(enable.retry.scripterror))), ("externalizerDomainCqhost", Some(externalizer.domain.cqhostQuery.toParamString(externalizer.domain.cqhost))), ("externalizerDomainHttp", Some(externalizer.domain.httpQuery.toParamString(externalizer.domain.http))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamIdsImplIDSJobProcessorInfo](req)

    } yield resp
  }
  
  def comDayCqDamIdsImplIDSPoolManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxErrorsToBlacklist: Integer, retryIntervalToWhitelist: Integer, connectTimeout: Integer, socketTimeout: Integer, processLabel: String, connectionUseMax: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxErrorsToBlacklistQuery: QueryParam[Integer], retryIntervalToWhitelistQuery: QueryParam[Integer], connectTimeoutQuery: QueryParam[Integer], socketTimeoutQuery: QueryParam[Integer], processLabelQuery: QueryParam[String], connectionUseMaxQuery: QueryParam[Integer]): Task[ComDayCqDamIdsImplIDSPoolManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamIdsImplIDSPoolManagerImplInfo] = jsonOf[ComDayCqDamIdsImplIDSPoolManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.ids.impl.IDSPoolManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxErrorsToBlacklist", Some(max.errors.to.blacklistQuery.toParamString(max.errors.to.blacklist))), ("retryIntervalToWhitelist", Some(retry.interval.to.whitelistQuery.toParamString(retry.interval.to.whitelist))), ("connectTimeout", Some(connect.timeoutQuery.toParamString(connect.timeout))), ("socketTimeout", Some(socket.timeoutQuery.toParamString(socket.timeout))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("connectionUseMax", Some(connection.use.maxQuery.toParamString(connection.use.max))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamIdsImplIDSPoolManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamInddImplHandlerIndesignXMPHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String, extractPages: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String], extractPagesQuery: QueryParam[Boolean]): Task[ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo] = jsonOf[ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.indd.impl.handler.IndesignXMPHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("extractPages", Some(extract.pagesQuery.toParamString(extract.pages))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamInddImplServletSnippetCreationServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], snippetcreationMaxcollections: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], snippetcreationMaxcollectionsQuery: QueryParam[Integer]): Task[ComDayCqDamInddImplServletSnippetCreationServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamInddImplServletSnippetCreationServletInfo] = jsonOf[ComDayCqDamInddImplServletSnippetCreationServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.indd.impl.servlet.SnippetCreationServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("snippetcreationMaxcollections", Some(snippetcreation.maxcollectionsQuery.toParamString(snippetcreation.maxcollections))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamInddImplServletSnippetCreationServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamInddProcessINDDMediaExtractProcess(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String, cqDamInddPagesRegex: String, idsJobDecoupled: Boolean, idsJobWorkflowModel: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String], cqDamInddPagesRegexQuery: QueryParam[String], idsJobDecoupledQuery: QueryParam[Boolean], idsJobWorkflowModelQuery: QueryParam[String]): Task[ComDayCqDamInddProcessINDDMediaExtractProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamInddProcessINDDMediaExtractProcessInfo] = jsonOf[ComDayCqDamInddProcessINDDMediaExtractProcessInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.indd.process.INDDMediaExtractProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))), ("cqDamInddPagesRegex", Some(cq.dam.indd.pages.regexQuery.toParamString(cq.dam.indd.pages.regex))), ("idsJobDecoupled", Some(ids.job.decoupledQuery.toParamString(ids.job.decoupled))), ("idsJobWorkflowModel", Some(ids.job.workflow.modelQuery.toParamString(ids.job.workflow.model))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamInddProcessINDDMediaExtractProcessInfo](req)

    } yield resp
  }
  
  def comDayCqDamPerformanceInternalAssetPerformanceDataHandlerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], batchCommitSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], batchCommitSizeQuery: QueryParam[Integer]): Task[ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo] = jsonOf[ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.performance.internal.AssetPerformanceDataHandlerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("batchCommitSize", Some(batch.commit.sizeQuery.toParamString(batch.commit.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamPerformanceInternalAssetPerformanceReportSyncJob(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String]): Task[ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo] = jsonOf[ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.performance.internal.AssetPerformanceReportSyncJob"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo](req)

    } yield resp
  }
  
  def comDayCqDamPimImplSourcingUploadProcessProductAssetsUploadPro(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], deleteZipFile: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], deleteZipFileQuery: QueryParam[Boolean]): Task[ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo] = jsonOf[ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.pim.impl.sourcing.upload.process.ProductAssetsUploadProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("deleteZipFile", Some(delete.zip.fileQuery.toParamString(delete.zip.file))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEven(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamS7damDynamicmediaconfigeventlistenerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamS7damDynamicmediaconfigeventlistenerEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo] = jsonOf[ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.analytics.impl.S7damDynamicMediaConfigEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamS7damDynamicmediaconfigeventlistenerEnabled", Some(cq.dam.s7dam.dynamicmediaconfigeventlistener.enabledQuery.toParamString(cq.dam.s7dam.dynamicmediaconfigeventlistener.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunner(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, schedulerConcurrent: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], schedulerConcurrentQuery: QueryParam[Boolean]): Task[ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo] = jsonOf[ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.analytics.impl.SiteCatalystReportRunner"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("schedulerConcurrent", Some(scheduler.concurrentQuery.toParamString(scheduler.concurrent))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonPostServletsSetCreateHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingPostOperation: String, slingServletMethods: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingPostOperationQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[String]): Task[ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo] = jsonOf[ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.post.servlets.SetCreateHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingPostOperation", Some(sling.post.operationQuery.toParamString(sling.post.operation))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonPostServletsSetModifyHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingPostOperation: String, slingServletMethods: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingPostOperationQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[String]): Task[ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo] = jsonOf[ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.post.servlets.SetModifyHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingPostOperation", Some(sling.post.operationQuery.toParamString(sling.post.operation))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonProcessVideoThumbnailDownloadProcess(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], processLabel: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], processLabelQuery: QueryParam[String]): Task[ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo] = jsonOf[ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.process.VideoThumbnailDownloadProcess"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("processLabel", Some(process.labelQuery.toParamString(process.label))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonS7damDamChangeEventListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamS7damDamchangeeventlistenerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamS7damDamchangeeventlistenerEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo] = jsonOf[ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.S7damDamChangeEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamS7damDamchangeeventlistenerEnabled", Some(cq.dam.s7dam.damchangeeventlistener.enabledQuery.toParamString(cq.dam.s7dam.damchangeeventlistener.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonServletsS7damProductInfoServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletPaths: String, slingServletMethods: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletPathsQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[String]): Task[ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo] = jsonOf[ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.servlets.S7damProductInfoServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletPaths", Some(sling.servlet.pathsQuery.toParamString(sling.servlet.paths))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo](req)

    } yield resp
  }
  
  def comDayCqDamS7damCommonVideoImplVideoProxyClientServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeName: Integer, cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeName: Integer, cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadName: Integer, cqDamS7damVideoproxyclientserviceHttpReadtimeoutName: Integer, cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutName: Integer, cqDamS7damVideoproxyclientserviceHttpMaxretrycountName: Integer, cqDamS7damVideoproxyclientserviceUploadprogressIntervalName: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeNameQuery: QueryParam[Integer], cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeNameQuery: QueryParam[Integer], cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadNameQuery: QueryParam[Integer], cqDamS7damVideoproxyclientserviceHttpReadtimeoutNameQuery: QueryParam[Integer], cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutNameQuery: QueryParam[Integer], cqDamS7damVideoproxyclientserviceHttpMaxretrycountNameQuery: QueryParam[Integer], cqDamS7damVideoproxyclientserviceUploadprogressIntervalNameQuery: QueryParam[Integer]): Task[ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo] = jsonOf[ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.s7dam.common.video.impl.VideoProxyClientServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeName", Some(cq.dam.s7dam.videoproxyclientservice.multipartupload.minsize.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.multipartupload.minsize.name))), ("cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeName", Some(cq.dam.s7dam.videoproxyclientservice.multipartupload.partsize.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.multipartupload.partsize.name))), ("cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadName", Some(cq.dam.s7dam.videoproxyclientservice.multipartupload.numthread.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.multipartupload.numthread.name))), ("cqDamS7damVideoproxyclientserviceHttpReadtimeoutName", Some(cq.dam.s7dam.videoproxyclientservice.http.readtimeout.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.http.readtimeout.name))), ("cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutName", Some(cq.dam.s7dam.videoproxyclientservice.http.connectiontimeout.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.http.connectiontimeout.name))), ("cqDamS7damVideoproxyclientserviceHttpMaxretrycountName", Some(cq.dam.s7dam.videoproxyclientservice.http.maxretrycount.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.http.maxretrycount.name))), ("cqDamS7damVideoproxyclientserviceUploadprogressIntervalName", Some(cq.dam.s7dam.videoproxyclientservice.uploadprogress.interval.nameQuery.toParamString(cq.dam.s7dam.videoproxyclientservice.uploadprogress.interval.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamScene7ImplScene7APIClientImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamScene7ApiclientRecordsperpageNofilterName: Integer, cqDamScene7ApiclientRecordsperpageWithfilterName: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamScene7ApiclientRecordsperpageNofilterNameQuery: QueryParam[Integer], cqDamScene7ApiclientRecordsperpageWithfilterNameQuery: QueryParam[Integer]): Task[ComDayCqDamScene7ImplScene7APIClientImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamScene7ImplScene7APIClientImplInfo] = jsonOf[ComDayCqDamScene7ImplScene7APIClientImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7APIClientImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamScene7ApiclientRecordsperpageNofilterName", Some(cq.dam.scene7.apiclient.recordsperpage.nofilter.nameQuery.toParamString(cq.dam.scene7.apiclient.recordsperpage.nofilter.name))), ("cqDamScene7ApiclientRecordsperpageWithfilterName", Some(cq.dam.scene7.apiclient.recordsperpage.withfilter.nameQuery.toParamString(cq.dam.scene7.apiclient.recordsperpage.withfilter.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamScene7ImplScene7APIClientImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamScene7ImplScene7AssetMimeTypeServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamScene7AssetmimetypeserviceMapping: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamScene7AssetmimetypeserviceMappingQuery: QueryParam[List[String]]): Task[ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo] = jsonOf[ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7AssetMimeTypeServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamScene7AssetmimetypeserviceMapping", Some(cq.dam.scene7.assetmimetypeservice.mappingQuery.toParamString(cq.dam.scene7.assetmimetypeservice.mapping))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamScene7ImplScene7ConfigurationEventListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamScene7ConfigurationeventlistenerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamScene7ConfigurationeventlistenerEnabledQuery: QueryParam[Boolean]): Task[ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo] = jsonOf[ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7ConfigurationEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamScene7ConfigurationeventlistenerEnabled", Some(cq.dam.scene7.configurationeventlistener.enabledQuery.toParamString(cq.dam.scene7.configurationeventlistener.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqDamScene7ImplScene7DamChangeEventListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamScene7DamchangeeventlistenerEnabled: Boolean, cqDamScene7DamchangeeventlistenerObservedPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamScene7DamchangeeventlistenerEnabledQuery: QueryParam[Boolean], cqDamScene7DamchangeeventlistenerObservedPathsQuery: QueryParam[List[String]]): Task[ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo] = jsonOf[ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7DamChangeEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamScene7DamchangeeventlistenerEnabled", Some(cq.dam.scene7.damchangeeventlistener.enabledQuery.toParamString(cq.dam.scene7.damchangeeventlistener.enabled))), ("cqDamScene7DamchangeeventlistenerObservedPaths", Some(cq.dam.scene7.damchangeeventlistener.observed.pathsQuery.toParamString(cq.dam.scene7.damchangeeventlistener.observed.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqDamScene7ImplScene7FlashTemplatesServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], scene7FlashTemplatesRti: String, scene7FlashTemplatesRsi: String, scene7FlashTemplatesRb: String, scene7FlashTemplatesRurl: String, scene7FlashTemplateUrlFormatParameter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], scene7FlashTemplatesRtiQuery: QueryParam[String], scene7FlashTemplatesRsiQuery: QueryParam[String], scene7FlashTemplatesRbQuery: QueryParam[String], scene7FlashTemplatesRurlQuery: QueryParam[String], scene7FlashTemplateUrlFormatParameterQuery: QueryParam[String]): Task[ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo] = jsonOf[ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7FlashTemplatesServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("scene7FlashTemplatesRti", Some(scene7FlashTemplates.rtiQuery.toParamString(scene7FlashTemplates.rti))), ("scene7FlashTemplatesRsi", Some(scene7FlashTemplates.rsiQuery.toParamString(scene7FlashTemplates.rsi))), ("scene7FlashTemplatesRb", Some(scene7FlashTemplates.rbQuery.toParamString(scene7FlashTemplates.rb))), ("scene7FlashTemplatesRurl", Some(scene7FlashTemplates.rurlQuery.toParamString(scene7FlashTemplates.rurl))), ("scene7FlashTemplateUrlFormatParameter", Some(scene7FlashTemplate.urlFormatParameterQuery.toParamString(scene7FlashTemplate.urlFormatParameter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamScene7ImplScene7UploadServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqDamScene7UploadserviceActivejobtimeoutLabel: Integer, cqDamScene7UploadserviceConnectionmaxperrouteLabel: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqDamScene7UploadserviceActivejobtimeoutLabelQuery: QueryParam[Integer], cqDamScene7UploadserviceConnectionmaxperrouteLabelQuery: QueryParam[Integer]): Task[ComDayCqDamScene7ImplScene7UploadServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamScene7ImplScene7UploadServiceImplInfo] = jsonOf[ComDayCqDamScene7ImplScene7UploadServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7UploadServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqDamScene7UploadserviceActivejobtimeoutLabel", Some(cq.dam.scene7.uploadservice.activejobtimeout.labelQuery.toParamString(cq.dam.scene7.uploadservice.activejobtimeout.label))), ("cqDamScene7UploadserviceConnectionmaxperrouteLabel", Some(cq.dam.scene7.uploadservice.connectionmaxperroute.labelQuery.toParamString(cq.dam.scene7.uploadservice.connectionmaxperroute.label))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamScene7ImplScene7UploadServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqDamStockIntegrationImplCacheStockCacheConfigurationSer(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], getCacheExpirationUnit: String, getCacheExpirationValue: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], getCacheExpirationUnitQuery: QueryParam[String], getCacheExpirationValueQuery: QueryParam[Integer]): Task[ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo] = jsonOf[ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.stock.integration.impl.cache.StockCacheConfigurationServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("getCacheExpirationUnit", Some(getCacheExpirationUnitQuery.toParamString(getCacheExpirationUnit))), ("getCacheExpirationValue", Some(getCacheExpirationValueQuery.toParamString(getCacheExpirationValue))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo](req)

    } yield resp
  }
  
  def comDayCqDamStockIntegrationImplConfigurationStockConfiguration(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, locale: String, imsConfig: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], localeQuery: QueryParam[String], imsConfigQuery: QueryParam[String]): Task[ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo] = jsonOf[ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.stock.integration.impl.configuration.StockConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("locale", Some(localeQuery.toParamString(locale))), ("imsConfig", Some(imsConfigQuery.toParamString(imsConfig))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo](req)

    } yield resp
  }
  
  def comDayCqDamVideoImplServletVideoTestServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[ComDayCqDamVideoImplServletVideoTestServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqDamVideoImplServletVideoTestServletInfo] = jsonOf[ComDayCqDamVideoImplServletVideoTestServletInfo]

    val path = "/system/console/configMgr/com.day.cq.dam.video.impl.servlet.VideoTestServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqDamVideoImplServletVideoTestServletInfo](req)

    } yield resp
  }
  
  def comDayCqExtwidgetServletsImageSpriteServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxWidth: Integer, maxHeight: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxWidthQuery: QueryParam[Integer], maxHeightQuery: QueryParam[Integer]): Task[ComDayCqExtwidgetServletsImageSpriteServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqExtwidgetServletsImageSpriteServletInfo] = jsonOf[ComDayCqExtwidgetServletsImageSpriteServletInfo]

    val path = "/system/console/configMgr/com.day.cq.extwidget.servlets.ImageSpriteServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxWidth", Some(maxWidthQuery.toParamString(maxWidth))), ("maxHeight", Some(maxHeightQuery.toParamString(maxHeight))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqExtwidgetServletsImageSpriteServletInfo](req)

    } yield resp
  }
  
  def comDayCqImageInternalFontFontHelper(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fontpath: List[String], oversamplingFactor: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fontpathQuery: QueryParam[List[String]], oversamplingFactorQuery: QueryParam[Integer]): Task[ComDayCqImageInternalFontFontHelperInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqImageInternalFontFontHelperInfo] = jsonOf[ComDayCqImageInternalFontFontHelperInfo]

    val path = "/system/console/configMgr/com.day.cq.image.internal.font.FontHelper"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fontpath", Some(fontpathQuery.toParamString(fontpath))), ("oversamplingFactor", Some(oversamplingFactorQuery.toParamString(oversamplingFactor))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqImageInternalFontFontHelperInfo](req)

    } yield resp
  }
  
  def comDayCqJcrclustersupportClusterStartLevelController(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], clusterLevelEnable: Boolean, clusterMasterLevel: Integer, clusterSlaveLevel: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], clusterLevelEnableQuery: QueryParam[Boolean], clusterMasterLevelQuery: QueryParam[Integer], clusterSlaveLevelQuery: QueryParam[Integer]): Task[ComDayCqJcrclustersupportClusterStartLevelControllerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqJcrclustersupportClusterStartLevelControllerInfo] = jsonOf[ComDayCqJcrclustersupportClusterStartLevelControllerInfo]

    val path = "/system/console/configMgr/com.day.cq.jcrclustersupport.ClusterStartLevelController"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("clusterLevelEnable", Some(cluster.level.enableQuery.toParamString(cluster.level.enable))), ("clusterMasterLevel", Some(cluster.master.levelQuery.toParamString(cluster.master.level))), ("clusterSlaveLevel", Some(cluster.slave.levelQuery.toParamString(cluster.slave.level))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqJcrclustersupportClusterStartLevelControllerInfo](req)

    } yield resp
  }
  
  def comDayCqMailerDefaultMailService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], smtpHost: String, smtpPort: Integer, smtpUser: String, smtpPassword: String, fromAddress: String, smtpSsl: Boolean, smtpStarttls: Boolean, debugEmail: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], smtpHostQuery: QueryParam[String], smtpPortQuery: QueryParam[Integer], smtpUserQuery: QueryParam[String], smtpPasswordQuery: QueryParam[String], fromAddressQuery: QueryParam[String], smtpSslQuery: QueryParam[Boolean], smtpStarttlsQuery: QueryParam[Boolean], debugEmailQuery: QueryParam[Boolean]): Task[ComDayCqMailerDefaultMailServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMailerDefaultMailServiceInfo] = jsonOf[ComDayCqMailerDefaultMailServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.mailer.DefaultMailService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("smtpHost", Some(smtp.hostQuery.toParamString(smtp.host))), ("smtpPort", Some(smtp.portQuery.toParamString(smtp.port))), ("smtpUser", Some(smtp.userQuery.toParamString(smtp.user))), ("smtpPassword", Some(smtp.passwordQuery.toParamString(smtp.password))), ("fromAddress", Some(from.addressQuery.toParamString(from.address))), ("smtpSsl", Some(smtp.sslQuery.toParamString(smtp.ssl))), ("smtpStarttls", Some(smtp.starttlsQuery.toParamString(smtp.starttls))), ("debugEmail", Some(debug.emailQuery.toParamString(debug.email))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMailerDefaultMailServiceInfo](req)

    } yield resp
  }
  
  def comDayCqMailerImplCqMailingService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxRecipientCount: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxRecipientCountQuery: QueryParam[String]): Task[ComDayCqMailerImplCqMailingServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMailerImplCqMailingServiceInfo] = jsonOf[ComDayCqMailerImplCqMailingServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.mailer.impl.CqMailingService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxRecipientCount", Some(max.recipient.countQuery.toParamString(max.recipient.count))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMailerImplCqMailingServiceInfo](req)

    } yield resp
  }
  
  def comDayCqMailerImplEmailCqEmailTemplateFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mailerEmailCharset: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mailerEmailCharsetQuery: QueryParam[String]): Task[ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo] = jsonOf[ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.mailer.impl.email.CqEmailTemplateFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mailerEmailCharset", Some(mailer.email.charsetQuery.toParamString(mailer.email.charset))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqMailerImplEmailCqRetrieverTemplateFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mailerEmailEmbed: Boolean, mailerEmailCharset: String, mailerEmailRetrieverUserID: String, mailerEmailRetrieverUserPWD: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mailerEmailEmbedQuery: QueryParam[Boolean], mailerEmailCharsetQuery: QueryParam[String], mailerEmailRetrieverUserIDQuery: QueryParam[String], mailerEmailRetrieverUserPWDQuery: QueryParam[String]): Task[ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo] = jsonOf[ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.mailer.impl.email.CqRetrieverTemplateFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mailerEmailEmbed", Some(mailer.email.embedQuery.toParamString(mailer.email.embed))), ("mailerEmailCharset", Some(mailer.email.charsetQuery.toParamString(mailer.email.charset))), ("mailerEmailRetrieverUserID", Some(mailer.email.retrieverUserIDQuery.toParamString(mailer.email.retrieverUserID))), ("mailerEmailRetrieverUserPWD", Some(mailer.email.retrieverUserPWDQuery.toParamString(mailer.email.retrieverUserPWD))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqMcmCampaignImplIntegrationConfigImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], aemMcmCampaignFormConstraints: List[String], aemMcmCampaignPublicUrl: String, aemMcmCampaignRelaxedSSL: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], aemMcmCampaignFormConstraintsQuery: QueryParam[List[String]], aemMcmCampaignPublicUrlQuery: QueryParam[String], aemMcmCampaignRelaxedSSLQuery: QueryParam[Boolean]): Task[ComDayCqMcmCampaignImplIntegrationConfigImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmCampaignImplIntegrationConfigImplInfo] = jsonOf[ComDayCqMcmCampaignImplIntegrationConfigImplInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.campaign.impl.IntegrationConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("aemMcmCampaignFormConstraints", Some(aem.mcm.campaign.formConstraintsQuery.toParamString(aem.mcm.campaign.formConstraints))), ("aemMcmCampaignPublicUrl", Some(aem.mcm.campaign.publicUrlQuery.toParamString(aem.mcm.campaign.publicUrl))), ("aemMcmCampaignRelaxedSSL", Some(aem.mcm.campaign.relaxedSSLQuery.toParamString(aem.mcm.campaign.relaxedSSL))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmCampaignImplIntegrationConfigImplInfo](req)

    } yield resp
  }
  
  def comDayCqMcmCampaignImporterPersonalizedTextHandlerFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo] = jsonOf[ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.campaign.importer.PersonalizedTextHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqMcmCoreNewsletterNewsletterEmailServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fromAddress: String, senderHost: String, maxBounceCount: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fromAddressQuery: QueryParam[String], senderHostQuery: QueryParam[String], maxBounceCountQuery: QueryParam[String]): Task[ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo] = jsonOf[ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.core.newsletter.NewsletterEmailServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fromAddress", Some(from.addressQuery.toParamString(from.address))), ("senderHost", Some(sender.hostQuery.toParamString(sender.host))), ("maxBounceCount", Some(max.bounce.countQuery.toParamString(max.bounce.count))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqMcmImplMCMConfiguration(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], experienceIndirection: List[String], touchpointIndirection: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], experienceIndirectionQuery: QueryParam[List[String]], touchpointIndirectionQuery: QueryParam[List[String]]): Task[ComDayCqMcmImplMCMConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmImplMCMConfigurationInfo] = jsonOf[ComDayCqMcmImplMCMConfigurationInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.impl.MCMConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("experienceIndirection", Some(experience.indirectionQuery.toParamString(experience.indirection))), ("touchpointIndirection", Some(touchpoint.indirectionQuery.toParamString(touchpoint.indirection))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmImplMCMConfigurationInfo](req)

    } yield resp
  }
  
  def comDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponen(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo] = jsonOf[ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.ClickThroughComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo](req)

    } yield resp
  }
  
  def comDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThroug(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo] = jsonOf[ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.GraphicalClickThroughComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo](req)

    } yield resp
  }
  
  def comDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponent(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo] = jsonOf[ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.LeadFormCTAComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo](req)

    } yield resp
  }
  
  def comDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHa(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo] = jsonOf[ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.mbox.MBoxExperienceTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo](req)

    } yield resp
  }
  
  def comDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagH(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo] = jsonOf[ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo]

    val path = "/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.mbox.TargetComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo](req)

    } yield resp
  }
  
  def comDayCqNotificationImplNotificationServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String]): Task[ComDayCqNotificationImplNotificationServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqNotificationImplNotificationServiceImplInfo] = jsonOf[ComDayCqNotificationImplNotificationServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.notification.impl.NotificationServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqNotificationImplNotificationServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqPersonalizationImplServletsTargetingConfigurationServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], forcelocation: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], forcelocationQuery: QueryParam[Boolean]): Task[ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo] = jsonOf[ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo]

    val path = "/system/console/configMgr/com.day.cq.personalization.impl.servlets.TargetingConfigurationServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("forcelocation", Some(forcelocationQuery.toParamString(forcelocation))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo](req)

    } yield resp
  }
  
  def comDayCqPollingImporterImplManagedPollConfigImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], id: String, enabled: Boolean, reference: Boolean, interval: Integer, expression: String, source: String, target: String, login: String, password: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], idQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], referenceQuery: QueryParam[Boolean], intervalQuery: QueryParam[Integer], expressionQuery: QueryParam[String], sourceQuery: QueryParam[String], targetQuery: QueryParam[String], loginQuery: QueryParam[String], passwordQuery: QueryParam[String]): Task[ComDayCqPollingImporterImplManagedPollConfigImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqPollingImporterImplManagedPollConfigImplInfo] = jsonOf[ComDayCqPollingImporterImplManagedPollConfigImplInfo]

    val path = "/system/console/configMgr/com.day.cq.polling.importer.impl.ManagedPollConfigImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("id", Some(idQuery.toParamString(id))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("reference", Some(referenceQuery.toParamString(reference))), ("interval", Some(intervalQuery.toParamString(interval))), ("expression", Some(expressionQuery.toParamString(expression))), ("source", Some(sourceQuery.toParamString(source))), ("target", Some(targetQuery.toParamString(target))), ("login", Some(loginQuery.toParamString(login))), ("password", Some(passwordQuery.toParamString(password))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqPollingImporterImplManagedPollConfigImplInfo](req)

    } yield resp
  }
  
  def comDayCqPollingImporterImplManagedPollingImporterImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], importerUser: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], importerUserQuery: QueryParam[String]): Task[ComDayCqPollingImporterImplManagedPollingImporterImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqPollingImporterImplManagedPollingImporterImplInfo] = jsonOf[ComDayCqPollingImporterImplManagedPollingImporterImplInfo]

    val path = "/system/console/configMgr/com.day.cq.polling.importer.impl.ManagedPollingImporterImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("importerUser", Some(importer.userQuery.toParamString(importer.user))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqPollingImporterImplManagedPollingImporterImplInfo](req)

    } yield resp
  }
  
  def comDayCqPollingImporterImplPollingImporterImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], importerMinInterval: Integer, importerUser: String, excludePaths: List[String], includePaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], importerMinIntervalQuery: QueryParam[Integer], importerUserQuery: QueryParam[String], excludePathsQuery: QueryParam[List[String]], includePathsQuery: QueryParam[List[String]]): Task[ComDayCqPollingImporterImplPollingImporterImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqPollingImporterImplPollingImporterImplInfo] = jsonOf[ComDayCqPollingImporterImplPollingImporterImplInfo]

    val path = "/system/console/configMgr/com.day.cq.polling.importer.impl.PollingImporterImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("importerMinInterval", Some(importer.min.intervalQuery.toParamString(importer.min.interval))), ("importerUser", Some(importer.userQuery.toParamString(importer.user))), ("excludePaths", Some(exclude.pathsQuery.toParamString(exclude.paths))), ("includePaths", Some(include.pathsQuery.toParamString(include.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqPollingImporterImplPollingImporterImplInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationAuditReplicationEventListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer]): Task[ComDayCqReplicationAuditReplicationEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationAuditReplicationEventListenerInfo] = jsonOf[ComDayCqReplicationAuditReplicationEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.audit.ReplicationEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationAuditReplicationEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationContentStaticContentBuilder(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], host: String, port: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hostQuery: QueryParam[String], portQuery: QueryParam[Integer]): Task[ComDayCqReplicationContentStaticContentBuilderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationContentStaticContentBuilderInfo] = jsonOf[ComDayCqReplicationContentStaticContentBuilderInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.content.StaticContentBuilder"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("host", Some(hostQuery.toParamString(host))), ("port", Some(portQuery.toParamString(port))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationContentStaticContentBuilderInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplAgentManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jobTopics: String, serviceUserTarget: String, agentProviderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jobTopicsQuery: QueryParam[String], serviceUserTargetQuery: QueryParam[String], agentProviderTargetQuery: QueryParam[String]): Task[ComDayCqReplicationImplAgentManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplAgentManagerImplInfo] = jsonOf[ComDayCqReplicationImplAgentManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.AgentManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jobTopics", Some(job.topicsQuery.toParamString(job.topics))), ("serviceUserTarget", Some(serviceUser.targetQuery.toParamString(serviceUser.target))), ("agentProviderTarget", Some(agentProvider.targetQuery.toParamString(agentProvider.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplAgentManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplContentDurboBinaryLessContentBuilder(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], binaryThreshold: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], binaryThresholdQuery: QueryParam[Integer]): Task[ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo] = jsonOf[ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.content.durbo.BinaryLessContentBuilder"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("binaryThreshold", Some(binary.thresholdQuery.toParamString(binary.threshold))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplContentDurboDurboImportConfigurationProv(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], preserveHierarchyNodes: Boolean, ignoreVersioning: Boolean, importAcl: Boolean, saveThreshold: Integer, preserveUserPaths: Boolean, preserveUuid: Boolean, preserveUuidNodetypes: List[String], preserveUuidSubtrees: List[String], autoCommit: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], preserveHierarchyNodesQuery: QueryParam[Boolean], ignoreVersioningQuery: QueryParam[Boolean], importAclQuery: QueryParam[Boolean], saveThresholdQuery: QueryParam[Integer], preserveUserPathsQuery: QueryParam[Boolean], preserveUuidQuery: QueryParam[Boolean], preserveUuidNodetypesQuery: QueryParam[List[String]], preserveUuidSubtreesQuery: QueryParam[List[String]], autoCommitQuery: QueryParam[Boolean]): Task[ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo] = jsonOf[ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.content.durbo.DurboImportConfigurationProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("preserveHierarchyNodes", Some(preserve.hierarchy.nodesQuery.toParamString(preserve.hierarchy.nodes))), ("ignoreVersioning", Some(ignore.versioningQuery.toParamString(ignore.versioning))), ("importAcl", Some(import.aclQuery.toParamString(import.acl))), ("saveThreshold", Some(save.thresholdQuery.toParamString(save.threshold))), ("preserveUserPaths", Some(preserve.user.pathsQuery.toParamString(preserve.user.paths))), ("preserveUuid", Some(preserve.uuidQuery.toParamString(preserve.uuid))), ("preserveUuidNodetypes", Some(preserve.uuid.nodetypesQuery.toParamString(preserve.uuid.nodetypes))), ("preserveUuidSubtrees", Some(preserve.uuid.subtreesQuery.toParamString(preserve.uuid.subtrees))), ("autoCommit", Some(auto.commitQuery.toParamString(auto.commit))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplReplicationContentFactoryProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], replicationContentUseFileStorage: Boolean, replicationContentMaxCommitAttempts: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], replicationContentUseFileStorageQuery: QueryParam[Boolean], replicationContentMaxCommitAttemptsQuery: QueryParam[Integer]): Task[ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo] = jsonOf[ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.ReplicationContentFactoryProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("replicationContentUseFileStorage", Some(replication.content.useFileStorageQuery.toParamString(replication.content.useFileStorage))), ("replicationContentMaxCommitAttempts", Some(replication.content.maxCommitAttemptsQuery.toParamString(replication.content.maxCommitAttempts))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplReplicationReceiverImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], receiverTmpfileThreshold: Integer, receiverPackagesUseInstall: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], receiverTmpfileThresholdQuery: QueryParam[Integer], receiverPackagesUseInstallQuery: QueryParam[Boolean]): Task[ComDayCqReplicationImplReplicationReceiverImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplReplicationReceiverImplInfo] = jsonOf[ComDayCqReplicationImplReplicationReceiverImplInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.ReplicationReceiverImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("receiverTmpfileThreshold", Some(receiver.tmpfile.thresholdQuery.toParamString(receiver.tmpfile.threshold))), ("receiverPackagesUseInstall", Some(receiver.packages.use.installQuery.toParamString(receiver.packages.use.install))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplReplicationReceiverImplInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplReplicatorImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], distributeEvents: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], distributeEventsQuery: QueryParam[Boolean]): Task[ComDayCqReplicationImplReplicatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplReplicatorImplInfo] = jsonOf[ComDayCqReplicationImplReplicatorImplInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.ReplicatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("distributeEvents", Some(distribute_eventsQuery.toParamString(distribute_events))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplReplicatorImplInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplReverseReplicator(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerPeriod: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerPeriodQuery: QueryParam[Integer]): Task[ComDayCqReplicationImplReverseReplicatorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplReverseReplicatorInfo] = jsonOf[ComDayCqReplicationImplReverseReplicatorInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.ReverseReplicator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerPeriod", Some(scheduler.periodQuery.toParamString(scheduler.period))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplReverseReplicatorInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplTransportBinaryLessTransportHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], disabledCipherSuites: List[String], enabledCipherSuites: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], disabledCipherSuitesQuery: QueryParam[List[String]], enabledCipherSuitesQuery: QueryParam[List[String]]): Task[ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo] = jsonOf[ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.transport.BinaryLessTransportHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("disabledCipherSuites", Some(disabled.cipher.suitesQuery.toParamString(disabled.cipher.suites))), ("enabledCipherSuites", Some(enabled.cipher.suitesQuery.toParamString(enabled.cipher.suites))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqReplicationImplTransportHttp(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], disabledCipherSuites: List[String], enabledCipherSuites: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], disabledCipherSuitesQuery: QueryParam[List[String]], enabledCipherSuitesQuery: QueryParam[List[String]]): Task[ComDayCqReplicationImplTransportHttpInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReplicationImplTransportHttpInfo] = jsonOf[ComDayCqReplicationImplTransportHttpInfo]

    val path = "/system/console/configMgr/com.day.cq.replication.impl.transport.Http"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("disabledCipherSuites", Some(disabled.cipher.suitesQuery.toParamString(disabled.cipher.suites))), ("enabledCipherSuites", Some(enabled.cipher.suitesQuery.toParamString(enabled.cipher.suites))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReplicationImplTransportHttpInfo](req)

    } yield resp
  }
  
  def comDayCqReportingImplCacheCacheImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], repcacheEnable: Boolean, repcacheTtl: Integer, repcacheMax: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], repcacheEnableQuery: QueryParam[Boolean], repcacheTtlQuery: QueryParam[Integer], repcacheMaxQuery: QueryParam[Integer]): Task[ComDayCqReportingImplCacheCacheImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReportingImplCacheCacheImplInfo] = jsonOf[ComDayCqReportingImplCacheCacheImplInfo]

    val path = "/system/console/configMgr/com.day.cq.reporting.impl.cache.CacheImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("repcacheEnable", Some(repcache.enableQuery.toParamString(repcache.enable))), ("repcacheTtl", Some(repcache.ttlQuery.toParamString(repcache.ttl))), ("repcacheMax", Some(repcache.maxQuery.toParamString(repcache.max))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReportingImplCacheCacheImplInfo](req)

    } yield resp
  }
  
  def comDayCqReportingImplConfigServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], repconfTimezone: String, repconfLocale: String, repconfSnapshots: String, repconfRepdir: String, repconfHourofday: Integer, repconfMinofhour: Integer, repconfMaxrows: Integer, repconfFakedata: Boolean, repconfSnapshotuser: String, repconfEnforcesnapshotuser: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], repconfTimezoneQuery: QueryParam[String], repconfLocaleQuery: QueryParam[String], repconfSnapshotsQuery: QueryParam[String], repconfRepdirQuery: QueryParam[String], repconfHourofdayQuery: QueryParam[Integer], repconfMinofhourQuery: QueryParam[Integer], repconfMaxrowsQuery: QueryParam[Integer], repconfFakedataQuery: QueryParam[Boolean], repconfSnapshotuserQuery: QueryParam[String], repconfEnforcesnapshotuserQuery: QueryParam[Boolean]): Task[ComDayCqReportingImplConfigServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReportingImplConfigServiceImplInfo] = jsonOf[ComDayCqReportingImplConfigServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.reporting.impl.ConfigServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("repconfTimezone", Some(repconf.timezoneQuery.toParamString(repconf.timezone))), ("repconfLocale", Some(repconf.localeQuery.toParamString(repconf.locale))), ("repconfSnapshots", Some(repconf.snapshotsQuery.toParamString(repconf.snapshots))), ("repconfRepdir", Some(repconf.repdirQuery.toParamString(repconf.repdir))), ("repconfHourofday", Some(repconf.hourofdayQuery.toParamString(repconf.hourofday))), ("repconfMinofhour", Some(repconf.minofhourQuery.toParamString(repconf.minofhour))), ("repconfMaxrows", Some(repconf.maxrowsQuery.toParamString(repconf.maxrows))), ("repconfFakedata", Some(repconf.fakedataQuery.toParamString(repconf.fakedata))), ("repconfSnapshotuser", Some(repconf.snapshotuserQuery.toParamString(repconf.snapshotuser))), ("repconfEnforcesnapshotuser", Some(repconf.enforcesnapshotuserQuery.toParamString(repconf.enforcesnapshotuser))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReportingImplConfigServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqReportingImplRLogAnalyzer(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], requestLogOutput: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], requestLogOutputQuery: QueryParam[String]): Task[ComDayCqReportingImplRLogAnalyzerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqReportingImplRLogAnalyzerInfo] = jsonOf[ComDayCqReportingImplRLogAnalyzerInfo]

    val path = "/system/console/configMgr/com.day.cq.reporting.impl.RLogAnalyzer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("requestLogOutput", Some(request.log.outputQuery.toParamString(request.log.output))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqReportingImplRLogAnalyzerInfo](req)

    } yield resp
  }
  
  def comDayCqRewriterLinkcheckerImplLinkCheckerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerPeriod: Integer, schedulerConcurrent: Boolean, serviceBadLinkToleranceInterval: Integer, serviceCheckOverridePatterns: List[String], serviceCacheBrokenInternalLinks: Boolean, serviceSpecialLinkPrefix: List[String], serviceSpecialLinkPatterns: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerPeriodQuery: QueryParam[Integer], schedulerConcurrentQuery: QueryParam[Boolean], serviceBadLinkToleranceIntervalQuery: QueryParam[Integer], serviceCheckOverridePatternsQuery: QueryParam[List[String]], serviceCacheBrokenInternalLinksQuery: QueryParam[Boolean], serviceSpecialLinkPrefixQuery: QueryParam[List[String]], serviceSpecialLinkPatternsQuery: QueryParam[List[String]]): Task[ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo] = jsonOf[ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerPeriod", Some(scheduler.periodQuery.toParamString(scheduler.period))), ("schedulerConcurrent", Some(scheduler.concurrentQuery.toParamString(scheduler.concurrent))), ("serviceBadLinkToleranceInterval", Some(service.bad_link_tolerance_intervalQuery.toParamString(service.bad_link_tolerance_interval))), ("serviceCheckOverridePatterns", Some(service.check_override_patternsQuery.toParamString(service.check_override_patterns))), ("serviceCacheBrokenInternalLinks", Some(service.cache_broken_internal_linksQuery.toParamString(service.cache_broken_internal_links))), ("serviceSpecialLinkPrefix", Some(service.special_link_prefixQuery.toParamString(service.special_link_prefix))), ("serviceSpecialLinkPatterns", Some(service.special_link_patternsQuery.toParamString(service.special_link_patterns))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo](req)

    } yield resp
  }
  
  def comDayCqRewriterLinkcheckerImplLinkCheckerTask(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerPeriod: Integer, schedulerConcurrent: Boolean, goodLinkTestInterval: Integer, badLinkTestInterval: Integer, linkUnusedInterval: Integer, connectionTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerPeriodQuery: QueryParam[Integer], schedulerConcurrentQuery: QueryParam[Boolean], goodLinkTestIntervalQuery: QueryParam[Integer], badLinkTestIntervalQuery: QueryParam[Integer], linkUnusedIntervalQuery: QueryParam[Integer], connectionTimeoutQuery: QueryParam[Integer]): Task[ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo] = jsonOf[ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo]

    val path = "/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerPeriod", Some(scheduler.periodQuery.toParamString(scheduler.period))), ("schedulerConcurrent", Some(scheduler.concurrentQuery.toParamString(scheduler.concurrent))), ("goodLinkTestInterval", Some(good_link_test_intervalQuery.toParamString(good_link_test_interval))), ("badLinkTestInterval", Some(bad_link_test_intervalQuery.toParamString(bad_link_test_interval))), ("linkUnusedInterval", Some(link_unused_intervalQuery.toParamString(link_unused_interval))), ("connectionTimeout", Some(connection.timeoutQuery.toParamString(connection.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo](req)

    } yield resp
  }
  
  def comDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], linkcheckertransformerDisableRewriting: Boolean, linkcheckertransformerDisableChecking: Boolean, linkcheckertransformerMapCacheSize: Integer, linkcheckertransformerStrictExtensionCheck: Boolean, linkcheckertransformerStripHtmltExtension: Boolean, linkcheckertransformerRewriteElements: List[String], linkcheckertransformerStripExtensionPathBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], linkcheckertransformerDisableRewritingQuery: QueryParam[Boolean], linkcheckertransformerDisableCheckingQuery: QueryParam[Boolean], linkcheckertransformerMapCacheSizeQuery: QueryParam[Integer], linkcheckertransformerStrictExtensionCheckQuery: QueryParam[Boolean], linkcheckertransformerStripHtmltExtensionQuery: QueryParam[Boolean], linkcheckertransformerRewriteElementsQuery: QueryParam[List[String]], linkcheckertransformerStripExtensionPathBlacklistQuery: QueryParam[List[String]]): Task[ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo] = jsonOf[ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerTransformerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("linkcheckertransformerDisableRewriting", Some(linkcheckertransformer.disableRewritingQuery.toParamString(linkcheckertransformer.disableRewriting))), ("linkcheckertransformerDisableChecking", Some(linkcheckertransformer.disableCheckingQuery.toParamString(linkcheckertransformer.disableChecking))), ("linkcheckertransformerMapCacheSize", Some(linkcheckertransformer.mapCacheSizeQuery.toParamString(linkcheckertransformer.mapCacheSize))), ("linkcheckertransformerStrictExtensionCheck", Some(linkcheckertransformer.strictExtensionCheckQuery.toParamString(linkcheckertransformer.strictExtensionCheck))), ("linkcheckertransformerStripHtmltExtension", Some(linkcheckertransformer.stripHtmltExtensionQuery.toParamString(linkcheckertransformer.stripHtmltExtension))), ("linkcheckertransformerRewriteElements", Some(linkcheckertransformer.rewriteElementsQuery.toParamString(linkcheckertransformer.rewriteElements))), ("linkcheckertransformerStripExtensionPathBlacklist", Some(linkcheckertransformer.stripExtensionPathBlacklistQuery.toParamString(linkcheckertransformer.stripExtensionPathBlacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqRewriterLinkcheckerImplLinkInfoStorageImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceMaxLinksPerHost: Integer, serviceSaveExternalLinkReferences: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceMaxLinksPerHostQuery: QueryParam[Integer], serviceSaveExternalLinkReferencesQuery: QueryParam[Boolean]): Task[ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo] = jsonOf[ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo]

    val path = "/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkInfoStorageImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceMaxLinksPerHost", Some(service.max_links_per_hostQuery.toParamString(service.max_links_per_host))), ("serviceSaveExternalLinkReferences", Some(service.save_external_link_referencesQuery.toParamString(service.save_external_link_references))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo](req)

    } yield resp
  }
  
  def comDayCqRewriterProcessorImplHtmlParserFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], htmlparserProcessTags: List[String], htmlparserPreserveCamelCase: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], htmlparserProcessTagsQuery: QueryParam[List[String]], htmlparserPreserveCamelCaseQuery: QueryParam[Boolean]): Task[ComDayCqRewriterProcessorImplHtmlParserFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqRewriterProcessorImplHtmlParserFactoryInfo] = jsonOf[ComDayCqRewriterProcessorImplHtmlParserFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.rewriter.processor.impl.HtmlParserFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("htmlparserProcessTags", Some(htmlparser.processTagsQuery.toParamString(htmlparser.processTags))), ("htmlparserPreserveCamelCase", Some(htmlparser.preserveCamelCaseQuery.toParamString(htmlparser.preserveCamelCase))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqRewriterProcessorImplHtmlParserFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqSearchImplBuilderQueryBuilderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], excerptProperties: List[String], cacheMaxEntries: Integer, cacheEntryLifetime: Integer, xpathUnion: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], excerptPropertiesQuery: QueryParam[List[String]], cacheMaxEntriesQuery: QueryParam[Integer], cacheEntryLifetimeQuery: QueryParam[Integer], xpathUnionQuery: QueryParam[Boolean]): Task[ComDayCqSearchImplBuilderQueryBuilderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqSearchImplBuilderQueryBuilderImplInfo] = jsonOf[ComDayCqSearchImplBuilderQueryBuilderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.search.impl.builder.QueryBuilderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("excerptProperties", Some(excerpt.propertiesQuery.toParamString(excerpt.properties))), ("cacheMaxEntries", Some(cache.max.entriesQuery.toParamString(cache.max.entries))), ("cacheEntryLifetime", Some(cache.entry.lifetimeQuery.toParamString(cache.entry.lifetime))), ("xpathUnion", Some(xpath.unionQuery.toParamString(xpath.union))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqSearchImplBuilderQueryBuilderImplInfo](req)

    } yield resp
  }
  
  def comDayCqSearchSuggestImplSuggestionIndexManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pathBuilderTarget: String, suggestBasepath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pathBuilderTargetQuery: QueryParam[String], suggestBasepathQuery: QueryParam[String]): Task[ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo] = jsonOf[ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.search.suggest.impl.SuggestionIndexManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pathBuilderTarget", Some(pathBuilder.targetQuery.toParamString(pathBuilder.target))), ("suggestBasepath", Some(suggest.basepathQuery.toParamString(suggest.basepath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqSearchpromoteImplPublishSearchPromoteConfigHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqSearchpromoteConfighandlerEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqSearchpromoteConfighandlerEnabledQuery: QueryParam[Boolean]): Task[ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo] = jsonOf[ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.searchpromote.impl.PublishSearchPromoteConfigHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqSearchpromoteConfighandlerEnabled", Some(cq.searchpromote.confighandler.enabledQuery.toParamString(cq.searchpromote.confighandler.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqSearchpromoteImplSearchPromoteServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqSearchpromoteConfigurationServerUri: String, cqSearchpromoteConfigurationEnvironment: String, connectionTimeout: Integer, socketTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqSearchpromoteConfigurationServerUriQuery: QueryParam[String], cqSearchpromoteConfigurationEnvironmentQuery: QueryParam[String], connectionTimeoutQuery: QueryParam[Integer], socketTimeoutQuery: QueryParam[Integer]): Task[ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo] = jsonOf[ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.searchpromote.impl.SearchPromoteServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqSearchpromoteConfigurationServerUri", Some(cq.searchpromote.configuration.server.uriQuery.toParamString(cq.searchpromote.configuration.server.uri))), ("cqSearchpromoteConfigurationEnvironment", Some(cq.searchpromote.configuration.environmentQuery.toParamString(cq.searchpromote.configuration.environment))), ("connectionTimeout", Some(connection.timeoutQuery.toParamString(connection.timeout))), ("socketTimeout", Some(socket.timeoutQuery.toParamString(socket.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqSecurityACLSetup(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqAclsetupRules: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqAclsetupRulesQuery: QueryParam[List[String]]): Task[ComDayCqSecurityACLSetupInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqSecurityACLSetupInfo] = jsonOf[ComDayCqSecurityACLSetupInfo]

    val path = "/system/console/configMgr/com.day.cq.security.ACLSetup"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqAclsetupRules", Some(cq.aclsetup.rulesQuery.toParamString(cq.aclsetup.rules))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqSecurityACLSetupInfo](req)

    } yield resp
  }
  
  def comDayCqStatisticsImplStatisticsServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerPeriod: Integer, schedulerConcurrent: Boolean, `path`: String, workspace: String, keywordsPath: String, asyncEntries: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerPeriodQuery: QueryParam[Integer], schedulerConcurrentQuery: QueryParam[Boolean], `path`Query: QueryParam[String], workspaceQuery: QueryParam[String], keywordsPathQuery: QueryParam[String], asyncEntriesQuery: QueryParam[Boolean]): Task[ComDayCqStatisticsImplStatisticsServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqStatisticsImplStatisticsServiceImplInfo] = jsonOf[ComDayCqStatisticsImplStatisticsServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.statistics.impl.StatisticsServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerPeriod", Some(scheduler.periodQuery.toParamString(scheduler.period))), ("schedulerConcurrent", Some(scheduler.concurrentQuery.toParamString(scheduler.concurrent))), ("`path`", Some(pathQuery.toParamString(path))), ("workspace", Some(workspaceQuery.toParamString(workspace))), ("keywordsPath", Some(keywordsPathQuery.toParamString(keywordsPath))), ("asyncEntries", Some(asyncEntriesQuery.toParamString(asyncEntries))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqStatisticsImplStatisticsServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqTaggingImplJcrTagManagerFactoryImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], validationEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], validationEnabledQuery: QueryParam[Boolean]): Task[ComDayCqTaggingImplJcrTagManagerFactoryImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqTaggingImplJcrTagManagerFactoryImplInfo] = jsonOf[ComDayCqTaggingImplJcrTagManagerFactoryImplInfo]

    val path = "/system/console/configMgr/com.day.cq.tagging.impl.JcrTagManagerFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("validationEnabled", Some(validation.enabledQuery.toParamString(validation.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqTaggingImplJcrTagManagerFactoryImplInfo](req)

    } yield resp
  }
  
  def comDayCqTaggingImplSearchTagPredicateEvaluator(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], ignorePath: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], ignorePathQuery: QueryParam[Boolean]): Task[ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo] = jsonOf[ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo]

    val path = "/system/console/configMgr/com.day.cq.tagging.impl.search.TagPredicateEvaluator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("ignorePath", Some(ignore_pathQuery.toParamString(ignore_path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo](req)

    } yield resp
  }
  
  def comDayCqTaggingImplTagGarbageCollector(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String]): Task[ComDayCqTaggingImplTagGarbageCollectorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqTaggingImplTagGarbageCollectorInfo] = jsonOf[ComDayCqTaggingImplTagGarbageCollectorInfo]

    val path = "/system/console/configMgr/com.day.cq.tagging.impl.TagGarbageCollector"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqTaggingImplTagGarbageCollectorInfo](req)

    } yield resp
  }
  
  def comDayCqWcmContentsyncImplHandlerPagesUpdateHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqPagesupdatehandlerImageresourcetypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqPagesupdatehandlerImageresourcetypesQuery: QueryParam[List[String]]): Task[ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo] = jsonOf[ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.contentsync.impl.handler.PagesUpdateHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqPagesupdatehandlerImageresourcetypes", Some(cq.pagesupdatehandler.imageresourcetypesQuery.toParamString(cq.pagesupdatehandler.imageresourcetypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqContentsyncPathrewritertransformerMappingLinks: List[String], cqContentsyncPathrewritertransformerMappingClientlibs: List[String], cqContentsyncPathrewritertransformerMappingImages: List[String], cqContentsyncPathrewritertransformerAttributePattern: String, cqContentsyncPathrewritertransformerClientlibraryPattern: String, cqContentsyncPathrewritertransformerClientlibraryReplace: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqContentsyncPathrewritertransformerMappingLinksQuery: QueryParam[List[String]], cqContentsyncPathrewritertransformerMappingClientlibsQuery: QueryParam[List[String]], cqContentsyncPathrewritertransformerMappingImagesQuery: QueryParam[List[String]], cqContentsyncPathrewritertransformerAttributePatternQuery: QueryParam[String], cqContentsyncPathrewritertransformerClientlibraryPatternQuery: QueryParam[String], cqContentsyncPathrewritertransformerClientlibraryReplaceQuery: QueryParam[String]): Task[ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo] = jsonOf[ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.contentsync.impl.rewriter.PathRewriterTransformerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqContentsyncPathrewritertransformerMappingLinks", Some(cq.contentsync.pathrewritertransformer.mapping.linksQuery.toParamString(cq.contentsync.pathrewritertransformer.mapping.links))), ("cqContentsyncPathrewritertransformerMappingClientlibs", Some(cq.contentsync.pathrewritertransformer.mapping.clientlibsQuery.toParamString(cq.contentsync.pathrewritertransformer.mapping.clientlibs))), ("cqContentsyncPathrewritertransformerMappingImages", Some(cq.contentsync.pathrewritertransformer.mapping.imagesQuery.toParamString(cq.contentsync.pathrewritertransformer.mapping.images))), ("cqContentsyncPathrewritertransformerAttributePattern", Some(cq.contentsync.pathrewritertransformer.attribute.patternQuery.toParamString(cq.contentsync.pathrewritertransformer.attribute.pattern))), ("cqContentsyncPathrewritertransformerClientlibraryPattern", Some(cq.contentsync.pathrewritertransformer.clientlibrary.patternQuery.toParamString(cq.contentsync.pathrewritertransformer.clientlibrary.pattern))), ("cqContentsyncPathrewritertransformerClientlibraryReplace", Some(cq.contentsync.pathrewritertransformer.clientlibrary.replaceQuery.toParamString(cq.contentsync.pathrewritertransformer.clientlibrary.replace))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplAuthoringUIModeServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], authoringUIModeServiceDefault: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], authoringUIModeServiceDefaultQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo] = jsonOf[ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.AuthoringUIModeServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("authoringUIModeServiceDefault", Some(authoringUIModeService.defaultQuery.toParamString(authoringUIModeService.default))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplCommandsWCMCommandServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], wcmcommandservletDeleteWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], wcmcommandservletDeleteWhitelistQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplCommandsWCMCommandServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplCommandsWCMCommandServletInfo] = jsonOf[ComDayCqWcmCoreImplCommandsWCMCommandServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.commands.WCMCommandServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("wcmcommandservletDeleteWhitelist", Some(wcmcommandservlet.delete_whitelistQuery.toParamString(wcmcommandservlet.delete_whitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplCommandsWCMCommandServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], dimDefaultMode: String, dimAppcacheEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], dimDefaultModeQuery: QueryParam[String], dimAppcacheEnabledQuery: QueryParam[Boolean]): Task[ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo] = jsonOf[ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.devicedetection.DeviceIdentificationModeImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("dimDefaultMode", Some(dim.default.modeQuery.toParamString(dim.default.mode))), ("dimAppcacheEnabled", Some(dim.appcache.enabledQuery.toParamString(dim.appcache.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplEventPageEventAuditListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], configured: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], configuredQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplEventPageEventAuditListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplEventPageEventAuditListenerInfo] = jsonOf[ComDayCqWcmCoreImplEventPageEventAuditListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.event.PageEventAuditListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("configured", Some(configuredQuery.toParamString(configured))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplEventPageEventAuditListenerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplEventPagePostProcessor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], paths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pathsQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplEventPagePostProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplEventPagePostProcessorInfo] = jsonOf[ComDayCqWcmCoreImplEventPagePostProcessorInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.event.PagePostProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("paths", Some(pathsQuery.toParamString(paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplEventPagePostProcessorInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplEventRepositoryChangeEventListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], paths: List[String], excludedPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pathsQuery: QueryParam[List[String]], excludedPathsQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo] = jsonOf[ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.event.RepositoryChangeEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("paths", Some(pathsQuery.toParamString(paths))), ("excludedPaths", Some(excludedPathsQuery.toParamString(excludedPaths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplEventTemplatePostProcessor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], paths: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pathsQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplEventTemplatePostProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplEventTemplatePostProcessorInfo] = jsonOf[ComDayCqWcmCoreImplEventTemplatePostProcessorInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.event.TemplatePostProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("paths", Some(pathsQuery.toParamString(paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplEventTemplatePostProcessorInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplLanguageManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], langmgrListPath: String, langmgrCountryDefault: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], langmgrListPathQuery: QueryParam[String], langmgrCountryDefaultQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplLanguageManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplLanguageManagerImplInfo] = jsonOf[ComDayCqWcmCoreImplLanguageManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.LanguageManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("langmgrListPath", Some(langmgr.list.pathQuery.toParamString(langmgr.list.path))), ("langmgrCountryDefault", Some(langmgr.country.defaultQuery.toParamString(langmgr.country.default))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplLanguageManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplLinkCheckerConfigurationFactoryImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], linkExpiredPrefix: String, linkExpiredRemove: Boolean, linkExpiredSuffix: String, linkInvalidPrefix: String, linkInvalidRemove: Boolean, linkInvalidSuffix: String, linkPredatedPrefix: String, linkPredatedRemove: Boolean, linkPredatedSuffix: String, linkWcmmodes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], linkExpiredPrefixQuery: QueryParam[String], linkExpiredRemoveQuery: QueryParam[Boolean], linkExpiredSuffixQuery: QueryParam[String], linkInvalidPrefixQuery: QueryParam[String], linkInvalidRemoveQuery: QueryParam[Boolean], linkInvalidSuffixQuery: QueryParam[String], linkPredatedPrefixQuery: QueryParam[String], linkPredatedRemoveQuery: QueryParam[Boolean], linkPredatedSuffixQuery: QueryParam[String], linkWcmmodesQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo] = jsonOf[ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.LinkCheckerConfigurationFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("linkExpiredPrefix", Some(link.expired.prefixQuery.toParamString(link.expired.prefix))), ("linkExpiredRemove", Some(link.expired.removeQuery.toParamString(link.expired.remove))), ("linkExpiredSuffix", Some(link.expired.suffixQuery.toParamString(link.expired.suffix))), ("linkInvalidPrefix", Some(link.invalid.prefixQuery.toParamString(link.invalid.prefix))), ("linkInvalidRemove", Some(link.invalid.removeQuery.toParamString(link.invalid.remove))), ("linkInvalidSuffix", Some(link.invalid.suffixQuery.toParamString(link.invalid.suffix))), ("linkPredatedPrefix", Some(link.predated.prefixQuery.toParamString(link.predated.prefix))), ("linkPredatedRemove", Some(link.predated.removeQuery.toParamString(link.predated.remove))), ("linkPredatedSuffix", Some(link.predated.suffixQuery.toParamString(link.predated.suffix))), ("linkWcmmodes", Some(link.wcmmodesQuery.toParamString(link.wcmmodes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplPagePageInfoAggregatorImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pageInfoProviderPropertyRegexDefault: String, pageInfoProviderPropertyName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pageInfoProviderPropertyRegexDefaultQuery: QueryParam[String], pageInfoProviderPropertyNameQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo] = jsonOf[ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.page.PageInfoAggregatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pageInfoProviderPropertyRegexDefault", Some(page.info.provider.property.regex.defaultQuery.toParamString(page.info.provider.property.regex.default))), ("pageInfoProviderPropertyName", Some(page.info.provider.property.nameQuery.toParamString(page.info.provider.property.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplPagePageManagerFactoryImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], illegalCharMapping: String, pageSubTreeActivationCheck: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], illegalCharMappingQuery: QueryParam[String], pageSubTreeActivationCheckQuery: QueryParam[Boolean]): Task[ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo] = jsonOf[ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.page.PageManagerFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("illegalCharMapping", Some(illegalCharMappingQuery.toParamString(illegalCharMapping))), ("pageSubTreeActivationCheck", Some(pageSubTreeActivationCheckQuery.toParamString(pageSubTreeActivationCheck))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplReferencesContentContentReferenceConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], contentReferenceConfigResourceTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], contentReferenceConfigResourceTypesQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo] = jsonOf[ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.references.content.ContentReferenceConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("contentReferenceConfigResourceTypes", Some(contentReferenceConfig.resourceTypesQuery.toParamString(contentReferenceConfig.resourceTypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplServletsContentfinderAssetViewHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], damShowexpired: Boolean, damShowhidden: Boolean, tagTitleSearch: Boolean, guessTotal: String, damExpiryProperty: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], damShowexpiredQuery: QueryParam[Boolean], damShowhiddenQuery: QueryParam[Boolean], tagTitleSearchQuery: QueryParam[Boolean], guessTotalQuery: QueryParam[String], damExpiryPropertyQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo] = jsonOf[ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.AssetViewHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("damShowexpired", Some(dam.showexpiredQuery.toParamString(dam.showexpired))), ("damShowhidden", Some(dam.showhiddenQuery.toParamString(dam.showhidden))), ("tagTitleSearch", Some(tagTitleSearchQuery.toParamString(tagTitleSearch))), ("guessTotal", Some(guessTotalQuery.toParamString(guessTotal))), ("damExpiryProperty", Some(dam.expiryPropertyQuery.toParamString(dam.expiryProperty))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplServletsContentfinderConnectorConnectorVie(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], itemResourceTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], itemResourceTypesQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo] = jsonOf[ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.connector.ConnectorViewHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("itemResourceTypes", Some(item.resource.typesQuery.toParamString(item.resource.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplServletsContentfinderPageViewHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], guessTotal: String, tagTitleSearch: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], guessTotalQuery: QueryParam[String], tagTitleSearchQuery: QueryParam[Boolean]): Task[ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo] = jsonOf[ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.PageViewHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("guessTotal", Some(guessTotalQuery.toParamString(guessTotal))), ("tagTitleSearch", Some(tagTitleSearchQuery.toParamString(tagTitleSearch))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplServletsFindReplaceServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], scope: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], scopeQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplServletsFindReplaceServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplServletsFindReplaceServletInfo] = jsonOf[ComDayCqWcmCoreImplServletsFindReplaceServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.FindReplaceServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("scope", Some(scopeQuery.toParamString(scope))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplServletsFindReplaceServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplServletsReferenceSearchServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], referencesearchservletMaxReferencesPerPage: Integer, referencesearchservletMaxPages: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], referencesearchservletMaxReferencesPerPageQuery: QueryParam[Integer], referencesearchservletMaxPagesQuery: QueryParam[Integer]): Task[ComDayCqWcmCoreImplServletsReferenceSearchServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplServletsReferenceSearchServletInfo] = jsonOf[ComDayCqWcmCoreImplServletsReferenceSearchServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.ReferenceSearchServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("referencesearchservletMaxReferencesPerPage", Some(referencesearchservlet.maxReferencesPerPageQuery.toParamString(referencesearchservlet.maxReferencesPerPage))), ("referencesearchservletMaxPages", Some(referencesearchservlet.maxPagesQuery.toParamString(referencesearchservlet.maxPages))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplServletsReferenceSearchServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplServletsThumbnailServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], workspace: String, dimensions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], workspaceQuery: QueryParam[String], dimensionsQuery: QueryParam[List[String]]): Task[ComDayCqWcmCoreImplServletsThumbnailServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplServletsThumbnailServletInfo] = jsonOf[ComDayCqWcmCoreImplServletsThumbnailServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.ThumbnailServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("workspace", Some(workspaceQuery.toParamString(workspace))), ("dimensions", Some(dimensionsQuery.toParamString(dimensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplServletsThumbnailServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplUtilsDefaultPageNameValidator(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], nonValidChars: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nonValidCharsQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo] = jsonOf[ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.utils.DefaultPageNameValidator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("nonValidChars", Some(nonValidCharsQuery.toParamString(nonValidChars))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplVariantsPageVariantsProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultExternalizerDomain: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultExternalizerDomainQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo] = jsonOf[ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.variants.PageVariantsProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultExternalizerDomain", Some(default.externalizer.domainQuery.toParamString(default.externalizer.domain))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplVersionManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], versionmanagerCreateVersionOnActivation: Boolean, versionmanagerPurgingEnabled: Boolean, versionmanagerPurgePaths: List[String], versionmanagerIvPaths: List[String], versionmanagerMaxAgeDays: Integer, versionmanagerMaxNumberVersions: Integer, versionmanagerMinNumberVersions: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], versionmanagerCreateVersionOnActivationQuery: QueryParam[Boolean], versionmanagerPurgingEnabledQuery: QueryParam[Boolean], versionmanagerPurgePathsQuery: QueryParam[List[String]], versionmanagerIvPathsQuery: QueryParam[List[String]], versionmanagerMaxAgeDaysQuery: QueryParam[Integer], versionmanagerMaxNumberVersionsQuery: QueryParam[Integer], versionmanagerMinNumberVersionsQuery: QueryParam[Integer]): Task[ComDayCqWcmCoreImplVersionManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplVersionManagerImplInfo] = jsonOf[ComDayCqWcmCoreImplVersionManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.VersionManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("versionmanagerCreateVersionOnActivation", Some(versionmanager.createVersionOnActivationQuery.toParamString(versionmanager.createVersionOnActivation))), ("versionmanagerPurgingEnabled", Some(versionmanager.purgingEnabledQuery.toParamString(versionmanager.purgingEnabled))), ("versionmanagerPurgePaths", Some(versionmanager.purgePathsQuery.toParamString(versionmanager.purgePaths))), ("versionmanagerIvPaths", Some(versionmanager.ivPathsQuery.toParamString(versionmanager.ivPaths))), ("versionmanagerMaxAgeDays", Some(versionmanager.maxAgeDaysQuery.toParamString(versionmanager.maxAgeDays))), ("versionmanagerMaxNumberVersions", Some(versionmanager.maxNumberVersionsQuery.toParamString(versionmanager.maxNumberVersions))), ("versionmanagerMinNumberVersions", Some(versionmanager.minNumberVersionsQuery.toParamString(versionmanager.minNumberVersions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplVersionManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplVersionPurgeTask(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], versionpurgePaths: List[String], versionpurgeRecursive: Boolean, versionpurgeMaxVersions: Integer, versionpurgeMinVersions: Integer, versionpurgeMaxAgeDays: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], versionpurgePathsQuery: QueryParam[List[String]], versionpurgeRecursiveQuery: QueryParam[Boolean], versionpurgeMaxVersionsQuery: QueryParam[Integer], versionpurgeMinVersionsQuery: QueryParam[Integer], versionpurgeMaxAgeDaysQuery: QueryParam[Integer]): Task[ComDayCqWcmCoreImplVersionPurgeTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplVersionPurgeTaskInfo] = jsonOf[ComDayCqWcmCoreImplVersionPurgeTaskInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.VersionPurgeTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("versionpurgePaths", Some(versionpurge.pathsQuery.toParamString(versionpurge.paths))), ("versionpurgeRecursive", Some(versionpurge.recursiveQuery.toParamString(versionpurge.recursive))), ("versionpurgeMaxVersions", Some(versionpurge.maxVersionsQuery.toParamString(versionpurge.maxVersions))), ("versionpurgeMinVersions", Some(versionpurge.minVersionsQuery.toParamString(versionpurge.minVersions))), ("versionpurgeMaxAgeDays", Some(versionpurge.maxAgeDaysQuery.toParamString(versionpurge.maxAgeDays))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplVersionPurgeTaskInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplWCMDebugFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], wcmdbgfilterEnabled: Boolean, wcmdbgfilterJspDebug: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], wcmdbgfilterEnabledQuery: QueryParam[Boolean], wcmdbgfilterJspDebugQuery: QueryParam[Boolean]): Task[ComDayCqWcmCoreImplWCMDebugFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplWCMDebugFilterInfo] = jsonOf[ComDayCqWcmCoreImplWCMDebugFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.WCMDebugFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("wcmdbgfilterEnabled", Some(wcmdbgfilter.enabledQuery.toParamString(wcmdbgfilter.enabled))), ("wcmdbgfilterJspDebug", Some(wcmdbgfilter.jspDebugQuery.toParamString(wcmdbgfilter.jspDebug))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplWCMDebugFilterInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplWCMDeveloperModeFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], wcmdevmodefilterEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], wcmdevmodefilterEnabledQuery: QueryParam[Boolean]): Task[ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo] = jsonOf[ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.WCMDeveloperModeFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("wcmdevmodefilterEnabled", Some(wcmdevmodefilter.enabledQuery.toParamString(wcmdevmodefilter.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreImplWarpTimeWarpFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], filterOrder: String, filterScope: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], filterOrderQuery: QueryParam[String], filterScopeQuery: QueryParam[String]): Task[ComDayCqWcmCoreImplWarpTimeWarpFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreImplWarpTimeWarpFilterInfo] = jsonOf[ComDayCqWcmCoreImplWarpTimeWarpFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.impl.warp.TimeWarpFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("filterOrder", Some(filter.orderQuery.toParamString(filter.order))), ("filterScope", Some(filter.scopeQuery.toParamString(filter.scope))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreImplWarpTimeWarpFilterInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreMvtMVTStatisticsImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mvtstatisticsTrackingurl: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mvtstatisticsTrackingurlQuery: QueryParam[String]): Task[ComDayCqWcmCoreMvtMVTStatisticsImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreMvtMVTStatisticsImplInfo] = jsonOf[ComDayCqWcmCoreMvtMVTStatisticsImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.mvt.MVTStatisticsImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mvtstatisticsTrackingurl", Some(mvtstatistics.trackingurlQuery.toParamString(mvtstatistics.trackingurl))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreMvtMVTStatisticsImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreStatsPageViewStatisticsImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pageviewstatisticsTrackingurl: String, pageviewstatisticsTrackingscriptEnabled: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pageviewstatisticsTrackingurlQuery: QueryParam[String], pageviewstatisticsTrackingscriptEnabledQuery: QueryParam[String]): Task[ComDayCqWcmCoreStatsPageViewStatisticsImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreStatsPageViewStatisticsImplInfo] = jsonOf[ComDayCqWcmCoreStatsPageViewStatisticsImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.stats.PageViewStatisticsImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pageviewstatisticsTrackingurl", Some(pageviewstatistics.trackingurlQuery.toParamString(pageviewstatistics.trackingurl))), ("pageviewstatisticsTrackingscriptEnabled", Some(pageviewstatistics.trackingscript.enabledQuery.toParamString(pageviewstatistics.trackingscript.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreStatsPageViewStatisticsImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmCoreWCMRequestFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], wcmfilterMode: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], wcmfilterModeQuery: QueryParam[String]): Task[ComDayCqWcmCoreWCMRequestFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmCoreWCMRequestFilterInfo] = jsonOf[ComDayCqWcmCoreWCMRequestFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.core.WCMRequestFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("wcmfilterMode", Some(wcmfilter.modeQuery.toParamString(wcmfilter.mode))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmCoreWCMRequestFilterInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterDesignPackageImporter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], extractFilter: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], extractFilterQuery: QueryParam[List[String]]): Task[ComDayCqWcmDesignimporterDesignPackageImporterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterDesignPackageImporterInfo] = jsonOf[ComDayCqWcmDesignimporterDesignPackageImporterInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.DesignPackageImporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("extractFilter", Some(extract.filterQuery.toParamString(extract.filter))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterDesignPackageImporterInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterImplCanvasBuilderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], filepattern: String, buildPageNodes: Boolean, buildClientLibs: Boolean, buildCanvasComponent: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], filepatternQuery: QueryParam[String], buildPageNodesQuery: QueryParam[Boolean], buildClientLibsQuery: QueryParam[Boolean], buildCanvasComponentQuery: QueryParam[Boolean]): Task[ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo] = jsonOf[ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.impl.CanvasBuilderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("filepattern", Some(filepatternQuery.toParamString(filepattern))), ("buildPageNodes", Some(build.page.nodesQuery.toParamString(build.page.nodes))), ("buildClientLibs", Some(build.client.libsQuery.toParamString(build.client.libs))), ("buildCanvasComponent", Some(build.canvas.componentQuery.toParamString(build.canvas.component))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterImplCanvasPageDeleteHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], minThreadPoolSize: Integer, maxThreadPoolSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], minThreadPoolSizeQuery: QueryParam[Integer], maxThreadPoolSizeQuery: QueryParam[Integer]): Task[ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo] = jsonOf[ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.impl.CanvasPageDeleteHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("minThreadPoolSize", Some(minThreadPoolSizeQuery.toParamString(minThreadPoolSize))), ("maxThreadPoolSize", Some(maxThreadPoolSizeQuery.toParamString(maxThreadPoolSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterImplEntryPreprocessorImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], searchPattern: String, replacePattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], searchPatternQuery: QueryParam[String], replacePatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo] = jsonOf[ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.impl.EntryPreprocessorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("searchPattern", Some(search.patternQuery.toParamString(search.pattern))), ("replacePattern", Some(replace.patternQuery.toParamString(replace.pattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterImplMobileCanvasBuilderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], filepattern: String, deviceGroups: List[String], buildPageNodes: Boolean, buildClientLibs: Boolean, buildCanvasComponent: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], filepatternQuery: QueryParam[String], deviceGroupsQuery: QueryParam[List[String]], buildPageNodesQuery: QueryParam[Boolean], buildClientLibsQuery: QueryParam[Boolean], buildCanvasComponentQuery: QueryParam[Boolean]): Task[ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo] = jsonOf[ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.impl.MobileCanvasBuilderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("filepattern", Some(filepatternQuery.toParamString(filepattern))), ("deviceGroups", Some(device.groupsQuery.toParamString(device.groups))), ("buildPageNodes", Some(build.page.nodesQuery.toParamString(build.page.nodes))), ("buildClientLibs", Some(build.client.libsQuery.toParamString(build.client.libs))), ("buildCanvasComponent", Some(build.canvas.componentQuery.toParamString(build.canvas.component))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryCanvasCompone(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.CanvasComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultCompon(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.DefaultComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHan(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.DefaultTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandle(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.HeadTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHand(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.IFrameTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryImageComponen(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ImageComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ImgTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptT(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.InlineScriptTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandle(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.LinkTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandle(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.MetaTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagH(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.NonScriptTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryParsysCompone(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ParsysComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHand(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ScriptTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.StyleTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryTextComponent(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TextComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponen(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String, componentResourceType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String], componentResourceTypeQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TitleComponentTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))), ("componentResourceType", Some(component.resourceTypeQuery.toParamString(component.resourceType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo](req)

    } yield resp
  }
  
  def comDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, tagpattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], tagpatternQuery: QueryParam[String]): Task[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo] = jsonOf[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TitleTagHandlerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("tagpattern", Some(tagpatternQuery.toParamString(tagpattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationFormsImplFormChooserServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceName: String, slingServletResourceTypes: String, slingServletSelectors: String, slingServletMethods: List[String], formsFormchooserservletAdvansesearchRequire: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceNameQuery: QueryParam[String], slingServletResourceTypesQuery: QueryParam[String], slingServletSelectorsQuery: QueryParam[String], slingServletMethodsQuery: QueryParam[List[String]], formsFormchooserservletAdvansesearchRequireQuery: QueryParam[Boolean]): Task[ComDayCqWcmFoundationFormsImplFormChooserServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationFormsImplFormChooserServletInfo] = jsonOf[ComDayCqWcmFoundationFormsImplFormChooserServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormChooserServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceName", Some(service.nameQuery.toParamString(service.name))), ("slingServletResourceTypes", Some(sling.servlet.resourceTypesQuery.toParamString(sling.servlet.resourceTypes))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))), ("formsFormchooserservletAdvansesearchRequire", Some(forms.formchooserservlet.advansesearch.requireQuery.toParamString(forms.formchooserservlet.advansesearch.require))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationFormsImplFormChooserServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationFormsImplFormParagraphPostProcessor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], formsFormparagraphpostprocessorEnabled: Boolean, formsFormparagraphpostprocessorFormresourcetypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], formsFormparagraphpostprocessorEnabledQuery: QueryParam[Boolean], formsFormparagraphpostprocessorFormresourcetypesQuery: QueryParam[List[String]]): Task[ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo] = jsonOf[ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormParagraphPostProcessor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("formsFormparagraphpostprocessorEnabled", Some(forms.formparagraphpostprocessor.enabledQuery.toParamString(forms.formparagraphpostprocessor.enabled))), ("formsFormparagraphpostprocessorFormresourcetypes", Some(forms.formparagraphpostprocessor.formresourcetypesQuery.toParamString(forms.formparagraphpostprocessor.formresourcetypes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationFormsImplFormsHandlingServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], nameWhitelist: String, allowExpressions: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameWhitelistQuery: QueryParam[String], allowExpressionsQuery: QueryParam[Boolean]): Task[ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo] = jsonOf[ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormsHandlingServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("nameWhitelist", Some(name.whitelistQuery.toParamString(name.whitelist))), ("allowExpressions", Some(allow.expressionsQuery.toParamString(allow.expressions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationFormsImplMailServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletResourceTypes: String, slingServletSelectors: String, resourceWhitelist: List[String], resourceBlacklist: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletResourceTypesQuery: QueryParam[String], slingServletSelectorsQuery: QueryParam[String], resourceWhitelistQuery: QueryParam[List[String]], resourceBlacklistQuery: QueryParam[String]): Task[ComDayCqWcmFoundationFormsImplMailServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationFormsImplMailServletInfo] = jsonOf[ComDayCqWcmFoundationFormsImplMailServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.MailServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletResourceTypes", Some(sling.servlet.resourceTypesQuery.toParamString(sling.servlet.resourceTypes))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("resourceWhitelist", Some(resource.whitelistQuery.toParamString(resource.whitelist))), ("resourceBlacklist", Some(resource.blacklistQuery.toParamString(resource.blacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationFormsImplMailServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationImplAdaptiveImageComponentServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], adaptSupportedWidths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], adaptSupportedWidthsQuery: QueryParam[List[String]]): Task[ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo] = jsonOf[ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.impl.AdaptiveImageComponentServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("adaptSupportedWidths", Some(adapt.supported.widthsQuery.toParamString(adapt.supported.widths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationImplHTTPAuthHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, authHttpNologin: Boolean, authHttpRealm: String, authDefaultLoginpage: String, authCredForm: List[String], authCredUtf8: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], authHttpNologinQuery: QueryParam[Boolean], authHttpRealmQuery: QueryParam[String], authDefaultLoginpageQuery: QueryParam[String], authCredFormQuery: QueryParam[List[String]], authCredUtf8Query: QueryParam[List[String]]): Task[ComDayCqWcmFoundationImplHTTPAuthHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationImplHTTPAuthHandlerInfo] = jsonOf[ComDayCqWcmFoundationImplHTTPAuthHandlerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.impl.HTTPAuthHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("authHttpNologin", Some(auth.http.nologinQuery.toParamString(auth.http.nologin))), ("authHttpRealm", Some(auth.http.realmQuery.toParamString(auth.http.realm))), ("authDefaultLoginpage", Some(auth.default.loginpageQuery.toParamString(auth.default.loginpage))), ("authCredForm", Some(auth.cred.formQuery.toParamString(auth.cred.form))), ("authCredUtf8", Some(auth.cred.utf8Query.toParamString(auth.cred.utf8))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationImplHTTPAuthHandlerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationImplPageImpressionsTracker(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingAuthRequirements: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingAuthRequirementsQuery: QueryParam[String]): Task[ComDayCqWcmFoundationImplPageImpressionsTrackerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationImplPageImpressionsTrackerInfo] = jsonOf[ComDayCqWcmFoundationImplPageImpressionsTrackerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.impl.PageImpressionsTracker"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingAuthRequirements", Some(sling.auth.requirementsQuery.toParamString(sling.auth.requirements))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationImplPageImpressionsTrackerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationImplPageRedirectServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], excludedResourceTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], excludedResourceTypesQuery: QueryParam[List[String]]): Task[ComDayCqWcmFoundationImplPageRedirectServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationImplPageRedirectServletInfo] = jsonOf[ComDayCqWcmFoundationImplPageRedirectServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.impl.PageRedirectServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("excludedResourceTypes", Some(excluded.resource.typesQuery.toParamString(excluded.resource.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationImplPageRedirectServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklist(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], defaultAttachmentTypeBlacklist: List[String], baselineAttachmentTypeBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], defaultAttachmentTypeBlacklistQuery: QueryParam[List[String]], baselineAttachmentTypeBlacklistQuery: QueryParam[List[String]]): Task[ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo] = jsonOf[ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.security.impl.DefaultAttachmentTypeBlacklistService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("defaultAttachmentTypeBlacklist", Some(default.attachment.type.blacklistQuery.toParamString(default.attachment.type.blacklist))), ("baselineAttachmentTypeBlacklist", Some(baseline.attachment.type.blacklistQuery.toParamString(baseline.attachment.type.blacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo](req)

    } yield resp
  }
  
  def comDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], parameterWhitelist: List[String], parameterWhitelistPrefixes: List[String], binaryParameterWhitelist: List[String], modifierWhitelist: List[String], operationWhitelist: List[String], operationWhitelistPrefixes: List[String], typehintWhitelist: List[String], resourcetypeWhitelist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], parameterWhitelistQuery: QueryParam[List[String]], parameterWhitelistPrefixesQuery: QueryParam[List[String]], binaryParameterWhitelistQuery: QueryParam[List[String]], modifierWhitelistQuery: QueryParam[List[String]], operationWhitelistQuery: QueryParam[List[String]], operationWhitelistPrefixesQuery: QueryParam[List[String]], typehintWhitelistQuery: QueryParam[List[String]], resourcetypeWhitelistQuery: QueryParam[List[String]]): Task[ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo] = jsonOf[ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.foundation.security.impl.SaferSlingPostValidatorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("parameterWhitelist", Some(parameter.whitelistQuery.toParamString(parameter.whitelist))), ("parameterWhitelistPrefixes", Some(parameter.whitelist.prefixesQuery.toParamString(parameter.whitelist.prefixes))), ("binaryParameterWhitelist", Some(binary.parameter.whitelistQuery.toParamString(binary.parameter.whitelist))), ("modifierWhitelist", Some(modifier.whitelistQuery.toParamString(modifier.whitelist))), ("operationWhitelist", Some(operation.whitelistQuery.toParamString(operation.whitelist))), ("operationWhitelistPrefixes", Some(operation.whitelist.prefixesQuery.toParamString(operation.whitelist.prefixes))), ("typehintWhitelist", Some(typehint.whitelistQuery.toParamString(typehint.whitelist))), ("resourcetypeWhitelist", Some(resourcetype.whitelistQuery.toParamString(resourcetype.whitelist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], deviceInfoTransformerEnabled: Boolean, deviceInfoTransformerCssStyle: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], deviceInfoTransformerEnabledQuery: QueryParam[Boolean], deviceInfoTransformerCssStyleQuery: QueryParam[String]): Task[ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo] = jsonOf[ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.mobile.core.impl.device.DeviceInfoTransformerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("deviceInfoTransformerEnabled", Some(device.info.transformer.enabledQuery.toParamString(device.info.transformer.enabled))), ("deviceInfoTransformerCssStyle", Some(device.info.transformer.css.styleQuery.toParamString(device.info.transformer.css.style))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMobileCoreImplRedirectRedirectFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], redirectEnabled: Boolean, redirectStatsEnabled: Boolean, redirectExtensions: List[String], redirectPaths: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], redirectEnabledQuery: QueryParam[Boolean], redirectStatsEnabledQuery: QueryParam[Boolean], redirectExtensionsQuery: QueryParam[List[String]], redirectPathsQuery: QueryParam[List[String]]): Task[ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo] = jsonOf[ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.mobile.core.impl.redirect.RedirectFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("redirectEnabled", Some(redirect.enabledQuery.toParamString(redirect.enabled))), ("redirectStatsEnabled", Some(redirect.stats.enabledQuery.toParamString(redirect.stats.enabled))), ("redirectExtensions", Some(redirect.extensionsQuery.toParamString(redirect.extensions))), ("redirectPaths", Some(redirect.pathsQuery.toParamString(redirect.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsContentCopyActionFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String], contentcopyactionOrderStyle: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]], contentcopyactionOrderStyleQuery: QueryParam[String]): Task[ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentCopyActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))), ("contentcopyactionOrderStyle", Some(contentcopyaction.order.styleQuery.toParamString(contentcopyaction.order.style))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsContentDeleteActionFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]]): Task[ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentDeleteActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsContentUpdateActionFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String], cqWcmMsmActionIgnoredMixin: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]], cqWcmMsmActionIgnoredMixinQuery: QueryParam[List[String]]): Task[ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentUpdateActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))), ("cqWcmMsmActionIgnoredMixin", Some(cq.wcm.msm.action.ignoredMixinQuery.toParamString(cq.wcm.msm.action.ignoredMixin))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsOrderChildrenActionFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]]): Task[ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.OrderChildrenActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsPageMoveActionFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String], cqWcmMsmImplActionsPagemovePropReferenceUpdate: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]], cqWcmMsmImplActionsPagemovePropReferenceUpdateQuery: QueryParam[Boolean]): Task[ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.PageMoveActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))), ("cqWcmMsmImplActionsPagemovePropReferenceUpdate", Some(cq.wcm.msm.impl.actions.pagemove.prop_referenceUpdateQuery.toParamString(cq.wcm.msm.impl.actions.pagemove.prop_referenceUpdate))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsReferencesUpdateActionFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String], cqWcmMsmImplActionReferencesupdatePropUpdateNested: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]], cqWcmMsmImplActionReferencesupdatePropUpdateNestedQuery: QueryParam[Boolean]): Task[ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ReferencesUpdateActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))), ("cqWcmMsmImplActionReferencesupdatePropUpdateNested", Some(cq.wcm.msm.impl.action.referencesupdate.prop_updateNestedQuery.toParamString(cq.wcm.msm.impl.action.referencesupdate.prop_updateNested))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplActionsVersionCopyActionFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmMsmActionExcludednodetypes: List[String], cqWcmMsmActionExcludedparagraphitems: List[String], cqWcmMsmActionExcludedprops: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmMsmActionExcludednodetypesQuery: QueryParam[List[String]], cqWcmMsmActionExcludedparagraphitemsQuery: QueryParam[List[String]], cqWcmMsmActionExcludedpropsQuery: QueryParam[List[String]]): Task[ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo] = jsonOf[ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.VersionCopyActionFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmMsmActionExcludednodetypes", Some(cq.wcm.msm.action.excludednodetypesQuery.toParamString(cq.wcm.msm.action.excludednodetypes))), ("cqWcmMsmActionExcludedparagraphitems", Some(cq.wcm.msm.action.excludedparagraphitemsQuery.toParamString(cq.wcm.msm.action.excludedparagraphitems))), ("cqWcmMsmActionExcludedprops", Some(cq.wcm.msm.action.excludedpropsQuery.toParamString(cq.wcm.msm.action.excludedprops))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplLiveRelationshipManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], liverelationshipmgrRelationsconfigDefault: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], liverelationshipmgrRelationsconfigDefaultQuery: QueryParam[String]): Task[ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo] = jsonOf[ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.LiveRelationshipManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("liverelationshipmgrRelationsconfigDefault", Some(liverelationshipmgr.relationsconfig.defaultQuery.toParamString(liverelationshipmgr.relationsconfig.default))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplRolloutManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String, rolloutmgrExcludedpropsDefault: List[String], rolloutmgrExcludedparagraphpropsDefault: List[String], rolloutmgrExcludednodetypesDefault: List[String], rolloutmgrThreadpoolMaxsize: Integer, rolloutmgrThreadpoolMaxshutdowntime: Integer, rolloutmgrThreadpoolPriority: String, rolloutmgrCommitSize: Integer, rolloutmgrConflicthandlingEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String], rolloutmgrExcludedpropsDefaultQuery: QueryParam[List[String]], rolloutmgrExcludedparagraphpropsDefaultQuery: QueryParam[List[String]], rolloutmgrExcludednodetypesDefaultQuery: QueryParam[List[String]], rolloutmgrThreadpoolMaxsizeQuery: QueryParam[Integer], rolloutmgrThreadpoolMaxshutdowntimeQuery: QueryParam[Integer], rolloutmgrThreadpoolPriorityQuery: QueryParam[String], rolloutmgrCommitSizeQuery: QueryParam[Integer], rolloutmgrConflicthandlingEnabledQuery: QueryParam[Boolean]): Task[ComDayCqWcmMsmImplRolloutManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplRolloutManagerImplInfo] = jsonOf[ComDayCqWcmMsmImplRolloutManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.RolloutManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("rolloutmgrExcludedpropsDefault", Some(rolloutmgr.excludedprops.defaultQuery.toParamString(rolloutmgr.excludedprops.default))), ("rolloutmgrExcludedparagraphpropsDefault", Some(rolloutmgr.excludedparagraphprops.defaultQuery.toParamString(rolloutmgr.excludedparagraphprops.default))), ("rolloutmgrExcludednodetypesDefault", Some(rolloutmgr.excludednodetypes.defaultQuery.toParamString(rolloutmgr.excludednodetypes.default))), ("rolloutmgrThreadpoolMaxsize", Some(rolloutmgr.threadpool.maxsizeQuery.toParamString(rolloutmgr.threadpool.maxsize))), ("rolloutmgrThreadpoolMaxshutdowntime", Some(rolloutmgr.threadpool.maxshutdowntimeQuery.toParamString(rolloutmgr.threadpool.maxshutdowntime))), ("rolloutmgrThreadpoolPriority", Some(rolloutmgr.threadpool.priorityQuery.toParamString(rolloutmgr.threadpool.priority))), ("rolloutmgrCommitSize", Some(rolloutmgr.commit.sizeQuery.toParamString(rolloutmgr.commit.size))), ("rolloutmgrConflicthandlingEnabled", Some(rolloutmgr.conflicthandling.enabledQuery.toParamString(rolloutmgr.conflicthandling.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplRolloutManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmMsmImplServletsAuditLogServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], auditlogservletDefaultEventsCount: Integer, auditlogservletDefaultPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], auditlogservletDefaultEventsCountQuery: QueryParam[Integer], auditlogservletDefaultPathQuery: QueryParam[String]): Task[ComDayCqWcmMsmImplServletsAuditLogServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmMsmImplServletsAuditLogServletInfo] = jsonOf[ComDayCqWcmMsmImplServletsAuditLogServletInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.msm.impl.servlets.AuditLogServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("auditlogservletDefaultEventsCount", Some(auditlogservlet.default.events.countQuery.toParamString(auditlogservlet.default.events.count))), ("auditlogservletDefaultPath", Some(auditlogservlet.default.pathQuery.toParamString(auditlogservlet.default.path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmMsmImplServletsAuditLogServletInfo](req)

    } yield resp
  }
  
  def comDayCqWcmNotificationEmailImplEmailChannel(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], emailFrom: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], emailFromQuery: QueryParam[String]): Task[ComDayCqWcmNotificationEmailImplEmailChannelInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmNotificationEmailImplEmailChannelInfo] = jsonOf[ComDayCqWcmNotificationEmailImplEmailChannelInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.notification.email.impl.EmailChannel"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("emailFrom", Some(email.fromQuery.toParamString(email.from))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmNotificationEmailImplEmailChannelInfo](req)

    } yield resp
  }
  
  def comDayCqWcmNotificationImplNotificationManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventTopics: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventTopicsQuery: QueryParam[List[String]]): Task[ComDayCqWcmNotificationImplNotificationManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmNotificationImplNotificationManagerImplInfo] = jsonOf[ComDayCqWcmNotificationImplNotificationManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.notification.impl.NotificationManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventTopics", Some(event.topicsQuery.toParamString(event.topics))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmNotificationImplNotificationManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmScriptingImplBVPManager(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], comDayCqWcmScriptingBvpScriptEngines: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], comDayCqWcmScriptingBvpScriptEnginesQuery: QueryParam[List[String]]): Task[ComDayCqWcmScriptingImplBVPManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmScriptingImplBVPManagerInfo] = jsonOf[ComDayCqWcmScriptingImplBVPManagerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.scripting.impl.BVPManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("comDayCqWcmScriptingBvpScriptEngines", Some(com.day.cq.wcm.scripting.bvp.script.enginesQuery.toParamString(com.day.cq.wcm.scripting.bvp.script.engines))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmScriptingImplBVPManagerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmUndoUndoConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cqWcmUndoEnabled: Boolean, cqWcmUndoPath: String, cqWcmUndoValidity: Integer, cqWcmUndoSteps: Integer, cqWcmUndoPersistence: String, cqWcmUndoPersistenceMode: Boolean, cqWcmUndoMarkermode: String, cqWcmUndoWhitelist: List[String], cqWcmUndoBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cqWcmUndoEnabledQuery: QueryParam[Boolean], cqWcmUndoPathQuery: QueryParam[String], cqWcmUndoValidityQuery: QueryParam[Integer], cqWcmUndoStepsQuery: QueryParam[Integer], cqWcmUndoPersistenceQuery: QueryParam[String], cqWcmUndoPersistenceModeQuery: QueryParam[Boolean], cqWcmUndoMarkermodeQuery: QueryParam[String], cqWcmUndoWhitelistQuery: QueryParam[List[String]], cqWcmUndoBlacklistQuery: QueryParam[List[String]]): Task[ComDayCqWcmUndoUndoConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmUndoUndoConfigInfo] = jsonOf[ComDayCqWcmUndoUndoConfigInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.undo.UndoConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cqWcmUndoEnabled", Some(cq.wcm.undo.enabledQuery.toParamString(cq.wcm.undo.enabled))), ("cqWcmUndoPath", Some(cq.wcm.undo.pathQuery.toParamString(cq.wcm.undo.path))), ("cqWcmUndoValidity", Some(cq.wcm.undo.validityQuery.toParamString(cq.wcm.undo.validity))), ("cqWcmUndoSteps", Some(cq.wcm.undo.stepsQuery.toParamString(cq.wcm.undo.steps))), ("cqWcmUndoPersistence", Some(cq.wcm.undo.persistenceQuery.toParamString(cq.wcm.undo.persistence))), ("cqWcmUndoPersistenceMode", Some(cq.wcm.undo.persistence.modeQuery.toParamString(cq.wcm.undo.persistence.mode))), ("cqWcmUndoMarkermode", Some(cq.wcm.undo.markermodeQuery.toParamString(cq.wcm.undo.markermode))), ("cqWcmUndoWhitelist", Some(cq.wcm.undo.whitelistQuery.toParamString(cq.wcm.undo.whitelist))), ("cqWcmUndoBlacklist", Some(cq.wcm.undo.blacklistQuery.toParamString(cq.wcm.undo.blacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmUndoUndoConfigInfo](req)

    } yield resp
  }
  
  def comDayCqWcmWebservicesupportImplReplicationEventListener(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], flushAgents: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], flushAgentsQuery: QueryParam[List[String]]): Task[ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo] = jsonOf[ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.webservicesupport.impl.ReplicationEventListener"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("flushAgents", Some(Flush agentsQuery.toParamString(Flush agents))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo](req)

    } yield resp
  }
  
  def comDayCqWcmWorkflowImplWcmWorkflowServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], eventFilter: String, minThreadPoolSize: Integer, maxThreadPoolSize: Integer, cqWcmWorkflowTerminateOnActivate: Boolean, cqWcmWorklfowTerminateExclusionList: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], eventFilterQuery: QueryParam[String], minThreadPoolSizeQuery: QueryParam[Integer], maxThreadPoolSizeQuery: QueryParam[Integer], cqWcmWorkflowTerminateOnActivateQuery: QueryParam[Boolean], cqWcmWorklfowTerminateExclusionListQuery: QueryParam[List[String]]): Task[ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo] = jsonOf[ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.workflow.impl.WcmWorkflowServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("eventFilter", Some(event.filterQuery.toParamString(event.filter))), ("minThreadPoolSize", Some(minThreadPoolSizeQuery.toParamString(minThreadPoolSize))), ("maxThreadPoolSize", Some(maxThreadPoolSizeQuery.toParamString(maxThreadPoolSize))), ("cqWcmWorkflowTerminateOnActivate", Some(cq.wcm.workflow.terminate.on.activateQuery.toParamString(cq.wcm.workflow.terminate.on.activate))), ("cqWcmWorklfowTerminateExclusionList", Some(cq.wcm.worklfow.terminate.exclusion.listQuery.toParamString(cq.wcm.worklfow.terminate.exclusion.list))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo](req)

    } yield resp
  }
  
  def comDayCqWcmWorkflowImplWorkflowPackageInfoProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], workflowpackageinfoproviderFilter: List[String], workflowpackageinfoproviderFilterRootpath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], workflowpackageinfoproviderFilterQuery: QueryParam[List[String]], workflowpackageinfoproviderFilterRootpathQuery: QueryParam[String]): Task[ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo] = jsonOf[ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo]

    val path = "/system/console/configMgr/com.day.cq.wcm.workflow.impl.WorkflowPackageInfoProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("workflowpackageinfoproviderFilter", Some(workflowpackageinfoprovider.filterQuery.toParamString(workflowpackageinfoprovider.filter))), ("workflowpackageinfoproviderFilterRootpath", Some(workflowpackageinfoprovider.filter.rootpathQuery.toParamString(workflowpackageinfoprovider.filter.rootpath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo](req)

    } yield resp
  }
  
  def comDayCqWidgetImplHtmlLibraryManagerImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], htmllibmanagerClientmanager: String, htmllibmanagerDebug: Boolean, htmllibmanagerDebugConsole: Boolean, htmllibmanagerDebugInitJs: String, htmllibmanagerDefaultthemename: String, htmllibmanagerDefaultuserthemename: String, htmllibmanagerFirebuglitePath: String, htmllibmanagerForceCQUrlInfo: Boolean, htmllibmanagerGzip: Boolean, htmllibmanagerMaxage: Integer, htmllibmanagerMaxDataUriSize: Integer, htmllibmanagerMinify: Boolean, htmllibmanagerPathList: List[String], htmllibmanagerTiming: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], htmllibmanagerClientmanagerQuery: QueryParam[String], htmllibmanagerDebugQuery: QueryParam[Boolean], htmllibmanagerDebugConsoleQuery: QueryParam[Boolean], htmllibmanagerDebugInitJsQuery: QueryParam[String], htmllibmanagerDefaultthemenameQuery: QueryParam[String], htmllibmanagerDefaultuserthemenameQuery: QueryParam[String], htmllibmanagerFirebuglitePathQuery: QueryParam[String], htmllibmanagerForceCQUrlInfoQuery: QueryParam[Boolean], htmllibmanagerGzipQuery: QueryParam[Boolean], htmllibmanagerMaxageQuery: QueryParam[Integer], htmllibmanagerMaxDataUriSizeQuery: QueryParam[Integer], htmllibmanagerMinifyQuery: QueryParam[Boolean], htmllibmanagerPathListQuery: QueryParam[List[String]], htmllibmanagerTimingQuery: QueryParam[Boolean]): Task[ComDayCqWidgetImplHtmlLibraryManagerImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWidgetImplHtmlLibraryManagerImplInfo] = jsonOf[ComDayCqWidgetImplHtmlLibraryManagerImplInfo]

    val path = "/system/console/configMgr/com.day.cq.widget.impl.HtmlLibraryManagerImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("htmllibmanagerClientmanager", Some(htmllibmanager.clientmanagerQuery.toParamString(htmllibmanager.clientmanager))), ("htmllibmanagerDebug", Some(htmllibmanager.debugQuery.toParamString(htmllibmanager.debug))), ("htmllibmanagerDebugConsole", Some(htmllibmanager.debug.consoleQuery.toParamString(htmllibmanager.debug.console))), ("htmllibmanagerDebugInitJs", Some(htmllibmanager.debug.init.jsQuery.toParamString(htmllibmanager.debug.init.js))), ("htmllibmanagerDefaultthemename", Some(htmllibmanager.defaultthemenameQuery.toParamString(htmllibmanager.defaultthemename))), ("htmllibmanagerDefaultuserthemename", Some(htmllibmanager.defaultuserthemenameQuery.toParamString(htmllibmanager.defaultuserthemename))), ("htmllibmanagerFirebuglitePath", Some(htmllibmanager.firebuglite.pathQuery.toParamString(htmllibmanager.firebuglite.path))), ("htmllibmanagerForceCQUrlInfo", Some(htmllibmanager.forceCQUrlInfoQuery.toParamString(htmllibmanager.forceCQUrlInfo))), ("htmllibmanagerGzip", Some(htmllibmanager.gzipQuery.toParamString(htmllibmanager.gzip))), ("htmllibmanagerMaxage", Some(htmllibmanager.maxageQuery.toParamString(htmllibmanager.maxage))), ("htmllibmanagerMaxDataUriSize", Some(htmllibmanager.maxDataUriSizeQuery.toParamString(htmllibmanager.maxDataUriSize))), ("htmllibmanagerMinify", Some(htmllibmanager.minifyQuery.toParamString(htmllibmanager.minify))), ("htmllibmanagerPathList", Some(htmllibmanager.path.listQuery.toParamString(htmllibmanager.path.list))), ("htmllibmanagerTiming", Some(htmllibmanager.timingQuery.toParamString(htmllibmanager.timing))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWidgetImplHtmlLibraryManagerImplInfo](req)

    } yield resp
  }
  
  def comDayCqWidgetImplWidgetExtensionProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], extendableWidgets: List[String], widgetextensionproviderDebug: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], extendableWidgetsQuery: QueryParam[List[String]], widgetextensionproviderDebugQuery: QueryParam[Boolean]): Task[ComDayCqWidgetImplWidgetExtensionProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWidgetImplWidgetExtensionProviderImplInfo] = jsonOf[ComDayCqWidgetImplWidgetExtensionProviderImplInfo]

    val path = "/system/console/configMgr/com.day.cq.widget.impl.WidgetExtensionProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("extendableWidgets", Some(extendable.widgetsQuery.toParamString(extendable.widgets))), ("widgetextensionproviderDebug", Some(widgetextensionprovider.debugQuery.toParamString(widgetextensionprovider.debug))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWidgetImplWidgetExtensionProviderImplInfo](req)

    } yield resp
  }
  
  def comDayCqWorkflowImplEmailEMailNotificationService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], fromAddress: String, hostPrefix: String, notifyOnabort: Boolean, notifyOncomplete: Boolean, notifyOncontainercomplete: Boolean, notifyUseronly: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], fromAddressQuery: QueryParam[String], hostPrefixQuery: QueryParam[String], notifyOnabortQuery: QueryParam[Boolean], notifyOncompleteQuery: QueryParam[Boolean], notifyOncontainercompleteQuery: QueryParam[Boolean], notifyUseronlyQuery: QueryParam[Boolean]): Task[ComDayCqWorkflowImplEmailEMailNotificationServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWorkflowImplEmailEMailNotificationServiceInfo] = jsonOf[ComDayCqWorkflowImplEmailEMailNotificationServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.workflow.impl.email.EMailNotificationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("fromAddress", Some(from.addressQuery.toParamString(from.address))), ("hostPrefix", Some(host.prefixQuery.toParamString(host.prefix))), ("notifyOnabort", Some(notify.onabortQuery.toParamString(notify.onabort))), ("notifyOncomplete", Some(notify.oncompleteQuery.toParamString(notify.oncomplete))), ("notifyOncontainercomplete", Some(notify.oncontainercompleteQuery.toParamString(notify.oncontainercomplete))), ("notifyUseronly", Some(notify.useronlyQuery.toParamString(notify.useronly))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWorkflowImplEmailEMailNotificationServiceInfo](req)

    } yield resp
  }
  
  def comDayCqWorkflowImplEmailTaskEMailNotificationService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], notifyOnupdate: Boolean, notifyOncomplete: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], notifyOnupdateQuery: QueryParam[Boolean], notifyOncompleteQuery: QueryParam[Boolean]): Task[ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo] = jsonOf[ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo]

    val path = "/system/console/configMgr/com.day.cq.workflow.impl.email.TaskEMailNotificationService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("notifyOnupdate", Some(notify.onupdateQuery.toParamString(notify.onupdate))), ("notifyOncomplete", Some(notify.oncompleteQuery.toParamString(notify.oncomplete))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo](req)

    } yield resp
  }
  
  def comDayCrxSecurityTokenImplImplTokenAuthenticationHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, tokenRequiredAttr: String, tokenAlternateUrl: String, tokenEncapsulated: Boolean, skipTokenRefresh: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], tokenRequiredAttrQuery: QueryParam[String], tokenAlternateUrlQuery: QueryParam[String], tokenEncapsulatedQuery: QueryParam[Boolean], skipTokenRefreshQuery: QueryParam[List[String]]): Task[ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo] = jsonOf[ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo]

    val path = "/system/console/configMgr/com.day.crx.security.token.impl.impl.TokenAuthenticationHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("tokenRequiredAttr", Some(token.required.attrQuery.toParamString(token.required.attr))), ("tokenAlternateUrl", Some(token.alternate.urlQuery.toParamString(token.alternate.url))), ("tokenEncapsulated", Some(token.encapsulatedQuery.toParamString(token.encapsulated))), ("skipTokenRefresh", Some(skip.token.refreshQuery.toParamString(skip.token.refresh))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo](req)

    } yield resp
  }
  
  def comDayCrxSecurityTokenImplTokenCleanupTask(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enableTokenCleanupTask: Boolean, schedulerExpression: String, batchSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enableTokenCleanupTaskQuery: QueryParam[Boolean], schedulerExpressionQuery: QueryParam[String], batchSizeQuery: QueryParam[Integer]): Task[ComDayCrxSecurityTokenImplTokenCleanupTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[ComDayCrxSecurityTokenImplTokenCleanupTaskInfo] = jsonOf[ComDayCrxSecurityTokenImplTokenCleanupTaskInfo]

    val path = "/system/console/configMgr/com.day.crx.security.token.impl.TokenCleanupTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enableTokenCleanupTask", Some(enable.token.cleanup.taskQuery.toParamString(enable.token.cleanup.task))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("batchSize", Some(batch.sizeQuery.toParamString(batch.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[ComDayCrxSecurityTokenImplTokenCleanupTaskInfo](req)

    } yield resp
  }
  
  def guideLocalizationService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], supportedLocales: List[String], localizableProperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], supportedLocalesQuery: QueryParam[List[String]], localizablePropertiesQuery: QueryParam[List[String]]): Task[GuideLocalizationServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[GuideLocalizationServiceInfo] = jsonOf[GuideLocalizationServiceInfo]

    val path = "/system/console/configMgr/Guide Localization Service"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("supportedLocales", Some(supportedLocalesQuery.toParamString(supportedLocales))), ("localizableProperties", Some(Localizable PropertiesQuery.toParamString(Localizable Properties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[GuideLocalizationServiceInfo](req)

    } yield resp
  }
  
  def messagingUserComponentFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], priority: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], priorityQuery: QueryParam[Integer]): Task[MessagingUserComponentFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[MessagingUserComponentFactoryInfo] = jsonOf[MessagingUserComponentFactoryInfo]

    val path = "/system/console/configMgr/MessagingUserComponentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[MessagingUserComponentFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheAriesJmxFrameworkStateConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], attributeChangeNotificationEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], attributeChangeNotificationEnabledQuery: QueryParam[Boolean]): Task[OrgApacheAriesJmxFrameworkStateConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheAriesJmxFrameworkStateConfigInfo] = jsonOf[OrgApacheAriesJmxFrameworkStateConfigInfo]

    val path = "/system/console/configMgr/org.apache.aries.jmx.framework.StateConfig"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("attributeChangeNotificationEnabled", Some(attributeChangeNotificationEnabledQuery.toParamString(attributeChangeNotificationEnabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheAriesJmxFrameworkStateConfigInfo](req)

    } yield resp
  }
  
  def orgApacheFelixEventadminImplEventAdmin(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheFelixEventadminThreadPoolSize: Integer, orgApacheFelixEventadminAsyncToSyncThreadRatio: BigDecimal, orgApacheFelixEventadminTimeout: Integer, orgApacheFelixEventadminRequireTopic: Boolean, orgApacheFelixEventadminIgnoreTimeout: List[String], orgApacheFelixEventadminIgnoreTopic: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheFelixEventadminThreadPoolSizeQuery: QueryParam[Integer], orgApacheFelixEventadminAsyncToSyncThreadRatioQuery: QueryParam[BigDecimal], orgApacheFelixEventadminTimeoutQuery: QueryParam[Integer], orgApacheFelixEventadminRequireTopicQuery: QueryParam[Boolean], orgApacheFelixEventadminIgnoreTimeoutQuery: QueryParam[List[String]], orgApacheFelixEventadminIgnoreTopicQuery: QueryParam[List[String]]): Task[OrgApacheFelixEventadminImplEventAdminInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixEventadminImplEventAdminInfo] = jsonOf[OrgApacheFelixEventadminImplEventAdminInfo]

    val path = "/system/console/configMgr/org.apache.felix.eventadmin.impl.EventAdmin"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheFelixEventadminThreadPoolSize", Some(org.apache.felix.eventadmin.ThreadPoolSizeQuery.toParamString(org.apache.felix.eventadmin.ThreadPoolSize))), ("orgApacheFelixEventadminAsyncToSyncThreadRatio", Some(org.apache.felix.eventadmin.AsyncToSyncThreadRatioQuery.toParamString(org.apache.felix.eventadmin.AsyncToSyncThreadRatio))), ("orgApacheFelixEventadminTimeout", Some(org.apache.felix.eventadmin.TimeoutQuery.toParamString(org.apache.felix.eventadmin.Timeout))), ("orgApacheFelixEventadminRequireTopic", Some(org.apache.felix.eventadmin.RequireTopicQuery.toParamString(org.apache.felix.eventadmin.RequireTopic))), ("orgApacheFelixEventadminIgnoreTimeout", Some(org.apache.felix.eventadmin.IgnoreTimeoutQuery.toParamString(org.apache.felix.eventadmin.IgnoreTimeout))), ("orgApacheFelixEventadminIgnoreTopic", Some(org.apache.felix.eventadmin.IgnoreTopicQuery.toParamString(org.apache.felix.eventadmin.IgnoreTopic))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixEventadminImplEventAdminInfo](req)

    } yield resp
  }
  
  def orgApacheFelixHttp(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheFelixHttpHost: String, orgApacheFelixHttpEnable: Boolean, orgOsgiServiceHttpPort: Integer, orgApacheFelixHttpTimeout: Integer, orgApacheFelixHttpsEnable: Boolean, orgOsgiServiceHttpPortSecure: Integer, orgApacheFelixHttpsKeystore: String, orgApacheFelixHttpsKeystorePassword: String, orgApacheFelixHttpsKeystoreKeyPassword: String, orgApacheFelixHttpsTruststore: String, orgApacheFelixHttpsTruststorePassword: String, orgApacheFelixHttpsClientcertificate: String, orgApacheFelixHttpContextPath: String, orgApacheFelixHttpMbeans: Boolean, orgApacheFelixHttpSessionTimeout: Integer, orgApacheFelixHttpJettyThreadpoolMax: Integer, orgApacheFelixHttpJettyAcceptors: Integer, orgApacheFelixHttpJettySelectors: Integer, orgApacheFelixHttpJettyHeaderBufferSize: Integer, orgApacheFelixHttpJettyRequestBufferSize: Integer, orgApacheFelixHttpJettyResponseBufferSize: Integer, orgApacheFelixHttpJettyMaxFormSize: Integer, orgApacheFelixHttpPathExclusions: List[String], orgApacheFelixHttpsJettyCiphersuitesExcluded: List[String], orgApacheFelixHttpsJettyCiphersuitesIncluded: List[String], orgApacheFelixHttpJettySendServerHeader: Boolean, orgApacheFelixHttpsJettyProtocolsIncluded: List[String], orgApacheFelixHttpsJettyProtocolsExcluded: List[String], orgApacheFelixProxyLoadBalancerConnectionEnable: Boolean, orgApacheFelixHttpsJettyRenegotiateAllowed: Boolean, orgApacheFelixHttpsJettySessionCookieHttpOnly: Boolean, orgApacheFelixHttpsJettySessionCookieSecure: Boolean, orgEclipseJettyServletSessionIdPathParameterName: String, orgEclipseJettyServletCheckingRemoteSessionIdEncoding: Boolean, orgEclipseJettyServletSessionCookie: String, orgEclipseJettyServletSessionDomain: String, orgEclipseJettyServletSessionPath: String, orgEclipseJettyServletMaxAge: Integer, orgApacheFelixHttpName: String, orgApacheFelixJettyGziphandlerEnable: Boolean, orgApacheFelixJettyGzipMinGzipSize: Integer, orgApacheFelixJettyGzipCompressionLevel: Integer, orgApacheFelixJettyGzipInflateBufferSize: Integer, orgApacheFelixJettyGzipSyncFlush: Boolean, orgApacheFelixJettyGzipExcludedUserAgents: List[String], orgApacheFelixJettyGzipIncludedMethods: List[String], orgApacheFelixJettyGzipExcludedMethods: List[String], orgApacheFelixJettyGzipIncludedPaths: List[String], orgApacheFelixJettyGzipExcludedPaths: List[String], orgApacheFelixJettyGzipIncludedMimeTypes: List[String], orgApacheFelixJettyGzipExcludedMimeTypes: List[String], orgApacheFelixHttpSessionInvalidate: Boolean, orgApacheFelixHttpSessionUniqueid: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheFelixHttpHostQuery: QueryParam[String], orgApacheFelixHttpEnableQuery: QueryParam[Boolean], orgOsgiServiceHttpPortQuery: QueryParam[Integer], orgApacheFelixHttpTimeoutQuery: QueryParam[Integer], orgApacheFelixHttpsEnableQuery: QueryParam[Boolean], orgOsgiServiceHttpPortSecureQuery: QueryParam[Integer], orgApacheFelixHttpsKeystoreQuery: QueryParam[String], orgApacheFelixHttpsKeystorePasswordQuery: QueryParam[String], orgApacheFelixHttpsKeystoreKeyPasswordQuery: QueryParam[String], orgApacheFelixHttpsTruststoreQuery: QueryParam[String], orgApacheFelixHttpsTruststorePasswordQuery: QueryParam[String], orgApacheFelixHttpsClientcertificateQuery: QueryParam[String], orgApacheFelixHttpContextPathQuery: QueryParam[String], orgApacheFelixHttpMbeansQuery: QueryParam[Boolean], orgApacheFelixHttpSessionTimeoutQuery: QueryParam[Integer], orgApacheFelixHttpJettyThreadpoolMaxQuery: QueryParam[Integer], orgApacheFelixHttpJettyAcceptorsQuery: QueryParam[Integer], orgApacheFelixHttpJettySelectorsQuery: QueryParam[Integer], orgApacheFelixHttpJettyHeaderBufferSizeQuery: QueryParam[Integer], orgApacheFelixHttpJettyRequestBufferSizeQuery: QueryParam[Integer], orgApacheFelixHttpJettyResponseBufferSizeQuery: QueryParam[Integer], orgApacheFelixHttpJettyMaxFormSizeQuery: QueryParam[Integer], orgApacheFelixHttpPathExclusionsQuery: QueryParam[List[String]], orgApacheFelixHttpsJettyCiphersuitesExcludedQuery: QueryParam[List[String]], orgApacheFelixHttpsJettyCiphersuitesIncludedQuery: QueryParam[List[String]], orgApacheFelixHttpJettySendServerHeaderQuery: QueryParam[Boolean], orgApacheFelixHttpsJettyProtocolsIncludedQuery: QueryParam[List[String]], orgApacheFelixHttpsJettyProtocolsExcludedQuery: QueryParam[List[String]], orgApacheFelixProxyLoadBalancerConnectionEnableQuery: QueryParam[Boolean], orgApacheFelixHttpsJettyRenegotiateAllowedQuery: QueryParam[Boolean], orgApacheFelixHttpsJettySessionCookieHttpOnlyQuery: QueryParam[Boolean], orgApacheFelixHttpsJettySessionCookieSecureQuery: QueryParam[Boolean], orgEclipseJettyServletSessionIdPathParameterNameQuery: QueryParam[String], orgEclipseJettyServletCheckingRemoteSessionIdEncodingQuery: QueryParam[Boolean], orgEclipseJettyServletSessionCookieQuery: QueryParam[String], orgEclipseJettyServletSessionDomainQuery: QueryParam[String], orgEclipseJettyServletSessionPathQuery: QueryParam[String], orgEclipseJettyServletMaxAgeQuery: QueryParam[Integer], orgApacheFelixHttpNameQuery: QueryParam[String], orgApacheFelixJettyGziphandlerEnableQuery: QueryParam[Boolean], orgApacheFelixJettyGzipMinGzipSizeQuery: QueryParam[Integer], orgApacheFelixJettyGzipCompressionLevelQuery: QueryParam[Integer], orgApacheFelixJettyGzipInflateBufferSizeQuery: QueryParam[Integer], orgApacheFelixJettyGzipSyncFlushQuery: QueryParam[Boolean], orgApacheFelixJettyGzipExcludedUserAgentsQuery: QueryParam[List[String]], orgApacheFelixJettyGzipIncludedMethodsQuery: QueryParam[List[String]], orgApacheFelixJettyGzipExcludedMethodsQuery: QueryParam[List[String]], orgApacheFelixJettyGzipIncludedPathsQuery: QueryParam[List[String]], orgApacheFelixJettyGzipExcludedPathsQuery: QueryParam[List[String]], orgApacheFelixJettyGzipIncludedMimeTypesQuery: QueryParam[List[String]], orgApacheFelixJettyGzipExcludedMimeTypesQuery: QueryParam[List[String]], orgApacheFelixHttpSessionInvalidateQuery: QueryParam[Boolean], orgApacheFelixHttpSessionUniqueidQuery: QueryParam[Boolean]): Task[OrgApacheFelixHttpInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixHttpInfo] = jsonOf[OrgApacheFelixHttpInfo]

    val path = "/system/console/configMgr/org.apache.felix.http"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheFelixHttpHost", Some(org.apache.felix.http.hostQuery.toParamString(org.apache.felix.http.host))), ("orgApacheFelixHttpEnable", Some(org.apache.felix.http.enableQuery.toParamString(org.apache.felix.http.enable))), ("orgOsgiServiceHttpPort", Some(org.osgi.service.http.portQuery.toParamString(org.osgi.service.http.port))), ("orgApacheFelixHttpTimeout", Some(org.apache.felix.http.timeoutQuery.toParamString(org.apache.felix.http.timeout))), ("orgApacheFelixHttpsEnable", Some(org.apache.felix.https.enableQuery.toParamString(org.apache.felix.https.enable))), ("orgOsgiServiceHttpPortSecure", Some(org.osgi.service.http.port.secureQuery.toParamString(org.osgi.service.http.port.secure))), ("orgApacheFelixHttpsKeystore", Some(org.apache.felix.https.keystoreQuery.toParamString(org.apache.felix.https.keystore))), ("orgApacheFelixHttpsKeystorePassword", Some(org.apache.felix.https.keystore.passwordQuery.toParamString(org.apache.felix.https.keystore.password))), ("orgApacheFelixHttpsKeystoreKeyPassword", Some(org.apache.felix.https.keystore.key.passwordQuery.toParamString(org.apache.felix.https.keystore.key.password))), ("orgApacheFelixHttpsTruststore", Some(org.apache.felix.https.truststoreQuery.toParamString(org.apache.felix.https.truststore))), ("orgApacheFelixHttpsTruststorePassword", Some(org.apache.felix.https.truststore.passwordQuery.toParamString(org.apache.felix.https.truststore.password))), ("orgApacheFelixHttpsClientcertificate", Some(org.apache.felix.https.clientcertificateQuery.toParamString(org.apache.felix.https.clientcertificate))), ("orgApacheFelixHttpContextPath", Some(org.apache.felix.http.context_pathQuery.toParamString(org.apache.felix.http.context_path))), ("orgApacheFelixHttpMbeans", Some(org.apache.felix.http.mbeansQuery.toParamString(org.apache.felix.http.mbeans))), ("orgApacheFelixHttpSessionTimeout", Some(org.apache.felix.http.session.timeoutQuery.toParamString(org.apache.felix.http.session.timeout))), ("orgApacheFelixHttpJettyThreadpoolMax", Some(org.apache.felix.http.jetty.threadpool.maxQuery.toParamString(org.apache.felix.http.jetty.threadpool.max))), ("orgApacheFelixHttpJettyAcceptors", Some(org.apache.felix.http.jetty.acceptorsQuery.toParamString(org.apache.felix.http.jetty.acceptors))), ("orgApacheFelixHttpJettySelectors", Some(org.apache.felix.http.jetty.selectorsQuery.toParamString(org.apache.felix.http.jetty.selectors))), ("orgApacheFelixHttpJettyHeaderBufferSize", Some(org.apache.felix.http.jetty.headerBufferSizeQuery.toParamString(org.apache.felix.http.jetty.headerBufferSize))), ("orgApacheFelixHttpJettyRequestBufferSize", Some(org.apache.felix.http.jetty.requestBufferSizeQuery.toParamString(org.apache.felix.http.jetty.requestBufferSize))), ("orgApacheFelixHttpJettyResponseBufferSize", Some(org.apache.felix.http.jetty.responseBufferSizeQuery.toParamString(org.apache.felix.http.jetty.responseBufferSize))), ("orgApacheFelixHttpJettyMaxFormSize", Some(org.apache.felix.http.jetty.maxFormSizeQuery.toParamString(org.apache.felix.http.jetty.maxFormSize))), ("orgApacheFelixHttpPathExclusions", Some(org.apache.felix.http.path_exclusionsQuery.toParamString(org.apache.felix.http.path_exclusions))), ("orgApacheFelixHttpsJettyCiphersuitesExcluded", Some(org.apache.felix.https.jetty.ciphersuites.excludedQuery.toParamString(org.apache.felix.https.jetty.ciphersuites.excluded))), ("orgApacheFelixHttpsJettyCiphersuitesIncluded", Some(org.apache.felix.https.jetty.ciphersuites.includedQuery.toParamString(org.apache.felix.https.jetty.ciphersuites.included))), ("orgApacheFelixHttpJettySendServerHeader", Some(org.apache.felix.http.jetty.sendServerHeaderQuery.toParamString(org.apache.felix.http.jetty.sendServerHeader))), ("orgApacheFelixHttpsJettyProtocolsIncluded", Some(org.apache.felix.https.jetty.protocols.includedQuery.toParamString(org.apache.felix.https.jetty.protocols.included))), ("orgApacheFelixHttpsJettyProtocolsExcluded", Some(org.apache.felix.https.jetty.protocols.excludedQuery.toParamString(org.apache.felix.https.jetty.protocols.excluded))), ("orgApacheFelixProxyLoadBalancerConnectionEnable", Some(org.apache.felix.proxy.load.balancer.connection.enableQuery.toParamString(org.apache.felix.proxy.load.balancer.connection.enable))), ("orgApacheFelixHttpsJettyRenegotiateAllowed", Some(org.apache.felix.https.jetty.renegotiateAllowedQuery.toParamString(org.apache.felix.https.jetty.renegotiateAllowed))), ("orgApacheFelixHttpsJettySessionCookieHttpOnly", Some(org.apache.felix.https.jetty.session.cookie.httpOnlyQuery.toParamString(org.apache.felix.https.jetty.session.cookie.httpOnly))), ("orgApacheFelixHttpsJettySessionCookieSecure", Some(org.apache.felix.https.jetty.session.cookie.secureQuery.toParamString(org.apache.felix.https.jetty.session.cookie.secure))), ("orgEclipseJettyServletSessionIdPathParameterName", Some(org.eclipse.jetty.servlet.SessionIdPathParameterNameQuery.toParamString(org.eclipse.jetty.servlet.SessionIdPathParameterName))), ("orgEclipseJettyServletCheckingRemoteSessionIdEncoding", Some(org.eclipse.jetty.servlet.CheckingRemoteSessionIdEncodingQuery.toParamString(org.eclipse.jetty.servlet.CheckingRemoteSessionIdEncoding))), ("orgEclipseJettyServletSessionCookie", Some(org.eclipse.jetty.servlet.SessionCookieQuery.toParamString(org.eclipse.jetty.servlet.SessionCookie))), ("orgEclipseJettyServletSessionDomain", Some(org.eclipse.jetty.servlet.SessionDomainQuery.toParamString(org.eclipse.jetty.servlet.SessionDomain))), ("orgEclipseJettyServletSessionPath", Some(org.eclipse.jetty.servlet.SessionPathQuery.toParamString(org.eclipse.jetty.servlet.SessionPath))), ("orgEclipseJettyServletMaxAge", Some(org.eclipse.jetty.servlet.MaxAgeQuery.toParamString(org.eclipse.jetty.servlet.MaxAge))), ("orgApacheFelixHttpName", Some(org.apache.felix.http.nameQuery.toParamString(org.apache.felix.http.name))), ("orgApacheFelixJettyGziphandlerEnable", Some(org.apache.felix.jetty.gziphandler.enableQuery.toParamString(org.apache.felix.jetty.gziphandler.enable))), ("orgApacheFelixJettyGzipMinGzipSize", Some(org.apache.felix.jetty.gzip.minGzipSizeQuery.toParamString(org.apache.felix.jetty.gzip.minGzipSize))), ("orgApacheFelixJettyGzipCompressionLevel", Some(org.apache.felix.jetty.gzip.compressionLevelQuery.toParamString(org.apache.felix.jetty.gzip.compressionLevel))), ("orgApacheFelixJettyGzipInflateBufferSize", Some(org.apache.felix.jetty.gzip.inflateBufferSizeQuery.toParamString(org.apache.felix.jetty.gzip.inflateBufferSize))), ("orgApacheFelixJettyGzipSyncFlush", Some(org.apache.felix.jetty.gzip.syncFlushQuery.toParamString(org.apache.felix.jetty.gzip.syncFlush))), ("orgApacheFelixJettyGzipExcludedUserAgents", Some(org.apache.felix.jetty.gzip.excludedUserAgentsQuery.toParamString(org.apache.felix.jetty.gzip.excludedUserAgents))), ("orgApacheFelixJettyGzipIncludedMethods", Some(org.apache.felix.jetty.gzip.includedMethodsQuery.toParamString(org.apache.felix.jetty.gzip.includedMethods))), ("orgApacheFelixJettyGzipExcludedMethods", Some(org.apache.felix.jetty.gzip.excludedMethodsQuery.toParamString(org.apache.felix.jetty.gzip.excludedMethods))), ("orgApacheFelixJettyGzipIncludedPaths", Some(org.apache.felix.jetty.gzip.includedPathsQuery.toParamString(org.apache.felix.jetty.gzip.includedPaths))), ("orgApacheFelixJettyGzipExcludedPaths", Some(org.apache.felix.jetty.gzip.excludedPathsQuery.toParamString(org.apache.felix.jetty.gzip.excludedPaths))), ("orgApacheFelixJettyGzipIncludedMimeTypes", Some(org.apache.felix.jetty.gzip.includedMimeTypesQuery.toParamString(org.apache.felix.jetty.gzip.includedMimeTypes))), ("orgApacheFelixJettyGzipExcludedMimeTypes", Some(org.apache.felix.jetty.gzip.excludedMimeTypesQuery.toParamString(org.apache.felix.jetty.gzip.excludedMimeTypes))), ("orgApacheFelixHttpSessionInvalidate", Some(org.apache.felix.http.session.invalidateQuery.toParamString(org.apache.felix.http.session.invalidate))), ("orgApacheFelixHttpSessionUniqueid", Some(org.apache.felix.http.session.uniqueidQuery.toParamString(org.apache.felix.http.session.uniqueid))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixHttpInfo](req)

    } yield resp
  }
  
  def orgApacheFelixHttpSslfilterSslFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], sslForwardHeader: String, sslForwardValue: String, sslForwardCertHeader: String, rewriteAbsoluteUrls: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], sslForwardHeaderQuery: QueryParam[String], sslForwardValueQuery: QueryParam[String], sslForwardCertHeaderQuery: QueryParam[String], rewriteAbsoluteUrlsQuery: QueryParam[Boolean]): Task[OrgApacheFelixHttpSslfilterSslFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixHttpSslfilterSslFilterInfo] = jsonOf[OrgApacheFelixHttpSslfilterSslFilterInfo]

    val path = "/system/console/configMgr/org.apache.felix.http.sslfilter.SslFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("sslForwardHeader", Some(ssl-forward.headerQuery.toParamString(ssl-forward.header))), ("sslForwardValue", Some(ssl-forward.valueQuery.toParamString(ssl-forward.value))), ("sslForwardCertHeader", Some(ssl-forward-cert.headerQuery.toParamString(ssl-forward-cert.header))), ("rewriteAbsoluteUrls", Some(rewrite.absolute.urlsQuery.toParamString(rewrite.absolute.urls))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixHttpSslfilterSslFilterInfo](req)

    } yield resp
  }
  
  def orgApacheFelixJaasConfigurationFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jaasControlFlag: String, jaasRanking: Integer, jaasRealmName: String, jaasClassname: String, jaasOptions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jaasControlFlagQuery: QueryParam[String], jaasRankingQuery: QueryParam[Integer], jaasRealmNameQuery: QueryParam[String], jaasClassnameQuery: QueryParam[String], jaasOptionsQuery: QueryParam[List[String]]): Task[OrgApacheFelixJaasConfigurationFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixJaasConfigurationFactoryInfo] = jsonOf[OrgApacheFelixJaasConfigurationFactoryInfo]

    val path = "/system/console/configMgr/org.apache.felix.jaas.Configuration.factory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jaasControlFlag", Some(jaas.controlFlagQuery.toParamString(jaas.controlFlag))), ("jaasRanking", Some(jaas.rankingQuery.toParamString(jaas.ranking))), ("jaasRealmName", Some(jaas.realmNameQuery.toParamString(jaas.realmName))), ("jaasClassname", Some(jaas.classnameQuery.toParamString(jaas.classname))), ("jaasOptions", Some(jaas.optionsQuery.toParamString(jaas.options))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixJaasConfigurationFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheFelixJaasConfigurationSpi(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jaasDefaultRealmName: String, jaasConfigProviderName: String, jaasGlobalConfigPolicy: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jaasDefaultRealmNameQuery: QueryParam[String], jaasConfigProviderNameQuery: QueryParam[String], jaasGlobalConfigPolicyQuery: QueryParam[String]): Task[OrgApacheFelixJaasConfigurationSpiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixJaasConfigurationSpiInfo] = jsonOf[OrgApacheFelixJaasConfigurationSpiInfo]

    val path = "/system/console/configMgr/org.apache.felix.jaas.ConfigurationSpi"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jaasDefaultRealmName", Some(jaas.defaultRealmNameQuery.toParamString(jaas.defaultRealmName))), ("jaasConfigProviderName", Some(jaas.configProviderNameQuery.toParamString(jaas.configProviderName))), ("jaasGlobalConfigPolicy", Some(jaas.globalConfigPolicyQuery.toParamString(jaas.globalConfigPolicy))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixJaasConfigurationSpiInfo](req)

    } yield resp
  }
  
  def orgApacheFelixScrScrService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], dsLoglevel: Integer, dsFactoryEnabled: Boolean, dsDelayedKeepInstances: Boolean, dsLockTimeoutMilliseconds: Integer, dsStopTimeoutMilliseconds: Integer, dsGlobalExtender: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], dsLoglevelQuery: QueryParam[Integer], dsFactoryEnabledQuery: QueryParam[Boolean], dsDelayedKeepInstancesQuery: QueryParam[Boolean], dsLockTimeoutMillisecondsQuery: QueryParam[Integer], dsStopTimeoutMillisecondsQuery: QueryParam[Integer], dsGlobalExtenderQuery: QueryParam[Boolean]): Task[OrgApacheFelixScrScrServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixScrScrServiceInfo] = jsonOf[OrgApacheFelixScrScrServiceInfo]

    val path = "/system/console/configMgr/org.apache.felix.scr.ScrService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("dsLoglevel", Some(ds.loglevelQuery.toParamString(ds.loglevel))), ("dsFactoryEnabled", Some(ds.factory.enabledQuery.toParamString(ds.factory.enabled))), ("dsDelayedKeepInstances", Some(ds.delayed.keepInstancesQuery.toParamString(ds.delayed.keepInstances))), ("dsLockTimeoutMilliseconds", Some(ds.lock.timeout.millisecondsQuery.toParamString(ds.lock.timeout.milliseconds))), ("dsStopTimeoutMilliseconds", Some(ds.stop.timeout.millisecondsQuery.toParamString(ds.stop.timeout.milliseconds))), ("dsGlobalExtender", Some(ds.global.extenderQuery.toParamString(ds.global.extender))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixScrScrServiceInfo](req)

    } yield resp
  }
  
  def orgApacheFelixSystemreadyImplComponentsCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], componentsList: List[String], `type`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], componentsListQuery: QueryParam[List[String]], `type`Query: QueryParam[String]): Task[OrgApacheFelixSystemreadyImplComponentsCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixSystemreadyImplComponentsCheckInfo] = jsonOf[OrgApacheFelixSystemreadyImplComponentsCheckInfo]

    val path = "/system/console/configMgr/org.apache.felix.systemready.impl.ComponentsCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("componentsList", Some(components.listQuery.toParamString(components.list))), ("`type`", Some(typeQuery.toParamString(type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixSystemreadyImplComponentsCheckInfo](req)

    } yield resp
  }
  
  def orgApacheFelixSystemreadyImplFrameworkStartCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], timeout: Integer, targetStartLevel: Integer, targetStartLevelPropName: String, `type`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], timeoutQuery: QueryParam[Integer], targetStartLevelQuery: QueryParam[Integer], targetStartLevelPropNameQuery: QueryParam[String], `type`Query: QueryParam[String]): Task[OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo] = jsonOf[OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo]

    val path = "/system/console/configMgr/org.apache.felix.systemready.impl.FrameworkStartCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("timeout", Some(timeoutQuery.toParamString(timeout))), ("targetStartLevel", Some(target.start.levelQuery.toParamString(target.start.level))), ("targetStartLevelPropName", Some(target.start.level.prop.nameQuery.toParamString(target.start.level.prop.name))), ("`type`", Some(typeQuery.toParamString(type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo](req)

    } yield resp
  }
  
  def orgApacheFelixSystemreadyImplServicesCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], servicesList: List[String], `type`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], servicesListQuery: QueryParam[List[String]], `type`Query: QueryParam[String]): Task[OrgApacheFelixSystemreadyImplServicesCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixSystemreadyImplServicesCheckInfo] = jsonOf[OrgApacheFelixSystemreadyImplServicesCheckInfo]

    val path = "/system/console/configMgr/org.apache.felix.systemready.impl.ServicesCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("servicesList", Some(services.listQuery.toParamString(services.list))), ("`type`", Some(typeQuery.toParamString(type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixSystemreadyImplServicesCheckInfo](req)

    } yield resp
  }
  
  def orgApacheFelixSystemreadyImplServletSystemAliveServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], osgiHttpWhiteboardServletPattern: String, osgiHttpWhiteboardContextSelect: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], osgiHttpWhiteboardServletPatternQuery: QueryParam[String], osgiHttpWhiteboardContextSelectQuery: QueryParam[String]): Task[OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo] = jsonOf[OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo]

    val path = "/system/console/configMgr/org.apache.felix.systemready.impl.servlet.SystemAliveServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("osgiHttpWhiteboardServletPattern", Some(osgi.http.whiteboard.servlet.patternQuery.toParamString(osgi.http.whiteboard.servlet.pattern))), ("osgiHttpWhiteboardContextSelect", Some(osgi.http.whiteboard.context.selectQuery.toParamString(osgi.http.whiteboard.context.select))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo](req)

    } yield resp
  }
  
  def orgApacheFelixSystemreadyImplServletSystemReadyServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], osgiHttpWhiteboardServletPattern: String, osgiHttpWhiteboardContextSelect: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], osgiHttpWhiteboardServletPatternQuery: QueryParam[String], osgiHttpWhiteboardContextSelectQuery: QueryParam[String]): Task[OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo] = jsonOf[OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo]

    val path = "/system/console/configMgr/org.apache.felix.systemready.impl.servlet.SystemReadyServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("osgiHttpWhiteboardServletPattern", Some(osgi.http.whiteboard.servlet.patternQuery.toParamString(osgi.http.whiteboard.servlet.pattern))), ("osgiHttpWhiteboardContextSelect", Some(osgi.http.whiteboard.context.selectQuery.toParamString(osgi.http.whiteboard.context.select))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo](req)

    } yield resp
  }
  
  def orgApacheFelixSystemreadySystemReadyMonitor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pollInterval: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pollIntervalQuery: QueryParam[Integer]): Task[OrgApacheFelixSystemreadySystemReadyMonitorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixSystemreadySystemReadyMonitorInfo] = jsonOf[OrgApacheFelixSystemreadySystemReadyMonitorInfo]

    val path = "/system/console/configMgr/org.apache.felix.systemready.SystemReadyMonitor"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pollInterval", Some(poll.intervalQuery.toParamString(poll.interval))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixSystemreadySystemReadyMonitorInfo](req)

    } yield resp
  }
  
  def orgApacheFelixWebconsoleInternalServletOsgiManager(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], managerRoot: String, httpServiceFilter: String, defaultRender: String, realm: String, username: String, password: String, category: String, locale: String, loglevel: Integer, plugins: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], managerRootQuery: QueryParam[String], httpServiceFilterQuery: QueryParam[String], defaultRenderQuery: QueryParam[String], realmQuery: QueryParam[String], usernameQuery: QueryParam[String], passwordQuery: QueryParam[String], categoryQuery: QueryParam[String], localeQuery: QueryParam[String], loglevelQuery: QueryParam[Integer], pluginsQuery: QueryParam[String]): Task[OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo] = jsonOf[OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo]

    val path = "/system/console/configMgr/org.apache.felix.webconsole.internal.servlet.OsgiManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("managerRoot", Some(manager.rootQuery.toParamString(manager.root))), ("httpServiceFilter", Some(http.service.filterQuery.toParamString(http.service.filter))), ("defaultRender", Some(default.renderQuery.toParamString(default.render))), ("realm", Some(realmQuery.toParamString(realm))), ("username", Some(usernameQuery.toParamString(username))), ("password", Some(passwordQuery.toParamString(password))), ("category", Some(categoryQuery.toParamString(category))), ("locale", Some(localeQuery.toParamString(locale))), ("loglevel", Some(loglevelQuery.toParamString(loglevel))), ("plugins", Some(pluginsQuery.toParamString(plugins))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo](req)

    } yield resp
  }
  
  def orgApacheFelixWebconsolePluginsEventInternalPluginServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxSizeQuery: QueryParam[Integer]): Task[OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo] = jsonOf[OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo]

    val path = "/system/console/configMgr/org.apache.felix.webconsole.plugins.event.internal.PluginServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxSize", Some(max.sizeQuery.toParamString(max.size))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo](req)

    } yield resp
  }
  
  def orgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCo(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], felixMemoryusageDumpThreshold: Integer, felixMemoryusageDumpInterval: Integer, felixMemoryusageDumpLocation: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], felixMemoryusageDumpThresholdQuery: QueryParam[Integer], felixMemoryusageDumpIntervalQuery: QueryParam[Integer], felixMemoryusageDumpLocationQuery: QueryParam[String]): Task[OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo] = jsonOf[OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo]

    val path = "/system/console/configMgr/org.apache.felix.webconsole.plugins.memoryusage.internal.MemoryUsageConfigurator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("felixMemoryusageDumpThreshold", Some(felix.memoryusage.dump.thresholdQuery.toParamString(felix.memoryusage.dump.threshold))), ("felixMemoryusageDumpInterval", Some(felix.memoryusage.dump.intervalQuery.toParamString(felix.memoryusage.dump.interval))), ("felixMemoryusageDumpLocation", Some(felix.memoryusage.dump.locationQuery.toParamString(felix.memoryusage.dump.location))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo](req)

    } yield resp
  }
  
  def orgApacheHttpProxyconfigurator(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], proxyEnabled: Boolean, proxyHost: String, proxyPort: Integer, proxyUser: String, proxyPassword: String, proxyExceptions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], proxyEnabledQuery: QueryParam[Boolean], proxyHostQuery: QueryParam[String], proxyPortQuery: QueryParam[Integer], proxyUserQuery: QueryParam[String], proxyPasswordQuery: QueryParam[String], proxyExceptionsQuery: QueryParam[List[String]]): Task[OrgApacheHttpProxyconfiguratorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheHttpProxyconfiguratorInfo] = jsonOf[OrgApacheHttpProxyconfiguratorInfo]

    val path = "/system/console/configMgr/org.apache.http.proxyconfigurator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("proxyEnabled", Some(proxy.enabledQuery.toParamString(proxy.enabled))), ("proxyHost", Some(proxy.hostQuery.toParamString(proxy.host))), ("proxyPort", Some(proxy.portQuery.toParamString(proxy.port))), ("proxyUser", Some(proxy.userQuery.toParamString(proxy.user))), ("proxyPassword", Some(proxy.passwordQuery.toParamString(proxy.password))), ("proxyExceptions", Some(proxy.exceptionsQuery.toParamString(proxy.exceptions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheHttpProxyconfiguratorInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], dir: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], dirQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo] = jsonOf[OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.blob.datastore.DataStoreTextProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("dir", Some(dirQuery.toParamString(dir))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsBlobDatastoreFileDataStore(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo] = jsonOf[OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.blob.datastore.FileDataStore"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mongouri: String, db: String, socketKeepAlive: Boolean, cache: Integer, nodeCachePercentage: Integer, prevDocCachePercentage: Integer, childrenCachePercentage: Integer, diffCachePercentage: Integer, cacheSegmentCount: Integer, cacheStackMoveDistance: Integer, blobCacheSize: Integer, persistentCache: String, journalCache: String, customBlobStore: Boolean, journalGCInterval: Integer, journalGCMaxAge: Integer, prefetchExternalChanges: Boolean, role: String, versionGcMaxAgeInSecs: Integer, versionGCExpression: String, versionGCTimeLimitInSecs: Integer, blobGcMaxAgeInSecs: Integer, blobTrackSnapshotIntervalInSecs: Integer, repositoryHome: String, maxReplicationLagInSecs: Integer, documentStoreType: String, bundlingDisabled: Boolean, updateLimit: Integer, persistentCacheIncludes: List[String], leaseCheckMode: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mongouriQuery: QueryParam[String], dbQuery: QueryParam[String], socketKeepAliveQuery: QueryParam[Boolean], cacheQuery: QueryParam[Integer], nodeCachePercentageQuery: QueryParam[Integer], prevDocCachePercentageQuery: QueryParam[Integer], childrenCachePercentageQuery: QueryParam[Integer], diffCachePercentageQuery: QueryParam[Integer], cacheSegmentCountQuery: QueryParam[Integer], cacheStackMoveDistanceQuery: QueryParam[Integer], blobCacheSizeQuery: QueryParam[Integer], persistentCacheQuery: QueryParam[String], journalCacheQuery: QueryParam[String], customBlobStoreQuery: QueryParam[Boolean], journalGCIntervalQuery: QueryParam[Integer], journalGCMaxAgeQuery: QueryParam[Integer], prefetchExternalChangesQuery: QueryParam[Boolean], roleQuery: QueryParam[String], versionGcMaxAgeInSecsQuery: QueryParam[Integer], versionGCExpressionQuery: QueryParam[String], versionGCTimeLimitInSecsQuery: QueryParam[Integer], blobGcMaxAgeInSecsQuery: QueryParam[Integer], blobTrackSnapshotIntervalInSecsQuery: QueryParam[Integer], repositoryHomeQuery: QueryParam[String], maxReplicationLagInSecsQuery: QueryParam[Integer], documentStoreTypeQuery: QueryParam[String], bundlingDisabledQuery: QueryParam[Boolean], updateLimitQuery: QueryParam[Integer], persistentCacheIncludesQuery: QueryParam[List[String]], leaseCheckModeQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo] = jsonOf[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mongouri", Some(mongouriQuery.toParamString(mongouri))), ("db", Some(dbQuery.toParamString(db))), ("socketKeepAlive", Some(socketKeepAliveQuery.toParamString(socketKeepAlive))), ("cache", Some(cacheQuery.toParamString(cache))), ("nodeCachePercentage", Some(nodeCachePercentageQuery.toParamString(nodeCachePercentage))), ("prevDocCachePercentage", Some(prevDocCachePercentageQuery.toParamString(prevDocCachePercentage))), ("childrenCachePercentage", Some(childrenCachePercentageQuery.toParamString(childrenCachePercentage))), ("diffCachePercentage", Some(diffCachePercentageQuery.toParamString(diffCachePercentage))), ("cacheSegmentCount", Some(cacheSegmentCountQuery.toParamString(cacheSegmentCount))), ("cacheStackMoveDistance", Some(cacheStackMoveDistanceQuery.toParamString(cacheStackMoveDistance))), ("blobCacheSize", Some(blobCacheSizeQuery.toParamString(blobCacheSize))), ("persistentCache", Some(persistentCacheQuery.toParamString(persistentCache))), ("journalCache", Some(journalCacheQuery.toParamString(journalCache))), ("customBlobStore", Some(customBlobStoreQuery.toParamString(customBlobStore))), ("journalGCInterval", Some(journalGCIntervalQuery.toParamString(journalGCInterval))), ("journalGCMaxAge", Some(journalGCMaxAgeQuery.toParamString(journalGCMaxAge))), ("prefetchExternalChanges", Some(prefetchExternalChangesQuery.toParamString(prefetchExternalChanges))), ("role", Some(roleQuery.toParamString(role))), ("versionGcMaxAgeInSecs", Some(versionGcMaxAgeInSecsQuery.toParamString(versionGcMaxAgeInSecs))), ("versionGCExpression", Some(versionGCExpressionQuery.toParamString(versionGCExpression))), ("versionGCTimeLimitInSecs", Some(versionGCTimeLimitInSecsQuery.toParamString(versionGCTimeLimitInSecs))), ("blobGcMaxAgeInSecs", Some(blobGcMaxAgeInSecsQuery.toParamString(blobGcMaxAgeInSecs))), ("blobTrackSnapshotIntervalInSecs", Some(blobTrackSnapshotIntervalInSecsQuery.toParamString(blobTrackSnapshotIntervalInSecs))), ("repositoryHome", Some(repository.homeQuery.toParamString(repository.home))), ("maxReplicationLagInSecs", Some(maxReplicationLagInSecsQuery.toParamString(maxReplicationLagInSecs))), ("documentStoreType", Some(documentStoreTypeQuery.toParamString(documentStoreType))), ("bundlingDisabled", Some(bundlingDisabledQuery.toParamString(bundlingDisabled))), ("updateLimit", Some(updateLimitQuery.toParamString(updateLimit))), ("persistentCacheIncludes", Some(persistentCacheIncludesQuery.toParamString(persistentCacheIncludes))), ("leaseCheckMode", Some(leaseCheckModeQuery.toParamString(leaseCheckMode))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePre(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], persistentCacheIncludes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], persistentCacheIncludesQuery: QueryParam[List[String]]): Task[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo] = jsonOf[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreServicePreset"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("persistentCacheIncludes", Some(persistentCacheIncludesQuery.toParamString(persistentCacheIncludes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCac(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], includedPaths: List[String], enableAsyncObserver: Boolean, observerQueueSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], includedPathsQuery: QueryParam[List[String]], enableAsyncObserverQuery: QueryParam[Boolean], observerQueueSizeQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo] = jsonOf[OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.secondary.SecondaryStoreCacheService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("includedPaths", Some(includedPathsQuery.toParamString(includedPaths))), ("enableAsyncObserver", Some(enableAsyncObserverQuery.toParamString(enableAsyncObserver))), ("observerQueueSize", Some(observerQueueSizeQuery.toParamString(observerQueueSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexAsyncIndexerService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], asyncConfigs: List[String], leaseTimeOutMinutes: Integer, failingIndexTimeoutSeconds: Integer, errorWarnIntervalSeconds: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], asyncConfigsQuery: QueryParam[List[String]], leaseTimeOutMinutesQuery: QueryParam[Integer], failingIndexTimeoutSecondsQuery: QueryParam[Integer], errorWarnIntervalSecondsQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.AsyncIndexerService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("asyncConfigs", Some(asyncConfigsQuery.toParamString(asyncConfigs))), ("leaseTimeOutMinutes", Some(leaseTimeOutMinutesQuery.toParamString(leaseTimeOutMinutes))), ("failingIndexTimeoutSeconds", Some(failingIndexTimeoutSecondsQuery.toParamString(failingIndexTimeoutSeconds))), ("errorWarnIntervalSeconds", Some(errorWarnIntervalSecondsQuery.toParamString(errorWarnIntervalSeconds))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServ(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], disabled: Boolean, debug: Boolean, localIndexDir: String, enableOpenIndexAsync: Boolean, threadPoolSize: Integer, prefetchIndexFiles: Boolean, extractedTextCacheSizeInMB: Integer, extractedTextCacheExpiryInSecs: Integer, alwaysUsePreExtractedCache: Boolean, booleanClauseLimit: Integer, enableHybridIndexing: Boolean, hybridQueueSize: Integer, disableStoredIndexDefinition: Boolean, deletedBlobsCollectionEnabled: Boolean, propIndexCleanerIntervalInSecs: Integer, enableSingleBlobIndexFiles: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], disabledQuery: QueryParam[Boolean], debugQuery: QueryParam[Boolean], localIndexDirQuery: QueryParam[String], enableOpenIndexAsyncQuery: QueryParam[Boolean], threadPoolSizeQuery: QueryParam[Integer], prefetchIndexFilesQuery: QueryParam[Boolean], extractedTextCacheSizeInMBQuery: QueryParam[Integer], extractedTextCacheExpiryInSecsQuery: QueryParam[Integer], alwaysUsePreExtractedCacheQuery: QueryParam[Boolean], booleanClauseLimitQuery: QueryParam[Integer], enableHybridIndexingQuery: QueryParam[Boolean], hybridQueueSizeQuery: QueryParam[Integer], disableStoredIndexDefinitionQuery: QueryParam[Boolean], deletedBlobsCollectionEnabledQuery: QueryParam[Boolean], propIndexCleanerIntervalInSecsQuery: QueryParam[Integer], enableSingleBlobIndexFilesQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("disabled", Some(disabledQuery.toParamString(disabled))), ("debug", Some(debugQuery.toParamString(debug))), ("localIndexDir", Some(localIndexDirQuery.toParamString(localIndexDir))), ("enableOpenIndexAsync", Some(enableOpenIndexAsyncQuery.toParamString(enableOpenIndexAsync))), ("threadPoolSize", Some(threadPoolSizeQuery.toParamString(threadPoolSize))), ("prefetchIndexFiles", Some(prefetchIndexFilesQuery.toParamString(prefetchIndexFiles))), ("extractedTextCacheSizeInMB", Some(extractedTextCacheSizeInMBQuery.toParamString(extractedTextCacheSizeInMB))), ("extractedTextCacheExpiryInSecs", Some(extractedTextCacheExpiryInSecsQuery.toParamString(extractedTextCacheExpiryInSecs))), ("alwaysUsePreExtractedCache", Some(alwaysUsePreExtractedCacheQuery.toParamString(alwaysUsePreExtractedCache))), ("booleanClauseLimit", Some(booleanClauseLimitQuery.toParamString(booleanClauseLimit))), ("enableHybridIndexing", Some(enableHybridIndexingQuery.toParamString(enableHybridIndexing))), ("hybridQueueSize", Some(hybridQueueSizeQuery.toParamString(hybridQueueSize))), ("disableStoredIndexDefinition", Some(disableStoredIndexDefinitionQuery.toParamString(disableStoredIndexDefinition))), ("deletedBlobsCollectionEnabled", Some(deletedBlobsCollectionEnabledQuery.toParamString(deletedBlobsCollectionEnabled))), ("propIndexCleanerIntervalInSecs", Some(propIndexCleanerIntervalInSecsQuery.toParamString(propIndexCleanerIntervalInSecs))), ("enableSingleBlobIndexFiles", Some(enableSingleBlobIndexFilesQuery.toParamString(enableSingleBlobIndexFiles))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCo(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], solrHomePath: String, solrCoreName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], solrHomePathQuery: QueryParam[String], solrCoreNameQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.EmbeddedSolrServerConfigurationProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("solrHomePath", Some(solr.home.pathQuery.toParamString(solr.home.path))), ("solrCoreName", Some(solr.core.nameQuery.toParamString(solr.core.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServers(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.NodeStateSolrServersObserverService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfiguration(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], pathDescField: String, pathChildField: String, pathParentField: String, pathExactField: String, catchAllField: String, collapsedPathField: String, pathDepthField: String, commitPolicy: String, rows: Integer, pathRestrictions: Boolean, propertyRestrictions: Boolean, primarytypesRestrictions: Boolean, ignoredProperties: List[String], usedProperties: List[String], typeMappings: List[String], propertyMappings: List[String], collapseJcrcontentNodes: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], pathDescFieldQuery: QueryParam[String], pathChildFieldQuery: QueryParam[String], pathParentFieldQuery: QueryParam[String], pathExactFieldQuery: QueryParam[String], catchAllFieldQuery: QueryParam[String], collapsedPathFieldQuery: QueryParam[String], pathDepthFieldQuery: QueryParam[String], commitPolicyQuery: QueryParam[String], rowsQuery: QueryParam[Integer], pathRestrictionsQuery: QueryParam[Boolean], propertyRestrictionsQuery: QueryParam[Boolean], primarytypesRestrictionsQuery: QueryParam[Boolean], ignoredPropertiesQuery: QueryParam[List[String]], usedPropertiesQuery: QueryParam[List[String]], typeMappingsQuery: QueryParam[List[String]], propertyMappingsQuery: QueryParam[List[String]], collapseJcrcontentNodesQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.OakSolrConfigurationProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("pathDescField", Some(path.desc.fieldQuery.toParamString(path.desc.field))), ("pathChildField", Some(path.child.fieldQuery.toParamString(path.child.field))), ("pathParentField", Some(path.parent.fieldQuery.toParamString(path.parent.field))), ("pathExactField", Some(path.exact.fieldQuery.toParamString(path.exact.field))), ("catchAllField", Some(catch.all.fieldQuery.toParamString(catch.all.field))), ("collapsedPathField", Some(collapsed.path.fieldQuery.toParamString(collapsed.path.field))), ("pathDepthField", Some(path.depth.fieldQuery.toParamString(path.depth.field))), ("commitPolicy", Some(commit.policyQuery.toParamString(commit.policy))), ("rows", Some(rowsQuery.toParamString(rows))), ("pathRestrictions", Some(path.restrictionsQuery.toParamString(path.restrictions))), ("propertyRestrictions", Some(property.restrictionsQuery.toParamString(property.restrictions))), ("primarytypesRestrictions", Some(primarytypes.restrictionsQuery.toParamString(primarytypes.restrictions))), ("ignoredProperties", Some(ignored.propertiesQuery.toParamString(ignored.properties))), ("usedProperties", Some(used.propertiesQuery.toParamString(used.properties))), ("typeMappings", Some(type.mappingsQuery.toParamString(type.mappings))), ("propertyMappings", Some(property.mappingsQuery.toParamString(property.mappings))), ("collapseJcrcontentNodes", Some(collapse.jcrcontent.nodesQuery.toParamString(collapse.jcrcontent.nodes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConf(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], solrHttpUrl: String, solrZkHost: String, solrCollection: String, solrSocketTimeout: Integer, solrConnectionTimeout: Integer, solrShardsNo: Integer, solrReplicationFactor: Integer, solrConfDir: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], solrHttpUrlQuery: QueryParam[String], solrZkHostQuery: QueryParam[String], solrCollectionQuery: QueryParam[String], solrSocketTimeoutQuery: QueryParam[Integer], solrConnectionTimeoutQuery: QueryParam[Integer], solrShardsNoQuery: QueryParam[Integer], solrReplicationFactorQuery: QueryParam[Integer], solrConfDirQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.RemoteSolrServerConfigurationProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("solrHttpUrl", Some(solr.http.urlQuery.toParamString(solr.http.url))), ("solrZkHost", Some(solr.zk.hostQuery.toParamString(solr.zk.host))), ("solrCollection", Some(solr.collectionQuery.toParamString(solr.collection))), ("solrSocketTimeout", Some(solr.socket.timeoutQuery.toParamString(solr.socket.timeout))), ("solrConnectionTimeout", Some(solr.connection.timeoutQuery.toParamString(solr.connection.timeout))), ("solrShardsNo", Some(solr.shards.noQuery.toParamString(solr.shards.no))), ("solrReplicationFactor", Some(solr.replication.factorQuery.toParamString(solr.replication.factor))), ("solrConfDir", Some(solr.conf.dirQuery.toParamString(solr.conf.dir))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvid(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], queryAggregation: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], queryAggregationQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.SolrQueryIndexProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("queryAggregation", Some(query.aggregationQuery.toParamString(query.aggregation))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSe(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serverType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serverTypeQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo] = jsonOf[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.SolrServerProviderService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serverType", Some(server.typeQuery.toParamString(server.type))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsMetricStatisticsProviderFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerTypeQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo] = jsonOf[OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.metric.StatisticsProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerType", Some(providerTypeQuery.toParamString(providerType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakPluginsObservationChangeCollectorProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxItems: Integer, maxPathDepth: Integer, enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxItemsQuery: QueryParam[Integer], maxPathDepthQuery: QueryParam[Integer], enabledQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo] = jsonOf[OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.plugins.observation.ChangeCollectorProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxItems", Some(maxItemsQuery.toParamString(maxItems))), ("maxPathDepth", Some(maxPathDepthQuery.toParamString(maxPathDepth))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakQueryQueryEngineSettingsService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], queryLimitInMemory: Integer, queryLimitReads: Integer, queryFailTraversal: Boolean, fastQuerySize: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], queryLimitInMemoryQuery: QueryParam[Integer], queryLimitReadsQuery: QueryParam[Integer], queryFailTraversalQuery: QueryParam[Boolean], fastQuerySizeQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo] = jsonOf[OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.query.QueryEngineSettingsService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("queryLimitInMemory", Some(queryLimitInMemoryQuery.toParamString(queryLimitInMemory))), ("queryLimitReads", Some(queryLimitReadsQuery.toParamString(queryLimitReads))), ("queryFailTraversal", Some(queryFailTraversalQuery.toParamString(queryFailTraversal))), ("fastQuerySize", Some(fastQuerySizeQuery.toParamString(fastQuerySize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheJackrabbitOakAuthenticationAppName: String, orgApacheJackrabbitOakAuthenticationConfigSpiName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheJackrabbitOakAuthenticationAppNameQuery: QueryParam[String], orgApacheJackrabbitOakAuthenticationConfigSpiNameQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo] = jsonOf[OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.AuthenticationConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheJackrabbitOakAuthenticationAppName", Some(org.apache.jackrabbit.oak.authentication.appNameQuery.toParamString(org.apache.jackrabbit.oak.authentication.appName))), ("orgApacheJackrabbitOakAuthenticationConfigSpiName", Some(org.apache.jackrabbit.oak.authentication.configSpiNameQuery.toParamString(org.apache.jackrabbit.oak.authentication.configSpiName))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdenti(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerName: String, hostName: String, hostPort: Integer, hostSsl: Boolean, hostTls: Boolean, hostNoCertCheck: Boolean, bindDn: String, bindPassword: String, searchTimeout: String, adminPoolMaxActive: Integer, adminPoolLookupOnValidate: Boolean, userPoolMaxActive: Integer, userPoolLookupOnValidate: Boolean, userBaseDN: String, userObjectclass: List[String], userIdAttribute: String, userExtraFilter: String, userMakeDnPath: Boolean, groupBaseDN: String, groupObjectclass: List[String], groupNameAttribute: String, groupExtraFilter: String, groupMakeDnPath: Boolean, groupMemberAttribute: String, useUidForExtId: Boolean, customattributes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerNameQuery: QueryParam[String], hostNameQuery: QueryParam[String], hostPortQuery: QueryParam[Integer], hostSslQuery: QueryParam[Boolean], hostTlsQuery: QueryParam[Boolean], hostNoCertCheckQuery: QueryParam[Boolean], bindDnQuery: QueryParam[String], bindPasswordQuery: QueryParam[String], searchTimeoutQuery: QueryParam[String], adminPoolMaxActiveQuery: QueryParam[Integer], adminPoolLookupOnValidateQuery: QueryParam[Boolean], userPoolMaxActiveQuery: QueryParam[Integer], userPoolLookupOnValidateQuery: QueryParam[Boolean], userBaseDNQuery: QueryParam[String], userObjectclassQuery: QueryParam[List[String]], userIdAttributeQuery: QueryParam[String], userExtraFilterQuery: QueryParam[String], userMakeDnPathQuery: QueryParam[Boolean], groupBaseDNQuery: QueryParam[String], groupObjectclassQuery: QueryParam[List[String]], groupNameAttributeQuery: QueryParam[String], groupExtraFilterQuery: QueryParam[String], groupMakeDnPathQuery: QueryParam[Boolean], groupMemberAttributeQuery: QueryParam[String], useUidForExtIdQuery: QueryParam[Boolean], customattributesQuery: QueryParam[List[String]]): Task[OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo] = jsonOf[OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerName", Some(provider.nameQuery.toParamString(provider.name))), ("hostName", Some(host.nameQuery.toParamString(host.name))), ("hostPort", Some(host.portQuery.toParamString(host.port))), ("hostSsl", Some(host.sslQuery.toParamString(host.ssl))), ("hostTls", Some(host.tlsQuery.toParamString(host.tls))), ("hostNoCertCheck", Some(host.noCertCheckQuery.toParamString(host.noCertCheck))), ("bindDn", Some(bind.dnQuery.toParamString(bind.dn))), ("bindPassword", Some(bind.passwordQuery.toParamString(bind.password))), ("searchTimeout", Some(searchTimeoutQuery.toParamString(searchTimeout))), ("adminPoolMaxActive", Some(adminPool.maxActiveQuery.toParamString(adminPool.maxActive))), ("adminPoolLookupOnValidate", Some(adminPool.lookupOnValidateQuery.toParamString(adminPool.lookupOnValidate))), ("userPoolMaxActive", Some(userPool.maxActiveQuery.toParamString(userPool.maxActive))), ("userPoolLookupOnValidate", Some(userPool.lookupOnValidateQuery.toParamString(userPool.lookupOnValidate))), ("userBaseDN", Some(user.baseDNQuery.toParamString(user.baseDN))), ("userObjectclass", Some(user.objectclassQuery.toParamString(user.objectclass))), ("userIdAttribute", Some(user.idAttributeQuery.toParamString(user.idAttribute))), ("userExtraFilter", Some(user.extraFilterQuery.toParamString(user.extraFilter))), ("userMakeDnPath", Some(user.makeDnPathQuery.toParamString(user.makeDnPath))), ("groupBaseDN", Some(group.baseDNQuery.toParamString(group.baseDN))), ("groupObjectclass", Some(group.objectclassQuery.toParamString(group.objectclass))), ("groupNameAttribute", Some(group.nameAttributeQuery.toParamString(group.nameAttribute))), ("groupExtraFilter", Some(group.extraFilterQuery.toParamString(group.extraFilter))), ("groupMakeDnPath", Some(group.makeDnPathQuery.toParamString(group.makeDnPath))), ("groupMemberAttribute", Some(group.memberAttributeQuery.toParamString(group.memberAttribute))), ("useUidForExtId", Some(useUidForExtIdQuery.toParamString(useUidForExtId))), ("customattributes", Some(customattributesQuery.toParamString(customattributes))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfigura(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], tokenExpiration: String, tokenLength: String, tokenRefresh: Boolean, tokenCleanupThreshold: Integer, passwordHashAlgorithm: String, passwordHashIterations: Integer, passwordSaltSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], tokenExpirationQuery: QueryParam[String], tokenLengthQuery: QueryParam[String], tokenRefreshQuery: QueryParam[Boolean], tokenCleanupThresholdQuery: QueryParam[Integer], passwordHashAlgorithmQuery: QueryParam[String], passwordHashIterationsQuery: QueryParam[Integer], passwordSaltSizeQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo] = jsonOf[OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.token.TokenConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("tokenExpiration", Some(tokenExpirationQuery.toParamString(tokenExpiration))), ("tokenLength", Some(tokenLengthQuery.toParamString(tokenLength))), ("tokenRefresh", Some(tokenRefreshQuery.toParamString(tokenRefresh))), ("tokenCleanupThreshold", Some(tokenCleanupThresholdQuery.toParamString(tokenCleanupThreshold))), ("passwordHashAlgorithm", Some(passwordHashAlgorithmQuery.toParamString(passwordHashAlgorithm))), ("passwordHashIterations", Some(passwordHashIterationsQuery.toParamString(passwordHashIterations))), ("passwordSaltSize", Some(passwordSaltSizeQuery.toParamString(passwordSaltSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigur(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], permissionsJr2: String, importBehavior: String, readPaths: List[String], administrativePrincipals: List[String], configurationRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], permissionsJr2Query: QueryParam[String], importBehaviorQuery: QueryParam[String], readPathsQuery: QueryParam[List[String]], administrativePrincipalsQuery: QueryParam[List[String]], configurationRankingQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo] = jsonOf[OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.authorization.AuthorizationConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("permissionsJr2", Some(permissionsJr2Query.toParamString(permissionsJr2))), ("importBehavior", Some(importBehaviorQuery.toParamString(importBehavior))), ("readPaths", Some(readPathsQuery.toParamString(readPaths))), ("administrativePrincipals", Some(administrativePrincipalsQuery.toParamString(administrativePrincipals))), ("configurationRanking", Some(configurationRankingQuery.toParamString(configurationRanking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityInternalSecurityProviderRegistrati(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], requiredServicePids: List[String], authorizationCompositionType: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], requiredServicePidsQuery: QueryParam[List[String]], authorizationCompositionTypeQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo] = jsonOf[OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.internal.SecurityProviderRegistration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("requiredServicePids", Some(requiredServicePidsQuery.toParamString(requiredServicePids))), ("authorizationCompositionType", Some(authorizationCompositionTypeQuery.toParamString(authorizationCompositionType))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeName(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], length: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], lengthQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo] = jsonOf[OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.user.RandomAuthorizableNodeName"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("length", Some(lengthQuery.toParamString(length))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSecurityUserUserConfigurationImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], usersPath: String, groupsPath: String, systemRelativePath: String, defaultDepth: Integer, importBehavior: String, passwordHashAlgorithm: String, passwordHashIterations: Integer, passwordSaltSize: Integer, omitAdminPw: Boolean, supportAutoSave: Boolean, passwordMaxAge: Integer, initialPasswordChange: Boolean, passwordHistorySize: Integer, passwordExpiryForAdmin: Boolean, cacheExpiration: Integer, enableRFC7613UsercaseMappedProfile: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], usersPathQuery: QueryParam[String], groupsPathQuery: QueryParam[String], systemRelativePathQuery: QueryParam[String], defaultDepthQuery: QueryParam[Integer], importBehaviorQuery: QueryParam[String], passwordHashAlgorithmQuery: QueryParam[String], passwordHashIterationsQuery: QueryParam[Integer], passwordSaltSizeQuery: QueryParam[Integer], omitAdminPwQuery: QueryParam[Boolean], supportAutoSaveQuery: QueryParam[Boolean], passwordMaxAgeQuery: QueryParam[Integer], initialPasswordChangeQuery: QueryParam[Boolean], passwordHistorySizeQuery: QueryParam[Integer], passwordExpiryForAdminQuery: QueryParam[Boolean], cacheExpirationQuery: QueryParam[Integer], enableRFC7613UsercaseMappedProfileQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo] = jsonOf[OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.security.user.UserConfigurationImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("usersPath", Some(usersPathQuery.toParamString(usersPath))), ("groupsPath", Some(groupsPathQuery.toParamString(groupsPath))), ("systemRelativePath", Some(systemRelativePathQuery.toParamString(systemRelativePath))), ("defaultDepth", Some(defaultDepthQuery.toParamString(defaultDepth))), ("importBehavior", Some(importBehaviorQuery.toParamString(importBehavior))), ("passwordHashAlgorithm", Some(passwordHashAlgorithmQuery.toParamString(passwordHashAlgorithm))), ("passwordHashIterations", Some(passwordHashIterationsQuery.toParamString(passwordHashIterations))), ("passwordSaltSize", Some(passwordSaltSizeQuery.toParamString(passwordSaltSize))), ("omitAdminPw", Some(omitAdminPwQuery.toParamString(omitAdminPw))), ("supportAutoSave", Some(supportAutoSaveQuery.toParamString(supportAutoSave))), ("passwordMaxAge", Some(passwordMaxAgeQuery.toParamString(passwordMaxAge))), ("initialPasswordChange", Some(initialPasswordChangeQuery.toParamString(initialPasswordChange))), ("passwordHistorySize", Some(passwordHistorySizeQuery.toParamString(passwordHistorySize))), ("passwordExpiryForAdmin", Some(passwordExpiryForAdminQuery.toParamString(passwordExpiryForAdmin))), ("cacheExpiration", Some(cacheExpirationQuery.toParamString(cacheExpiration))), ("enableRFC7613UsercaseMappedProfile", Some(enableRFC7613UsercaseMappedProfileQuery.toParamString(enableRFC7613UsercaseMappedProfile))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSegmentAzureAzureSegmentStoreService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], accountName: String, containerName: String, accessKey: String, rootPath: String, connectionURL: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], accountNameQuery: QueryParam[String], containerNameQuery: QueryParam[String], accessKeyQuery: QueryParam[String], rootPathQuery: QueryParam[String], connectionURLQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo] = jsonOf[OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.segment.azure.AzureSegmentStoreService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("accountName", Some(accountNameQuery.toParamString(accountName))), ("containerName", Some(containerNameQuery.toParamString(containerName))), ("accessKey", Some(accessKeyQuery.toParamString(accessKey))), ("rootPath", Some(rootPathQuery.toParamString(rootPath))), ("connectionURL", Some(connectionURLQuery.toParamString(connectionURL))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSegmentSegmentNodeStoreFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], repositoryHome: String, tarmkMode: String, tarmkSize: Integer, segmentCacheSize: Integer, stringCacheSize: Integer, templateCacheSize: Integer, stringDeduplicationCacheSize: Integer, templateDeduplicationCacheSize: Integer, nodeDeduplicationCacheSize: Integer, pauseCompaction: Boolean, compactionRetryCount: Integer, compactionForceTimeout: Integer, compactionSizeDeltaEstimation: Integer, compactionDisableEstimation: Boolean, compactionRetainedGenerations: Integer, compactionMemoryThreshold: Integer, compactionProgressLog: Integer, standby: Boolean, customBlobStore: Boolean, customSegmentStore: Boolean, splitPersistence: Boolean, repositoryBackupDir: String, blobGcMaxAgeInSecs: Integer, blobTrackSnapshotIntervalInSecs: Integer, role: String, registerDescriptors: Boolean, dispatchChanges: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], repositoryHomeQuery: QueryParam[String], tarmkModeQuery: QueryParam[String], tarmkSizeQuery: QueryParam[Integer], segmentCacheSizeQuery: QueryParam[Integer], stringCacheSizeQuery: QueryParam[Integer], templateCacheSizeQuery: QueryParam[Integer], stringDeduplicationCacheSizeQuery: QueryParam[Integer], templateDeduplicationCacheSizeQuery: QueryParam[Integer], nodeDeduplicationCacheSizeQuery: QueryParam[Integer], pauseCompactionQuery: QueryParam[Boolean], compactionRetryCountQuery: QueryParam[Integer], compactionForceTimeoutQuery: QueryParam[Integer], compactionSizeDeltaEstimationQuery: QueryParam[Integer], compactionDisableEstimationQuery: QueryParam[Boolean], compactionRetainedGenerationsQuery: QueryParam[Integer], compactionMemoryThresholdQuery: QueryParam[Integer], compactionProgressLogQuery: QueryParam[Integer], standbyQuery: QueryParam[Boolean], customBlobStoreQuery: QueryParam[Boolean], customSegmentStoreQuery: QueryParam[Boolean], splitPersistenceQuery: QueryParam[Boolean], repositoryBackupDirQuery: QueryParam[String], blobGcMaxAgeInSecsQuery: QueryParam[Integer], blobTrackSnapshotIntervalInSecsQuery: QueryParam[Integer], roleQuery: QueryParam[String], registerDescriptorsQuery: QueryParam[Boolean], dispatchChangesQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo] = jsonOf[OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("repositoryHome", Some(repository.homeQuery.toParamString(repository.home))), ("tarmkMode", Some(tarmk.modeQuery.toParamString(tarmk.mode))), ("tarmkSize", Some(tarmk.sizeQuery.toParamString(tarmk.size))), ("segmentCacheSize", Some(segmentCache.sizeQuery.toParamString(segmentCache.size))), ("stringCacheSize", Some(stringCache.sizeQuery.toParamString(stringCache.size))), ("templateCacheSize", Some(templateCache.sizeQuery.toParamString(templateCache.size))), ("stringDeduplicationCacheSize", Some(stringDeduplicationCache.sizeQuery.toParamString(stringDeduplicationCache.size))), ("templateDeduplicationCacheSize", Some(templateDeduplicationCache.sizeQuery.toParamString(templateDeduplicationCache.size))), ("nodeDeduplicationCacheSize", Some(nodeDeduplicationCache.sizeQuery.toParamString(nodeDeduplicationCache.size))), ("pauseCompaction", Some(pauseCompactionQuery.toParamString(pauseCompaction))), ("compactionRetryCount", Some(compaction.retryCountQuery.toParamString(compaction.retryCount))), ("compactionForceTimeout", Some(compaction.force.timeoutQuery.toParamString(compaction.force.timeout))), ("compactionSizeDeltaEstimation", Some(compaction.sizeDeltaEstimationQuery.toParamString(compaction.sizeDeltaEstimation))), ("compactionDisableEstimation", Some(compaction.disableEstimationQuery.toParamString(compaction.disableEstimation))), ("compactionRetainedGenerations", Some(compaction.retainedGenerationsQuery.toParamString(compaction.retainedGenerations))), ("compactionMemoryThreshold", Some(compaction.memoryThresholdQuery.toParamString(compaction.memoryThreshold))), ("compactionProgressLog", Some(compaction.progressLogQuery.toParamString(compaction.progressLog))), ("standby", Some(standbyQuery.toParamString(standby))), ("customBlobStore", Some(customBlobStoreQuery.toParamString(customBlobStore))), ("customSegmentStore", Some(customSegmentStoreQuery.toParamString(customSegmentStore))), ("splitPersistence", Some(splitPersistenceQuery.toParamString(splitPersistence))), ("repositoryBackupDir", Some(repository.backup.dirQuery.toParamString(repository.backup.dir))), ("blobGcMaxAgeInSecs", Some(blobGcMaxAgeInSecsQuery.toParamString(blobGcMaxAgeInSecs))), ("blobTrackSnapshotIntervalInSecs", Some(blobTrackSnapshotIntervalInSecsQuery.toParamString(blobTrackSnapshotIntervalInSecs))), ("role", Some(roleQuery.toParamString(role))), ("registerDescriptors", Some(registerDescriptorsQuery.toParamString(registerDescriptors))), ("dispatchChanges", Some(dispatchChangesQuery.toParamString(dispatchChanges))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], commitsTrackerWriterGroups: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], commitsTrackerWriterGroupsQuery: QueryParam[List[String]]): Task[OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo] = jsonOf[OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreMonitorService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("commitsTrackerWriterGroups", Some(commitsTrackerWriterGroupsQuery.toParamString(commitsTrackerWriterGroups))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSegmentSegmentNodeStoreService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], repositoryHome: String, tarmkMode: String, tarmkSize: Integer, segmentCacheSize: Integer, stringCacheSize: Integer, templateCacheSize: Integer, stringDeduplicationCacheSize: Integer, templateDeduplicationCacheSize: Integer, nodeDeduplicationCacheSize: Integer, pauseCompaction: Boolean, compactionRetryCount: Integer, compactionForceTimeout: Integer, compactionSizeDeltaEstimation: Integer, compactionDisableEstimation: Boolean, compactionRetainedGenerations: Integer, compactionMemoryThreshold: Integer, compactionProgressLog: Integer, standby: Boolean, customBlobStore: Boolean, customSegmentStore: Boolean, splitPersistence: Boolean, repositoryBackupDir: String, blobGcMaxAgeInSecs: Integer, blobTrackSnapshotIntervalInSecs: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], repositoryHomeQuery: QueryParam[String], tarmkModeQuery: QueryParam[String], tarmkSizeQuery: QueryParam[Integer], segmentCacheSizeQuery: QueryParam[Integer], stringCacheSizeQuery: QueryParam[Integer], templateCacheSizeQuery: QueryParam[Integer], stringDeduplicationCacheSizeQuery: QueryParam[Integer], templateDeduplicationCacheSizeQuery: QueryParam[Integer], nodeDeduplicationCacheSizeQuery: QueryParam[Integer], pauseCompactionQuery: QueryParam[Boolean], compactionRetryCountQuery: QueryParam[Integer], compactionForceTimeoutQuery: QueryParam[Integer], compactionSizeDeltaEstimationQuery: QueryParam[Integer], compactionDisableEstimationQuery: QueryParam[Boolean], compactionRetainedGenerationsQuery: QueryParam[Integer], compactionMemoryThresholdQuery: QueryParam[Integer], compactionProgressLogQuery: QueryParam[Integer], standbyQuery: QueryParam[Boolean], customBlobStoreQuery: QueryParam[Boolean], customSegmentStoreQuery: QueryParam[Boolean], splitPersistenceQuery: QueryParam[Boolean], repositoryBackupDirQuery: QueryParam[String], blobGcMaxAgeInSecsQuery: QueryParam[Integer], blobTrackSnapshotIntervalInSecsQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo] = jsonOf[OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("repositoryHome", Some(repository.homeQuery.toParamString(repository.home))), ("tarmkMode", Some(tarmk.modeQuery.toParamString(tarmk.mode))), ("tarmkSize", Some(tarmk.sizeQuery.toParamString(tarmk.size))), ("segmentCacheSize", Some(segmentCache.sizeQuery.toParamString(segmentCache.size))), ("stringCacheSize", Some(stringCache.sizeQuery.toParamString(stringCache.size))), ("templateCacheSize", Some(templateCache.sizeQuery.toParamString(templateCache.size))), ("stringDeduplicationCacheSize", Some(stringDeduplicationCache.sizeQuery.toParamString(stringDeduplicationCache.size))), ("templateDeduplicationCacheSize", Some(templateDeduplicationCache.sizeQuery.toParamString(templateDeduplicationCache.size))), ("nodeDeduplicationCacheSize", Some(nodeDeduplicationCache.sizeQuery.toParamString(nodeDeduplicationCache.size))), ("pauseCompaction", Some(pauseCompactionQuery.toParamString(pauseCompaction))), ("compactionRetryCount", Some(compaction.retryCountQuery.toParamString(compaction.retryCount))), ("compactionForceTimeout", Some(compaction.force.timeoutQuery.toParamString(compaction.force.timeout))), ("compactionSizeDeltaEstimation", Some(compaction.sizeDeltaEstimationQuery.toParamString(compaction.sizeDeltaEstimation))), ("compactionDisableEstimation", Some(compaction.disableEstimationQuery.toParamString(compaction.disableEstimation))), ("compactionRetainedGenerations", Some(compaction.retainedGenerationsQuery.toParamString(compaction.retainedGenerations))), ("compactionMemoryThreshold", Some(compaction.memoryThresholdQuery.toParamString(compaction.memoryThreshold))), ("compactionProgressLog", Some(compaction.progressLogQuery.toParamString(compaction.progressLog))), ("standby", Some(standbyQuery.toParamString(standby))), ("customBlobStore", Some(customBlobStoreQuery.toParamString(customBlobStore))), ("customSegmentStore", Some(customSegmentStoreQuery.toParamString(customSegmentStore))), ("splitPersistence", Some(splitPersistenceQuery.toParamString(splitPersistence))), ("repositoryBackupDir", Some(repository.backup.dirQuery.toParamString(repository.backup.dir))), ("blobGcMaxAgeInSecs", Some(blobGcMaxAgeInSecsQuery.toParamString(blobGcMaxAgeInSecs))), ("blobTrackSnapshotIntervalInSecs", Some(blobTrackSnapshotIntervalInSecsQuery.toParamString(blobTrackSnapshotIntervalInSecs))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingInstallerConfigurationPersist: Boolean, mode: String, port: Integer, primaryHost: String, interval: Integer, primaryAllowedClientIpRanges: List[String], secure: Boolean, standbyReadtimeout: Integer, standbyAutoclean: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingInstallerConfigurationPersistQuery: QueryParam[Boolean], modeQuery: QueryParam[String], portQuery: QueryParam[Integer], primaryHostQuery: QueryParam[String], intervalQuery: QueryParam[Integer], primaryAllowedClientIpRangesQuery: QueryParam[List[String]], secureQuery: QueryParam[Boolean], standbyReadtimeoutQuery: QueryParam[Integer], standbyAutocleanQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo] = jsonOf[OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.segment.standby.store.StandbyStoreService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingInstallerConfigurationPersist", Some(org.apache.sling.installer.configuration.persistQuery.toParamString(org.apache.sling.installer.configuration.persist))), ("mode", Some(modeQuery.toParamString(mode))), ("port", Some(portQuery.toParamString(port))), ("primaryHost", Some(primary.hostQuery.toParamString(primary.host))), ("interval", Some(intervalQuery.toParamString(interval))), ("primaryAllowedClientIpRanges", Some(primary.allowed-client-ip-rangesQuery.toParamString(primary.allowed-client-ip-ranges))), ("secure", Some(secureQuery.toParamString(secure))), ("standbyReadtimeout", Some(standby.readtimeoutQuery.toParamString(standby.readtimeout))), ("standbyAutoclean", Some(standby.autocleanQuery.toParamString(standby.autoclean))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDe(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], handlerName: String, userExpirationTime: String, userAutoMembership: List[String], userPropertyMapping: List[String], userPathPrefix: String, userMembershipExpTime: String, userMembershipNestingDepth: Integer, userDynamicMembership: Boolean, userDisableMissing: Boolean, groupExpirationTime: String, groupAutoMembership: List[String], groupPropertyMapping: List[String], groupPathPrefix: String, enableRFC7613UsercaseMappedProfile: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], handlerNameQuery: QueryParam[String], userExpirationTimeQuery: QueryParam[String], userAutoMembershipQuery: QueryParam[List[String]], userPropertyMappingQuery: QueryParam[List[String]], userPathPrefixQuery: QueryParam[String], userMembershipExpTimeQuery: QueryParam[String], userMembershipNestingDepthQuery: QueryParam[Integer], userDynamicMembershipQuery: QueryParam[Boolean], userDisableMissingQuery: QueryParam[Boolean], groupExpirationTimeQuery: QueryParam[String], groupAutoMembershipQuery: QueryParam[List[String]], groupPropertyMappingQuery: QueryParam[List[String]], groupPathPrefixQuery: QueryParam[String], enableRFC7613UsercaseMappedProfileQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo] = jsonOf[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.DefaultSyncHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("handlerName", Some(handler.nameQuery.toParamString(handler.name))), ("userExpirationTime", Some(user.expirationTimeQuery.toParamString(user.expirationTime))), ("userAutoMembership", Some(user.autoMembershipQuery.toParamString(user.autoMembership))), ("userPropertyMapping", Some(user.propertyMappingQuery.toParamString(user.propertyMapping))), ("userPathPrefix", Some(user.pathPrefixQuery.toParamString(user.pathPrefix))), ("userMembershipExpTime", Some(user.membershipExpTimeQuery.toParamString(user.membershipExpTime))), ("userMembershipNestingDepth", Some(user.membershipNestingDepthQuery.toParamString(user.membershipNestingDepth))), ("userDynamicMembership", Some(user.dynamicMembershipQuery.toParamString(user.dynamicMembership))), ("userDisableMissing", Some(user.disableMissingQuery.toParamString(user.disableMissing))), ("groupExpirationTime", Some(group.expirationTimeQuery.toParamString(group.expirationTime))), ("groupAutoMembership", Some(group.autoMembershipQuery.toParamString(group.autoMembership))), ("groupPropertyMapping", Some(group.propertyMappingQuery.toParamString(group.propertyMapping))), ("groupPathPrefix", Some(group.pathPrefixQuery.toParamString(group.pathPrefix))), ("enableRFC7613UsercaseMappedProfile", Some(enableRFC7613UsercaseMappedProfileQuery.toParamString(enableRFC7613UsercaseMappedProfile))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplEx(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jaasRanking: Integer, jaasControlFlag: String, jaasRealmName: String, idpName: String, syncHandlerName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jaasRankingQuery: QueryParam[Integer], jaasControlFlagQuery: QueryParam[String], jaasRealmNameQuery: QueryParam[String], idpNameQuery: QueryParam[String], syncHandlerNameQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo] = jsonOf[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.ExternalLoginModuleFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jaasRanking", Some(jaas.rankingQuery.toParamString(jaas.ranking))), ("jaasControlFlag", Some(jaas.controlFlagQuery.toParamString(jaas.controlFlag))), ("jaasRealmName", Some(jaas.realmNameQuery.toParamString(jaas.realmName))), ("idpName", Some(idp.nameQuery.toParamString(idp.name))), ("syncHandlerName", Some(sync.handlerNameQuery.toParamString(sync.handlerName))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPr(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], protectExternalId: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], protectExternalIdQuery: QueryParam[Boolean]): Task[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo] = jsonOf[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.principal.ExternalPrincipalConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("protectExternalId", Some(protectExternalIdQuery.toParamString(protectExternalId))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfi(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], cugSupportedPaths: List[String], cugEnabled: Boolean, configurationRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], cugSupportedPathsQuery: QueryParam[List[String]], cugEnabledQuery: QueryParam[Boolean], configurationRankingQuery: QueryParam[Integer]): Task[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo] = jsonOf[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authorization.cug.impl.CugConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("cugSupportedPaths", Some(cugSupportedPathsQuery.toParamString(cugSupportedPaths))), ("cugEnabled", Some(cugEnabledQuery.toParamString(cugEnabled))), ("configurationRanking", Some(configurationRankingQuery.toParamString(configurationRanking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExclu(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], principalNames: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], principalNamesQuery: QueryParam[List[String]]): Task[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo] = jsonOf[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authorization.cug.impl.CugExcludeImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("principalNames", Some(principalNamesQuery.toParamString(principalNames))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizable(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabledActions: String, userPrivilegeNames: List[String], groupPrivilegeNames: List[String], constraint: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledActionsQuery: QueryParam[String], userPrivilegeNamesQuery: QueryParam[List[String]], groupPrivilegeNamesQuery: QueryParam[List[String]], constraintQuery: QueryParam[String]): Task[OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo] = jsonOf[OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.user.action.DefaultAuthorizableActionProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabledActions", Some(enabledActionsQuery.toParamString(enabledActions))), ("userPrivilegeNames", Some(userPrivilegeNamesQuery.toParamString(userPrivilegeNames))), ("groupPrivilegeNames", Some(groupPrivilegeNamesQuery.toParamString(groupPrivilegeNames))), ("constraint", Some(constraintQuery.toParamString(constraint))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitVaultPackagingImplPackagingImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], packageRoots: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], packageRootsQuery: QueryParam[List[String]]): Task[OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo] = jsonOf[OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.vault.packaging.impl.PackagingImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("packageRoots", Some(packageRootsQuery.toParamString(packageRoots))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo](req)

    } yield resp
  }
  
  def orgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistry(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], homePath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], homePathQuery: QueryParam[String]): Task[OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo] = jsonOf[OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo]

    val path = "/system/console/configMgr/org.apache.jackrabbit.vault.packaging.registry.impl.FSPackageRegistry"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("homePath", Some(homePathQuery.toParamString(homePath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingAuthCoreImplLogoutServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletMethods: List[String], slingServletPaths: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletMethodsQuery: QueryParam[List[String]], slingServletPathsQuery: QueryParam[String]): Task[OrgApacheSlingAuthCoreImplLogoutServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingAuthCoreImplLogoutServletInfo] = jsonOf[OrgApacheSlingAuthCoreImplLogoutServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.auth.core.impl.LogoutServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletMethods", Some(sling.servlet.methodsQuery.toParamString(sling.servlet.methods))), ("slingServletPaths", Some(sling.servlet.pathsQuery.toParamString(sling.servlet.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingAuthCoreImplLogoutServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigImplConfigurationBindingsValueProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo] = jsonOf[OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.impl.ConfigurationBindingsValueProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigImplConfigurationResolverImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], configBucketNames: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], configBucketNamesQuery: QueryParam[List[String]]): Task[OrgApacheSlingCaconfigImplConfigurationResolverImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigImplConfigurationResolverImplInfo] = jsonOf[OrgApacheSlingCaconfigImplConfigurationResolverImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.impl.ConfigurationResolverImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("configBucketNames", Some(configBucketNamesQuery.toParamString(configBucketNames))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigImplConfigurationResolverImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStra(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, configPropertyInheritancePropertyNames: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], configPropertyInheritancePropertyNamesQuery: QueryParam[List[String]]): Task[OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo] = jsonOf[OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.impl.def.DefaultConfigurationInheritanceStrategy"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("configPropertyInheritancePropertyNames", Some(configPropertyInheritancePropertyNamesQuery.toParamString(configPropertyInheritancePropertyNames))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStra(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean]): Task[OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo] = jsonOf[OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.impl.def.DefaultConfigurationPersistenceStrategy"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProvi(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], description: String, overrides: List[String], enabled: Boolean, serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], descriptionQuery: QueryParam[String], overridesQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], serviceRankingQuery: QueryParam[Integer]): Task[OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo] = jsonOf[OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.impl.override.OsgiConfigurationOverrideProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("description", Some(descriptionQuery.toParamString(description))), ("overrides", Some(overridesQuery.toParamString(overrides))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOve(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], serviceRankingQuery: QueryParam[Integer]): Task[OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo] = jsonOf[OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.impl.override.SystemPropertyConfigurationOverrideProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigManagementImplConfigurationManagementSetti(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], ignorePropertyNameRegex: List[String], configCollectionPropertiesResourceNames: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], ignorePropertyNameRegexQuery: QueryParam[List[String]], configCollectionPropertiesResourceNamesQuery: QueryParam[List[String]]): Task[OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo] = jsonOf[OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.management.impl.ConfigurationManagementSettingsImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("ignorePropertyNameRegex", Some(ignorePropertyNameRegexQuery.toParamString(ignorePropertyNameRegex))), ("configCollectionPropertiesResourceNames", Some(configCollectionPropertiesResourceNamesQuery.toParamString(configCollectionPropertiesResourceNames))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigResourceImplDefDefaultConfigurationResour(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, configPath: String, fallbackPaths: List[String], configCollectionInheritancePropertyNames: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], configPathQuery: QueryParam[String], fallbackPathsQuery: QueryParam[List[String]], configCollectionInheritancePropertyNamesQuery: QueryParam[List[String]]): Task[OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo] = jsonOf[OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.resource.impl.def.DefaultConfigurationResourceResolvingStrategy"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("configPath", Some(configPathQuery.toParamString(configPath))), ("fallbackPaths", Some(fallbackPathsQuery.toParamString(fallbackPaths))), ("configCollectionInheritancePropertyNames", Some(configCollectionInheritancePropertyNamesQuery.toParamString(configCollectionInheritancePropertyNames))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategy(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], enabled: Boolean, configRefResourceNames: List[String], configRefPropertyNames: List[String], serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], configRefResourceNamesQuery: QueryParam[List[String]], configRefPropertyNamesQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer]): Task[OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo] = jsonOf[OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo]

    val path = "/system/console/configMgr/org.apache.sling.caconfig.resource.impl.def.DefaultContextPathStrategy"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("configRefResourceNames", Some(configRefResourceNamesQuery.toParamString(configRefResourceNames))), ("configRefPropertyNames", Some(configRefPropertyNamesQuery.toParamString(configRefPropertyNames))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsHtmlInternalTagsoupHtmlParser(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], parserFeatures: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], parserFeaturesQuery: QueryParam[List[String]]): Task[OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo] = jsonOf[OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.html.internal.TagsoupHtmlParser"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("parserFeatures", Some(parser.featuresQuery.toParamString(parser.features))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsLogLogManager(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingCommonsLogLevel: String, orgApacheSlingCommonsLogFile: String, orgApacheSlingCommonsLogFileNumber: Integer, orgApacheSlingCommonsLogFileSize: String, orgApacheSlingCommonsLogPattern: String, orgApacheSlingCommonsLogConfigurationFile: String, orgApacheSlingCommonsLogPackagingDataEnabled: Boolean, orgApacheSlingCommonsLogMaxCallerDataDepth: Integer, orgApacheSlingCommonsLogMaxOldFileCountInDump: Integer, orgApacheSlingCommonsLogNumOfLines: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingCommonsLogLevelQuery: QueryParam[String], orgApacheSlingCommonsLogFileQuery: QueryParam[String], orgApacheSlingCommonsLogFileNumberQuery: QueryParam[Integer], orgApacheSlingCommonsLogFileSizeQuery: QueryParam[String], orgApacheSlingCommonsLogPatternQuery: QueryParam[String], orgApacheSlingCommonsLogConfigurationFileQuery: QueryParam[String], orgApacheSlingCommonsLogPackagingDataEnabledQuery: QueryParam[Boolean], orgApacheSlingCommonsLogMaxCallerDataDepthQuery: QueryParam[Integer], orgApacheSlingCommonsLogMaxOldFileCountInDumpQuery: QueryParam[Integer], orgApacheSlingCommonsLogNumOfLinesQuery: QueryParam[Integer]): Task[OrgApacheSlingCommonsLogLogManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsLogLogManagerInfo] = jsonOf[OrgApacheSlingCommonsLogLogManagerInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.log.LogManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingCommonsLogLevel", Some(org.apache.sling.commons.log.levelQuery.toParamString(org.apache.sling.commons.log.level))), ("orgApacheSlingCommonsLogFile", Some(org.apache.sling.commons.log.fileQuery.toParamString(org.apache.sling.commons.log.file))), ("orgApacheSlingCommonsLogFileNumber", Some(org.apache.sling.commons.log.file.numberQuery.toParamString(org.apache.sling.commons.log.file.number))), ("orgApacheSlingCommonsLogFileSize", Some(org.apache.sling.commons.log.file.sizeQuery.toParamString(org.apache.sling.commons.log.file.size))), ("orgApacheSlingCommonsLogPattern", Some(org.apache.sling.commons.log.patternQuery.toParamString(org.apache.sling.commons.log.pattern))), ("orgApacheSlingCommonsLogConfigurationFile", Some(org.apache.sling.commons.log.configurationFileQuery.toParamString(org.apache.sling.commons.log.configurationFile))), ("orgApacheSlingCommonsLogPackagingDataEnabled", Some(org.apache.sling.commons.log.packagingDataEnabledQuery.toParamString(org.apache.sling.commons.log.packagingDataEnabled))), ("orgApacheSlingCommonsLogMaxCallerDataDepth", Some(org.apache.sling.commons.log.maxCallerDataDepthQuery.toParamString(org.apache.sling.commons.log.maxCallerDataDepth))), ("orgApacheSlingCommonsLogMaxOldFileCountInDump", Some(org.apache.sling.commons.log.maxOldFileCountInDumpQuery.toParamString(org.apache.sling.commons.log.maxOldFileCountInDump))), ("orgApacheSlingCommonsLogNumOfLines", Some(org.apache.sling.commons.log.numOfLinesQuery.toParamString(org.apache.sling.commons.log.numOfLines))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsLogLogManagerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsLogLogManagerFactoryConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingCommonsLogLevel: String, orgApacheSlingCommonsLogFile: String, orgApacheSlingCommonsLogPattern: String, orgApacheSlingCommonsLogNames: List[String], orgApacheSlingCommonsLogAdditiv: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingCommonsLogLevelQuery: QueryParam[String], orgApacheSlingCommonsLogFileQuery: QueryParam[String], orgApacheSlingCommonsLogPatternQuery: QueryParam[String], orgApacheSlingCommonsLogNamesQuery: QueryParam[List[String]], orgApacheSlingCommonsLogAdditivQuery: QueryParam[Boolean]): Task[OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo] = jsonOf[OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.log.LogManager.factory.config"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingCommonsLogLevel", Some(org.apache.sling.commons.log.levelQuery.toParamString(org.apache.sling.commons.log.level))), ("orgApacheSlingCommonsLogFile", Some(org.apache.sling.commons.log.fileQuery.toParamString(org.apache.sling.commons.log.file))), ("orgApacheSlingCommonsLogPattern", Some(org.apache.sling.commons.log.patternQuery.toParamString(org.apache.sling.commons.log.pattern))), ("orgApacheSlingCommonsLogNames", Some(org.apache.sling.commons.log.namesQuery.toParamString(org.apache.sling.commons.log.names))), ("orgApacheSlingCommonsLogAdditiv", Some(org.apache.sling.commons.log.additivQuery.toParamString(org.apache.sling.commons.log.additiv))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsLogLogManagerFactoryWriter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingCommonsLogFile: String, orgApacheSlingCommonsLogFileNumber: Integer, orgApacheSlingCommonsLogFileSize: String, orgApacheSlingCommonsLogFileBuffered: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingCommonsLogFileQuery: QueryParam[String], orgApacheSlingCommonsLogFileNumberQuery: QueryParam[Integer], orgApacheSlingCommonsLogFileSizeQuery: QueryParam[String], orgApacheSlingCommonsLogFileBufferedQuery: QueryParam[Boolean]): Task[OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo] = jsonOf[OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.log.LogManager.factory.writer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingCommonsLogFile", Some(org.apache.sling.commons.log.fileQuery.toParamString(org.apache.sling.commons.log.file))), ("orgApacheSlingCommonsLogFileNumber", Some(org.apache.sling.commons.log.file.numberQuery.toParamString(org.apache.sling.commons.log.file.number))), ("orgApacheSlingCommonsLogFileSize", Some(org.apache.sling.commons.log.file.sizeQuery.toParamString(org.apache.sling.commons.log.file.size))), ("orgApacheSlingCommonsLogFileBuffered", Some(org.apache.sling.commons.log.file.bufferedQuery.toParamString(org.apache.sling.commons.log.file.buffered))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsMetricsInternalLogReporter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], period: Integer, timeUnit: String, level: String, loggerName: String, prefix: String, pattern: String, registryName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], periodQuery: QueryParam[Integer], timeUnitQuery: QueryParam[String], levelQuery: QueryParam[String], loggerNameQuery: QueryParam[String], prefixQuery: QueryParam[String], patternQuery: QueryParam[String], registryNameQuery: QueryParam[String]): Task[OrgApacheSlingCommonsMetricsInternalLogReporterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsMetricsInternalLogReporterInfo] = jsonOf[OrgApacheSlingCommonsMetricsInternalLogReporterInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.metrics.internal.LogReporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("period", Some(periodQuery.toParamString(period))), ("timeUnit", Some(timeUnitQuery.toParamString(timeUnit))), ("level", Some(levelQuery.toParamString(level))), ("loggerName", Some(loggerNameQuery.toParamString(loggerName))), ("prefix", Some(prefixQuery.toParamString(prefix))), ("pattern", Some(patternQuery.toParamString(pattern))), ("registryName", Some(registryNameQuery.toParamString(registryName))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsMetricsInternalLogReporterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], datasources: List[String], step: Integer, archives: List[String], `path`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], datasourcesQuery: QueryParam[List[String]], stepQuery: QueryParam[Integer], archivesQuery: QueryParam[List[String]], `path`Query: QueryParam[String]): Task[OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo] = jsonOf[OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.metrics.rrd4j.impl.CodahaleMetricsReporter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("datasources", Some(datasourcesQuery.toParamString(datasources))), ("step", Some(stepQuery.toParamString(step))), ("archives", Some(archivesQuery.toParamString(archives))), ("`path`", Some(pathQuery.toParamString(path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsMimeInternalMimeTypeServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mimeTypes: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mimeTypesQuery: QueryParam[List[String]]): Task[OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo] = jsonOf[OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.mime.internal.MimeTypeServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mimeTypes", Some(mime.typesQuery.toParamString(mime.types))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsSchedulerImplQuartzScheduler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], poolName: String, allowedPoolNames: List[String], schedulerUseleaderforsingle: Boolean, metricsFilters: List[String], slowThresholdMillis: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], poolNameQuery: QueryParam[String], allowedPoolNamesQuery: QueryParam[List[String]], schedulerUseleaderforsingleQuery: QueryParam[Boolean], metricsFiltersQuery: QueryParam[List[String]], slowThresholdMillisQuery: QueryParam[Integer]): Task[OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo] = jsonOf[OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.scheduler.impl.QuartzScheduler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("poolName", Some(poolNameQuery.toParamString(poolName))), ("allowedPoolNames", Some(allowedPoolNamesQuery.toParamString(allowedPoolNames))), ("schedulerUseleaderforsingle", Some(scheduler.useleaderforsingleQuery.toParamString(scheduler.useleaderforsingle))), ("metricsFilters", Some(metrics.filtersQuery.toParamString(metrics.filters))), ("slowThresholdMillis", Some(slowThresholdMillisQuery.toParamString(slowThresholdMillis))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsSchedulerImplSchedulerHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxQuartzJobDurationAcceptable: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxQuartzJobDurationAcceptableQuery: QueryParam[Integer]): Task[OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo] = jsonOf[OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.scheduler.impl.SchedulerHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxQuartzJobDurationAcceptable", Some(max.quartzJob.duration.acceptableQuery.toParamString(max.quartzJob.duration.acceptable))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo](req)

    } yield resp
  }
  
  def orgApacheSlingCommonsThreadsImplDefaultThreadPoolFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, minPoolSize: Integer, maxPoolSize: Integer, queueSize: Integer, maxThreadAge: Integer, keepAliveTime: Integer, blockPolicy: String, shutdownGraceful: Boolean, daemon: Boolean, shutdownWaitTime: Integer, priority: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], minPoolSizeQuery: QueryParam[Integer], maxPoolSizeQuery: QueryParam[Integer], queueSizeQuery: QueryParam[Integer], maxThreadAgeQuery: QueryParam[Integer], keepAliveTimeQuery: QueryParam[Integer], blockPolicyQuery: QueryParam[String], shutdownGracefulQuery: QueryParam[Boolean], daemonQuery: QueryParam[Boolean], shutdownWaitTimeQuery: QueryParam[Integer], priorityQuery: QueryParam[String]): Task[OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo] = jsonOf[OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.commons.threads.impl.DefaultThreadPool.factory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("minPoolSize", Some(minPoolSizeQuery.toParamString(minPoolSize))), ("maxPoolSize", Some(maxPoolSizeQuery.toParamString(maxPoolSize))), ("queueSize", Some(queueSizeQuery.toParamString(queueSize))), ("maxThreadAge", Some(maxThreadAgeQuery.toParamString(maxThreadAge))), ("keepAliveTime", Some(keepAliveTimeQuery.toParamString(keepAliveTime))), ("blockPolicy", Some(blockPolicyQuery.toParamString(blockPolicy))), ("shutdownGraceful", Some(shutdownGracefulQuery.toParamString(shutdownGraceful))), ("daemon", Some(daemonQuery.toParamString(daemon))), ("shutdownWaitTime", Some(shutdownWaitTimeQuery.toParamString(shutdownWaitTime))), ("priority", Some(priorityQuery.toParamString(priority))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDatasourceDataSourceFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], datasourceName: String, datasourceSvcPropName: String, driverClassName: String, url: String, username: String, password: String, defaultAutoCommit: String, defaultReadOnly: String, defaultTransactionIsolation: String, defaultCatalog: String, maxActive: Integer, maxIdle: Integer, minIdle: Integer, initialSize: Integer, maxWait: Integer, maxAge: Integer, testOnBorrow: Boolean, testOnReturn: Boolean, testWhileIdle: Boolean, validationQuery: String, validationQueryTimeout: Integer, timeBetweenEvictionRunsMillis: Integer, minEvictableIdleTimeMillis: Integer, connectionProperties: String, initSQL: String, jdbcInterceptors: String, validationInterval: Integer, logValidationErrors: Boolean, datasourceSvcProperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], datasourceNameQuery: QueryParam[String], datasourceSvcPropNameQuery: QueryParam[String], driverClassNameQuery: QueryParam[String], urlQuery: QueryParam[String], usernameQuery: QueryParam[String], passwordQuery: QueryParam[String], defaultAutoCommitQuery: QueryParam[String], defaultReadOnlyQuery: QueryParam[String], defaultTransactionIsolationQuery: QueryParam[String], defaultCatalogQuery: QueryParam[String], maxActiveQuery: QueryParam[Integer], maxIdleQuery: QueryParam[Integer], minIdleQuery: QueryParam[Integer], initialSizeQuery: QueryParam[Integer], maxWaitQuery: QueryParam[Integer], maxAgeQuery: QueryParam[Integer], testOnBorrowQuery: QueryParam[Boolean], testOnReturnQuery: QueryParam[Boolean], testWhileIdleQuery: QueryParam[Boolean], validationQueryQuery: QueryParam[String], validationQueryTimeoutQuery: QueryParam[Integer], timeBetweenEvictionRunsMillisQuery: QueryParam[Integer], minEvictableIdleTimeMillisQuery: QueryParam[Integer], connectionPropertiesQuery: QueryParam[String], initSQLQuery: QueryParam[String], jdbcInterceptorsQuery: QueryParam[String], validationIntervalQuery: QueryParam[Integer], logValidationErrorsQuery: QueryParam[Boolean], datasourceSvcPropertiesQuery: QueryParam[List[String]]): Task[OrgApacheSlingDatasourceDataSourceFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDatasourceDataSourceFactoryInfo] = jsonOf[OrgApacheSlingDatasourceDataSourceFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.datasource.DataSourceFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("datasourceName", Some(datasource.nameQuery.toParamString(datasource.name))), ("datasourceSvcPropName", Some(datasource.svc.prop.nameQuery.toParamString(datasource.svc.prop.name))), ("driverClassName", Some(driverClassNameQuery.toParamString(driverClassName))), ("url", Some(urlQuery.toParamString(url))), ("username", Some(usernameQuery.toParamString(username))), ("password", Some(passwordQuery.toParamString(password))), ("defaultAutoCommit", Some(defaultAutoCommitQuery.toParamString(defaultAutoCommit))), ("defaultReadOnly", Some(defaultReadOnlyQuery.toParamString(defaultReadOnly))), ("defaultTransactionIsolation", Some(defaultTransactionIsolationQuery.toParamString(defaultTransactionIsolation))), ("defaultCatalog", Some(defaultCatalogQuery.toParamString(defaultCatalog))), ("maxActive", Some(maxActiveQuery.toParamString(maxActive))), ("maxIdle", Some(maxIdleQuery.toParamString(maxIdle))), ("minIdle", Some(minIdleQuery.toParamString(minIdle))), ("initialSize", Some(initialSizeQuery.toParamString(initialSize))), ("maxWait", Some(maxWaitQuery.toParamString(maxWait))), ("maxAge", Some(maxAgeQuery.toParamString(maxAge))), ("testOnBorrow", Some(testOnBorrowQuery.toParamString(testOnBorrow))), ("testOnReturn", Some(testOnReturnQuery.toParamString(testOnReturn))), ("testWhileIdle", Some(testWhileIdleQuery.toParamString(testWhileIdle))), ("validationQuery", Some(validationQueryQuery.toParamString(validationQuery))), ("validationQueryTimeout", Some(validationQueryTimeoutQuery.toParamString(validationQueryTimeout))), ("timeBetweenEvictionRunsMillis", Some(timeBetweenEvictionRunsMillisQuery.toParamString(timeBetweenEvictionRunsMillis))), ("minEvictableIdleTimeMillis", Some(minEvictableIdleTimeMillisQuery.toParamString(minEvictableIdleTimeMillis))), ("connectionProperties", Some(connectionPropertiesQuery.toParamString(connectionProperties))), ("initSQL", Some(initSQLQuery.toParamString(initSQL))), ("jdbcInterceptors", Some(jdbcInterceptorsQuery.toParamString(jdbcInterceptors))), ("validationInterval", Some(validationIntervalQuery.toParamString(validationInterval))), ("logValidationErrors", Some(logValidationErrorsQuery.toParamString(logValidationErrors))), ("datasourceSvcProperties", Some(datasource.svc.propertiesQuery.toParamString(datasource.svc.properties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDatasourceDataSourceFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDatasourceJNDIDataSourceFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], datasourceName: String, datasourceSvcPropName: String, datasourceJndiName: String, jndiProperties: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], datasourceNameQuery: QueryParam[String], datasourceSvcPropNameQuery: QueryParam[String], datasourceJndiNameQuery: QueryParam[String], jndiPropertiesQuery: QueryParam[List[String]]): Task[OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo] = jsonOf[OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.datasource.JNDIDataSourceFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("datasourceName", Some(datasource.nameQuery.toParamString(datasource.name))), ("datasourceSvcPropName", Some(datasource.svc.prop.nameQuery.toParamString(datasource.svc.prop.name))), ("datasourceJndiName", Some(datasource.jndi.nameQuery.toParamString(datasource.jndi.name))), ("jndiProperties", Some(jndi.propertiesQuery.toParamString(jndi.properties))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDiscoveryOakConfig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], connectorPingTimeout: Integer, connectorPingInterval: Integer, discoveryLiteCheckInterval: Integer, clusterSyncServiceTimeout: Integer, clusterSyncServiceInterval: Integer, enableSyncToken: Boolean, minEventDelay: Integer, socketConnectTimeout: Integer, soTimeout: Integer, topologyConnectorUrls: List[String], topologyConnectorWhitelist: List[String], autoStopLocalLoopEnabled: Boolean, gzipConnectorRequestsEnabled: Boolean, hmacEnabled: Boolean, enableEncryption: Boolean, sharedKey: String, hmacSharedKeyTTL: Integer, backoffStandbyFactor: String, backoffStableFactor: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], connectorPingTimeoutQuery: QueryParam[Integer], connectorPingIntervalQuery: QueryParam[Integer], discoveryLiteCheckIntervalQuery: QueryParam[Integer], clusterSyncServiceTimeoutQuery: QueryParam[Integer], clusterSyncServiceIntervalQuery: QueryParam[Integer], enableSyncTokenQuery: QueryParam[Boolean], minEventDelayQuery: QueryParam[Integer], socketConnectTimeoutQuery: QueryParam[Integer], soTimeoutQuery: QueryParam[Integer], topologyConnectorUrlsQuery: QueryParam[List[String]], topologyConnectorWhitelistQuery: QueryParam[List[String]], autoStopLocalLoopEnabledQuery: QueryParam[Boolean], gzipConnectorRequestsEnabledQuery: QueryParam[Boolean], hmacEnabledQuery: QueryParam[Boolean], enableEncryptionQuery: QueryParam[Boolean], sharedKeyQuery: QueryParam[String], hmacSharedKeyTTLQuery: QueryParam[Integer], backoffStandbyFactorQuery: QueryParam[String], backoffStableFactorQuery: QueryParam[String]): Task[OrgApacheSlingDiscoveryOakConfigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDiscoveryOakConfigInfo] = jsonOf[OrgApacheSlingDiscoveryOakConfigInfo]

    val path = "/system/console/configMgr/org.apache.sling.discovery.oak.Config"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("connectorPingTimeout", Some(connectorPingTimeoutQuery.toParamString(connectorPingTimeout))), ("connectorPingInterval", Some(connectorPingIntervalQuery.toParamString(connectorPingInterval))), ("discoveryLiteCheckInterval", Some(discoveryLiteCheckIntervalQuery.toParamString(discoveryLiteCheckInterval))), ("clusterSyncServiceTimeout", Some(clusterSyncServiceTimeoutQuery.toParamString(clusterSyncServiceTimeout))), ("clusterSyncServiceInterval", Some(clusterSyncServiceIntervalQuery.toParamString(clusterSyncServiceInterval))), ("enableSyncToken", Some(enableSyncTokenQuery.toParamString(enableSyncToken))), ("minEventDelay", Some(minEventDelayQuery.toParamString(minEventDelay))), ("socketConnectTimeout", Some(socketConnectTimeoutQuery.toParamString(socketConnectTimeout))), ("soTimeout", Some(soTimeoutQuery.toParamString(soTimeout))), ("topologyConnectorUrls", Some(topologyConnectorUrlsQuery.toParamString(topologyConnectorUrls))), ("topologyConnectorWhitelist", Some(topologyConnectorWhitelistQuery.toParamString(topologyConnectorWhitelist))), ("autoStopLocalLoopEnabled", Some(autoStopLocalLoopEnabledQuery.toParamString(autoStopLocalLoopEnabled))), ("gzipConnectorRequestsEnabled", Some(gzipConnectorRequestsEnabledQuery.toParamString(gzipConnectorRequestsEnabled))), ("hmacEnabled", Some(hmacEnabledQuery.toParamString(hmacEnabled))), ("enableEncryption", Some(enableEncryptionQuery.toParamString(enableEncryption))), ("sharedKey", Some(sharedKeyQuery.toParamString(sharedKey))), ("hmacSharedKeyTTL", Some(hmacSharedKeyTTLQuery.toParamString(hmacSharedKeyTTL))), ("backoffStandbyFactor", Some(backoffStandbyFactorQuery.toParamString(backoffStandbyFactor))), ("backoffStableFactor", Some(backoffStableFactorQuery.toParamString(backoffStableFactor))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDiscoveryOakConfigInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDiscoveryOakSynchronizedClocksHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String]): Task[OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo] = jsonOf[OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo]

    val path = "/system/console/configMgr/org.apache.sling.discovery.oak.SynchronizedClocksHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionAgentImplForwardDistributionAgentFacto(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, title: String, details: String, enabled: Boolean, serviceName: String, logLevel: String, allowedRoots: List[String], queueProcessingEnabled: Boolean, packageImporterEndpoints: List[String], passiveQueues: List[String], priorityQueues: List[String], retryStrategy: String, retryAttempts: Integer, requestAuthorizationStrategyTarget: String, transportSecretProviderTarget: String, packageBuilderTarget: String, triggersTarget: String, queueProvider: String, asyncDelivery: Boolean, httpConnTimeout: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], titleQuery: QueryParam[String], detailsQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], serviceNameQuery: QueryParam[String], logLevelQuery: QueryParam[String], allowedRootsQuery: QueryParam[List[String]], queueProcessingEnabledQuery: QueryParam[Boolean], packageImporterEndpointsQuery: QueryParam[List[String]], passiveQueuesQuery: QueryParam[List[String]], priorityQueuesQuery: QueryParam[List[String]], retryStrategyQuery: QueryParam[String], retryAttemptsQuery: QueryParam[Integer], requestAuthorizationStrategyTargetQuery: QueryParam[String], transportSecretProviderTargetQuery: QueryParam[String], packageBuilderTargetQuery: QueryParam[String], triggersTargetQuery: QueryParam[String], queueProviderQuery: QueryParam[String], asyncDeliveryQuery: QueryParam[Boolean], httpConnTimeoutQuery: QueryParam[Integer]): Task[OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo] = jsonOf[OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.agent.impl.ForwardDistributionAgentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("title", Some(titleQuery.toParamString(title))), ("details", Some(detailsQuery.toParamString(details))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("logLevel", Some(log.levelQuery.toParamString(log.level))), ("allowedRoots", Some(allowed.rootsQuery.toParamString(allowed.roots))), ("queueProcessingEnabled", Some(queue.processing.enabledQuery.toParamString(queue.processing.enabled))), ("packageImporterEndpoints", Some(packageImporter.endpointsQuery.toParamString(packageImporter.endpoints))), ("passiveQueues", Some(passiveQueuesQuery.toParamString(passiveQueues))), ("priorityQueues", Some(priorityQueuesQuery.toParamString(priorityQueues))), ("retryStrategy", Some(retry.strategyQuery.toParamString(retry.strategy))), ("retryAttempts", Some(retry.attemptsQuery.toParamString(retry.attempts))), ("requestAuthorizationStrategyTarget", Some(requestAuthorizationStrategy.targetQuery.toParamString(requestAuthorizationStrategy.target))), ("transportSecretProviderTarget", Some(transportSecretProvider.targetQuery.toParamString(transportSecretProvider.target))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))), ("triggersTarget", Some(triggers.targetQuery.toParamString(triggers.target))), ("queueProvider", Some(queue.providerQuery.toParamString(queue.provider))), ("asyncDelivery", Some(async.deliveryQuery.toParamString(async.delivery))), ("httpConnTimeout", Some(http.conn.timeoutQuery.toParamString(http.conn.timeout))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionAgentImplPrivilegeDistributionRequestA(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, jcrPrivilege: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], jcrPrivilegeQuery: QueryParam[String]): Task[OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo] = jsonOf[OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.agent.impl.PrivilegeDistributionRequestAuthorizationStrategyFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("jcrPrivilege", Some(jcrPrivilegeQuery.toParamString(jcrPrivilege))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionAgentImplQueueDistributionAgentFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, title: String, details: String, enabled: Boolean, serviceName: String, logLevel: String, allowedRoots: List[String], requestAuthorizationStrategyTarget: String, queueProviderFactoryTarget: String, packageBuilderTarget: String, triggersTarget: String, priorityQueues: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], titleQuery: QueryParam[String], detailsQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], serviceNameQuery: QueryParam[String], logLevelQuery: QueryParam[String], allowedRootsQuery: QueryParam[List[String]], requestAuthorizationStrategyTargetQuery: QueryParam[String], queueProviderFactoryTargetQuery: QueryParam[String], packageBuilderTargetQuery: QueryParam[String], triggersTargetQuery: QueryParam[String], priorityQueuesQuery: QueryParam[List[String]]): Task[OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo] = jsonOf[OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.agent.impl.QueueDistributionAgentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("title", Some(titleQuery.toParamString(title))), ("details", Some(detailsQuery.toParamString(details))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("logLevel", Some(log.levelQuery.toParamString(log.level))), ("allowedRoots", Some(allowed.rootsQuery.toParamString(allowed.roots))), ("requestAuthorizationStrategyTarget", Some(requestAuthorizationStrategy.targetQuery.toParamString(requestAuthorizationStrategy.target))), ("queueProviderFactoryTarget", Some(queueProviderFactory.targetQuery.toParamString(queueProviderFactory.target))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))), ("triggersTarget", Some(triggers.targetQuery.toParamString(triggers.target))), ("priorityQueues", Some(priorityQueuesQuery.toParamString(priorityQueues))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionAgentImplReverseDistributionAgentFacto(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, title: String, details: String, enabled: Boolean, serviceName: String, logLevel: String, queueProcessingEnabled: Boolean, packageExporterEndpoints: List[String], pullItems: Integer, httpConnTimeout: Integer, requestAuthorizationStrategyTarget: String, transportSecretProviderTarget: String, packageBuilderTarget: String, triggersTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], titleQuery: QueryParam[String], detailsQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], serviceNameQuery: QueryParam[String], logLevelQuery: QueryParam[String], queueProcessingEnabledQuery: QueryParam[Boolean], packageExporterEndpointsQuery: QueryParam[List[String]], pullItemsQuery: QueryParam[Integer], httpConnTimeoutQuery: QueryParam[Integer], requestAuthorizationStrategyTargetQuery: QueryParam[String], transportSecretProviderTargetQuery: QueryParam[String], packageBuilderTargetQuery: QueryParam[String], triggersTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo] = jsonOf[OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.agent.impl.ReverseDistributionAgentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("title", Some(titleQuery.toParamString(title))), ("details", Some(detailsQuery.toParamString(details))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("logLevel", Some(log.levelQuery.toParamString(log.level))), ("queueProcessingEnabled", Some(queue.processing.enabledQuery.toParamString(queue.processing.enabled))), ("packageExporterEndpoints", Some(packageExporter.endpointsQuery.toParamString(packageExporter.endpoints))), ("pullItems", Some(pull.itemsQuery.toParamString(pull.items))), ("httpConnTimeout", Some(http.conn.timeoutQuery.toParamString(http.conn.timeout))), ("requestAuthorizationStrategyTarget", Some(requestAuthorizationStrategy.targetQuery.toParamString(requestAuthorizationStrategy.target))), ("transportSecretProviderTarget", Some(transportSecretProvider.targetQuery.toParamString(transportSecretProvider.target))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))), ("triggersTarget", Some(triggers.targetQuery.toParamString(triggers.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionAgentImplSimpleDistributionAgentFactor(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, title: String, details: String, enabled: Boolean, serviceName: String, logLevel: String, queueProcessingEnabled: Boolean, packageExporterTarget: String, packageImporterTarget: String, requestAuthorizationStrategyTarget: String, triggersTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], titleQuery: QueryParam[String], detailsQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], serviceNameQuery: QueryParam[String], logLevelQuery: QueryParam[String], queueProcessingEnabledQuery: QueryParam[Boolean], packageExporterTargetQuery: QueryParam[String], packageImporterTargetQuery: QueryParam[String], requestAuthorizationStrategyTargetQuery: QueryParam[String], triggersTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo] = jsonOf[OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.agent.impl.SimpleDistributionAgentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("title", Some(titleQuery.toParamString(title))), ("details", Some(detailsQuery.toParamString(details))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("logLevel", Some(log.levelQuery.toParamString(log.level))), ("queueProcessingEnabled", Some(queue.processing.enabledQuery.toParamString(queue.processing.enabled))), ("packageExporterTarget", Some(packageExporter.targetQuery.toParamString(packageExporter.target))), ("packageImporterTarget", Some(packageImporter.targetQuery.toParamString(packageImporter.target))), ("requestAuthorizationStrategyTarget", Some(requestAuthorizationStrategy.targetQuery.toParamString(requestAuthorizationStrategy.target))), ("triggersTarget", Some(triggers.targetQuery.toParamString(triggers.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionAgentImplSyncDistributionAgentFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, title: String, details: String, enabled: Boolean, serviceName: String, logLevel: String, queueProcessingEnabled: Boolean, passiveQueues: List[String], packageExporterEndpoints: List[String], packageImporterEndpoints: List[String], retryStrategy: String, retryAttempts: Integer, pullItems: Integer, httpConnTimeout: Integer, requestAuthorizationStrategyTarget: String, transportSecretProviderTarget: String, packageBuilderTarget: String, triggersTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], titleQuery: QueryParam[String], detailsQuery: QueryParam[String], enabledQuery: QueryParam[Boolean], serviceNameQuery: QueryParam[String], logLevelQuery: QueryParam[String], queueProcessingEnabledQuery: QueryParam[Boolean], passiveQueuesQuery: QueryParam[List[String]], packageExporterEndpointsQuery: QueryParam[List[String]], packageImporterEndpointsQuery: QueryParam[List[String]], retryStrategyQuery: QueryParam[String], retryAttemptsQuery: QueryParam[Integer], pullItemsQuery: QueryParam[Integer], httpConnTimeoutQuery: QueryParam[Integer], requestAuthorizationStrategyTargetQuery: QueryParam[String], transportSecretProviderTargetQuery: QueryParam[String], packageBuilderTargetQuery: QueryParam[String], triggersTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo] = jsonOf[OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.agent.impl.SyncDistributionAgentFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("title", Some(titleQuery.toParamString(title))), ("details", Some(detailsQuery.toParamString(details))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("logLevel", Some(log.levelQuery.toParamString(log.level))), ("queueProcessingEnabled", Some(queue.processing.enabledQuery.toParamString(queue.processing.enabled))), ("passiveQueues", Some(passiveQueuesQuery.toParamString(passiveQueues))), ("packageExporterEndpoints", Some(packageExporter.endpointsQuery.toParamString(packageExporter.endpoints))), ("packageImporterEndpoints", Some(packageImporter.endpointsQuery.toParamString(packageImporter.endpoints))), ("retryStrategy", Some(retry.strategyQuery.toParamString(retry.strategy))), ("retryAttempts", Some(retry.attemptsQuery.toParamString(retry.attempts))), ("pullItems", Some(pull.itemsQuery.toParamString(pull.items))), ("httpConnTimeout", Some(http.conn.timeoutQuery.toParamString(http.conn.timeout))), ("requestAuthorizationStrategyTarget", Some(requestAuthorizationStrategy.targetQuery.toParamString(requestAuthorizationStrategy.target))), ("transportSecretProviderTarget", Some(transportSecretProvider.targetQuery.toParamString(transportSecretProvider.target))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))), ("triggersTarget", Some(triggers.targetQuery.toParamString(triggers.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionMonitorDistributionQueueHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String, numberOfRetriesAllowed: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String], numberOfRetriesAllowedQuery: QueryParam[Integer]): Task[OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo] = jsonOf[OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.monitor.DistributionQueueHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))), ("numberOfRetriesAllowed", Some(numberOfRetriesAllowedQuery.toParamString(numberOfRetriesAllowed))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionPackagingImplExporterAgentDistributio(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, queue: String, dropInvalidItems: Boolean, agentTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], queueQuery: QueryParam[String], dropInvalidItemsQuery: QueryParam[Boolean], agentTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo] = jsonOf[OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.AgentDistributionPackageExporterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("queue", Some(queueQuery.toParamString(queue))), ("dropInvalidItems", Some(drop.invalid.itemsQuery.toParamString(drop.invalid.items))), ("agentTarget", Some(agent.targetQuery.toParamString(agent.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionPackagingImplExporterLocalDistributio(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, packageBuilderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], packageBuilderTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo] = jsonOf[OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.LocalDistributionPackageExporterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionPackagingImplExporterRemoteDistributi(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, endpoints: List[String], pullItems: Integer, packageBuilderTarget: String, transportSecretProviderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], endpointsQuery: QueryParam[List[String]], pullItemsQuery: QueryParam[Integer], packageBuilderTargetQuery: QueryParam[String], transportSecretProviderTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo] = jsonOf[OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.RemoteDistributionPackageExporterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("endpoints", Some(endpointsQuery.toParamString(endpoints))), ("pullItems", Some(pull.itemsQuery.toParamString(pull.items))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))), ("transportSecretProviderTarget", Some(transportSecretProvider.targetQuery.toParamString(transportSecretProvider.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionPackagingImplImporterLocalDistributio(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, packageBuilderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], packageBuilderTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo] = jsonOf[OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.LocalDistributionPackageImporterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("packageBuilderTarget", Some(packageBuilder.targetQuery.toParamString(packageBuilder.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionPackagingImplImporterRemoteDistributi(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, endpoints: List[String], transportSecretProviderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], endpointsQuery: QueryParam[List[String]], transportSecretProviderTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo] = jsonOf[OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.RemoteDistributionPackageImporterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("endpoints", Some(endpointsQuery.toParamString(endpoints))), ("transportSecretProviderTarget", Some(transportSecretProvider.targetQuery.toParamString(transportSecretProvider.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionPackagingImplImporterRepositoryDistri(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, serviceName: String, `path`: String, privilegeName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], serviceNameQuery: QueryParam[String], `path`Query: QueryParam[String], privilegeNameQuery: QueryParam[String]): Task[OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo] = jsonOf[OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.RepositoryDistributionPackageImporterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("serviceName", Some(service.nameQuery.toParamString(service.name))), ("`path`", Some(pathQuery.toParamString(path))), ("privilegeName", Some(privilege.nameQuery.toParamString(privilege.name))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionResourcesImplDistributionConfiguration(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerRoots: String, kind: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerRootsQuery: QueryParam[String], kindQuery: QueryParam[String]): Task[OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo] = jsonOf[OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.resources.impl.DistributionConfigurationResourceProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerRoots", Some(provider.rootsQuery.toParamString(provider.roots))), ("kind", Some(kindQuery.toParamString(kind))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionResourcesImplDistributionServiceResour(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerRoots: String, kind: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerRootsQuery: QueryParam[String], kindQuery: QueryParam[String]): Task[OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo] = jsonOf[OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.resources.impl.DistributionServiceResourceProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerRoots", Some(provider.rootsQuery.toParamString(provider.roots))), ("kind", Some(kindQuery.toParamString(kind))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionSerializationImplDistributionPackageBu(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `type`: String, formatTarget: String, tempFsFolder: String, fileThreshold: Integer, memoryUnit: String, useOffHeapMemory: Boolean, digestAlgorithm: String, monitoringQueueSize: Integer, cleanupDelay: Integer, packageFilters: List[String], propertyFilters: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `type`Query: QueryParam[String], formatTargetQuery: QueryParam[String], tempFsFolderQuery: QueryParam[String], fileThresholdQuery: QueryParam[Integer], memoryUnitQuery: QueryParam[String], useOffHeapMemoryQuery: QueryParam[Boolean], digestAlgorithmQuery: QueryParam[String], monitoringQueueSizeQuery: QueryParam[Integer], cleanupDelayQuery: QueryParam[Integer], packageFiltersQuery: QueryParam[List[String]], propertyFiltersQuery: QueryParam[List[String]]): Task[OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo] = jsonOf[OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.serialization.impl.DistributionPackageBuilderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`type`", Some(typeQuery.toParamString(type))), ("formatTarget", Some(format.targetQuery.toParamString(format.target))), ("tempFsFolder", Some(tempFsFolderQuery.toParamString(tempFsFolder))), ("fileThreshold", Some(fileThresholdQuery.toParamString(fileThreshold))), ("memoryUnit", Some(memoryUnitQuery.toParamString(memoryUnit))), ("useOffHeapMemory", Some(useOffHeapMemoryQuery.toParamString(useOffHeapMemory))), ("digestAlgorithm", Some(digestAlgorithmQuery.toParamString(digestAlgorithm))), ("monitoringQueueSize", Some(monitoringQueueSizeQuery.toParamString(monitoringQueueSize))), ("cleanupDelay", Some(cleanupDelayQuery.toParamString(cleanupDelay))), ("packageFilters", Some(package.filtersQuery.toParamString(package.filters))), ("propertyFilters", Some(property.filtersQuery.toParamString(property.filters))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionSerializationImplVltVaultDistribution(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `type`: String, importMode: String, aclHandling: String, packageRoots: String, packageFilters: List[String], propertyFilters: List[String], tempFsFolder: String, useBinaryReferences: Boolean, autoSaveThreshold: Integer, cleanupDelay: Integer, fileThreshold: Integer, MEGA_BYTES: String, useOffHeapMemory: Boolean, digestAlgorithm: String, monitoringQueueSize: Integer, pathsMapping: List[String], strictImport: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `type`Query: QueryParam[String], importModeQuery: QueryParam[String], aclHandlingQuery: QueryParam[String], packageRootsQuery: QueryParam[String], packageFiltersQuery: QueryParam[List[String]], propertyFiltersQuery: QueryParam[List[String]], tempFsFolderQuery: QueryParam[String], useBinaryReferencesQuery: QueryParam[Boolean], autoSaveThresholdQuery: QueryParam[Integer], cleanupDelayQuery: QueryParam[Integer], fileThresholdQuery: QueryParam[Integer], MEGA_BYTESQuery: QueryParam[String], useOffHeapMemoryQuery: QueryParam[Boolean], digestAlgorithmQuery: QueryParam[String], monitoringQueueSizeQuery: QueryParam[Integer], pathsMappingQuery: QueryParam[List[String]], strictImportQuery: QueryParam[Boolean]): Task[OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo] = jsonOf[OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.serialization.impl.vlt.VaultDistributionPackageBuilderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`type`", Some(typeQuery.toParamString(type))), ("importMode", Some(importModeQuery.toParamString(importMode))), ("aclHandling", Some(aclHandlingQuery.toParamString(aclHandling))), ("packageRoots", Some(package.rootsQuery.toParamString(package.roots))), ("packageFilters", Some(package.filtersQuery.toParamString(package.filters))), ("propertyFilters", Some(property.filtersQuery.toParamString(property.filters))), ("tempFsFolder", Some(tempFsFolderQuery.toParamString(tempFsFolder))), ("useBinaryReferences", Some(useBinaryReferencesQuery.toParamString(useBinaryReferences))), ("autoSaveThreshold", Some(autoSaveThresholdQuery.toParamString(autoSaveThreshold))), ("cleanupDelay", Some(cleanupDelayQuery.toParamString(cleanupDelay))), ("fileThreshold", Some(fileThresholdQuery.toParamString(fileThreshold))), ("MEGA_BYTES", Some(MEGA_BYTESQuery.toParamString(MEGA_BYTES))), ("useOffHeapMemory", Some(useOffHeapMemoryQuery.toParamString(useOffHeapMemory))), ("digestAlgorithm", Some(digestAlgorithmQuery.toParamString(digestAlgorithm))), ("monitoringQueueSize", Some(monitoringQueueSizeQuery.toParamString(monitoringQueueSize))), ("pathsMapping", Some(pathsMappingQuery.toParamString(pathsMapping))), ("strictImport", Some(strictImportQuery.toParamString(strictImport))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTransportImplUserCredentialsDistributi(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, username: String, password: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], usernameQuery: QueryParam[String], passwordQuery: QueryParam[String]): Task[OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo] = jsonOf[OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.transport.impl.UserCredentialsDistributionTransportSecretProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("username", Some(usernameQuery.toParamString(username))), ("password", Some(passwordQuery.toParamString(password))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTriggerImplDistributionEventDistribute(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `path`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `path`Query: QueryParam[String]): Task[OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo] = jsonOf[OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.DistributionEventDistributeDistributionTriggerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`path`", Some(pathQuery.toParamString(path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTriggerImplJcrEventDistributionTrigger(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `path`: String, ignoredPathsPatterns: List[String], serviceName: String, deep: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `path`Query: QueryParam[String], ignoredPathsPatternsQuery: QueryParam[List[String]], serviceNameQuery: QueryParam[String], deepQuery: QueryParam[Boolean]): Task[OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo] = jsonOf[OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.JcrEventDistributionTriggerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`path`", Some(pathQuery.toParamString(path))), ("ignoredPathsPatterns", Some(ignoredPathsPatternsQuery.toParamString(ignoredPathsPatterns))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("deep", Some(deepQuery.toParamString(deep))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTriggerImplPersistedJcrEventDistributi(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `path`: String, serviceName: String, nuggetsPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `path`Query: QueryParam[String], serviceNameQuery: QueryParam[String], nuggetsPathQuery: QueryParam[String]): Task[OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo] = jsonOf[OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.PersistedJcrEventDistributionTriggerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`path`", Some(pathQuery.toParamString(path))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))), ("nuggetsPath", Some(nuggetsPathQuery.toParamString(nuggetsPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTriggerImplRemoteEventDistributionTrig(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, endpoint: String, transportSecretProviderTarget: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], endpointQuery: QueryParam[String], transportSecretProviderTargetQuery: QueryParam[String]): Task[OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo] = jsonOf[OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.RemoteEventDistributionTriggerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("endpoint", Some(endpointQuery.toParamString(endpoint))), ("transportSecretProviderTarget", Some(transportSecretProvider.targetQuery.toParamString(transportSecretProvider.target))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTriggerImplResourceEventDistributionTr(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `path`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `path`Query: QueryParam[String]): Task[OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo] = jsonOf[OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.ResourceEventDistributionTriggerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`path`", Some(pathQuery.toParamString(path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo](req)

    } yield resp
  }
  
  def orgApacheSlingDistributionTriggerImplScheduledDistributionTrigge(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, `path`: String, seconds: String, serviceName: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], `path`Query: QueryParam[String], secondsQuery: QueryParam[String], serviceNameQuery: QueryParam[String]): Task[OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo] = jsonOf[OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo]

    val path = "/system/console/configMgr/org.apache.sling.distribution.trigger.impl.ScheduledDistributionTriggerFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("`path`", Some(pathQuery.toParamString(path))), ("seconds", Some(secondsQuery.toParamString(seconds))), ("serviceName", Some(serviceNameQuery.toParamString(serviceName))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEngineImplAuthSlingAuthenticator(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], osgiHttpWhiteboardContextSelect: String, osgiHttpWhiteboardListener: String, authSudoCookie: String, authSudoParameter: String, authAnnonymous: Boolean, slingAuthRequirements: List[String], slingAuthAnonymousUser: String, slingAuthAnonymousPassword: String, authHttp: String, authHttpRealm: String, authUriSuffix: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], osgiHttpWhiteboardContextSelectQuery: QueryParam[String], osgiHttpWhiteboardListenerQuery: QueryParam[String], authSudoCookieQuery: QueryParam[String], authSudoParameterQuery: QueryParam[String], authAnnonymousQuery: QueryParam[Boolean], slingAuthRequirementsQuery: QueryParam[List[String]], slingAuthAnonymousUserQuery: QueryParam[String], slingAuthAnonymousPasswordQuery: QueryParam[String], authHttpQuery: QueryParam[String], authHttpRealmQuery: QueryParam[String], authUriSuffixQuery: QueryParam[List[String]]): Task[OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo] = jsonOf[OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo]

    val path = "/system/console/configMgr/org.apache.sling.engine.impl.auth.SlingAuthenticator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("osgiHttpWhiteboardContextSelect", Some(osgi.http.whiteboard.context.selectQuery.toParamString(osgi.http.whiteboard.context.select))), ("osgiHttpWhiteboardListener", Some(osgi.http.whiteboard.listenerQuery.toParamString(osgi.http.whiteboard.listener))), ("authSudoCookie", Some(auth.sudo.cookieQuery.toParamString(auth.sudo.cookie))), ("authSudoParameter", Some(auth.sudo.parameterQuery.toParamString(auth.sudo.parameter))), ("authAnnonymous", Some(auth.annonymousQuery.toParamString(auth.annonymous))), ("slingAuthRequirements", Some(sling.auth.requirementsQuery.toParamString(sling.auth.requirements))), ("slingAuthAnonymousUser", Some(sling.auth.anonymous.userQuery.toParamString(sling.auth.anonymous.user))), ("slingAuthAnonymousPassword", Some(sling.auth.anonymous.passwordQuery.toParamString(sling.auth.anonymous.password))), ("authHttp", Some(auth.httpQuery.toParamString(auth.http))), ("authHttpRealm", Some(auth.http.realmQuery.toParamString(auth.http.realm))), ("authUriSuffix", Some(auth.uri.suffixQuery.toParamString(auth.uri.suffix))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEngineImplDebugRequestProgressTrackerLogFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], extensions: List[String], minDurationMs: Integer, maxDurationMs: Integer, compactLogFormat: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], extensionsQuery: QueryParam[List[String]], minDurationMsQuery: QueryParam[Integer], maxDurationMsQuery: QueryParam[Integer], compactLogFormatQuery: QueryParam[Boolean]): Task[OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo] = jsonOf[OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo]

    val path = "/system/console/configMgr/org.apache.sling.engine.impl.debug.RequestProgressTrackerLogFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("extensions", Some(extensionsQuery.toParamString(extensions))), ("minDurationMs", Some(minDurationMsQuery.toParamString(minDurationMs))), ("maxDurationMs", Some(maxDurationMsQuery.toParamString(maxDurationMs))), ("compactLogFormat", Some(compactLogFormatQuery.toParamString(compactLogFormat))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEngineImplLogRequestLogger(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], requestLogOutput: String, requestLogOutputtype: Integer, requestLogEnabled: Boolean, accessLogOutput: String, accessLogOutputtype: Integer, accessLogEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], requestLogOutputQuery: QueryParam[String], requestLogOutputtypeQuery: QueryParam[Integer], requestLogEnabledQuery: QueryParam[Boolean], accessLogOutputQuery: QueryParam[String], accessLogOutputtypeQuery: QueryParam[Integer], accessLogEnabledQuery: QueryParam[Boolean]): Task[OrgApacheSlingEngineImplLogRequestLoggerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEngineImplLogRequestLoggerInfo] = jsonOf[OrgApacheSlingEngineImplLogRequestLoggerInfo]

    val path = "/system/console/configMgr/org.apache.sling.engine.impl.log.RequestLogger"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("requestLogOutput", Some(request.log.outputQuery.toParamString(request.log.output))), ("requestLogOutputtype", Some(request.log.outputtypeQuery.toParamString(request.log.outputtype))), ("requestLogEnabled", Some(request.log.enabledQuery.toParamString(request.log.enabled))), ("accessLogOutput", Some(access.log.outputQuery.toParamString(access.log.output))), ("accessLogOutputtype", Some(access.log.outputtypeQuery.toParamString(access.log.outputtype))), ("accessLogEnabled", Some(access.log.enabledQuery.toParamString(access.log.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEngineImplLogRequestLoggerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEngineImplLogRequestLoggerService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], requestLogServiceFormat: String, requestLogServiceOutput: String, requestLogServiceOutputtype: Integer, requestLogServiceOnentry: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], requestLogServiceFormatQuery: QueryParam[String], requestLogServiceOutputQuery: QueryParam[String], requestLogServiceOutputtypeQuery: QueryParam[Integer], requestLogServiceOnentryQuery: QueryParam[Boolean]): Task[OrgApacheSlingEngineImplLogRequestLoggerServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEngineImplLogRequestLoggerServiceInfo] = jsonOf[OrgApacheSlingEngineImplLogRequestLoggerServiceInfo]

    val path = "/system/console/configMgr/org.apache.sling.engine.impl.log.RequestLoggerService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("requestLogServiceFormat", Some(request.log.service.formatQuery.toParamString(request.log.service.format))), ("requestLogServiceOutput", Some(request.log.service.outputQuery.toParamString(request.log.service.output))), ("requestLogServiceOutputtype", Some(request.log.service.outputtypeQuery.toParamString(request.log.service.outputtype))), ("requestLogServiceOnentry", Some(request.log.service.onentryQuery.toParamString(request.log.service.onentry))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEngineImplLogRequestLoggerServiceInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEngineImplSlingMainServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingMaxCalls: Integer, slingMaxInclusions: Integer, slingTraceAllow: Boolean, slingMaxRecordRequests: Integer, slingStorePatternRequests: List[String], slingServerinfo: String, slingAdditionalResponseHeaders: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingMaxCallsQuery: QueryParam[Integer], slingMaxInclusionsQuery: QueryParam[Integer], slingTraceAllowQuery: QueryParam[Boolean], slingMaxRecordRequestsQuery: QueryParam[Integer], slingStorePatternRequestsQuery: QueryParam[List[String]], slingServerinfoQuery: QueryParam[String], slingAdditionalResponseHeadersQuery: QueryParam[List[String]]): Task[OrgApacheSlingEngineImplSlingMainServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEngineImplSlingMainServletInfo] = jsonOf[OrgApacheSlingEngineImplSlingMainServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.engine.impl.SlingMainServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingMaxCalls", Some(sling.max.callsQuery.toParamString(sling.max.calls))), ("slingMaxInclusions", Some(sling.max.inclusionsQuery.toParamString(sling.max.inclusions))), ("slingTraceAllow", Some(sling.trace.allowQuery.toParamString(sling.trace.allow))), ("slingMaxRecordRequests", Some(sling.max.record.requestsQuery.toParamString(sling.max.record.requests))), ("slingStorePatternRequests", Some(sling.store.pattern.requestsQuery.toParamString(sling.store.pattern.requests))), ("slingServerinfo", Some(sling.serverinfoQuery.toParamString(sling.serverinfo))), ("slingAdditionalResponseHeaders", Some(sling.additional.response.headersQuery.toParamString(sling.additional.response.headers))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEngineImplSlingMainServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEngineParameters(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingDefaultParameterEncoding: String, slingDefaultMaxParameters: Integer, fileLocation: String, fileThreshold: Integer, fileMax: Integer, requestMax: Integer, slingDefaultParameterCheckForAdditionalContainerParameters: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingDefaultParameterEncodingQuery: QueryParam[String], slingDefaultMaxParametersQuery: QueryParam[Integer], fileLocationQuery: QueryParam[String], fileThresholdQuery: QueryParam[Integer], fileMaxQuery: QueryParam[Integer], requestMaxQuery: QueryParam[Integer], slingDefaultParameterCheckForAdditionalContainerParametersQuery: QueryParam[Boolean]): Task[OrgApacheSlingEngineParametersInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEngineParametersInfo] = jsonOf[OrgApacheSlingEngineParametersInfo]

    val path = "/system/console/configMgr/org.apache.sling.engine.parameters"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingDefaultParameterEncoding", Some(sling.default.parameter.encodingQuery.toParamString(sling.default.parameter.encoding))), ("slingDefaultMaxParameters", Some(sling.default.max.parametersQuery.toParamString(sling.default.max.parameters))), ("fileLocation", Some(file.locationQuery.toParamString(file.location))), ("fileThreshold", Some(file.thresholdQuery.toParamString(file.threshold))), ("fileMax", Some(file.maxQuery.toParamString(file.max))), ("requestMax", Some(request.maxQuery.toParamString(request.max))), ("slingDefaultParameterCheckForAdditionalContainerParameters", Some(sling.default.parameter.checkForAdditionalContainerParametersQuery.toParamString(sling.default.parameter.checkForAdditionalContainerParameters))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEngineParametersInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEventImplEventingThreadPool(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], minPoolSize: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], minPoolSizeQuery: QueryParam[Integer]): Task[OrgApacheSlingEventImplEventingThreadPoolInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEventImplEventingThreadPoolInfo] = jsonOf[OrgApacheSlingEventImplEventingThreadPoolInfo]

    val path = "/system/console/configMgr/org.apache.sling.event.impl.EventingThreadPool"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("minPoolSize", Some(minPoolSizeQuery.toParamString(minPoolSize))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEventImplEventingThreadPoolInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEventImplJobsDefaultJobManager(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], queuePriority: String, queueRetries: Integer, queueRetrydelay: Integer, queueMaxparallel: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], queuePriorityQuery: QueryParam[String], queueRetriesQuery: QueryParam[Integer], queueRetrydelayQuery: QueryParam[Integer], queueMaxparallelQuery: QueryParam[Integer]): Task[OrgApacheSlingEventImplJobsDefaultJobManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEventImplJobsDefaultJobManagerInfo] = jsonOf[OrgApacheSlingEventImplJobsDefaultJobManagerInfo]

    val path = "/system/console/configMgr/org.apache.sling.event.impl.jobs.DefaultJobManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("queuePriority", Some(queue.priorityQuery.toParamString(queue.priority))), ("queueRetries", Some(queue.retriesQuery.toParamString(queue.retries))), ("queueRetrydelay", Some(queue.retrydelayQuery.toParamString(queue.retrydelay))), ("queueMaxparallel", Some(queue.maxparallelQuery.toParamString(queue.maxparallel))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEventImplJobsDefaultJobManagerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEventImplJobsJcrPersistenceHandler(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jobConsumermanagerDisableDistribution: Boolean, startupDelay: Integer, cleanupPeriod: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jobConsumermanagerDisableDistributionQuery: QueryParam[Boolean], startupDelayQuery: QueryParam[Integer], cleanupPeriodQuery: QueryParam[Integer]): Task[OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo] = jsonOf[OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo]

    val path = "/system/console/configMgr/org.apache.sling.event.impl.jobs.jcr.PersistenceHandler"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jobConsumermanagerDisableDistribution", Some(job.consumermanager.disableDistributionQuery.toParamString(job.consumermanager.disableDistribution))), ("startupDelay", Some(startup.delayQuery.toParamString(startup.delay))), ("cleanupPeriod", Some(cleanup.periodQuery.toParamString(cleanup.period))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEventImplJobsJobConsumerManager(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingInstallerConfigurationPersist: Boolean, jobConsumermanagerWhitelist: List[String], jobConsumermanagerBlacklist: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingInstallerConfigurationPersistQuery: QueryParam[Boolean], jobConsumermanagerWhitelistQuery: QueryParam[List[String]], jobConsumermanagerBlacklistQuery: QueryParam[List[String]]): Task[OrgApacheSlingEventImplJobsJobConsumerManagerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEventImplJobsJobConsumerManagerInfo] = jsonOf[OrgApacheSlingEventImplJobsJobConsumerManagerInfo]

    val path = "/system/console/configMgr/org.apache.sling.event.impl.jobs.JobConsumerManager"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingInstallerConfigurationPersist", Some(org.apache.sling.installer.configuration.persistQuery.toParamString(org.apache.sling.installer.configuration.persist))), ("jobConsumermanagerWhitelist", Some(job.consumermanager.whitelistQuery.toParamString(job.consumermanager.whitelist))), ("jobConsumermanagerBlacklist", Some(job.consumermanager.blacklistQuery.toParamString(job.consumermanager.blacklist))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEventImplJobsJobConsumerManagerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingEventJobsQueueConfiguration(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], queueName: String, queueTopics: List[String], queueType: String, queuePriority: String, queueRetries: Integer, queueRetrydelay: Integer, queueMaxparallel: BigDecimal, queueKeepJobs: Boolean, queuePreferRunOnCreationInstance: Boolean, queueThreadPoolSize: Integer, serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], queueNameQuery: QueryParam[String], queueTopicsQuery: QueryParam[List[String]], queueTypeQuery: QueryParam[String], queuePriorityQuery: QueryParam[String], queueRetriesQuery: QueryParam[Integer], queueRetrydelayQuery: QueryParam[Integer], queueMaxparallelQuery: QueryParam[BigDecimal], queueKeepJobsQuery: QueryParam[Boolean], queuePreferRunOnCreationInstanceQuery: QueryParam[Boolean], queueThreadPoolSizeQuery: QueryParam[Integer], serviceRankingQuery: QueryParam[Integer]): Task[OrgApacheSlingEventJobsQueueConfigurationInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingEventJobsQueueConfigurationInfo] = jsonOf[OrgApacheSlingEventJobsQueueConfigurationInfo]

    val path = "/system/console/configMgr/org.apache.sling.event.jobs.QueueConfiguration"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("queueName", Some(queue.nameQuery.toParamString(queue.name))), ("queueTopics", Some(queue.topicsQuery.toParamString(queue.topics))), ("queueType", Some(queue.typeQuery.toParamString(queue.type))), ("queuePriority", Some(queue.priorityQuery.toParamString(queue.priority))), ("queueRetries", Some(queue.retriesQuery.toParamString(queue.retries))), ("queueRetrydelay", Some(queue.retrydelayQuery.toParamString(queue.retrydelay))), ("queueMaxparallel", Some(queue.maxparallelQuery.toParamString(queue.maxparallel))), ("queueKeepJobs", Some(queue.keepJobsQuery.toParamString(queue.keepJobs))), ("queuePreferRunOnCreationInstance", Some(queue.preferRunOnCreationInstanceQuery.toParamString(queue.preferRunOnCreationInstance))), ("queueThreadPoolSize", Some(queue.threadPoolSizeQuery.toParamString(queue.threadPoolSize))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingEventJobsQueueConfigurationInfo](req)

    } yield resp
  }
  
  def orgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingW(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], users: List[String], groups: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], usersQuery: QueryParam[List[String]], groupsQuery: QueryParam[List[String]]): Task[OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo] = jsonOf[OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo]

    val path = "/system/console/configMgr/org.apache.sling.extensions.webconsolesecurityprovider.internal.SlingWebConsoleSecurityProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("users", Some(usersQuery.toParamString(users))), ("groups", Some(groupsQuery.toParamString(groups))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo](req)

    } yield resp
  }
  
  def orgApacheSlingFeatureflagsFeature(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, description: String, enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], descriptionQuery: QueryParam[String], enabledQuery: QueryParam[Boolean]): Task[OrgApacheSlingFeatureflagsFeatureInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingFeatureflagsFeatureInfo] = jsonOf[OrgApacheSlingFeatureflagsFeatureInfo]

    val path = "/system/console/configMgr/org.apache.sling.featureflags.Feature"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("description", Some(descriptionQuery.toParamString(description))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingFeatureflagsFeatureInfo](req)

    } yield resp
  }
  
  def orgApacheSlingFeatureflagsImplConfiguredFeature(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], name: String, description: String, enabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], nameQuery: QueryParam[String], descriptionQuery: QueryParam[String], enabledQuery: QueryParam[Boolean]): Task[OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo] = jsonOf[OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo]

    val path = "/system/console/configMgr/org.apache.sling.featureflags.impl.ConfiguredFeature"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("name", Some(nameQuery.toParamString(name))), ("description", Some(descriptionQuery.toParamString(description))), ("enabled", Some(enabledQuery.toParamString(enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHapiImplHApiUtilImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingHapiToolsResourcetype: String, orgApacheSlingHapiToolsCollectionresourcetype: String, orgApacheSlingHapiToolsSearchpaths: List[String], orgApacheSlingHapiToolsExternalurl: String, orgApacheSlingHapiToolsEnabled: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingHapiToolsResourcetypeQuery: QueryParam[String], orgApacheSlingHapiToolsCollectionresourcetypeQuery: QueryParam[String], orgApacheSlingHapiToolsSearchpathsQuery: QueryParam[List[String]], orgApacheSlingHapiToolsExternalurlQuery: QueryParam[String], orgApacheSlingHapiToolsEnabledQuery: QueryParam[Boolean]): Task[OrgApacheSlingHapiImplHApiUtilImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHapiImplHApiUtilImplInfo] = jsonOf[OrgApacheSlingHapiImplHApiUtilImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.hapi.impl.HApiUtilImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingHapiToolsResourcetype", Some(org.apache.sling.hapi.tools.resourcetypeQuery.toParamString(org.apache.sling.hapi.tools.resourcetype))), ("orgApacheSlingHapiToolsCollectionresourcetype", Some(org.apache.sling.hapi.tools.collectionresourcetypeQuery.toParamString(org.apache.sling.hapi.tools.collectionresourcetype))), ("orgApacheSlingHapiToolsSearchpaths", Some(org.apache.sling.hapi.tools.searchpathsQuery.toParamString(org.apache.sling.hapi.tools.searchpaths))), ("orgApacheSlingHapiToolsExternalurl", Some(org.apache.sling.hapi.tools.externalurlQuery.toParamString(org.apache.sling.hapi.tools.externalurl))), ("orgApacheSlingHapiToolsEnabled", Some(org.apache.sling.hapi.tools.enabledQuery.toParamString(org.apache.sling.hapi.tools.enabled))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHapiImplHApiUtilImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHcCoreImplCompositeHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String, filterTags: List[String], filterCombineTagsWithOr: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String], filterTagsQuery: QueryParam[List[String]], filterCombineTagsWithOrQuery: QueryParam[Boolean]): Task[OrgApacheSlingHcCoreImplCompositeHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHcCoreImplCompositeHealthCheckInfo] = jsonOf[OrgApacheSlingHcCoreImplCompositeHealthCheckInfo]

    val path = "/system/console/configMgr/org.apache.sling.hc.core.impl.CompositeHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))), ("filterTags", Some(filter.tagsQuery.toParamString(filter.tags))), ("filterCombineTagsWithOr", Some(filter.combineTagsWithOrQuery.toParamString(filter.combineTagsWithOr))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHcCoreImplCompositeHealthCheckInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHcCoreImplExecutorHealthCheckExecutorImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], timeoutInMs: Integer, longRunningFutureThresholdForCriticalMs: Integer, resultCacheTtlInMs: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], timeoutInMsQuery: QueryParam[Integer], longRunningFutureThresholdForCriticalMsQuery: QueryParam[Integer], resultCacheTtlInMsQuery: QueryParam[Integer]): Task[OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo] = jsonOf[OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.hc.core.impl.executor.HealthCheckExecutorImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("timeoutInMs", Some(timeoutInMsQuery.toParamString(timeoutInMs))), ("longRunningFutureThresholdForCriticalMs", Some(longRunningFutureThresholdForCriticalMsQuery.toParamString(longRunningFutureThresholdForCriticalMs))), ("resultCacheTtlInMs", Some(resultCacheTtlInMsQuery.toParamString(resultCacheTtlInMs))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHcCoreImplJmxAttributeHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String, mbeanName: String, attributeName: String, attributeValueConstraint: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String], mbeanNameQuery: QueryParam[String], attributeNameQuery: QueryParam[String], attributeValueConstraintQuery: QueryParam[String]): Task[OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo] = jsonOf[OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo]

    val path = "/system/console/configMgr/org.apache.sling.hc.core.impl.JmxAttributeHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))), ("mbeanName", Some(mbean.nameQuery.toParamString(mbean.name))), ("attributeName", Some(attribute.nameQuery.toParamString(attribute.name))), ("attributeValueConstraint", Some(attribute.value.constraintQuery.toParamString(attribute.value.constraint))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHcCoreImplScriptableHealthCheck(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], hcName: String, hcTags: List[String], hcMbeanName: String, expression: String, languageExtension: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], hcNameQuery: QueryParam[String], hcTagsQuery: QueryParam[List[String]], hcMbeanNameQuery: QueryParam[String], expressionQuery: QueryParam[String], languageExtensionQuery: QueryParam[String]): Task[OrgApacheSlingHcCoreImplScriptableHealthCheckInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHcCoreImplScriptableHealthCheckInfo] = jsonOf[OrgApacheSlingHcCoreImplScriptableHealthCheckInfo]

    val path = "/system/console/configMgr/org.apache.sling.hc.core.impl.ScriptableHealthCheck"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("hcName", Some(hc.nameQuery.toParamString(hc.name))), ("hcTags", Some(hc.tagsQuery.toParamString(hc.tags))), ("hcMbeanName", Some(hc.mbean.nameQuery.toParamString(hc.mbean.name))), ("expression", Some(expressionQuery.toParamString(expression))), ("languageExtension", Some(language.extensionQuery.toParamString(language.extension))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHcCoreImplScriptableHealthCheckInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHcCoreImplServletHealthCheckExecutorServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], servletPath: String, disabled: Boolean, corsAccessControlAllowOrigin: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], servletPathQuery: QueryParam[String], disabledQuery: QueryParam[Boolean], corsAccessControlAllowOriginQuery: QueryParam[String]): Task[OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo] = jsonOf[OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.hc.core.impl.servlet.HealthCheckExecutorServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("servletPath", Some(servletPathQuery.toParamString(servletPath))), ("disabled", Some(disabledQuery.toParamString(disabled))), ("corsAccessControlAllowOrigin", Some(cors.accessControlAllowOriginQuery.toParamString(cors.accessControlAllowOrigin))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingHcCoreImplServletResultTxtVerboseSerializer(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], totalWidth: Integer, colWidthName: Integer, colWidthResult: Integer, colWidthTiming: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], totalWidthQuery: QueryParam[Integer], colWidthNameQuery: QueryParam[Integer], colWidthResultQuery: QueryParam[Integer], colWidthTimingQuery: QueryParam[Integer]): Task[OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo] = jsonOf[OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo]

    val path = "/system/console/configMgr/org.apache.sling.hc.core.impl.servlet.ResultTxtVerboseSerializer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("totalWidth", Some(totalWidthQuery.toParamString(totalWidth))), ("colWidthName", Some(colWidthNameQuery.toParamString(colWidthName))), ("colWidthResult", Some(colWidthResultQuery.toParamString(colWidthResult))), ("colWidthTiming", Some(colWidthTimingQuery.toParamString(colWidthTiming))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingI18nImplI18NFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, slingFilterScope: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], slingFilterScopeQuery: QueryParam[List[String]]): Task[OrgApacheSlingI18nImplI18NFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingI18nImplI18NFilterInfo] = jsonOf[OrgApacheSlingI18nImplI18NFilterInfo]

    val path = "/system/console/configMgr/org.apache.sling.i18n.impl.I18NFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("slingFilterScope", Some(sling.filter.scopeQuery.toParamString(sling.filter.scope))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingI18nImplI18NFilterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingI18nImplJcrResourceBundleProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], localeDefault: String, preloadBundles: Boolean, invalidationDelay: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], localeDefaultQuery: QueryParam[String], preloadBundlesQuery: QueryParam[Boolean], invalidationDelayQuery: QueryParam[Integer]): Task[OrgApacheSlingI18nImplJcrResourceBundleProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingI18nImplJcrResourceBundleProviderInfo] = jsonOf[OrgApacheSlingI18nImplJcrResourceBundleProviderInfo]

    val path = "/system/console/configMgr/org.apache.sling.i18n.impl.JcrResourceBundleProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("localeDefault", Some(locale.defaultQuery.toParamString(locale.default))), ("preloadBundles", Some(preload.bundlesQuery.toParamString(preload.bundles))), ("invalidationDelay", Some(invalidation.delayQuery.toParamString(invalidation.delay))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingI18nImplJcrResourceBundleProviderInfo](req)

    } yield resp
  }
  
  def orgApacheSlingInstallerProviderJcrImplJcrInstaller(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], handlerSchemes: List[String], slingJcrinstallFolderNameRegexp: String, slingJcrinstallFolderMaxDepth: Integer, slingJcrinstallSearchPath: List[String], slingJcrinstallNewConfigPath: String, slingJcrinstallSignalPath: String, slingJcrinstallEnableWriteback: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], handlerSchemesQuery: QueryParam[List[String]], slingJcrinstallFolderNameRegexpQuery: QueryParam[String], slingJcrinstallFolderMaxDepthQuery: QueryParam[Integer], slingJcrinstallSearchPathQuery: QueryParam[List[String]], slingJcrinstallNewConfigPathQuery: QueryParam[String], slingJcrinstallSignalPathQuery: QueryParam[String], slingJcrinstallEnableWritebackQuery: QueryParam[Boolean]): Task[OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo] = jsonOf[OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo]

    val path = "/system/console/configMgr/org.apache.sling.installer.provider.jcr.impl.JcrInstaller"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("handlerSchemes", Some(handler.schemesQuery.toParamString(handler.schemes))), ("slingJcrinstallFolderNameRegexp", Some(sling.jcrinstall.folder.name.regexpQuery.toParamString(sling.jcrinstall.folder.name.regexp))), ("slingJcrinstallFolderMaxDepth", Some(sling.jcrinstall.folder.max.depthQuery.toParamString(sling.jcrinstall.folder.max.depth))), ("slingJcrinstallSearchPath", Some(sling.jcrinstall.search.pathQuery.toParamString(sling.jcrinstall.search.path))), ("slingJcrinstallNewConfigPath", Some(sling.jcrinstall.new.config.pathQuery.toParamString(sling.jcrinstall.new.config.path))), ("slingJcrinstallSignalPath", Some(sling.jcrinstall.signal.pathQuery.toParamString(sling.jcrinstall.signal.path))), ("slingJcrinstallEnableWriteback", Some(sling.jcrinstall.enable.writebackQuery.toParamString(sling.jcrinstall.enable.writeback))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrBaseInternalLoginAdminWhitelist(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], whitelistBypass: Boolean, whitelistBundlesRegexp: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], whitelistBypassQuery: QueryParam[Boolean], whitelistBundlesRegexpQuery: QueryParam[String]): Task[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo] = jsonOf[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.base.internal.LoginAdminWhitelist"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("whitelistBypass", Some(whitelist.bypassQuery.toParamString(whitelist.bypass))), ("whitelistBundlesRegexp", Some(whitelist.bundles.regexpQuery.toParamString(whitelist.bundles.regexp))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrBaseInternalLoginAdminWhitelistFragment(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], whitelistName: String, whitelistBundles: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], whitelistNameQuery: QueryParam[String], whitelistBundlesQuery: QueryParam[List[String]]): Task[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo] = jsonOf[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.base.internal.LoginAdminWhitelist.fragment"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("whitelistName", Some(whitelist.nameQuery.toParamString(whitelist.name))), ("whitelistBundles", Some(whitelist.bundlesQuery.toParamString(whitelist.bundles))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrDavexImplServletsSlingDavExServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], alias: String, davCreateAbsoluteUri: Boolean, davProtectedhandlers: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], aliasQuery: QueryParam[String], davCreateAbsoluteUriQuery: QueryParam[Boolean], davProtectedhandlersQuery: QueryParam[String]): Task[OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo] = jsonOf[OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("alias", Some(aliasQuery.toParamString(alias))), ("davCreateAbsoluteUri", Some(dav.create-absolute-uriQuery.toParamString(dav.create-absolute-uri))), ("davProtectedhandlers", Some(dav.protectedhandlersQuery.toParamString(dav.protectedhandlers))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrJackrabbitServerJndiRegistrationSupport(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], javaNamingFactoryInitial: String, javaNamingProviderUrl: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], javaNamingFactoryInitialQuery: QueryParam[String], javaNamingProviderUrlQuery: QueryParam[String]): Task[OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo] = jsonOf[OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.jackrabbit.server.JndiRegistrationSupport"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("javaNamingFactoryInitial", Some(java.naming.factory.initialQuery.toParamString(java.naming.factory.initial))), ("javaNamingProviderUrl", Some(java.naming.provider.urlQuery.toParamString(java.naming.provider.url))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrJackrabbitServerRmiRegistrationSupport(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], port: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], portQuery: QueryParam[Integer]): Task[OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo] = jsonOf[OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.jackrabbit.server.RmiRegistrationSupport"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("port", Some(portQuery.toParamString(port))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrRepoinitImplRepositoryInitializer(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], references: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], referencesQuery: QueryParam[List[String]]): Task[OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo] = jsonOf[OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.repoinit.impl.RepositoryInitializer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("references", Some(referencesQuery.toParamString(references))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrRepoinitRepositoryInitializer(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], references: List[String], scripts: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], referencesQuery: QueryParam[List[String]], scriptsQuery: QueryParam[List[String]]): Task[OrgApacheSlingJcrRepoinitRepositoryInitializerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrRepoinitRepositoryInitializerInfo] = jsonOf[OrgApacheSlingJcrRepoinitRepositoryInitializerInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.repoinit.RepositoryInitializer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("references", Some(referencesQuery.toParamString(references))), ("scripts", Some(scriptsQuery.toParamString(scripts))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrRepoinitRepositoryInitializerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], resourceResolverSearchpath: List[String], resourceResolverManglenamespaces: Boolean, resourceResolverAllowDirect: Boolean, resourceResolverRequiredProviders: List[String], resourceResolverRequiredProvidernames: List[String], resourceResolverVirtual: List[String], resourceResolverMapping: List[String], resourceResolverMapLocation: String, resourceResolverMapObservation: List[String], resourceResolverDefaultVanityRedirectStatus: Integer, resourceResolverEnableVanitypath: Boolean, resourceResolverVanitypathMaxEntries: Integer, resourceResolverVanitypathMaxEntriesStartup: Boolean, resourceResolverVanitypathBloomfilterMaxBytes: Integer, resourceResolverOptimizeAliasResolution: Boolean, resourceResolverVanitypathWhitelist: List[String], resourceResolverVanitypathBlacklist: List[String], resourceResolverVanityPrecedence: Boolean, resourceResolverProviderhandlingParanoid: Boolean, resourceResolverLogClosing: Boolean, resourceResolverLogUnclosed: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], resourceResolverSearchpathQuery: QueryParam[List[String]], resourceResolverManglenamespacesQuery: QueryParam[Boolean], resourceResolverAllowDirectQuery: QueryParam[Boolean], resourceResolverRequiredProvidersQuery: QueryParam[List[String]], resourceResolverRequiredProvidernamesQuery: QueryParam[List[String]], resourceResolverVirtualQuery: QueryParam[List[String]], resourceResolverMappingQuery: QueryParam[List[String]], resourceResolverMapLocationQuery: QueryParam[String], resourceResolverMapObservationQuery: QueryParam[List[String]], resourceResolverDefaultVanityRedirectStatusQuery: QueryParam[Integer], resourceResolverEnableVanitypathQuery: QueryParam[Boolean], resourceResolverVanitypathMaxEntriesQuery: QueryParam[Integer], resourceResolverVanitypathMaxEntriesStartupQuery: QueryParam[Boolean], resourceResolverVanitypathBloomfilterMaxBytesQuery: QueryParam[Integer], resourceResolverOptimizeAliasResolutionQuery: QueryParam[Boolean], resourceResolverVanitypathWhitelistQuery: QueryParam[List[String]], resourceResolverVanitypathBlacklistQuery: QueryParam[List[String]], resourceResolverVanityPrecedenceQuery: QueryParam[Boolean], resourceResolverProviderhandlingParanoidQuery: QueryParam[Boolean], resourceResolverLogClosingQuery: QueryParam[Boolean], resourceResolverLogUnclosedQuery: QueryParam[Boolean]): Task[OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo] = jsonOf[OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.resource.internal.JcrResourceResolverFactoryImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("resourceResolverSearchpath", Some(resource.resolver.searchpathQuery.toParamString(resource.resolver.searchpath))), ("resourceResolverManglenamespaces", Some(resource.resolver.manglenamespacesQuery.toParamString(resource.resolver.manglenamespaces))), ("resourceResolverAllowDirect", Some(resource.resolver.allowDirectQuery.toParamString(resource.resolver.allowDirect))), ("resourceResolverRequiredProviders", Some(resource.resolver.required.providersQuery.toParamString(resource.resolver.required.providers))), ("resourceResolverRequiredProvidernames", Some(resource.resolver.required.providernamesQuery.toParamString(resource.resolver.required.providernames))), ("resourceResolverVirtual", Some(resource.resolver.virtualQuery.toParamString(resource.resolver.virtual))), ("resourceResolverMapping", Some(resource.resolver.mappingQuery.toParamString(resource.resolver.mapping))), ("resourceResolverMapLocation", Some(resource.resolver.map.locationQuery.toParamString(resource.resolver.map.location))), ("resourceResolverMapObservation", Some(resource.resolver.map.observationQuery.toParamString(resource.resolver.map.observation))), ("resourceResolverDefaultVanityRedirectStatus", Some(resource.resolver.default.vanity.redirect.statusQuery.toParamString(resource.resolver.default.vanity.redirect.status))), ("resourceResolverEnableVanitypath", Some(resource.resolver.enable.vanitypathQuery.toParamString(resource.resolver.enable.vanitypath))), ("resourceResolverVanitypathMaxEntries", Some(resource.resolver.vanitypath.maxEntriesQuery.toParamString(resource.resolver.vanitypath.maxEntries))), ("resourceResolverVanitypathMaxEntriesStartup", Some(resource.resolver.vanitypath.maxEntries.startupQuery.toParamString(resource.resolver.vanitypath.maxEntries.startup))), ("resourceResolverVanitypathBloomfilterMaxBytes", Some(resource.resolver.vanitypath.bloomfilter.maxBytesQuery.toParamString(resource.resolver.vanitypath.bloomfilter.maxBytes))), ("resourceResolverOptimizeAliasResolution", Some(resource.resolver.optimize.alias.resolutionQuery.toParamString(resource.resolver.optimize.alias.resolution))), ("resourceResolverVanitypathWhitelist", Some(resource.resolver.vanitypath.whitelistQuery.toParamString(resource.resolver.vanitypath.whitelist))), ("resourceResolverVanitypathBlacklist", Some(resource.resolver.vanitypath.blacklistQuery.toParamString(resource.resolver.vanitypath.blacklist))), ("resourceResolverVanityPrecedence", Some(resource.resolver.vanity.precedenceQuery.toParamString(resource.resolver.vanity.precedence))), ("resourceResolverProviderhandlingParanoid", Some(resource.resolver.providerhandling.paranoidQuery.toParamString(resource.resolver.providerhandling.paranoid))), ("resourceResolverLogClosing", Some(resource.resolver.log.closingQuery.toParamString(resource.resolver.log.closing))), ("resourceResolverLogUnclosed", Some(resource.resolver.log.unclosedQuery.toParamString(resource.resolver.log.unclosed))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrResourceInternalJcrSystemUserValidator(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], allowOnlySystemUser: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], allowOnlySystemUserQuery: QueryParam[Boolean]): Task[OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo] = jsonOf[OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.resource.internal.JcrSystemUserValidator"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("allowOnlySystemUser", Some(allow.only.system.userQuery.toParamString(allow.only.system.user))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrResourcesecurityImplResourceAccessGateFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], `path`: String, checkpathPrefix: String, jcrPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], `path`Query: QueryParam[String], checkpathPrefixQuery: QueryParam[String], jcrPathQuery: QueryParam[String]): Task[OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo] = jsonOf[OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.resourcesecurity.impl.ResourceAccessGateFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("`path`", Some(pathQuery.toParamString(path))), ("checkpathPrefix", Some(checkpath.prefixQuery.toParamString(checkpath.prefix))), ("jcrPath", Some(jcrPathQuery.toParamString(jcrPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrWebdavImplHandlerDefaultHandlerService(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, typeCollections: String, typeNoncollections: String, typeContent: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], typeCollectionsQuery: QueryParam[String], typeNoncollectionsQuery: QueryParam[String], typeContentQuery: QueryParam[String]): Task[OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo] = jsonOf[OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.webdav.impl.handler.DefaultHandlerService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("typeCollections", Some(type.collectionsQuery.toParamString(type.collections))), ("typeNoncollections", Some(type.noncollectionsQuery.toParamString(type.noncollections))), ("typeContent", Some(type.contentQuery.toParamString(type.content))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServic(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer]): Task[OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo] = jsonOf[OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.webdav.impl.handler.DirListingExportHandlerService"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJcrWebdavImplServletsSimpleWebDavServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], davRoot: String, davCreateAbsoluteUri: Boolean, davRealm: String, collectionTypes: List[String], filterPrefixes: List[String], filterTypes: String, filterUris: String, typeCollections: String, typeNoncollections: String, typeContent: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], davRootQuery: QueryParam[String], davCreateAbsoluteUriQuery: QueryParam[Boolean], davRealmQuery: QueryParam[String], collectionTypesQuery: QueryParam[List[String]], filterPrefixesQuery: QueryParam[List[String]], filterTypesQuery: QueryParam[String], filterUrisQuery: QueryParam[String], typeCollectionsQuery: QueryParam[String], typeNoncollectionsQuery: QueryParam[String], typeContentQuery: QueryParam[String]): Task[OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo] = jsonOf[OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.jcr.webdav.impl.servlets.SimpleWebDavServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("davRoot", Some(dav.rootQuery.toParamString(dav.root))), ("davCreateAbsoluteUri", Some(dav.create-absolute-uriQuery.toParamString(dav.create-absolute-uri))), ("davRealm", Some(dav.realmQuery.toParamString(dav.realm))), ("collectionTypes", Some(collection.typesQuery.toParamString(collection.types))), ("filterPrefixes", Some(filter.prefixesQuery.toParamString(filter.prefixes))), ("filterTypes", Some(filter.typesQuery.toParamString(filter.types))), ("filterUris", Some(filter.urisQuery.toParamString(filter.uris))), ("typeCollections", Some(type.collectionsQuery.toParamString(type.collections))), ("typeNoncollections", Some(type.noncollectionsQuery.toParamString(type.noncollections))), ("typeContent", Some(type.contentQuery.toParamString(type.content))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingJmxProviderImplJMXResourceProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], providerRoots: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], providerRootsQuery: QueryParam[String]): Task[OrgApacheSlingJmxProviderImplJMXResourceProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingJmxProviderImplJMXResourceProviderInfo] = jsonOf[OrgApacheSlingJmxProviderImplJMXResourceProviderInfo]

    val path = "/system/console/configMgr/org.apache.sling.jmx.provider.impl.JMXResourceProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("providerRoots", Some(provider.rootsQuery.toParamString(provider.roots))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingJmxProviderImplJMXResourceProviderInfo](req)

    } yield resp
  }
  
  def orgApacheSlingModelsImplModelAdapterFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], osgiHttpWhiteboardListener: String, osgiHttpWhiteboardContextSelect: String, maxRecursionDepth: Integer, cleanupJobPeriod: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], osgiHttpWhiteboardListenerQuery: QueryParam[String], osgiHttpWhiteboardContextSelectQuery: QueryParam[String], maxRecursionDepthQuery: QueryParam[Integer], cleanupJobPeriodQuery: QueryParam[Integer]): Task[OrgApacheSlingModelsImplModelAdapterFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingModelsImplModelAdapterFactoryInfo] = jsonOf[OrgApacheSlingModelsImplModelAdapterFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.models.impl.ModelAdapterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("osgiHttpWhiteboardListener", Some(osgi.http.whiteboard.listenerQuery.toParamString(osgi.http.whiteboard.listener))), ("osgiHttpWhiteboardContextSelect", Some(osgi.http.whiteboard.context.selectQuery.toParamString(osgi.http.whiteboard.context.select))), ("maxRecursionDepth", Some(max.recursion.depthQuery.toParamString(max.recursion.depth))), ("cleanupJobPeriod", Some(cleanup.job.periodQuery.toParamString(cleanup.job.period))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingModelsImplModelAdapterFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingModelsJacksonexporterImplResourceModuleProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], maxRecursionLevels: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], maxRecursionLevelsQuery: QueryParam[Integer]): Task[OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo] = jsonOf[OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo]

    val path = "/system/console/configMgr/org.apache.sling.models.jacksonexporter.impl.ResourceModuleProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("maxRecursionLevels", Some(max.recursion.levelsQuery.toParamString(max.recursion.levels))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo](req)

    } yield resp
  }
  
  def orgApacheSlingResourceInventoryImplResourceInventoryPrinterFacto(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], felixInventoryPrinterName: String, felixInventoryPrinterTitle: String, `path`: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], felixInventoryPrinterNameQuery: QueryParam[String], felixInventoryPrinterTitleQuery: QueryParam[String], `path`Query: QueryParam[String]): Task[OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo] = jsonOf[OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo]

    val path = "/system/console/configMgr/org.apache.sling.resource.inventory.impl.ResourceInventoryPrinterFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("felixInventoryPrinterName", Some(felix.inventory.printer.nameQuery.toParamString(felix.inventory.printer.name))), ("felixInventoryPrinterTitle", Some(felix.inventory.printer.titleQuery.toParamString(felix.inventory.printer.title))), ("`path`", Some(pathQuery.toParamString(path))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo](req)

    } yield resp
  }
  
  def orgApacheSlingResourcemergerImplMergedResourceProviderFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mergeRoot: String, mergeReadOnly: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mergeRootQuery: QueryParam[String], mergeReadOnlyQuery: QueryParam[Boolean]): Task[OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo] = jsonOf[OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.resourcemerger.impl.MergedResourceProviderFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mergeRoot", Some(merge.rootQuery.toParamString(merge.root))), ("mergeReadOnly", Some(merge.readOnlyQuery.toParamString(merge.readOnly))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingResourcemergerPickerOverriding(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], mergeRoot: String, mergeReadOnly: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], mergeRootQuery: QueryParam[String], mergeReadOnlyQuery: QueryParam[Boolean]): Task[OrgApacheSlingResourcemergerPickerOverridingInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingResourcemergerPickerOverridingInfo] = jsonOf[OrgApacheSlingResourcemergerPickerOverridingInfo]

    val path = "/system/console/configMgr/org.apache.sling.resourcemerger.picker.overriding"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("mergeRoot", Some(merge.rootQuery.toParamString(merge.root))), ("mergeReadOnly", Some(merge.readOnlyQuery.toParamString(merge.readOnly))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingResourcemergerPickerOverridingInfo](req)

    } yield resp
  }
  
  def orgApacheSlingScriptingCoreImplScriptCacheImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingScriptingCacheSize: Integer, orgApacheSlingScriptingCacheAdditionalExtensions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingScriptingCacheSizeQuery: QueryParam[Integer], orgApacheSlingScriptingCacheAdditionalExtensionsQuery: QueryParam[List[String]]): Task[OrgApacheSlingScriptingCoreImplScriptCacheImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingScriptingCoreImplScriptCacheImplInfo] = jsonOf[OrgApacheSlingScriptingCoreImplScriptCacheImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.scripting.core.impl.ScriptCacheImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingScriptingCacheSize", Some(org.apache.sling.scripting.cache.sizeQuery.toParamString(org.apache.sling.scripting.cache.size))), ("orgApacheSlingScriptingCacheAdditionalExtensions", Some(org.apache.sling.scripting.cache.additional_extensionsQuery.toParamString(org.apache.sling.scripting.cache.additional_extensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingScriptingCoreImplScriptCacheImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingScriptingCoreImplScriptingResourceResolverProvider(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], logStacktraceOnclose: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], logStacktraceOncloseQuery: QueryParam[Boolean]): Task[OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo] = jsonOf[OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo]

    val path = "/system/console/configMgr/org.apache.sling.scripting.core.impl.ScriptingResourceResolverProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("logStacktraceOnclose", Some(log.stacktrace.oncloseQuery.toParamString(log.stacktrace.onclose))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo](req)

    } yield resp
  }
  
  def orgApacheSlingScriptingJavaImplJavaScriptEngineFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], javaClassdebuginfo: Boolean, javaJavaEncoding: String, javaCompilerSourceVM: String, javaCompilerTargetVM: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], javaClassdebuginfoQuery: QueryParam[Boolean], javaJavaEncodingQuery: QueryParam[String], javaCompilerSourceVMQuery: QueryParam[String], javaCompilerTargetVMQuery: QueryParam[String]): Task[OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo] = jsonOf[OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.scripting.java.impl.JavaScriptEngineFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("javaClassdebuginfo", Some(java.classdebuginfoQuery.toParamString(java.classdebuginfo))), ("javaJavaEncoding", Some(java.javaEncodingQuery.toParamString(java.javaEncoding))), ("javaCompilerSourceVM", Some(java.compilerSourceVMQuery.toParamString(java.compilerSourceVM))), ("javaCompilerTargetVM", Some(java.compilerTargetVMQuery.toParamString(java.compilerTargetVM))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFa(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingScriptingJavascriptRhinoOptLevel: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingScriptingJavascriptRhinoOptLevelQuery: QueryParam[Integer]): Task[OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo] = jsonOf[OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo]

    val path = "/system/console/configMgr/org.apache.sling.scripting.javascript.internal.RhinoJavaScriptEngineFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingScriptingJavascriptRhinoOptLevel", Some(org.apache.sling.scripting.javascript.rhino.optLevelQuery.toParamString(org.apache.sling.scripting.javascript.rhino.optLevel))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo](req)

    } yield resp
  }
  
  def orgApacheSlingScriptingJspJspScriptEngineFactory(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], jasperCompilerTargetVM: String, jasperCompilerSourceVM: String, jasperClassdebuginfo: Boolean, jasperEnablePooling: Boolean, jasperIeClassId: String, jasperGenStringAsCharArray: Boolean, jasperKeepgenerated: Boolean, jasperMappedfile: Boolean, jasperTrimSpaces: Boolean, jasperDisplaySourceFragments: Boolean, defaultIsSession: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], jasperCompilerTargetVMQuery: QueryParam[String], jasperCompilerSourceVMQuery: QueryParam[String], jasperClassdebuginfoQuery: QueryParam[Boolean], jasperEnablePoolingQuery: QueryParam[Boolean], jasperIeClassIdQuery: QueryParam[String], jasperGenStringAsCharArrayQuery: QueryParam[Boolean], jasperKeepgeneratedQuery: QueryParam[Boolean], jasperMappedfileQuery: QueryParam[Boolean], jasperTrimSpacesQuery: QueryParam[Boolean], jasperDisplaySourceFragmentsQuery: QueryParam[Boolean], defaultIsSessionQuery: QueryParam[Boolean]): Task[OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo] = jsonOf[OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo]

    val path = "/system/console/configMgr/org.apache.sling.scripting.jsp.JspScriptEngineFactory"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("jasperCompilerTargetVM", Some(jasper.compilerTargetVMQuery.toParamString(jasper.compilerTargetVM))), ("jasperCompilerSourceVM", Some(jasper.compilerSourceVMQuery.toParamString(jasper.compilerSourceVM))), ("jasperClassdebuginfo", Some(jasper.classdebuginfoQuery.toParamString(jasper.classdebuginfo))), ("jasperEnablePooling", Some(jasper.enablePoolingQuery.toParamString(jasper.enablePooling))), ("jasperIeClassId", Some(jasper.ieClassIdQuery.toParamString(jasper.ieClassId))), ("jasperGenStringAsCharArray", Some(jasper.genStringAsCharArrayQuery.toParamString(jasper.genStringAsCharArray))), ("jasperKeepgenerated", Some(jasper.keepgeneratedQuery.toParamString(jasper.keepgenerated))), ("jasperMappedfile", Some(jasper.mappedfileQuery.toParamString(jasper.mappedfile))), ("jasperTrimSpaces", Some(jasper.trimSpacesQuery.toParamString(jasper.trimSpaces))), ("jasperDisplaySourceFragments", Some(jasper.displaySourceFragmentsQuery.toParamString(jasper.displaySourceFragments))), ("defaultIsSession", Some(default.is.sessionQuery.toParamString(default.is.session))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo](req)

    } yield resp
  }
  
  def orgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProv(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], orgApacheSlingScriptingSightlyJsBindings: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], orgApacheSlingScriptingSightlyJsBindingsQuery: QueryParam[List[String]]): Task[OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo] = jsonOf[OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo]

    val path = "/system/console/configMgr/org.apache.sling.scripting.sightly.js.impl.jsapi.SlyBindingsValuesProvider"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("orgApacheSlingScriptingSightlyJsBindings", Some(org.apache.sling.scripting.sightly.js.bindingsQuery.toParamString(org.apache.sling.scripting.sightly.js.bindings))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo](req)

    } yield resp
  }
  
  def orgApacheSlingSecurityImplContentDispositionFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingContentDispositionPaths: List[String], slingContentDispositionExcludedPaths: List[String], slingContentDispositionAllPaths: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingContentDispositionPathsQuery: QueryParam[List[String]], slingContentDispositionExcludedPathsQuery: QueryParam[List[String]], slingContentDispositionAllPathsQuery: QueryParam[Boolean]): Task[OrgApacheSlingSecurityImplContentDispositionFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingSecurityImplContentDispositionFilterInfo] = jsonOf[OrgApacheSlingSecurityImplContentDispositionFilterInfo]

    val path = "/system/console/configMgr/org.apache.sling.security.impl.ContentDispositionFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingContentDispositionPaths", Some(sling.content.disposition.pathsQuery.toParamString(sling.content.disposition.paths))), ("slingContentDispositionExcludedPaths", Some(sling.content.disposition.excluded.pathsQuery.toParamString(sling.content.disposition.excluded.paths))), ("slingContentDispositionAllPaths", Some(sling.content.disposition.all.pathsQuery.toParamString(sling.content.disposition.all.paths))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingSecurityImplContentDispositionFilterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingSecurityImplReferrerFilter(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], allowEmpty: Boolean, allowHosts: List[String], allowHostsRegexp: List[String], filterMethods: List[String], excludeAgentsRegexp: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], allowEmptyQuery: QueryParam[Boolean], allowHostsQuery: QueryParam[List[String]], allowHostsRegexpQuery: QueryParam[List[String]], filterMethodsQuery: QueryParam[List[String]], excludeAgentsRegexpQuery: QueryParam[List[String]]): Task[OrgApacheSlingSecurityImplReferrerFilterInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingSecurityImplReferrerFilterInfo] = jsonOf[OrgApacheSlingSecurityImplReferrerFilterInfo]

    val path = "/system/console/configMgr/org.apache.sling.security.impl.ReferrerFilter"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("allowEmpty", Some(allow.emptyQuery.toParamString(allow.empty))), ("allowHosts", Some(allow.hostsQuery.toParamString(allow.hosts))), ("allowHostsRegexp", Some(allow.hosts.regexpQuery.toParamString(allow.hosts.regexp))), ("filterMethods", Some(filter.methodsQuery.toParamString(filter.methods))), ("excludeAgentsRegexp", Some(exclude.agents.regexpQuery.toParamString(exclude.agents.regexp))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingSecurityImplReferrerFilterInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServiceusermappingImplServiceUserMapperImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], userMapping: List[String], userDefault: String, userEnableDefaultMapping: Boolean, requireValidation: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], userMappingQuery: QueryParam[List[String]], userDefaultQuery: QueryParam[String], userEnableDefaultMappingQuery: QueryParam[Boolean], requireValidationQuery: QueryParam[Boolean]): Task[OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo] = jsonOf[OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.serviceusermapping.impl.ServiceUserMapperImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("userMapping", Some(user.mappingQuery.toParamString(user.mapping))), ("userDefault", Some(user.defaultQuery.toParamString(user.default))), ("userEnableDefaultMapping", Some(user.enable.default.mappingQuery.toParamString(user.enable.default.mapping))), ("requireValidation", Some(require.validationQuery.toParamString(require.validation))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServiceusermappingImplServiceUserMapperImplAmended(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], serviceRanking: Integer, userMapping: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], serviceRankingQuery: QueryParam[Integer], userMappingQuery: QueryParam[List[String]]): Task[OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo] = jsonOf[OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo]

    val path = "/system/console/configMgr/org.apache.sling.serviceusermapping.impl.ServiceUserMapperImpl.amended"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("serviceRanking", Some(service.rankingQuery.toParamString(service.ranking))), ("userMapping", Some(user.mappingQuery.toParamString(user.mapping))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServletsGetDefaultGetServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], aliases: List[String], index: Boolean, indexFiles: List[String], enableHtml: Boolean, enableJson: Boolean, enableTxt: Boolean, enableXml: Boolean, jsonMaximumresults: Integer, ecmaSuport: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], aliasesQuery: QueryParam[List[String]], indexQuery: QueryParam[Boolean], indexFilesQuery: QueryParam[List[String]], enableHtmlQuery: QueryParam[Boolean], enableJsonQuery: QueryParam[Boolean], enableTxtQuery: QueryParam[Boolean], enableXmlQuery: QueryParam[Boolean], jsonMaximumresultsQuery: QueryParam[Integer], ecmaSuportQuery: QueryParam[Boolean]): Task[OrgApacheSlingServletsGetDefaultGetServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServletsGetDefaultGetServletInfo] = jsonOf[OrgApacheSlingServletsGetDefaultGetServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.servlets.get.DefaultGetServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("aliases", Some(aliasesQuery.toParamString(aliases))), ("index", Some(indexQuery.toParamString(index))), ("indexFiles", Some(index.filesQuery.toParamString(index.files))), ("enableHtml", Some(enable.htmlQuery.toParamString(enable.html))), ("enableJson", Some(enable.jsonQuery.toParamString(enable.json))), ("enableTxt", Some(enable.txtQuery.toParamString(enable.txt))), ("enableXml", Some(enable.xmlQuery.toParamString(enable.xml))), ("jsonMaximumresults", Some(json.maximumresultsQuery.toParamString(json.maximumresults))), ("ecmaSuport", Some(ecmaSuportQuery.toParamString(ecmaSuport))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServletsGetDefaultGetServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServletsGetImplVersionVersionInfoServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingServletSelectors: List[String], ecmaSuport: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingServletSelectorsQuery: QueryParam[List[String]], ecmaSuportQuery: QueryParam[Boolean]): Task[OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo] = jsonOf[OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.servlets.get.impl.version.VersionInfoServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingServletSelectors", Some(sling.servlet.selectorsQuery.toParamString(sling.servlet.selectors))), ("ecmaSuport", Some(ecmaSuportQuery.toParamString(ecmaSuport))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServletsPostImplHelperChunkCleanUpTask(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], schedulerExpression: String, schedulerConcurrent: Boolean, chunkCleanupAge: Integer)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], schedulerExpressionQuery: QueryParam[String], schedulerConcurrentQuery: QueryParam[Boolean], chunkCleanupAgeQuery: QueryParam[Integer]): Task[OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo] = jsonOf[OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo]

    val path = "/system/console/configMgr/org.apache.sling.servlets.post.impl.helper.ChunkCleanUpTask"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("schedulerExpression", Some(scheduler.expressionQuery.toParamString(scheduler.expression))), ("schedulerConcurrent", Some(scheduler.concurrentQuery.toParamString(scheduler.concurrent))), ("chunkCleanupAge", Some(chunk.cleanup.ageQuery.toParamString(chunk.cleanup.age))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServletsPostImplSlingPostServlet(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], servletPostDateFormats: List[String], servletPostNodeNameHints: List[String], servletPostNodeNameMaxLength: Integer, servletPostCheckinNewVersionableNodes: Boolean, servletPostAutoCheckout: Boolean, servletPostAutoCheckin: Boolean, servletPostIgnorePattern: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], servletPostDateFormatsQuery: QueryParam[List[String]], servletPostNodeNameHintsQuery: QueryParam[List[String]], servletPostNodeNameMaxLengthQuery: QueryParam[Integer], servletPostCheckinNewVersionableNodesQuery: QueryParam[Boolean], servletPostAutoCheckoutQuery: QueryParam[Boolean], servletPostAutoCheckinQuery: QueryParam[Boolean], servletPostIgnorePatternQuery: QueryParam[String]): Task[OrgApacheSlingServletsPostImplSlingPostServletInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServletsPostImplSlingPostServletInfo] = jsonOf[OrgApacheSlingServletsPostImplSlingPostServletInfo]

    val path = "/system/console/configMgr/org.apache.sling.servlets.post.impl.SlingPostServlet"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("servletPostDateFormats", Some(servlet.post.dateFormatsQuery.toParamString(servlet.post.dateFormats))), ("servletPostNodeNameHints", Some(servlet.post.nodeNameHintsQuery.toParamString(servlet.post.nodeNameHints))), ("servletPostNodeNameMaxLength", Some(servlet.post.nodeNameMaxLengthQuery.toParamString(servlet.post.nodeNameMaxLength))), ("servletPostCheckinNewVersionableNodes", Some(servlet.post.checkinNewVersionableNodesQuery.toParamString(servlet.post.checkinNewVersionableNodes))), ("servletPostAutoCheckout", Some(servlet.post.autoCheckoutQuery.toParamString(servlet.post.autoCheckout))), ("servletPostAutoCheckin", Some(servlet.post.autoCheckinQuery.toParamString(servlet.post.autoCheckin))), ("servletPostIgnorePattern", Some(servlet.post.ignorePatternQuery.toParamString(servlet.post.ignorePattern))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServletsPostImplSlingPostServletInfo](req)

    } yield resp
  }
  
  def orgApacheSlingServletsResolverSlingServletResolver(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], servletresolverServletRoot: String, servletresolverCacheSize: Integer, servletresolverPaths: List[String], servletresolverDefaultExtensions: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], servletresolverServletRootQuery: QueryParam[String], servletresolverCacheSizeQuery: QueryParam[Integer], servletresolverPathsQuery: QueryParam[List[String]], servletresolverDefaultExtensionsQuery: QueryParam[List[String]]): Task[OrgApacheSlingServletsResolverSlingServletResolverInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingServletsResolverSlingServletResolverInfo] = jsonOf[OrgApacheSlingServletsResolverSlingServletResolverInfo]

    val path = "/system/console/configMgr/org.apache.sling.servlets.resolver.SlingServletResolver"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("servletresolverServletRoot", Some(servletresolver.servletRootQuery.toParamString(servletresolver.servletRoot))), ("servletresolverCacheSize", Some(servletresolver.cacheSizeQuery.toParamString(servletresolver.cacheSize))), ("servletresolverPaths", Some(servletresolver.pathsQuery.toParamString(servletresolver.paths))), ("servletresolverDefaultExtensions", Some(servletresolver.defaultExtensionsQuery.toParamString(servletresolver.defaultExtensions))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingServletsResolverSlingServletResolverInfo](req)

    } yield resp
  }
  
  def orgApacheSlingSettingsImplSlingSettingsServiceImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], slingName: String, slingDescription: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], slingNameQuery: QueryParam[String], slingDescriptionQuery: QueryParam[String]): Task[OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo] = jsonOf[OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.settings.impl.SlingSettingsServiceImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("slingName", Some(sling.nameQuery.toParamString(sling.name))), ("slingDescription", Some(sling.descriptionQuery.toParamString(sling.description))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingStartupfilterImplStartupFilterImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], activeByDefault: Boolean, defaultMessage: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], activeByDefaultQuery: QueryParam[Boolean], defaultMessageQuery: QueryParam[String]): Task[OrgApacheSlingStartupfilterImplStartupFilterImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingStartupfilterImplStartupFilterImplInfo] = jsonOf[OrgApacheSlingStartupfilterImplStartupFilterImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.startupfilter.impl.StartupFilterImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("activeByDefault", Some(active.by.defaultQuery.toParamString(active.by.default))), ("defaultMessage", Some(default.messageQuery.toParamString(default.message))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingStartupfilterImplStartupFilterImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingTenantInternalTenantProviderImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], tenantRoot: String, tenantPathMatcher: List[String])(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], tenantRootQuery: QueryParam[String], tenantPathMatcherQuery: QueryParam[List[String]]): Task[OrgApacheSlingTenantInternalTenantProviderImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingTenantInternalTenantProviderImplInfo] = jsonOf[OrgApacheSlingTenantInternalTenantProviderImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.tenant.internal.TenantProviderImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("tenantRoot", Some(tenant.rootQuery.toParamString(tenant.root))), ("tenantPathMatcher", Some(tenant.path.matcherQuery.toParamString(tenant.path.matcher))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingTenantInternalTenantProviderImplInfo](req)

    } yield resp
  }
  
  def orgApacheSlingTracerInternalLogTracer(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], tracerSets: List[String], enabled: Boolean, servletEnabled: Boolean, recordingCacheSizeInMB: Integer, recordingCacheDurationInSecs: Integer, recordingCompressionEnabled: Boolean, gzipResponse: Boolean)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], tracerSetsQuery: QueryParam[List[String]], enabledQuery: QueryParam[Boolean], servletEnabledQuery: QueryParam[Boolean], recordingCacheSizeInMBQuery: QueryParam[Integer], recordingCacheDurationInSecsQuery: QueryParam[Integer], recordingCompressionEnabledQuery: QueryParam[Boolean], gzipResponseQuery: QueryParam[Boolean]): Task[OrgApacheSlingTracerInternalLogTracerInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingTracerInternalLogTracerInfo] = jsonOf[OrgApacheSlingTracerInternalLogTracerInfo]

    val path = "/system/console/configMgr/org.apache.sling.tracer.internal.LogTracer"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("tracerSets", Some(tracerSetsQuery.toParamString(tracerSets))), ("enabled", Some(enabledQuery.toParamString(enabled))), ("servletEnabled", Some(servletEnabledQuery.toParamString(servletEnabled))), ("recordingCacheSizeInMB", Some(recordingCacheSizeInMBQuery.toParamString(recordingCacheSizeInMB))), ("recordingCacheDurationInSecs", Some(recordingCacheDurationInSecsQuery.toParamString(recordingCacheDurationInSecs))), ("recordingCompressionEnabled", Some(recordingCompressionEnabledQuery.toParamString(recordingCompressionEnabled))), ("gzipResponse", Some(gzipResponseQuery.toParamString(gzipResponse))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingTracerInternalLogTracerInfo](req)

    } yield resp
  }
  
  def orgApacheSlingXssImplXSSFilterImpl(post: Boolean, apply: Boolean, delete: Boolean, action: String, location: String, propertylist: List[String], policyPath: String)(implicit postQuery: QueryParam[Boolean], applyQuery: QueryParam[Boolean], deleteQuery: QueryParam[Boolean], actionQuery: QueryParam[String], locationQuery: QueryParam[String], propertylistQuery: QueryParam[List[String]], policyPathQuery: QueryParam[String]): Task[OrgApacheSlingXssImplXSSFilterImplInfo] = {
    implicit val returnTypeDecoder: EntityDecoder[OrgApacheSlingXssImplXSSFilterImplInfo] = jsonOf[OrgApacheSlingXssImplXSSFilterImplInfo]

    val path = "/system/console/configMgr/org.apache.sling.xss.impl.XSSFilterImpl"
    
    val httpMethod = Method.POST
    val contentType = `Content-Type`(MediaType.`application/json`)
    val headers = Headers(
      )
    val queryParams = Query(
      ("post", Some(postQuery.toParamString(post))), ("apply", Some(applyQuery.toParamString(apply))), ("delete", Some(deleteQuery.toParamString(delete))), ("action", Some(actionQuery.toParamString(action))), ("location", Some($locationQuery.toParamString($location))), ("propertylist", Some(propertylistQuery.toParamString(propertylist))), ("policyPath", Some(policyPathQuery.toParamString(policyPath))))

    for {
      uri           <- Task.fromDisjunction(Uri.fromString(path))
      uriWithParams =  uri.copy(query = queryParams)
      req           =  Request(method = httpMethod, uri = uriWithParams, headers = headers.put(contentType))
      resp          <- client.expect[OrgApacheSlingXssImplXSSFilterImplInfo](req)

    } yield resp
  }
  
}
