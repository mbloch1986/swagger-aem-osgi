/**
 * Adobe Experience Manager OSGI config (AEM) API
 * Swagger AEM OSGI is an OpenAPI specification for Adobe Experience Manager (AEM) OSGI Configurations API
 *
 * OpenAPI spec version: 1.0.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include "OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties.h"

#include "OAIHelpers.h"

#include <QJsonDocument>
#include <QJsonArray>
#include <QObject>
#include <QDebug>

namespace OpenAPI {

OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties(QString json) {
    init();
    this->fromJson(json);
}

OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties() {
    init();
}

OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::~OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties() {
    this->cleanup();
}

void
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::init() {
    pool_name = new OAIConfigNodePropertyString();
    m_pool_name_isSet = false;
    allowed_pool_names = new OAIConfigNodePropertyArray();
    m_allowed_pool_names_isSet = false;
    scheduler_useleaderforsingle = new OAIConfigNodePropertyBoolean();
    m_scheduler_useleaderforsingle_isSet = false;
    metrics_filters = new OAIConfigNodePropertyArray();
    m_metrics_filters_isSet = false;
    slow_threshold_millis = new OAIConfigNodePropertyInteger();
    m_slow_threshold_millis_isSet = false;
}

void
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::cleanup() {
    if(pool_name != nullptr) { 
        delete pool_name;
    }
    if(allowed_pool_names != nullptr) { 
        delete allowed_pool_names;
    }
    if(scheduler_useleaderforsingle != nullptr) { 
        delete scheduler_useleaderforsingle;
    }
    if(metrics_filters != nullptr) { 
        delete metrics_filters;
    }
    if(slow_threshold_millis != nullptr) { 
        delete slow_threshold_millis;
    }
}

OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties*
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::fromJson(QString json) {
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
    return this;
}

void
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::fromJsonObject(QJsonObject pJson) {
    ::OpenAPI::setValue(&pool_name, pJson["poolName"], "OAIConfigNodePropertyString", "OAIConfigNodePropertyString");
    
    ::OpenAPI::setValue(&allowed_pool_names, pJson["allowedPoolNames"], "OAIConfigNodePropertyArray", "OAIConfigNodePropertyArray");
    
    ::OpenAPI::setValue(&scheduler_useleaderforsingle, pJson["scheduler.useleaderforsingle"], "OAIConfigNodePropertyBoolean", "OAIConfigNodePropertyBoolean");
    
    ::OpenAPI::setValue(&metrics_filters, pJson["metrics.filters"], "OAIConfigNodePropertyArray", "OAIConfigNodePropertyArray");
    
    ::OpenAPI::setValue(&slow_threshold_millis, pJson["slowThresholdMillis"], "OAIConfigNodePropertyInteger", "OAIConfigNodePropertyInteger");
    
}

QString
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::asJson ()
{
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::asJsonObject() {
    QJsonObject obj;
    if((pool_name != nullptr) && (pool_name->isSet())){
        toJsonValue(QString("poolName"), pool_name, obj, QString("OAIConfigNodePropertyString"));
    }
    if((allowed_pool_names != nullptr) && (allowed_pool_names->isSet())){
        toJsonValue(QString("allowedPoolNames"), allowed_pool_names, obj, QString("OAIConfigNodePropertyArray"));
    }
    if((scheduler_useleaderforsingle != nullptr) && (scheduler_useleaderforsingle->isSet())){
        toJsonValue(QString("scheduler.useleaderforsingle"), scheduler_useleaderforsingle, obj, QString("OAIConfigNodePropertyBoolean"));
    }
    if((metrics_filters != nullptr) && (metrics_filters->isSet())){
        toJsonValue(QString("metrics.filters"), metrics_filters, obj, QString("OAIConfigNodePropertyArray"));
    }
    if((slow_threshold_millis != nullptr) && (slow_threshold_millis->isSet())){
        toJsonValue(QString("slowThresholdMillis"), slow_threshold_millis, obj, QString("OAIConfigNodePropertyInteger"));
    }

    return obj;
}

OAIConfigNodePropertyString*
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::getPoolName() {
    return pool_name;
}
void
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::setPoolName(OAIConfigNodePropertyString* pool_name) {
    this->pool_name = pool_name;
    this->m_pool_name_isSet = true;
}

OAIConfigNodePropertyArray*
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::getAllowedPoolNames() {
    return allowed_pool_names;
}
void
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::setAllowedPoolNames(OAIConfigNodePropertyArray* allowed_pool_names) {
    this->allowed_pool_names = allowed_pool_names;
    this->m_allowed_pool_names_isSet = true;
}

OAIConfigNodePropertyBoolean*
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::getSchedulerUseleaderforsingle() {
    return scheduler_useleaderforsingle;
}
void
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::setSchedulerUseleaderforsingle(OAIConfigNodePropertyBoolean* scheduler_useleaderforsingle) {
    this->scheduler_useleaderforsingle = scheduler_useleaderforsingle;
    this->m_scheduler_useleaderforsingle_isSet = true;
}

OAIConfigNodePropertyArray*
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::getMetricsFilters() {
    return metrics_filters;
}
void
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::setMetricsFilters(OAIConfigNodePropertyArray* metrics_filters) {
    this->metrics_filters = metrics_filters;
    this->m_metrics_filters_isSet = true;
}

OAIConfigNodePropertyInteger*
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::getSlowThresholdMillis() {
    return slow_threshold_millis;
}
void
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::setSlowThresholdMillis(OAIConfigNodePropertyInteger* slow_threshold_millis) {
    this->slow_threshold_millis = slow_threshold_millis;
    this->m_slow_threshold_millis_isSet = true;
}


bool
OAIOrgApacheSlingCommonsSchedulerImplQuartzSchedulerProperties::isSet(){
    bool isObjectUpdated = false;
    do{
        if(pool_name != nullptr && pool_name->isSet()){ isObjectUpdated = true; break;}
        if(allowed_pool_names != nullptr && allowed_pool_names->isSet()){ isObjectUpdated = true; break;}
        if(scheduler_useleaderforsingle != nullptr && scheduler_useleaderforsingle->isSet()){ isObjectUpdated = true; break;}
        if(metrics_filters != nullptr && metrics_filters->isSet()){ isObjectUpdated = true; break;}
        if(slow_threshold_millis != nullptr && slow_threshold_millis->isSet()){ isObjectUpdated = true; break;}
    }while(false);
    return isObjectUpdated;
}
}

